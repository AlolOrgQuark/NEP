<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>RIES Solver — 表达式搜索</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&family=Syne:wght@400;600;700;800&display=swap');
    :root{
      --bg:#0a0c10;
      --surface:#111318;
      --surface2:#181c23;
      --surface3:#1e2330;
      --border:rgba(255,255,255,.07);
      --border-hi:rgba(255,255,255,.13);
      --text:rgba(225,230,240,.92);
      --text-soft:rgba(160,170,190,.7);
      --accent:#3b82f6;
      --accent2:#06b6d4;
      --accent3:#8b5cf6;
      --green:#10b981;
      --amber:#f59e0b;
      --red:#ef4444;
      --glow:rgba(59,130,246,.18);
      --radius:12px;
      --radius-sm:8px;
      --shadow:0 4px 32px rgba(0,0,0,.45);
      --shadow-sm:0 2px 12px rgba(0,0,0,.3);
      color-scheme:dark;
    }
    *,*::before,*::after{box-sizing:border-box;}
    body{
      font-family:'Syne',ui-sans-serif,system-ui,sans-serif;
      margin:0;
      min-height:100vh;
      background:var(--bg);
      color:var(--text);
      line-height:1.5;
      overflow-x:hidden;
    }
    body::before{
      content:'';position:fixed;top:0;left:0;right:0;height:400px;pointer-events:none;
      background:radial-gradient(ellipse 80% 60% at 50% -20%,rgba(59,130,246,.12),transparent);
      z-index:0;
    }
    #app{max-width:1200px;margin:0 auto;padding:20px 18px 60px;position:relative;z-index:1;}

    /* Header */
    .header{
      display:flex;align-items:baseline;gap:14px;margin-bottom:28px;
      animation:slideDown .4s ease both;
    }
    .header h1{
      font-size:26px;font-weight:800;letter-spacing:-.5px;margin:0;
      background:linear-gradient(120deg,#e2e8f0,#94a3b8);
      -webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;
    }
    .header-sub{font-family:'IBM Plex Mono',monospace;font-size:11px;color:var(--text-soft);letter-spacing:.5px;}

    /* Cards */
    .card{
      background:var(--surface);
      border:1px solid var(--border);
      border-radius:var(--radius);
      padding:16px;
      box-shadow:var(--shadow-sm);
      transition:border-color .2s;
    }
    .card:hover{border-color:var(--border-hi);}
    .card + .card{margin-top:12px;}

    /* Section label */
    .section-label{
      font-size:10px;font-weight:700;letter-spacing:1.2px;text-transform:uppercase;
      color:var(--text-soft);display:flex;align-items:center;gap:8px;margin-bottom:12px;
    }
    .section-label::after{content:'';flex:1;height:1px;background:var(--border);}

    /* Form fields */
    .field-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(148px,1fr));gap:10px;}
    .field-group{display:flex;flex-direction:column;gap:5px;}
    label.field-label{font-size:11px;font-weight:600;color:var(--text-soft);letter-spacing:.4px;}
    input[type="text"],input[type="number"],select,textarea{
      font-family:'IBM Plex Mono',monospace;
      font-size:13px;
      padding:8px 10px;
      width:100%;
      background:var(--surface2);
      border:1px solid var(--border);
      border-radius:var(--radius-sm);
      color:var(--text);
      outline:none;
      transition:border-color .15s, box-shadow .15s;
      -webkit-appearance:none;
    }
    input:focus,select:focus,textarea:focus{
      border-color:rgba(59,130,246,.5);
      box-shadow:0 0 0 3px rgba(59,130,246,.1);
    }
    select option{background:var(--surface2);}
    textarea{resize:vertical;min-height:120px;line-height:1.55;}

    /* Checkboxes */
    .check-row{
      display:flex;align-items:center;gap:8px;font-size:12px;color:var(--text-soft);
      cursor:pointer;padding:3px 0;
    }
    .check-row input[type="checkbox"]{
      width:14px;height:14px;cursor:pointer;
      accent-color:var(--accent);
    }

    /* Buttons */
    button{
      font-family:'Syne',sans-serif;
      font-weight:600;font-size:12px;
      cursor:pointer;
      border-radius:var(--radius-sm);
      border:1px solid var(--border);
      padding:7px 13px;
      background:var(--surface2);
      color:var(--text);
      transition:all .15s ease;
      position:relative;overflow:hidden;
      white-space:nowrap;
    }
    button::after{
      content:'';position:absolute;inset:0;opacity:0;
      background:linear-gradient(135deg,rgba(255,255,255,.06),transparent);
      transition:opacity .15s;
    }
    button:hover::after{opacity:1;}
    button:hover{border-color:var(--border-hi);transform:translateY(-1px);box-shadow:0 4px 12px rgba(0,0,0,.3);}
    button:active{transform:translateY(0);box-shadow:none;}
    button:disabled{opacity:.4;cursor:not-allowed;transform:none;box-shadow:none;}
    button:disabled::after{display:none;}

    .btn-primary{
      background:linear-gradient(135deg,var(--accent),var(--accent2));
      border-color:transparent;color:#fff;
      box-shadow:0 2px 16px rgba(59,130,246,.3);
      min-width:110px;padding:9px 18px;font-size:13px;
    }
    .btn-primary:hover{
      box-shadow:0 4px 24px rgba(59,130,246,.5);
      transform:translateY(-2px);
    }
    .btn-primary.running{
      background:linear-gradient(135deg,#374151,#4b5563);
      box-shadow:none;
      animation:pulse-btn 1.5s infinite;
    }
    @keyframes pulse-btn{0%,100%{opacity:1}50%{opacity:.75}}

    .btn-stop{
      background:rgba(239,68,68,.1);border-color:rgba(239,68,68,.25);color:var(--red);
    }
    .btn-stop:hover{background:rgba(239,68,68,.18);border-color:rgba(239,68,68,.4);}

    .btn-small{padding:5px 10px;font-size:11px;}
    .btn-copy{padding:5px 10px;font-size:11px;font-family:'IBM Plex Mono',monospace;}

    /* Action bar */
    .action-bar{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:16px;}

    /* Const / ops panels */
    .split{display:grid;grid-template-columns:1.1fr .9fr;gap:12px;margin-top:12px;}
    .split>*{min-width:0;overflow:hidden;}
    @media(max-width:900px){.split{grid-template-columns:1fr}}
    .const-wrap{
      max-height:280px;overflow-y:auto;overflow-x:hidden;border:1px solid var(--border);
      border-radius:var(--radius-sm);
      scrollbar-width:thin;scrollbar-color:var(--surface3) transparent;
    }
    .const-wrap::-webkit-scrollbar{width:5px;}
    .const-wrap::-webkit-scrollbar-thumb{background:var(--surface3);border-radius:4px;}
    .const-table{width:100%;border-collapse:collapse;min-width:0;table-layout:fixed;}
    .const-table th,.const-table td{
      border-bottom:1px solid var(--border);padding:6px 8px;font-size:11px;
    }
    .const-table th{
      position:sticky;top:0;background:var(--surface);z-index:2;
      font-weight:700;letter-spacing:.5px;text-transform:uppercase;
      color:var(--text-soft);font-size:10px;
    }
    .const-table td{font-family:'IBM Plex Mono',monospace;font-size:12px;color:var(--text);}
    .const-table tbody tr:hover{background:rgba(255,255,255,.025);}
    .mini-inp{
      width:100%;min-width:0;padding:2px 3px;font-size:10px;
      background:var(--surface2);border:1px solid var(--border);border-radius:5px;
      color:var(--text);font-family:'IBM Plex Mono',monospace;
    }
    .mini-inp:focus{border-color:rgba(59,130,246,.5);outline:none;}

    /* Ops grid */
    .ops-grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:5px;min-width:0;}
    @media(max-width:640px){.ops-grid{grid-template-columns:repeat(2,minmax(0,1fr));}}
    .ops-grid .check-row{
      padding:5px 8px;background:var(--surface2);
      border-radius:6px;border:1px solid var(--border);
      transition:border-color .15s,background .15s;
    }
    .ops-grid .check-row:hover{border-color:var(--border-hi);background:var(--surface3);}

    /* Toolbar */
    .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;}

    /* Progress */
    .progress-card{
      background:var(--surface);border:1px solid var(--border);
      border-radius:var(--radius);padding:14px 16px;margin-top:12px;
      transition:border-color .3s;
    }
    .progress-card.active{border-color:rgba(59,130,246,.35);box-shadow:0 0 0 1px rgba(59,130,246,.1);}
    .rt-meta{
      display:flex;gap:16px;flex-wrap:wrap;
      font-family:'IBM Plex Mono',monospace;font-size:11px;
      color:var(--text-soft);margin-bottom:10px;
    }
    .rt-meta span{display:flex;align-items:center;gap:5px;}
    .rt-meta .dot{
      width:7px;height:7px;border-radius:50%;
      background:var(--text-soft);flex-shrink:0;
    }
    .rt-meta .dot.active{background:var(--accent);box-shadow:0 0 6px var(--accent);animation:pulse-dot 1.2s infinite;}
    @keyframes pulse-dot{0%,100%{opacity:1}50%{opacity:.4}}
    .progress-bar-wrap{
      height:4px;background:var(--surface3);border-radius:999px;overflow:hidden;
    }
    .progress-bar-fill{
      height:100%;width:0%;
      background:linear-gradient(90deg,var(--accent),var(--accent2));
      border-radius:999px;
      transition:width .3s ease;
      position:relative;overflow:hidden;
    }
    .progress-bar-fill::after{
      content:'';position:absolute;top:0;left:-100%;width:100%;height:100%;
      background:linear-gradient(90deg,transparent,rgba(255,255,255,.4),transparent);
      animation:none;opacity:0;transition:opacity .3s;
    }
    .progress-card.active .progress-bar-fill::after{
      animation:shimmer 1.8s infinite;opacity:1;
    }
    @keyframes shimmer{to{left:200%}}

    /* Status pills */
    .status-pills{display:flex;flex-wrap:wrap;gap:6px;margin-top:10px;}
    .pill{
      padding:3px 9px;border-radius:999px;
      font-size:10px;font-family:'IBM Plex Mono',monospace;
      border:1px solid var(--border);background:var(--surface2);
      color:var(--text-soft);
    }
    .prune-info{
      margin-top:8px;padding:8px 12px;background:rgba(255,255,255,.03);
      border-radius:8px;font-size:11px;font-family:'IBM Plex Mono',monospace;
      color:var(--text-soft);line-height:1.7;
    }

    /* Results */
    .results-header{
      display:flex;align-items:center;gap:10px;flex-wrap:wrap;
      margin:16px 0 8px;
    }
    .results-label{font-size:11px;font-weight:700;letter-spacing:1px;text-transform:uppercase;color:var(--text-soft);}
    .copy-msg{font-family:'IBM Plex Mono',monospace;font-size:11px;color:var(--green);
      animation:fadeMsg .2s ease both;}
    @keyframes fadeMsg{from{opacity:0;transform:translateX(-4px)}to{opacity:1;transform:none}}

    .table-wrap{
      border:1px solid var(--border);border-radius:var(--radius);
      overflow-x:auto;overflow-y:hidden;
      -webkit-overflow-scrolling:touch;
      scrollbar-width:thin;scrollbar-color:var(--surface3) transparent;
    }
    .table-wrap::-webkit-scrollbar{height:5px;}
    .table-wrap::-webkit-scrollbar-thumb{background:var(--surface3);border-radius:3px;}
    table{
      width:100%;border-collapse:collapse;min-width:560px;
    }
    thead{background:var(--surface2);}
    th{
      padding:10px 10px;text-align:left;
      font-size:10px;font-weight:700;letter-spacing:.8px;text-transform:uppercase;
      color:var(--text-soft);white-space:nowrap;
      border-bottom:1px solid var(--border);
    }
    th.sortable{cursor:pointer;user-select:none;transition:color .15s,transform .18s ease,background .18s ease;position:relative;}
    th.sortable:hover{color:var(--text);background:rgba(255,255,255,.03);}
    th.sortable::after{content:" ↕";opacity:.3;font-size:9px;}
    th.sortable[data-sort-dir="asc"]::after{content:" ↑";opacity:.8;color:var(--accent);}
    th.sortable[data-sort-dir="desc"]::after{content:" ↓";opacity:.8;color:var(--accent);}
    th.sortable.sorting{transform:translateY(-1px);}
    tbody.sorting tr{animation:none!important;}
    td{
      padding:9px 10px;font-size:12px;
      border-bottom:1px solid rgba(255,255,255,.04);
      vertical-align:top;white-space:nowrap;
    }
    td.expr{white-space:normal;overflow-wrap:anywhere;word-break:break-word;font-family:'IBM Plex Mono',monospace;font-size:12px;}
    td.mono{font-family:'IBM Plex Mono',monospace;}
    .right{text-align:right;}
    tr{transition:background .12s;}
    tbody tr:hover{background:rgba(255,255,255,.025);}
    tbody tr{animation:rowIn .2s ease both;}
    @keyframes rowIn{from{opacity:0;transform:translateY(4px)}to{opacity:1;transform:none}}
    @keyframes rowPulse{from{background:rgba(59,130,246,.16)}to{background:transparent}}
    tbody.flash tr{animation:rowPulse .32s ease;}

    .tag{
      display:inline-block;padding:1px 7px;border-radius:4px;
      font-size:10px;font-weight:600;font-family:'IBM Plex Mono',monospace;
    }
    .tag-fwd{background:rgba(59,130,246,.15);color:#93c5fd;border:1px solid rgba(59,130,246,.2);}
    .tag-meet{background:rgba(16,185,129,.15);color:#6ee7b7;border:1px solid rgba(16,185,129,.2);}
    .counts-line{margin-top:3px;font-size:10px;opacity:.65;font-family:'IBM Plex Mono',monospace;}

    /* Details/disclosure */
    .custom-details{
      border:1px solid var(--border);border-radius:var(--radius-sm);
      overflow:hidden;transition:border-color .2s;
    }
    .custom-details:hover{border-color:var(--border-hi);}
    .custom-details summary{
      padding:10px 14px;cursor:pointer;
      font-size:12px;font-weight:700;letter-spacing:.3px;
      display:flex;align-items:center;gap:8px;
      background:var(--surface2);list-style:none;
      transition:background .15s;user-select:none;
    }
    .custom-details summary::-webkit-details-marker{display:none;}
    .custom-details summary::before{
      content:'▶';font-size:9px;color:var(--text-soft);
      transition:transform .2s;display:inline-block;
    }
    .custom-details[open] summary::before{transform:rotate(90deg);}
    .custom-details summary:hover{background:var(--surface3);}
    .custom-details-body{
      padding:0 14px;background:var(--surface);
      overflow:hidden;max-height:0;opacity:0;
      transition:max-height .3s cubic-bezier(0.4,0,0.2,1),opacity .25s ease,padding .3s ease;
    }
    .custom-details pre{
      white-space:pre;overflow-x:auto;display:block;
      margin:0;font-size:11px;color:var(--text-soft);
      font-family:'IBM Plex Mono',monospace;line-height:1.6;
      scrollbar-width:thin;scrollbar-color:var(--surface3) transparent;
    }
    .custom-details pre::-webkit-scrollbar{height:4px;}
    .custom-details pre::-webkit-scrollbar-thumb{background:var(--surface3);border-radius:3px;}

    /* Mode badge */
    .mode-badge{
      display:inline-flex;align-items:center;gap:5px;padding:4px 10px;
      border-radius:999px;font-size:10px;font-weight:700;letter-spacing:.5px;
      border:1px solid rgba(59,130,246,.25);background:rgba(59,130,246,.08);
      color:#93c5fd;
    }

    /* Warn text */
    .warn{color:var(--amber);}

    /* Animations */
    @keyframes slideDown{from{opacity:0;transform:translateY(-10px)}to{opacity:1;transform:none}}
    .card{animation:cardIn .3s ease both;}
    @keyframes cardIn{from{opacity:0;transform:translateY(8px)}to{opacity:1;transform:none}}
    .card:nth-child(1){animation-delay:.05s}
    .card:nth-child(2){animation-delay:.1s}
    .card:nth-child(3){animation-delay:.15s}
    .card:nth-child(4){animation-delay:.2s}

    /* Divider */
    .divider{height:1px;background:var(--border);margin:14px 0;}

    /* Number input arrows hidden on mobile */
    input[type=number]{-moz-appearance:textfield;}
    input[type=number]::-webkit-outer-spin-button,
    input[type=number]::-webkit-inner-spin-button{-webkit-appearance:none;margin:0;}

    /* Responsive */
    @media(max-width:600px){
      .field-grid{grid-template-columns:repeat(2,1fr);}
      #app{padding:14px 12px 40px;}
    }
  </style>
  <style>html{scroll-behavior:smooth}</style>
</head>
<body>
<div id="app">

<div class="header">
  <h1>RIES Solver</h1>

</div>

<!-- Main Config Card -->
<div class="card">
  <div class="section-label">搜索参数</div>
  <div class="field-grid">
    <div class="field-group">
      <label class="field-label">目标值 T</label>
      <input id="target" type="text" value="24" class="mono"/>
    </div>
    <div class="field-group">
      <label class="field-label">模式</label>
      <select id="mode">
        <option value="speed" selected>普通模式</option>
        <option value="normal">中等模式</option>
        <option value="accuracy">精确模式</option>
      </select>
    </div>
    <div class="field-group">
      <label class="field-label">最大复杂度</label>
      <input id="maxC" type="number" value="24" min="1" max="200"/>
    </div>
    <div class="field-group">
      <label class="field-label">Beam</label>
      <input id="beam" type="number" value="4000" min="50" max="50000"/>
    </div>
    <div class="field-group">
      <label class="field-label">Diversity 比例</label>
      <input id="divRatio" type="number" value="0.25" min="0" max="1" step="0.05"/>
    </div>
    <div class="field-group">
      <label class="field-label">输出条数</label>
      <input id="outN" type="number" value="30" min="1" max="200"/>
    </div>
    <div class="field-group">
      <label class="field-label">更新间隔 ms</label>
      <input id="emitInterval" type="number" value="500" min="50" max="60000"/>
    </div>
    <div class="field-group">
      <label class="field-label">时间上限 ms</label>
      <input id="timeLimit" type="number" value="12000" min="0" max="600000"/>
      <label class="check-row" style="margin-top:4px">
        <input id="infiniteTime" type="checkbox"/><span>无限时间</span>
      </label>
    </div>
  </div>

  <div class="divider"></div>

  <div class="field-grid">
    <div class="field-group" style="grid-column:1/-1">
      <label class="field-label">搜索选项</label>
      <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:4px 12px;margin-top:2px">
        <label class="check-row"><input id="bidir" type="checkbox" checked/><span>双向搜索（meet）</span></label>
        <label class="check-row"><input id="showCounts" type="checkbox" checked/><span>显示常数计数</span></label>
        <label class="check-row"><input id="pruneEquiv" type="checkbox" checked/><span>恒等式剪枝</span></label>
        <label class="check-row"><input id="excludeExact" type="checkbox"/><span>排除 exact</span></label>
        <label class="check-row"><input id="dedupeByValue" type="checkbox"/><span>同值仅保留最简</span></label>
        <label class="check-row"><input id="debugMode" type="checkbox"/><span>Debug 统计</span></label>
        <label class="check-row"><input id="latexMode" type="checkbox"/><span>LaTeX 渲染</span></label>
      </div>
    </div>
    <div class="field-group">
      <label class="field-label">多线程</label>
      <label class="check-row" style="margin-bottom:6px"><input id="mt" type="checkbox" checked/><span>启用</span></label>
      <div style="display:flex;gap:8px;align-items:center">
        <input id="threads" type="number" value="6" min="1" max="64" style="max-width:80px"/>
        <span style="font-size:11px;color:var(--text-soft)">线程</span>
        <span class="warn" id="mtHint" style="font-size:11px"></span>
      </div>
    </div>

  </div>
</div>

<!-- Constants + Ops -->
<div class="split">
  <div class="card" style="padding:12px">
    <div class="section-label">常数 + 次数限制
      <button id="cAll" class="btn-small" style="margin-left:auto">全选</button>
      <button id="cNone" class="btn-small">全不选</button>
      <button id="btnResetConstraints" class="btn-small" title="清空所有 min/max 约束并恢复常数/函数默认勾选">恢复默认</button>
    </div>
    <div class="const-wrap">
      <table class="const-table">
        <thead><tr>
          <th style="width:36px">启用</th>
          <th style="width:90px">符号</th>
          <th style="width:100px">数值</th>
          <th style="width:62px">min</th>
          <th style="width:62px">max</th>
        </tr></thead>
        <tbody id="constBody"></tbody>
      </table>
    </div>
  </div>

  <div class="card" style="padding:12px">
    <div class="section-label">运算 / 函数
      <button id="oAll" class="btn-small" style="margin-left:auto">全选</button>
      <button id="oNone" class="btn-small">全不选</button>
    </div>
    <div class="ops-grid" id="opsBox"></div>
  </div>
</div>

<!-- Custom Script -->
<div class="card" style="margin-top:12px">
  <div class="section-label">自定义扩展</div>
  <div style="display:flex;align-items:center;gap:12px;margin-bottom:10px;flex-wrap:wrap">
    <label class="check-row">
      <input id="customEnable" type="checkbox"/>
      <span style="font-weight:600">启用自定义约束脚本</span>
    </label>
    <button id="btnApplyCustom" class="btn-small">应用扩展到 UI</button>
    <span style="font-size:11px;color:var(--text-soft)">新增项会出现在常数表和运算表</span>
  </div>
  <textarea id="customBox" class="mono" style="min-height:120px;font-family:'IBM Plex Mono',monospace;font-size:12px;line-height:1.55"></textarea>

  <details class="custom-details" style="margin-top:10px">
    <summary>自定义脚本示例</summary>
    <div class="custom-details-body">
      <pre class="mono" style="white-space:pre;overflow-x:auto;display:block;margin:0;font-size:11px;opacity:.9;padding-bottom:4px">// 示例：要求“所有数字常量必须按指定顺序出现”。
// 例：SEQ=[1,1,4,5,1,4]，只允许叶子序列恰好为 1,1,4,5,1,4 的表达式。
// 重点：把“顺序规则”放进 binaryPrune + leafOrder，尽量在扩展期早剪枝。

const SEQ=[1,1,4,5,1,4];
function isNumberSym(sym){ return /^[-+]?\d+(?:\.\d+)?$/.test(String(sym||"")); }

function getConstraints(){
  return {
    leafOrder:"nondecreasing", // 先做廉价排序剪枝，减少排列爆炸
    pruneLevel:"aggressive",

    // 早剪枝：对 +/* 做稳定顺序规范，减少交换律重复
    binaryPrune:(ctx)=>{
      if((ctx.op==="+"||ctx.op==="*") && Number.isFinite(ctx.av) && Number.isFinite(ctx.bv)){
        if(ctx.av&gt;ctx.bv) return true;
      }
      // 阻止过大中间值继续膨胀（对 speed/medium 模式很关键）
      if((ctx.op==="^"||ctx.op==="exp") && (Math.abs(ctx.av)&gt;20 || Math.abs(ctx.bv)&gt;20)) return true;
      return false;
    },

    unaryPrune:(ctx)=>{
      if((ctx.op==="exp"||ctx.op==="fact"||ctx.op==="gammafn") && Math.abs(ctx.v)&gt;12) return true;
      return false;
    }
  };
}

function allowCandidate(ctx){
  const leaves=Array.isArray(ctx.leaves)?ctx.leaves:[];
  const nums=[];
  for(const s of leaves){
    if(isNumberSym(s)) nums.push(Number(s));
  }
  // 完整校验：长度必须一致，逐位严格相等。
  if(nums.length!==SEQ.length) return false;
  for(let i=0;i&lt;SEQ.length;i++){
    if(nums[i]!==SEQ[i]) return false;
  }
  return true;
}
</pre>
    </div>
  </details>

  <div class="status-pills" id="status" style="display:none"></div>
  <div class="prune-info" id="pruneStats" style="display:none"></div>
</div>

<!-- Progress -->
<div class="progress-card" id="progressCard">
  <div class="rt-meta" id="rtMeta">
    <span><span class="dot" id="rtDot"></span><span id="rtComplexity">复杂度：0/0</span></span>
    <span id="rtElapsed">时间：0 ms</span>
    <span id="rtVisited">evaluated：0</span>
  </div>
  <div class="progress-bar-wrap">
    <div class="progress-bar-fill" id="rtBar"></div>
  </div>
</div>

<!-- Action Buttons -->
<div class="action-bar" style="margin-top:14px">
  <button id="btnStart" class="btn-primary">▶ 开始搜索</button>
  <button id="btnStop" class="btn-stop" disabled>■ 停止</button>
</div>

<!-- Results -->
<div class="results-header">
  <span class="results-label">搜索结果</span>
  <button class="btn-copy" id="btnCopyAllExpr">复制表达式</button>
  <button class="btn-copy" id="btnCopyAllTable">复制含数值</button>
  <span class="copy-msg" id="copyMsg" style="display:none"></span>
</div>

<div class="table-wrap">
  <table>
    <thead>
      <tr>
        <th id="thType" style="width:6%" data-sort-key="searchType" class="sortable">type</th>
        <th data-sort-key="expr" class="sortable">expression</th>
        <th style="width:13%" data-sort-key="v" class="sortable">value</th>
        <th style="width:10%" data-sort-key="delta" class="sortable">distance</th>
        <th style="width:9%" data-sort-key="acc" class="sortable">accuracy</th>
        <th class="right sortable" style="width:4%" data-sort-key="cost">C</th>
        <th style="width:3%">copy</th>
      </tr>
    </thead>
    <tbody id="tbody"></tbody>
  </table>
</div>

</div>

<script>
(()=>{
const $=id=>document.getElementById(id);

function fmtCompact(x){
  if(!Number.isFinite(x))return String(x);
  if(Object.is(x,-0))x=0;
  const a=Math.abs(x);
  if(a===0)return"0";
  if(a>=1e6||a<0.001)return x.toExponential(5);
  return x.toPrecision(7).replace(/\.?0+$/,"");
}

function fmtValue(x){
  if(!Number.isFinite(x)) return String(x);
  if(Object.is(x,-0)) x=0;
  if(x===0) return "0";
  const a=Math.abs(x);
  if(a>=1e18 || a<1e-18) return x.toExponential(15).replace(/\.?0+e/,"e");
  return x.toPrecision(16).replace(/\.?0+$/,""
  ).replace(/\.?0+e/,"e");
}

const fmt = fmtCompact;

// ----------- base constants / ops (UI) -----------
const BASE_CONST_LIST=[
  ...Array.from({length:41},(_,i)=>{const v=i-10;return{key:String(v),sym:String(v),val:v,on:(v>=0&&v<=10)}}),
  {key:"1/2",sym:"1/2",val:.5,on:true},{key:"1/3",sym:"1/3",val:1/3,on:false},{key:"2/3",sym:"2/3",val:2/3,on:false},
  {key:"1/4",sym:"1/4",val:.25,on:false},{key:"3/4",sym:"3/4",val:.75,on:false},
  {key:"1/5",sym:"1/5",val:.2,on:false},{key:"2/5",sym:"2/5",val:.4,on:false},{key:"1/6",sym:"1/6",val:1/6,on:false},
  {key:"pi",sym:"π",val:Math.PI,on:true},{key:"2pi",sym:"2π",val:2*Math.PI,on:false},
  {key:"pi/2",sym:"π/2",val:Math.PI/2,on:false},{key:"pi/3",sym:"π/3",val:Math.PI/3,on:false},{key:"pi/4",sym:"π/4",val:Math.PI/4,on:false},
  {key:"e",sym:"e",val:Math.E,on:true},{key:"phi",sym:"φ",val:(1+Math.sqrt(5))/2,on:false},
  {key:"sqrt2",sym:"√2",val:Math.SQRT2,on:true},{key:"sqrt3",sym:"√3",val:Math.sqrt(3),on:false},{key:"sqrt5",sym:"√5",val:Math.sqrt(5),on:false},
  {key:"ln2",sym:"ln(2)",val:Math.LN2,on:false},{key:"ln10",sym:"ln(10)",val:Math.LN10,on:false},
  {key:"gamma",sym:"γ",val:.5772156649015328606,on:false},
  {key:"catalan",sym:"G(Catalan)",val:.91596559417721901505,on:false},
  {key:"zeta3",sym:"ζ(3)",val:1.2020569031595942854,on:false},
];

const BASE_OP_LIST=[
  {key:"+",label:"+",kind:"bin",on:true},{key:"-",label:"-",kind:"bin",on:true},
  {key:"*",label:"*",kind:"bin",on:true},{key:"/",label:"/",kind:"bin",on:true},{key:"^",label:"^",kind:"bin",on:true},
  {key:"logab",label:"logab(a,b)",kind:"bin",on:false},
  {key:"min",label:"min(a,b)",kind:"bin",on:false},{key:"max",label:"max(a,b)",kind:"bin",on:false},
  {key:"atan2",label:"atan2",kind:"bin",on:false},{key:"hypot",label:"hypot",kind:"bin",on:false},
  {key:"mod",label:"mod",kind:"bin",on:false},{key:"gcd",label:"gcd",kind:"bin",on:false},{key:"lcm",label:"lcm",kind:"bin",on:false},
  {key:"neg",label:"neg(-x)",kind:"un",on:true},{key:"abs",label:"abs",kind:"un",on:true},
  {key:"inv",label:"inv(1/x)",kind:"un",on:false},
  {key:"sqrt",label:"sqrt",kind:"un",on:true},{key:"cbrt",label:"cbrt",kind:"un",on:false},
  {key:"square",label:"square",kind:"un",on:false},{key:"cube",label:"cube",kind:"un",on:false},
  {key:"exp",label:"exp",kind:"un",on:true},{key:"expm1",label:"expm1",kind:"un",on:false},
  {key:"log",label:"log",kind:"un",on:true},{key:"log10",label:"log10",kind:"un",on:false},{key:"log1p",label:"log1p",kind:"un",on:false},
  {key:"sin",label:"sin",kind:"un",on:false},{key:"cos",label:"cos",kind:"un",on:false},{key:"tan",label:"tan",kind:"un",on:false},
  {key:"asin",label:"asin",kind:"un",on:false},{key:"acos",label:"acos",kind:"un",on:false},{key:"atan",label:"atan",kind:"un",on:false},
  {key:"sinh",label:"sinh",kind:"un",on:false},{key:"cosh",label:"cosh",kind:"un",on:false},{key:"tanh",label:"tanh",kind:"un",on:false},
  {key:"floor",label:"floor",kind:"un",on:false},{key:"ceil",label:"ceil",kind:"un",on:false},
  {key:"round",label:"round",kind:"un",on:false},{key:"frac",label:"frac",kind:"un",on:false},{key:"sign",label:"sign",kind:"un",on:false},
  {key:"fact",label:"fact(!)",kind:"un",on:false},{key:"gammafn",label:"Γ(x)",kind:"un",on:false},{key:"erf",label:"erf",kind:"un",on:false},
];

let CONST_LIST = BASE_CONST_LIST.slice();
let OP_LIST = BASE_OP_LIST.slice();

// ----------- custom extension loader -----------
function safeEvalCustom(code){
  const src = String(code||"");
  const fn = new Function('"use strict";\n'+src+'\n;return {'
    +'getExtensions:(typeof getExtensions==="function")?getExtensions:null,'
    +'getConstraints:(typeof getConstraints==="function")?getConstraints:null,'
    +'allowCandidate:(typeof allowCandidate==="function")?allowCandidate:null,'
    +'scoreAdjust:(typeof scoreAdjust==="function")?scoreAdjust:null'
    +'};');
  return fn();
}

function normalizeExt(ext){
  if(!ext||typeof ext!=="object") return {constants:[],unaryOps:[],binaryOps:[]};
  const out={constants:[],unaryOps:[],binaryOps:[]};
  if(Array.isArray(ext.constants)) out.constants = ext.constants.slice();
  if(Array.isArray(ext.unaryOps)) out.unaryOps = ext.unaryOps.slice();
  if(Array.isArray(ext.binaryOps)) out.binaryOps = ext.binaryOps.slice();
  return out;
}

function mergeExtensionsToLists(ext){
  // Avoid key collisions: if collision, last wins but keep stable ordering.
  const cMap=new Map(CONST_LIST.map(c=>[c.key,c]));
  for(const c of (ext.constants||[])){
    if(!c||!c.key) continue;
    const cc={key:String(c.key),sym:String(c.sym??c.key),val:Number(c.val),on:!!c.on, custom:true};
    if(!Number.isFinite(cc.val)) continue;
    cMap.set(cc.key,cc);
  }
  CONST_LIST = Array.from(cMap.values());

  const oMap=new Map(OP_LIST.map(o=>[o.key,o]));
  for(const u of (ext.unaryOps||[])){
    if(!u||!u.key) continue;
    oMap.set(String(u.key), {key:String(u.key), label:String(u.label??u.key), kind:"un", on:!!u.on, custom:true});
  }
  for(const b of (ext.binaryOps||[])){
    if(!b||!b.key) continue;
    oMap.set(String(b.key), {key:String(b.key), label:String(b.label??b.key), kind:"bin", on:!!b.on, custom:true});
  }
  OP_LIST = Array.from(oMap.values());
}

// ----------- UI mount -----------
function mountConsts(){
  const tb=$("constBody");tb.innerHTML="";
  for(const c of CONST_LIST){
    const tr=document.createElement("tr");
    const t1=document.createElement("td"),ch=document.createElement("input");
    ch.type="checkbox";ch.className="cstOn";ch.dataset.key=c.key;ch.checked=!!c.on;t1.appendChild(ch);
    const t2=document.createElement("td");t2.className="mono";t2.textContent=c.sym;
    const t3=document.createElement("td");t3.className="mono";t3.textContent=fmt(c.val);
    const t4=document.createElement("td"),i1=document.createElement("input");
    i1.type="text";i1.placeholder="0";i1.className="mini-inp cstMin";i1.dataset.key=c.key;t4.appendChild(i1);
    const t5=document.createElement("td"),i2=document.createElement("input");
    i2.type="text";i2.placeholder="∞";i2.className="mini-inp cstMax";i2.dataset.key=c.key;t5.appendChild(i2);
    tr.append(t1,t2,t3,t4,t5);tb.appendChild(tr);
  }
}
function mountOps(){
  const b=$("opsBox");b.innerHTML="";
  for(const o of OP_LIST){
    const l=document.createElement("label"),ch=document.createElement("input");
    ch.type="checkbox";ch.className="opOn";ch.dataset.key=o.key;ch.checked=!!o.on;
    l.className="check-row";
    const s=document.createElement("span");s.textContent=o.label;
    l.append(ch,s);b.appendChild(l);
  }
}
function setAll(cls,v){document.querySelectorAll("."+cls).forEach(x=>x.checked=v);}
$("cAll").onclick=()=>setAll("cstOn",true);
$("cNone").onclick=()=>setAll("cstOn",false);
$("oAll").onclick=()=>setAll("opOn",true);
$("oNone").onclick=()=>setAll("opOn",false);

function resetConstraintsToDefault(){
  // reset lists back to base (custom extensions removed)
  CONST_LIST = BASE_CONST_LIST.slice();
  OP_LIST = BASE_OP_LIST.slice();
  mountConsts();
  mountOps();

  // constants: restore default enable + clear min/max
  for(const c of CONST_LIST){
    const key=c.key;
    const ch=document.querySelector('.cstOn[data-key="'+CSS.escape(key)+'"]');
    const mn=document.querySelector('.cstMin[data-key="'+CSS.escape(key)+'"]');
    const mx=document.querySelector('.cstMax[data-key="'+CSS.escape(key)+'"]');
    if(ch) ch.checked=!!c.on;
    if(mn) mn.value="";
    if(mx) mx.value="";
  }
  // ops: restore default enable
  for(const o of OP_LIST){
    const ch=document.querySelector('.opOn[data-key="'+CSS.escape(o.key)+'"]');
    if(ch) ch.checked=!!o.on;
  }
  scheduleSave();
}
$("btnResetConstraints").onclick=()=>{ resetConstraintsToDefault(); };

$("btnApplyCustom").onclick=()=>{
  try{
    CONST_LIST = BASE_CONST_LIST.slice();
    OP_LIST = BASE_OP_LIST.slice();
    if($("customEnable").checked){
      const scope = safeEvalCustom($("customBox").value);
      const ext = scope.getExtensions ? normalizeExt(scope.getExtensions()) : {constants:[],unaryOps:[],binaryOps:[]};
      mergeExtensionsToLists(ext);
    }
    const st = collectUIState(); // keep selections if possible
    mountConsts(); mountOps();
    applyUIState(st);
    scheduleSave();
  }catch(e){
    alert("应用自定义扩展失败: "+(e?.message||String(e)));
  }
};

function statusPills(o){
  const el=$("status");el.innerHTML="";
  for(const [k,v] of Object.entries(o)){
    const d=document.createElement("div");
    d.className="pill mono";
    d.textContent=`${k}: ${v}`;
    el.appendChild(d);
  }
}

function updateRuntimePanel(payload){
  const c=Math.max(0, Number(payload?.c||0));
  const maxC=Math.max(1, Number(payload?.maxC||1));
  const elapsed=Math.max(0, Number(payload?.elapsed||0));
  const visited=Math.max(0, Number(payload?.visited||0));
  const pct=Math.max(0, Math.min(100, (c/maxC)*100));
  const rtDotEl=$("rtDot"); if(rtDotEl) rtDotEl.className=$("progressCard").classList.contains("active")?"dot active":"dot";
  $("rtComplexity").textContent=`复杂度：${c}/${maxC}`;
  $("rtElapsed").textContent=`时间：${Math.round(elapsed)} ms`;
  $("rtVisited").textContent=`evaluated：${visited.toLocaleString()}`;
  $("rtBar").style.width=`${pct.toFixed(1)}%`;
}

// ---------- LaTeX render (KaTeX) ----------
let katexLoading=null;
async function ensureLatexRenderer(){
  if(window.katex) return true;
  if(!navigator.onLine) return false;
  if(katexLoading) return katexLoading;

  katexLoading = new Promise((resolve)=>{
    // 先加载 CSS
    const link=document.createElement('link');
    link.rel='stylesheet';
    link.href='https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css';
    document.head.appendChild(link);
    // 再加载 JS
    const sc=document.createElement('script');
    sc.src='https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js';
    sc.async=true;
    sc.onload=()=>resolve(!!window.katex);
    sc.onerror=()=>resolve(false);
    document.head.appendChild(sc);
  });
  return katexLoading;
}

const SUP_DIGITS={"⁰":"0","¹":"1","²":"2","³":"3","⁴":"4","⁵":"5","⁶":"6","⁷":"7","⁸":"8","⁹":"9"};

function normalizeTargetExpr(src){
  let s=String(src??"").trim();
  s=s.replace(/[“”]/g,'"').replace(/[‘’]/g,"'");
  s=s.replace(/[−﹣－]/g,"-").replace(/[×·]/g,"*").replace(/[÷]/g,"/");
  s=s.replace(/\s+/g,"");
  // reduce chained signs: +- => -, -- => +, -+ => -, ++ => +
  for(let i=0;i<6;i++){
    const next=s.replace(/\+\+/g,"+").replace(/\+-/g,"-").replace(/-\+/g,"-").replace(/--/g,"+");
    if(next===s)break;
    s=next;
  }
  s=s.replace(/[⁰¹²³⁴⁵⁶⁷⁸⁹]+/g,m=>"^"+m.split("").map(ch=>SUP_DIGITS[ch]||"").join(""));
  return s;
}

function parseTarget(s){
  const src=normalizeTargetExpr(s);
  if(!src)return NaN;
  const tokens=[];
  const isDigit=(ch)=>ch>="0"&&ch<="9";
  const isAlpha=(ch)=>/[A-Za-z_πφ√]/.test(ch);
  let i=0;
  while(i<src.length){
    const ch=src[i];
    if(isDigit(ch)||ch==="."){
      let j=i+1;
      while(j<src.length&&(isDigit(src[j])||src[j]==="."))j++;
      tokens.push({t:"num",v:Number(src.slice(i,j))});
      i=j;continue;
    }
    if(isAlpha(ch)){
      let j=i+1;
      while(j<src.length&&/[A-Za-z0-9_πφ]/.test(src[j]))j++;
      const raw=src.slice(i,j).toLowerCase();
      if(raw==="pi"||raw==="π")tokens.push({t:"num",v:Math.PI});
      else if(raw==="e")tokens.push({t:"num",v:Math.E});
      else if(raw==="phi"||raw==="φ")tokens.push({t:"num",v:(1+Math.sqrt(5))/2});
      else if(raw==="sqrt2"||raw==="√2")tokens.push({t:"num",v:Math.SQRT2});
      else if(raw==="sqrt3"||raw==="√3")tokens.push({t:"num",v:Math.sqrt(3)});
      else if(raw==="sqrt5"||raw==="√5")tokens.push({t:"num",v:Math.sqrt(5)});
      else return NaN;
      i=j;continue;
    }
    if("()+-*/^".includes(ch)){tokens.push({t:ch,v:ch});i++;continue;}
    return NaN;
  }

  const out=[]; const ops=[];
  const prec={"u-":4,"^":3,"*":2,"/":2,"+":1,"-":1};
  const rightAssoc={"^":true,"u-":true};
  let prevType="start";
  for(const tk of tokens){
    if(tk.t==="num"){
      if(prevType==="num"||prevType===")") return NaN;
      out.push(tk); prevType="num"; continue;
    }
    if(tk.t==="("){
      if(prevType==="num"||prevType===")") return NaN;
      ops.push(tk); prevType="("; continue;
    }
    if(tk.t===")"){
      while(ops.length&&ops[ops.length-1].t!=="(") out.push(ops.pop());
      if(!ops.length)return NaN;
      ops.pop(); prevType=")"; continue;
    }
    let op=tk.t;
    if(op==="-"&&(prevType==="start"||prevType==="("||prevType==="op")){
      ops.push({t:"u-",v:"u-"});
      prevType="op";
      continue;
    }
    if(op==="+"&&(prevType==="start"||prevType==="("||prevType==="op")) { prevType="op"; continue; }
    if(prevType==="start"||prevType==="("||prevType==="op") return NaN;
    while(ops.length){
      const top=ops[ops.length-1].t;
      if(top==="(")break;
      const cond=rightAssoc[op] ? (prec[op]<prec[top]) : (prec[op]<=prec[top]);
      if(!cond)break;
      out.push(ops.pop());
    }
    ops.push({t:op,v:op}); prevType="op";
  }
  if(prevType==="op"||prevType==="(") return NaN;
  while(ops.length){
    const op=ops.pop();
    if(op.t==="(") return NaN;
    out.push(op);
  }

  const st=[];
  for(const tk of out){
    if(tk.t==="num") st.push(tk.v);
    else if(tk.t==="u-"){
      if(st.length<1)return NaN;
      st.push(-st.pop());
    }else{
      if(st.length<2)return NaN;
      const b=st.pop(),a=st.pop();
      let v=NaN;
      if(tk.t==="+")v=a+b;
      else if(tk.t==="-")v=a-b;
      else if(tk.t==="*")v=a*b;
      else if(tk.t==="/")v=a/b;
      else if(tk.t==="^")v=Math.pow(a,b);
      st.push(v);
    }
  }
  return st.length===1?st[0]:NaN;
}
function parseNNI(r,ie=false){
  const t=String(r??"").trim();
  if(t==="")return{ok:true,val:ie?Infinity:0};
  if(!/^[0-9]+$/.test(t))return{ok:false,err:t};
  return{ok:true,val:Number(t)};
}
function getOps(){
  const en=new Set([...document.querySelectorAll(".opOn")].filter(x=>x.checked).map(x=>x.dataset.key));
  return{
    opsUn:OP_LIST.filter(o=>o.kind==="un"&&en.has(o.key)).map(o=>o.key),
    opsBin:OP_LIST.filter(o=>o.kind==="bin"&&en.has(o.key)).map(o=>o.key),
  };
}

function normalizeMode(mode){
  if(mode==="balanced"||mode==="meet"||mode==="free"||mode==="meetfast") return "normal";
  if(mode==="medium") return "normal"; // 兼容旧存档
  if(mode==="ries") return "accuracy";
  if(mode==="speed"||mode==="normal"||mode==="accuracy") return mode;
  return "speed";
}
function tuneOpsByMode(mode){ normalizeMode(mode); }
function mapUiModeToEngine(mode){
  const m=normalizeMode(mode);
  if(m==="normal") return "medium"; // 普通 -> speed profile
  if(m==="medium") return "normal"; // 中等 -> normal profile
  return m;
}

function getConsts(){
  const en=new Set([...document.querySelectorAll(".cstOn")].filter(x=>x.checked).map(x=>x.dataset.key));
  const mnM=new Map([...document.querySelectorAll(".cstMin")].map(x=>[x.dataset.key,x.value]));
  const mxM=new Map([...document.querySelectorAll(".cstMax")].map(x=>[x.dataset.key,x.value]));
  const out=[];
  for(const c of CONST_LIST){
    if(!en.has(c.key))continue;
    const mnP=parseNNI(mnM.get(c.key),false);if(!mnP.ok)throw new Error(c.sym+" min");
    const mxP=parseNNI(mxM.get(c.key),true); if(!mxP.ok)throw new Error(c.sym+" max");
    const mn=Math.floor(mnP.val),mx=mxP.val===Infinity?65535:Math.floor(mxP.val);
    if(mn>mx)throw new Error(c.sym+" min>max");
    out.push({key:c.key,s:c.sym,v:c.val,min:mn,max:mx});
  }
  if(!out.length)throw new Error("请至少启用一个常数");
  return out;
}

async function copyText(text){
  text=String(text??"");
  const setMsg=(s)=>{ const el=$("copyMsg"); el.textContent=s; el.style.display=s?"":"none"; setTimeout(()=>{el.textContent="";el.style.display="none";}, 1500); };
  try{
    if(navigator.clipboard && navigator.clipboard.writeText){
      await navigator.clipboard.writeText(text);
      setMsg("已复制"); return true;
    }
  }catch(e){}
  try{
    const ta=document.createElement("textarea");
    ta.value=text; ta.style.position="fixed"; ta.style.left="-9999px"; ta.style.top="0";
    document.body.appendChild(ta); ta.focus(); ta.select();
    const ok=document.execCommand("copy"); document.body.removeChild(ta);
    if(ok){ setMsg("已复制"); return true; }
  }catch(e){}
  try{ window.prompt("复制以下文本：", text); setMsg("已打开复制框"); return false;
  }catch(e){ setMsg("复制失败"); return false; }
}

let lastRows=[];
const sortState={key:null,dir:"asc"};
const zhSorter=new Intl.Collator("zh-CN",{numeric:true,sensitivity:"base"});
const numKeys=new Set(["v","delta","cost"]);
const accRank={exact:0,close:1};
function sortRows(rows){
  const arr=(rows||[]).slice();
  const k=sortState.key;
  if(!k) return arr;
  const dir=sortState.dir==="asc"?1:-1;
  arr.sort((a,b)=>{
    let av=a?.[k], bv=b?.[k];
    if(k==="searchType") return dir*zhSorter.compare(String(av||""),String(bv||""));
    if(k==="acc") return dir*((accRank[String(av||"").toLowerCase()]??2)-(accRank[String(bv||"").toLowerCase()]??2));
    if(numKeys.has(k)){
      av=Number(av); bv=Number(bv);
      if(!Number.isFinite(av)&&!Number.isFinite(bv)) return 0;
      if(!Number.isFinite(av)) return 1;
      if(!Number.isFinite(bv)) return -1;
      return dir*(av-bv);
    }
    return dir*zhSorter.compare(String(av??""),String(bv??""));
  });
  return arr;
}
function updateSortHeaders(){
  document.querySelectorAll("thead th.sortable").forEach((th)=>{
    const key=th.dataset.sortKey;
    th.dataset.sortDir=(key&&sortState.key===key)?sortState.dir:"";
  });
}
$("btnCopyAllExpr").onclick=()=>{ if(!lastRows.length)return; copyText(lastRows.map(r=>r.expr).join("\n")); };
$("btnCopyAllTable").onclick=()=>{
  if(!lastRows.length)return;
  const lines=lastRows.map(r=>{
    const d=(r.delta>=0?"+":"")+fmt(r.delta);
    return `${r.expr}\t= ${fmt(r.v)}\tΔ ${d}\tC ${r.cost}\t${r.acc}`;
  });
  copyText(lines.join("\n"));
};

function setTypeColumnVisible(show){
  const th=$("thType");
  if(th) th.style.display=show?"":"none";
  document.querySelectorAll("#tbody tr").forEach((tr)=>{
    const td=tr.firstElementChild;
    if(td) td.style.display=show?"":"none";
  });
}

let renderFrame=0;
async function renderResults(rows,showCounts,debugOn=false,latexMode=false,opts={}){
  lastRows=(rows||[]).slice();
  const sorted=sortRows(lastRows);
  const tb=$("tbody");tb.innerHTML="";
  const silent=!!opts.silentSort;
  if(silent){ tb.classList.add("sorting"); }
  const frag=document.createDocumentFragment();
  let _rowIdx=0;
  const useLatex = latexMode && await ensureLatexRenderer();
  for(const r of sorted){
    const tr=document.createElement("tr");
    const t1=document.createElement("td");
    const tg=document.createElement("span");
    const tp=r.searchType||"fwd";
    if(debugOn){
      tg.className="tag "+(tp==="meet"?"tag-meet":"tag-fwd");
      tg.textContent=tp;
      t1.appendChild(tg);
    }
    t1.style.display=debugOn?"":"none";
    const t2=document.createElement("td");
    t2.className="mono expr";
    t2.textContent=r.expr;

    if(useLatex && r.latex){
      const lx=document.createElement("div");
      lx.className="countsLine";
      try{
        lx.innerHTML=window.katex.renderToString(r.latex,{throwOnError:false,displayMode:false,output:'html'});
      }catch(e){
        lx.textContent=r.latex;
      }
      t2.appendChild(lx);
    }

    if(showCounts && r.countsInfo){
      const d=document.createElement("div");
      d.className="mono countsLine";
      d.textContent=r.countsInfo;
      t2.appendChild(d);
    }
    const t3=document.createElement("td");t3.className="mono";t3.textContent=fmtValue(r.v);
    const t4=document.createElement("td");t4.className="mono";t4.textContent=(r.delta>=0?"+":"")+fmtValue(r.delta);
    const t5=document.createElement("td");t5.className="mono";t5.textContent=r.acc;
    const t6=document.createElement("td");t6.className="mono right";t6.textContent=String(r.cost);
    const t7=document.createElement("td");
    const b=document.createElement("button");
    b.className="btn-copy"; b.textContent="复制"; b.onclick=()=>copyText(r.expr);
    t7.appendChild(b);
    tr.style.animationDelay=silent?"0ms":(_rowIdx++*12)+"ms";
    tr.append(t1,t2,t3,t4,t5,t6,t7);
    frag.appendChild(tr);
  }
  tb.appendChild(frag);
  if(silent){
    requestAnimationFrame(()=>{tb.classList.remove("sorting");tb.classList.add("flash");setTimeout(()=>tb.classList.remove("flash"),340);});
  }
  setTypeColumnVisible(debugOn);
}

// ---------- localStorage ----------
const LS_KEY="ries_solver_cfg_v10";
function collectUIState(){
  const ops={};
  document.querySelectorAll(".opOn").forEach(ch=>{ops[ch.dataset.key]=!!ch.checked;});
  const consts={};
  document.querySelectorAll(".cstOn").forEach(ch=>{
    const key=ch.dataset.key;
    const mn=document.querySelector('.cstMin[data-key="'+CSS.escape(key)+'"]')?.value ?? "";
    const mx=document.querySelector('.cstMax[data-key="'+CSS.escape(key)+'"]')?.value ?? "";
    consts[key]={on:!!ch.checked,min:mn,max:mx};
  });
  return {
    target:$("target").value, mode:$("mode").value,
    maxC:$("maxC").value, beam:$("beam").value,
    divRatio:$("divRatio").value, outN:$("outN").value,
    emitInterval:$("emitInterval").value, timeLimit:$("timeLimit").value,
    infiniteTime:$("infiniteTime").checked, bidir:$("bidir").checked,
    showCounts:$("showCounts").checked, pruneEquiv:$("pruneEquiv").checked,
    excludeExact:$("excludeExact").checked, dedupeByValue:$("dedupeByValue")?.checked||false, debugMode:$("debugMode").checked,
    latexMode:$("latexMode").checked, customEnable:$("customEnable").checked,
    customBox:$("customBox").value, mt:$("mt").checked, threads:$("threads").value,
    ops,consts
  };
}
function applyUIState(st){
  if(!st||typeof st!=="object")return;
  if(st.target!=null)$("target").value=st.target;
  if(st.mode!=null)$("mode").value=normalizeMode(st.mode);
  if(st.maxC!=null)$("maxC").value=st.maxC;
  if(st.beam!=null)$("beam").value=st.beam;
  if(st.divRatio!=null)$("divRatio").value=st.divRatio;
  if(st.outN!=null)$("outN").value=st.outN;
  if(st.emitInterval!=null)$("emitInterval").value=st.emitInterval;
  if(st.timeLimit!=null)$("timeLimit").value=st.timeLimit;
  if(st.infiniteTime!=null)$("infiniteTime").checked=!!st.infiniteTime;
  if(st.bidir!=null)$("bidir").checked=!!st.bidir;
  if(st.showCounts!=null)$("showCounts").checked=!!st.showCounts;
  if(st.pruneEquiv!=null)$("pruneEquiv").checked=!!st.pruneEquiv;
  if(st.excludeExact!=null)$("excludeExact").checked=!!st.excludeExact;
  if(st.dedupeByValue!=null&&$("dedupeByValue"))$("dedupeByValue").checked=!!st.dedupeByValue;
  if(st.debugMode!=null)$("debugMode").checked=!!st.debugMode;
  if(st.latexMode!=null)$("latexMode").checked=!!st.latexMode;
  if(st.customEnable!=null)$("customEnable").checked=!!st.customEnable;
  if(st.customBox!=null)$("customBox").value=String(st.customBox);
  if(st.mt!=null)$("mt").checked=!!st.mt;
  if(st.threads!=null)$("threads").value=st.threads;
  if(st.ops){
    document.querySelectorAll(".opOn").forEach(ch=>{
      const k=ch.dataset.key;
      if(k in st.ops) ch.checked=!!st.ops[k];
    });
  }
  if(st.consts){
    document.querySelectorAll(".cstOn").forEach(ch=>{
      const k=ch.dataset.key;
      if(st.consts[k]){
        ch.checked=!!st.consts[k].on;
        const mn=document.querySelector('.cstMin[data-key="'+CSS.escape(k)+'"]');
        const mx=document.querySelector('.cstMax[data-key="'+CSS.escape(k)+'"]');
        if(mn) mn.value=st.consts[k].min ?? "";
        if(mx) mx.value=st.consts[k].max ?? "";
      }
    });
  }
  tuneOpsByMode($("mode").value);
}
let saveTimer=null;
function scheduleSave(){
  if(saveTimer)clearTimeout(saveTimer);
  saveTimer=setTimeout(()=>{
    try{localStorage.setItem(LS_KEY, JSON.stringify(collectUIState()));}catch(e){}
  },250);
}
function hookAutoSave(){
  const ids=["target","mode","maxC","beam","divRatio","outN","emitInterval","timeLimit","infiniteTime","bidir","showCounts","pruneEquiv","excludeExact","dedupeByValue","debugMode","latexMode","customEnable","customBox","mt","threads"];
  ids.forEach(id=>{
    const el=$(id);
    el.addEventListener("input",scheduleSave);
    el.addEventListener("change",scheduleSave);
  });
  document.addEventListener("input",(e)=>{
    if(e.target?.classList?.contains("cstOn")||e.target?.classList?.contains("cstMin")||e.target?.classList?.contains("cstMax")||e.target?.classList?.contains("opOn")){
      scheduleSave();
    }
  });
}

function updateMtHint(){
  const hc=navigator.hardwareConcurrency||4;
  $("threads").max=String(Math.max(1,Math.min(64,hc)));
  $("mtHint").textContent=$("mt").checked?("建议≤"+$("threads").max):"";
}
$("mt").addEventListener("change",()=>{updateMtHint();scheduleSave();});
$("threads").addEventListener("input",()=>{updateMtHint();scheduleSave();});
$("mode").addEventListener("change",()=>{
  const mode=normalizeMode($("mode").value);
  $("mode").value=mode;
  tuneOpsByMode(mode);
  if(["speed","normal","accuracy"].includes(mode)) $("bidir").checked=true;
  scheduleSave();
});
$("infiniteTime").addEventListener("change",()=>{$("timeLimit").disabled=$("infiniteTime").checked;scheduleSave();});
$("debugMode").addEventListener("change",()=>{
  setTypeColumnVisible($("debugMode").checked);
  renderResults(lastRows,$("showCounts").checked,$("debugMode").checked,$("latexMode").checked);
  scheduleSave();
});

// ================= SubWorker code (supports reqMask + custom ops + leafOrder pruning) =================
const SUBWORKER_CODE = `
let stopFlag=false;
const CAP=1e12;

let KEYP=12;
let USE_BITMASK=true;
let NO_CONSTRAINT_FAST=false;
let TCOUNT=0;
let MAXT=null;
let OPS_UN=[], OPS_BIN=[];
let PRUNE=true;
let NEED_ZERO=false, NEED_ONE=false;
let HAS_NEG=true, HAS_DIV=true, HAS_MUL=true, HAS_SUB=true;
let PRUNE_LEVEL=1;
let FORBID_UN=new Set(), FORBID_BIN=new Set();
let CONSTRAINT_UN_FN=null, CONSTRAINT_BIN_FN=null;

// bitmask-coverage retention (fix "bitmask漏解" due to beam fragmentation)
let REQ_MASK=0, REQ_POP=0;
function popcnt32(x){
  x = x - ((x >>> 1) & 0x55555555);
  x = (x & 0x33333333) + ((x >>> 2) & 0x33333333);
  return (((x + (x >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24;
}
function reqAdj(mask){
  if(!REQ_MASK) return 1.0;
  const cov = popcnt32((mask|0) & REQ_MASK);
  return 1.0 / (1.0 + 0.35 * cov);
}

// leafOrder constraint
let LEAF_ORDER=""; // "nondecreasing" or ""
function ordLeaf(sym){
  if(!LEAF_ORDER) return {has:0, ok:1, mn:0, mx:0};
  if(/^-?\\d+$/.test(sym)){
    const v=Number(sym);
    if(Number.isFinite(v)){
      return {has:1, ok:1, mn:v, mx:v};
    }
  }
  return {has:0, ok:1, mn:0, mx:0};
}
function ordUn(st){ return st; }
function ordBin(a,b){
  if(!LEAF_ORDER) return {has:0, ok:1, mn:0, mx:0};
  if(!a.ok || !b.ok) return {has:(a.has|b.has), ok:0, mn:0, mx:0};
  if(a.has && b.has){
    if(a.mx > b.mn) return {has:1, ok:0, mn:0, mx:0};
    return {has:1, ok:1, mn:Math.min(a.mn,b.mn), mx:Math.max(a.mx,b.mx)};
  }
  if(a.has) return a;
  if(b.has) return b;
  return {has:0, ok:1, mn:0, mx:0};
}

// custom ops
let CUSTOM_UN=new Map();
let CUSTOM_BIN=new Map();
let CUSTOM_META=new Map(); // key -> {w, comm, type}
let CUSTOM_PRUNE_UN=new Map();
let CUSTOM_PRUNE_BIN=new Map();

function vKey(v){ if(!Number.isFinite(v))return "NaN"; if(Object.is(v,-0))v=0; return v.toPrecision(KEYP); }
function nearInt(x){ return Math.abs(x - Math.round(x)) < 1e-12; }
function safePowStable(a,b){
  if(!Number.isFinite(a)||!Number.isFinite(b))return NaN;
  if(a<0){const rb=Math.round(b);if(Math.abs(b-rb)>1e-12)return NaN;b=rb;}
  if(Math.abs(b)>60)return NaN;
  const r1=Math.pow(a,b);
  if(!Number.isFinite(r1)||Math.abs(r1)>CAP)return NaN;
  const bp=Math.round(b);
  if(Math.abs(b-bp)<1e-10 && Math.abs(bp)<=24){
    let r=1,base=a,e=Math.abs(bp);
    while(e>0){if(e&1)r*=base;base*=base;if(!Number.isFinite(r)||!Number.isFinite(base)||Math.abs(r)>CAP||Math.abs(base)>CAP)return NaN;e>>=1;}
    if(bp<0)r=1/r;
    return(!Number.isFinite(r)||Math.abs(r)>CAP)?NaN:r;
  }
  return r1;
}
function gcdInt(a,b){a=Math.abs(a);b=Math.abs(b);while(b){const t=a%b;a=b;b=t;}return a;}

function applyUn(op,v){
  switch(op){
    case "neg":return -v;case "abs":return Math.abs(v);case "inv":return v===0?NaN:1/v;
    case "sqrt":return v<0?NaN:Math.sqrt(v);case "cbrt":return Math.cbrt(v);
    case "square":{const r=v*v;return r>CAP?NaN:r;}
    case "cube":{const r=v*v*v;return Math.abs(r)>CAP?NaN:r;}
    case "exp":return v>80?NaN:Math.exp(v);case "expm1":return v>80?NaN:Math.expm1(v);
    case "log":return v<=0?NaN:Math.log(v);case "log10":return v<=0?NaN:Math.log10(v);case "log1p":return v<=-1?NaN:Math.log1p(v);
    case "sin":return Math.sin(v);case "cos":return Math.cos(v);case "tan":return Math.tan(v);
    case "asin":return(v<-1||v>1)?NaN:Math.asin(v);case "acos":return(v<-1||v>1)?NaN:Math.acos(v);case "atan":return Math.atan(v);
    case "sinh":return Math.abs(v)>80?NaN:Math.sinh(v);case "cosh":return Math.abs(v)>80?NaN:Math.cosh(v);case "tanh":return Math.tanh(v);
    case "floor":return Math.floor(v);case "ceil":return Math.ceil(v);case "round":return Math.round(v);
    case "frac":return v-Math.floor(v);case "sign":return Math.sign(v);
    default:{
      const fn=CUSTOM_UN.get(op);
      if(fn){ try{ return fn(v); }catch(e){ return NaN; } }
      return NaN;
    }
  }
}
function applyBin(op,a,b){
  switch(op){
    case "+":return a+b;case "-":return a-b;case "*":return a*b;case "/":return b===0?NaN:a/b;
    case "^":return safePowStable(a,b);
    case "logab":return (a>0&&a!==1&&b>0)?(Math.log(b)/Math.log(a)):NaN;
    case "min":return Math.min(a,b);case "max":return Math.max(a,b);
    case "atan2":return Math.atan2(a,b);case "hypot":return Math.hypot(a,b);
    case "mod":{if(!nearInt(a)||!nearInt(b))return NaN;const bb=Math.round(b);return bb===0?NaN:((Math.round(a)%bb)+bb)%bb;}
    case "gcd":{if(!nearInt(a)||!nearInt(b))return NaN;const aa=Math.round(a),bb=Math.round(b);return(Math.abs(aa)>1e6||Math.abs(bb)>1e6)?NaN:gcdInt(aa,bb);}
    case "lcm":{if(!nearInt(a)||!nearInt(b))return NaN;const aa=Math.round(a),bb=Math.round(b);if(Math.abs(aa)>1e6||Math.abs(bb)>1e6)return NaN;return Math.abs(aa/gcdInt(aa,bb)*bb);}
    default:{
      const fn=CUSTOM_BIN.get(op);
      if(fn){ try{ return fn(a,b); }catch(e){ return NaN; } }
      return NaN;
    }
  }
}
function wUn(op){
  switch(op){
    case "neg":case "abs":case "sign":return 1;
    case "sqrt":case "cbrt":case "inv":case "floor":case "ceil":case "round":case "frac":case "square":case "cube":return 2;
    case "exp":case "expm1":case "log":case "log10":case "log1p":case "sin":case "cos":case "tan":return 3;
    case "asin":case "acos":case "atan":case "sinh":case "cosh":case "tanh":return 4;
    default:{
      const m=CUSTOM_META.get(op);
      if(m && m.type==="un" && Number.isFinite(m.w)) return m.w|0;
      return 3;
    }
  }
}
function wBin(op){
  switch(op){
    case "+":case "-":case "*":case "/":return 1;
    case "^":return 3;
    case "logab":return 4;
    case "min":case "max":return 2;
    case "mod":return 3;
    case "atan2":case "hypot":return 4;
    case "gcd":case "lcm":return 6;
    default:{
      const m=CUSTOM_META.get(op);
      if(m && m.type==="bin" && Number.isFinite(m.w)) return m.w|0;
      return 2;
    }
  }
}
function isComm(op){
  if(op==="+"||op==="*"||op==="min"||op==="max"||op==="gcd"||op==="lcm")return true;
  const m=CUSTOM_META.get(op);
  return !!(m && m.type==="bin" && m.comm);
}

const TAG_NONE=0,TAG_NEG=1,TAG_EXP=2,TAG_LOG=3,TAG_SQRT=4,TAG_SQ=5,TAG_INV=6,TAG_ABS=7;
const TAG_ADD=17,TAG_SUB=18,TAG_MUL=19,TAG_DIV=20,TAG_POW=21;
const F_ZERO=1<<8,F_ONE=1<<9,F_NEGONE=1<<10,F_INT=1<<11,F_NONNEG=1<<12,F_CONST=1<<13,F_HAS_ABS=1<<14;
function getTag(f){return f&0xFF;}
function has(f,b){return(f&b)!==0;}
function pruneUn(op,cf,cv){
  if(FORBID_UN.has(op)) return true;
  const ct=getTag(cf);
  if(PRUNE_LEVEL===0){
    if(op==="neg"&&ct===TAG_NEG)return true;
    if(op==="inv"&&ct===TAG_INV)return true;
    return false;
  }
  if(op==="neg"&&ct===TAG_NEG)return true;
  if(op==="abs"&&(ct===TAG_ABS||ct===TAG_NEG))return true;
  if(op==="abs"&&has(cf,F_HAS_ABS))return true;
  if(op==="abs"&&has(cf,F_NONNEG))return true;
  if(op==="inv"&&ct===TAG_INV)return true;
  if(op==="exp"&&ct===TAG_LOG)return true;
  if(op==="log"&&ct===TAG_EXP)return true;
  if(op==="sqrt"&&ct===TAG_SQ)return true;
  if(op==="square"&&ct===TAG_SQRT)return true;
  if(op==="neg"&&has(cf,F_ZERO))return true;
  if(op==="sqrt"&&(has(cf,F_ZERO)||has(cf,F_ONE)))return true;
  if(op==="exp"&&has(cf,F_ZERO))return true;
  if(op==="log"&&has(cf,F_ONE))return true;
  if(op==="inv"&&(has(cf,F_ONE)||has(cf,F_NEGONE)))return true;
  if(op==="square"&&(has(cf,F_ZERO)||has(cf,F_ONE)))return true;
  if((op==="floor"||op==="ceil"||op==="round")&&has(cf,F_INT))return true;
  if(op==="frac"&&has(cf,F_INT))return true;
  if(op==="sign"&&(has(cf,F_ZERO)))return true;

  const fn=CUSTOM_PRUNE_UN.get(op);
  if(fn){ try{ if(fn(cf,cv)) return true; }catch(e){} }
  if(CONSTRAINT_UN_FN){ try{ if(CONSTRAINT_UN_FN({op,flags:cf,v:cv,tag:ct})) return true; }catch(e){} }

  return false;
}
function pruneBin(op,af,bf,av,bv){
  if(FORBID_BIN.has(op)) return true;
  if(PRUNE_LEVEL===0){
    if((op==="+"||op==="*") && has(af,F_CONST) && has(bf,F_CONST) && av > bv) return true;
    return false;
  }
  if(op==="+"&&(has(af,F_ZERO)||has(bf,F_ZERO)) && !NEED_ZERO)return true;
  if(op==="-"&&has(bf,F_ZERO))return true;
  if(op==="-"&&Math.abs(av-bv)<1e-15)return true;
  if(op==="-"&&has(af,F_ZERO))return true;
  if(op==="*"&&(has(af,F_ZERO)||has(bf,F_ZERO)))return true;
  if(op==="*"&&(has(af,F_ONE)||has(bf,F_ONE)) && !NEED_ONE)return true;
  if(op==="*"&&(has(af,F_NEGONE)||has(bf,F_NEGONE))&&HAS_NEG)return true;
  if(op==="/"&&has(af,F_ZERO))return true;
  if(op==="/"&&(has(bf,F_ONE)||has(bf,F_NEGONE)) && !NEED_ONE && (has(bf,F_NEGONE)?HAS_NEG:true))return true;
  if(op==="/"&&Math.abs(av-bv)<1e-15&&Math.abs(av)>1e-15)return true;
  if(op==="^"&&has(bf,F_ZERO) && !NEED_ZERO)return true;
  if(op==="^"&&has(bf,F_ONE)  && !NEED_ONE)return true;
  if(op==="^"&&has(af,F_ZERO) && !NEED_ZERO)return true;
  if(op==="^"&&has(af,F_ONE)  && !NEED_ONE)return true;
  if(op==="^"&&has(af,F_NEGONE)&&has(bf,F_INT))return true;

  if(op==="*"&&(getTag(af)===TAG_INV||getTag(bf)===TAG_INV) && HAS_DIV)return true;


  // commutative normalization for non-const nodes
  if((op==="+"||op==="*") && !has(af,F_CONST) && !has(bf,F_CONST)){
    if(Number.isFinite(av)&&Number.isFinite(bv)&&av>bv+1e-15) return true;
  }
  // associativity canonicalization (keep right-associated form)
  if(op==="+"&&getTag(af)===TAG_ADD) return true;
  if(op==="*"&&getTag(af)===TAG_MUL) return true;
  // subtraction normalization for const leaves when neg exists
  if(op==="-"&&HAS_NEG&&has(af,F_CONST)&&has(bf,F_CONST)&&av<bv) return true;

  const fn=CUSTOM_PRUNE_BIN.get(op);
  if(fn){ try{ if(fn(af,bf,av,bv)) return true; }catch(e){} }
  if(CONSTRAINT_BIN_FN){ try{ if(CONSTRAINT_BIN_FN({op,af,bf,av,bv})) return true; }catch(e){} }

  return false;
}

function bbScore(v, D, magA){
  if(!Number.isFinite(v))return 1e9;
  const a=Math.abs(v);
  const mag=magA*Math.log1p(a);
  if(a===0)return mag;
  let best=Math.abs(v-Math.round(v));
  const DD=D|0;
  for(let d=2;d<=DD;d++){
    const rd=Math.round(v*d);
    const err=Math.abs(v*d-rd)/d;
    if(err<best)best=err;
    if(best<1e-15)break;
  }
  return best+mag;
}

let layers=new Map();

function mkBucket(beam){
  // Bounded max-heap by keep (root = worst item). Fixed cap = beam*5 items.
  // O(log n) per insert, ~13x less memory than old Map approach.
  const cap=Math.max(beam*5,6000);
  const h=[];          // heap array
  const idx=new Map(); // key -> heap position
  function sw(i,j){const a=h[i],b=h[j];h[i]=b;h[j]=a;idx.set(b.key,i);idx.set(a.key,j);}
  function up(i){while(i>0){const p=(i-1)>>1;if(h[p].keep>=h[i].keep)break;sw(p,i);i=p;}}
  function dn(i){for(;;){let b=i,l=i*2+1,r=l+1;if(l<h.length&&h[l].keep>h[b].keep)b=l;if(r<h.length&&h[r].keep>h[b].keep)b=r;if(b===i)break;sw(i,b);i=b;}}
  const bucket={values(){return h;}};
  function put(key,pack){
    const i=idx.get(key);
    if(i!==undefined){if(pack.keep>=h[i].keep)return;h[i]=pack;pack.key=key;dn(i);return;}
    pack.key=key;
    if(h.length<cap){const i=h.length;h.push(pack);idx.set(key,i);up(i);}
    else if(pack.keep<h[0].keep){idx.delete(h[0].key);h[0]=pack;idx.set(key,0);dn(0);}
  }
  return{bucket,put};
}

onmessage=(ev)=>{
  const msg=ev.data;
  if(msg.type==="init"){
    KEYP=msg.keyPrec|0;
    USE_BITMASK=!!msg.useBitmask;
    NO_CONSTRAINT_FAST=!!msg.noConstraintFast;
    TCOUNT=msg.tCount|0;
    MAXT=msg.maxT?new Uint16Array(msg.maxT):null;
    OPS_UN=msg.opsUn||[];
    OPS_BIN=msg.opsBin||[];
    PRUNE=!!msg.pruneEquiv;
    NEED_ZERO=!!msg.needZero;
    NEED_ONE=!!msg.needOne;
    HAS_NEG=!!msg.hasNeg; HAS_SUB=!!msg.hasSub; HAS_DIV=!!msg.hasDiv; HAS_MUL=!!msg.hasMul;
    PRUNE_LEVEL = Math.max(0, Math.min(2, msg.pruneLevel|0));
    FORBID_UN = new Set(Array.isArray(msg.forbidUn)?msg.forbidUn:[]);
    FORBID_BIN = new Set(Array.isArray(msg.forbidBin)?msg.forbidBin:[]);
    CONSTRAINT_UN_FN=null; CONSTRAINT_BIN_FN=null;
    try{
      if(msg.constraintUnSrc) CONSTRAINT_UN_FN=new Function("ctx","const f=("+msg.constraintUnSrc+"); return !!f(ctx);");
      if(msg.constraintBinSrc) CONSTRAINT_BIN_FN=new Function("ctx","const f=("+msg.constraintBinSrc+"); return !!f(ctx);");
    }catch(e){ CONSTRAINT_UN_FN=null; CONSTRAINT_BIN_FN=null; }

    REQ_MASK = (msg.reqMask|0) || 0;
    REQ_POP  = (msg.reqPop|0) || 0;

    LEAF_ORDER = String(msg.leafOrder||"") || "";

    // compile custom ops
    CUSTOM_UN=new Map(); CUSTOM_BIN=new Map(); CUSTOM_META=new Map();
    CUSTOM_PRUNE_UN=new Map(); CUSTOM_PRUNE_BIN=new Map();
    try{
      const cu=msg.customUnary||[];
      for(const d of cu){
        if(!d||!d.key||!d.impl) continue;
        const key=String(d.key);
        CUSTOM_META.set(key,{type:"un", w:(d.weight|0)||3, comm:false});
        CUSTOM_UN.set(key, new Function("x","return ("+String(d.impl)+");"));
        if(d.pruneImpl) CUSTOM_PRUNE_UN.set(key, new Function("flags","x","return !!("+String(d.pruneImpl)+");"));
      }
      const cb=msg.customBinary||[];
      for(const d of cb){
        if(!d||!d.key||!d.impl) continue;
        const key=String(d.key);
        CUSTOM_META.set(key,{type:"bin", w:(d.weight|0)||2, comm:!!d.commutative});
        CUSTOM_BIN.set(key, new Function("a","b","return ("+String(d.impl)+");"));
        if(d.pruneImpl) CUSTOM_PRUNE_BIN.set(key, new Function("af","bf","a","b","return !!("+String(d.pruneImpl)+");"));
      }
    }catch(e){}

    layers=new Map();
    postMessage({type:"inited"});
    return;
  }
  if(msg.type==="setLayer"){
    layers.set(msg.cost|0,msg.layer);
    return;
  }
  if(msg.type==="task"){
    const{T,c,beam,capUn,capBin,workerId,workerCount,bbD,bbMagA,keepMode}=msg;
    const{bucket,put}=mkBucket(beam);
    let visited=0,pruned=0;

    function keepScoreSub(goal,bb){ return (keepMode==="goal")?goal:Math.min(goal,bb); }

    const keyOf=(v,maskOrCk)=>{
      const vk=vKey(v);
      if(USE_BITMASK) return vk+"|"+maskOrCk;
      if(NO_CONSTRAINT_FAST) return vk;
      return vk+"|"+maskOrCk;
    };

    for(const op of OPS_UN){
      const w=wUn(op),sc=c-w;
      if(sc<1)continue;
      const src=layers.get(sc);
      if(!src||!src.len)continue;
      const lim=Math.min(src.len,capUn);
      for(let i=workerId;i<lim;i+=workerCount){
        const av=src.v[i],af=src.flags?src.flags[i]:0;
        if(PRUNE&&pruneUn(op,af,av)){pruned++;continue;}
        const v=applyUn(op,av);visited++;
        if(!Number.isFinite(v)||Math.abs(v)>CAP)continue;
        const goal=Math.abs(v-T);
        const bb=bbScore(v,bbD,bbMagA);
        let keep=keepScoreSub(goal,bb);

        if(USE_BITMASK){
          const mask=src.mask[i]|0;
          if(LEAF_ORDER && src.ordOk && src.ordOk[i]===0) continue;
          keep *= reqAdj(mask);
          put(keyOf(v,mask),{v,goal,bb,keep,mask,kind:"u",op,ac:sc,ai:i});
        }else{
          if(NO_CONSTRAINT_FAST){
            put(keyOf(v,0),{v,goal,bb,keep,ck:"",kind:"u",op,ac:sc,ai:i});
          }else{
            // counts mode used only when enabled in main (not in this file by default)
            put(keyOf(v,""),{v,goal,bb,keep,ck:"",kind:"u",op,ac:sc,ai:i});
          }
        }
      }
    }

    for(const op of OPS_BIN){
      const w=wBin(op),rem=c-w;
      if(rem<2)continue;
      const comm=isComm(op);
      const icMax = comm ? Math.floor(rem/2) : (rem-1);
      for(let ic=1;ic<=icMax;ic++){
        const jc=rem-ic;
        const A=layers.get(ic),B=layers.get(jc);
        if(!A||!B||!A.len||!B.len)continue;
        const cA=Math.min(A.len,capBin),cB=Math.min(B.len,capBin);
        for(let ia=workerId;ia<cA;ia+=workerCount){
          const av=A.v[ia],af=A.flags?A.flags[ia]:0;
          const stB=(comm&&ic===jc)?ia:0;
          for(let ib=stB;ib<cB;ib++){
            const bv=B.v[ib],bf=B.flags?B.flags[ib]:0;
            if(PRUNE&&pruneBin(op,af,bf,av,bv)){pruned++;continue;}

            if(USE_BITMASK){
              const am=A.mask[ia]|0,bm=B.mask[ib]|0;
              if((am&bm)!==0)continue;

              if(LEAF_ORDER){
                if(A.ordOk && A.ordOk[ia]===0) continue;
                if(B.ordOk && B.ordOk[ib]===0) continue;
                // cheap nondecreasing order: if both have leaves then check A.max <= B.min
                if(A.ordHas && B.ordHas && A.ordHas[ia] && B.ordHas[ib]){
                  const aMx=A.ordMax[ia], bMn=B.ordMin[ib];
                  if(aMx > bMn) continue;
                }
              }

              const mask=am|bm;
              const v=applyBin(op,av,bv);visited++;
              if(!Number.isFinite(v)||Math.abs(v)>CAP)continue;
              const goal=Math.abs(v-T);
              const bb=bbScore(v,bbD,bbMagA);
              let keep=keepScoreSub(goal,bb);
              keep *= reqAdj(mask);
              put(keyOf(v,mask),{v,goal,bb,keep,mask,kind:"b",op,ac:ic,ai:ia,bc:jc,bi:ib});
            }else{
              const v=applyBin(op,av,bv);visited++;
              if(!Number.isFinite(v)||Math.abs(v)>CAP)continue;
              const goal=Math.abs(v-T);
              const bb=bbScore(v,bbD,bbMagA);
              const keep=keepScoreSub(goal,bb);
              put(keyOf(v,0),{v,goal,bb,keep,ck:"",kind:"b",op,ac:ic,ai:ia,bc:jc,bi:ib});
            }
          }
        }
      }
    }

    postMessage({type:"taskDone",payload:{visited,pruned,items:Array.from(bucket.values())}});
  }
};
`;

// ================= Worker builder =================
function buildWorker(){
const workerSrc = `
let stopFlag=false;

const CAP=1e12, EXACT_EPS=5e-15, INF=65535;

function modeParams(mode){
  if(mode==="speed") return {
    keyPrec:10, bestPrec:10, keepMode:"goal",
    bbD:18, bbMagA:0.032,
    qGoal:0.36,qBB:0.06,qMeet:0.10,qDiv:0.03,qPow:0.05,qFunc:0.03,qDepth:0.06,qMag:0.08,qIrr:0.02,
    qPowBase:0.08, qPowExp:0.06,
    qReq:0.06,
    meetStyle:"bin", meetPrec:10, meetQ:12288, meetR:6,
    revBeamMul:2.0, meetHitBonus:0.22,
    // 收紧eps: 原candEpsMul=1.55导致68%eps通过但29%confirm拒绝(昂贵AST求值)
    // 将candEpsMul从1.55→0.85, confirmEpsMul从0.92→0.75
    candEpsMul:0.85, confirmEpsMul:0.75, binSlackMul:0.10, confirmAbsFloor:1.2e-6,
    spillMul:0.78, capMul:1.0, keepMeetDup:false,
    meetSweepMul:0.20, meetSweepPowMul:0.34,
    beamMul:0.92, subLayerCapMul:1.08,
    // 减小索引探针量: meetKeyProbeCap 260→120, idxKeysPerItem 12→6(speed模式只用主键+邻域键)
    revIdxKeyCap:180, fwdIdxKeyCap:180, meetKeyProbeCap:48, meetSweepRevCap:120, idxKeysPerItem:4, idxPerItemCap:24,
    capUnMul:3.0, capBinMul:2.6, jumpMul:1.45, meetStage2:0, qSeed:0.08,
    // 明确设置采样率: 0.28 (原来undefined→0.50)
    meetFwdSampleRatio:0.09,
    // 每个fwd项最多尝试N对, 防止单项消耗过多时间
    speedMeetMaxPairsPerItem:22,
    // meetFwd扫描时只用主键检测revIdx命中(不生成全部transform域键)
    speedMeetScanPrimaryOnly:true,
    // buildRev中对非pow项跳过transform域键(只用主键+邻域)
    speedRevMeetPrimaryOnly:true,
    // speed模式每层meetFwd总时限(ms)
    speedMeetLayerTimeCapMs:10,
  };
  if(mode==="accuracy") return {
    keyPrec:14, bestPrec:13, keepMode:"goal",
    bbD:72, bbMagA:0.018,
    qGoal:0.15,qBB:0.09,qMeet:0.14,qDiv:0.04,qPow:0.12,qFunc:0.07,qDepth:0.08,qMag:0.09,qIrr:0.04,
    qPowBase:0.18, qPowExp:0.14, qFrac:0.10,
    qReq:0.10,
    meetStyle:"bin", meetPrec:13, meetQ:24576, meetR:12,
    revBeamMul:2.0, meetHitBonus:0.10,
    candEpsMul:0.85, confirmEpsMul:1.0, binSlackMul:0.30, confirmAbsFloor:0.0,
    spillMul:1.1, capMul:1.0, keepMeetDup:false,
    meetSweepMul:0.09, meetSweepPowMul:0.15,
    beamMul:1.0, subLayerCapMul:1.1,
    revIdxKeyCap:200, fwdIdxKeyCap:200, meetKeyProbeCap:280, meetSweepRevCap:140, idxKeysPerItem:10, idxPerItemCap:50,
    capUnMul:3.0, capBinMul:2.2, jumpMul:1.6, meetStage2:1, qSeed:0.12,
    meetFwdSampleRatio:0.35  // accuracy模式：严格采样，专注最接近T的候选
  };
  // === normal模式优化说明 (基于日志分析) ===
  // 日志: meetFwd=301148ms(76%), buildRev=89200ms(23%), rejConfirm=252133/610172=41%
  // 核心问题: candEpsMul太松→大量无效pair进入probe/confirm; meetFwdSampleRatio偏高→meet候选太多
  // revIdx分散: 323565 keys, avgItems=2.66, 说明索引碎片化严重
  // 优化策略:
  // 1. candEpsMul: 1.00→0.72 - 从日志看41% confirm拒绝率, 说明候选eps太松; 收紧30%可减少~25%无效pair
  // 2. meetFwdSampleRatio: 0.45→0.30 - meetFwd占76%时间, 采样比从45%→30%理论节省~33%时间
  // 3. revIdxKeyCap: 130→180 - 增加每个key存储候选数量以提高召回率(当前avgItems=2.66太少)
  // 4. idxPerItemCap: 32→48, idxKeysPerItem: 8→10 - 更多transform-domain key → 更广召回
  // 5. meetKeyProbeCap: 160→200 - 每次查找更多候选
  // 6. meetQ: 20480→24576 - 更细粒度量化减少漏解(桶边界问题)
  // 7. confirmEpsMul: 1.05→0.90 - 配合candEpsMul收紧, 减少虚警
  // 8. capUnMul/capBinMul微调: 收紧一点避免beam膨胀
  return {
    keyPrec:13, bestPrec:12, keepMode:"goal",
    bbD:52, bbMagA:0.02,
    qGoal:0.20,qBB:0.07,qMeet:0.22,qDiv:0.04,qPow:0.12,qFunc:0.06,qDepth:0.07,qMag:0.08,qIrr:0.03,
    qPowBase:0.16, qPowExp:0.12, qFrac:0.08,
    qReq:0.10,
    // meetQ提升: 更细粒度量化，减少桶边界漏解
    meetStyle:"bin", meetPrec:13, meetQ:24576, meetR:10,
    revBeamMul:1.4, meetHitBonus:0.22,
    // 关键修复: 收紧candEps减少无效confirm, confirmEps同步收紧
    candEpsMul:0.45, confirmEpsMul:0.55, binSlackMul:0.12, confirmAbsFloor:0.0,
    spillMul:1.0, capMul:1.0, keepMeetDup:false,
    meetSweepMul:0.12, meetSweepPowMul:0.20,
    beamMul:0.90, subLayerCapMul:1.0,
    // 增大索引容量: 提高召回
    revIdxKeyCap:240, fwdIdxKeyCap:240, meetKeyProbeCap:280, meetSweepRevCap:140, idxKeysPerItem:14, idxPerItemCap:64,
    capUnMul:2.5, capBinMul:2.0, jumpMul:1.55, meetStage2:1, qSeed:0.10,
    // 关键: 降低meetFwd采样比例, 释放76%时间占用
    meetFwdSampleRatio:0.18
  };
}

let KEYP=12, BESTP=11;
let ALLOW_ADD=true, NEED_ZERO=false, NEED_ONE=false;
let HAS_NEG=true, HAS_SUB=true, HAS_DIV=true, HAS_MUL=true;
let PRUNE_LEVEL=1;
let FORBID_UN=new Set(), FORBID_BIN=new Set();
let CONSTRAINT_UN_FN=null, CONSTRAINT_BIN_FN=null;

// bitmask coverage retention (RIES-like: preserve required constructs)
let REQ_MASK=0, REQ_POP=0;
function popcnt32(x){
  x = x - ((x >>> 1) & 0x55555555);
  x = (x & 0x33333333) + ((x >>> 2) & 0x33333333);
  return (((x + (x >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24;
}
function reqAdj(mask){
  if(!REQ_MASK) return 1.0;
  const cov = popcnt32((mask|0) & REQ_MASK);
  return 1.0 / (1.0 + 0.35 * cov);
}

function vKey(v){if(!Number.isFinite(v))return"NaN";if(Object.is(v,-0))v=0;return v.toPrecision(KEYP)}

let MEET_STYLE="prec";
let MEETP=10;
let MEET_Q=8192;
let MEET_R=2;
let ADAPTIVE_MEET=true;

function meetKeyPrec(v){if(!Number.isFinite(v))return"NaN";if(Object.is(v,-0))v=0;return v.toPrecision(MEETP)}
function meetKeyBinPrimary(v){
  if(!Number.isFinite(v))return"NaN";
  if(Object.is(v,-0))v=0;
  if(v===0)return"0|0|0";
  const sign=v<0?1:0;
  const a=Math.abs(v);
  const e=Math.floor(Math.log2(a));
  const scale=Math.pow(2,e);
  const x=a/scale;
  const q=Math.round(x*MEET_Q);
  return""+sign+"|"+e+"|"+q;
}
function meetPrimaryKey(v){
  return MEET_STYLE==="bin"?meetKeyBinPrimary(v):meetKeyPrec(v);
}
// Generalized meet keys: primary bin-quantized + neighborhood + precision +
// transform-domain keys so that values related by any monotone function can share keys.
// This allows fwd[f(x)] and rev[f(y)] to match even when f introduces nonlinearity.
const _meetKeyOut = []; 
// Inline quantized key builder for any domain value
function _bk(prefix,val){
  if(!Number.isFinite(val)||Math.abs(val)>1e13)return null;
  if(Object.is(val,-0))val=0;
  if(val===0)return prefix+"|0|0|0";
  const sign=val<0?1:0;
  const a=Math.abs(val);
  const e=Math.floor(Math.log2(a));
  const sc=Math.pow(2,e);
  const q=Math.round((a/sc)*MEET_Q);
  return prefix+"|"+sign+"|"+e+"|"+q;
}
function _bkNeighbor(prefix,val,rr){
  if(!Number.isFinite(val)||Math.abs(val)>1e13)return;
  if(Object.is(val,-0))val=0;
  if(val===0){_meetKeyOut.push(prefix+"|0|0|0");return;}
  const sign=val<0?1:0;
  const a=Math.abs(val);
  const e=Math.floor(Math.log2(a));
  const sc=Math.pow(2,e);
  const q0=Math.round((a/sc)*MEET_Q);
  _meetKeyOut.push(prefix+"|"+sign+"|"+e+"|"+q0);
  for(let d=1;d<=rr;d++){
    _meetKeyOut.push(prefix+"|"+sign+"|"+e+"|"+(q0-d));
    _meetKeyOut.push(prefix+"|"+sign+"|"+e+"|"+(q0+d));
  }
}
function meetKeys(v,goalHint=Infinity,depthHint=0,skipTransformDomains=false){
  if(MEET_STYLE!=="bin") return [meetKeyPrec(v)];
  if(!Number.isFinite(v)) return ["NaN"];
  if(Object.is(v,-0)) v=0;
  if(v===0) return ["0|0|0","0"];

  _meetKeyOut.length = 0;

  const sign=v<0?1:0;
  const a=Math.abs(v);
  const e=Math.floor(Math.log2(a));
  const scale=Math.pow(2,e);
  const x=a/scale;
  const q0 = Math.round(x * MEET_Q);

  _meetKeyOut.push(""+sign+"|"+e+"|"+q0);

  let rr=Math.max(1,MEET_R|0);
  if(ADAPTIVE_MEET){
    const g=Math.abs(Number.isFinite(goalHint)?goalHint:Infinity);
    const d=Math.max(0, depthHint|0);
    if(g>1e-2) rr=Math.min(rr,3);
    if(g>1) rr=Math.min(rr,2);
    if(d>=7) rr=Math.min(rr,2);
  }
  if(rr>0){
    for(let d=1;d<=rr;d++){
      _meetKeyOut.push(""+sign+"|"+e+"|"+(q0-d));
      _meetKeyOut.push(""+sign+"|"+e+"|"+(q0+d));
    }
  }

  // 在speed模式跳过变换域键时，只返回主键+邻域+精度键（共约7个）
  if(skipTransformDomains){
    _meetKeyOut.push(meetKeyPrec(v));
    return _meetKeyOut.slice();
  }

  // ▼▼▼ 新增：在粗粒度键(±rr)之外，加一个2倍分辨率的细粒度键
  // 解决 "ε漏解"：两值在同一粗桶边界两侧，粗键不重叠但实际值非常接近
  {
    const q0fine = Math.round(x * MEET_Q * 2); // 2倍分辨率
    _meetKeyOut.push("X|"+sign+"|"+e+"|"+q0fine);
    _meetKeyOut.push("X|"+sign+"|"+e+"|"+(q0fine-1));
    _meetKeyOut.push("X|"+sign+"|"+e+"|"+(q0fine+1));
  }
  // ▲▲▲ 结束

  _meetKeyOut.push(meetKeyPrec(v));

  const av=Math.abs(v);

  // --- Log-domain key (power-base meet: fwd[base] ↔ rev[exponent via ^]) ---
  if(av>1e-9 && av<1e10 && v>0){
    const lv=Math.log(v);
    if(Number.isFinite(lv) && Math.abs(lv)<1e9){
      _bkNeighbor("L",lv,Math.min(3,MEET_R));
    }
  }

  // --- Sqrt-domain key (square-root meet) ---
  if(v>=0 && av<1e10 && av>0){
    const sv=Math.sqrt(v);
    const k=_bk("S",sv);
    if(k)_meetKeyOut.push(k);
  }

  // --- Square-domain key: for x² meets; if we have v, add key for v² ---
  if(av<1e5){
    const sq=v*v;
    const k=_bk("Q",sq);
    if(k)_meetKeyOut.push(k);
  }

  // --- Cube-root domain key: cbrt(v) and v³ ---
  if(av>0 && av<1e9){
    const cr=Math.cbrt(v);
    if(Number.isFinite(cr)){
      const k=_bk("C",cr);
      if(k)_meetKeyOut.push(k);
    }
  }

  // Trig/exp cross-domain keys: only include when the result range is useful.
  // PERF FIX: these added 6-8 extra keys per value causing massive index bloat.
  // Only include asin/acos if in [-1,1] range (for trig-output meets)
  if(av<=1.0+1e-9){
    const as=Math.asin(Math.max(-1,Math.min(1,v)));
    if(Number.isFinite(as)){const k=_bk("AS",as);if(k)_meetKeyOut.push(k);}
  }
  // Only include exp key for small values (high probability of being log-inverse meet)
  if(av<6){
    const ev=Math.exp(v);
    if(Number.isFinite(ev)&&ev<1e8){
      const k=_bk("E",ev);
      if(k)_meetKeyOut.push(k);
    }
  }


  // 幂域键: v^2, v^3, v^(1/3)
  if(av>1e-9 && av<1e5){
    const v2=v*v;
    if(Number.isFinite(v2)&&Math.abs(v2)<1e12){
      const k=_bk("P2",v2);
      if(k)_meetKeyOut.push(k);
    }
    if(av<1e3){
      const v3=v*v*v;
      if(Number.isFinite(v3)&&Math.abs(v3)<1e12){
        const k=_bk("P3",v3);
        if(k)_meetKeyOut.push(k);
      }
    }
    const vc=Math.cbrt(v);
    if(Number.isFinite(vc)){
      const k=_bk("P13",vc);
      if(k)_meetKeyOut.push(k);
    }
  }

  return _meetKeyOut.slice();
}

function relAcc(v,T){
  const r=Math.abs(v-T)/Math.max(1,Math.abs(T));
  if(r<EXACT_EPS||r===0)return"exact";
  const n=1/r;
  if(!Number.isFinite(n))return"exact";
  return n>1e6?n.toExponential(4):n.toPrecision(6).replace(/\\\\.0+$/,"");
}

function safePowStable(a,b){
  if(!Number.isFinite(a)||!Number.isFinite(b))return NaN;
  if(a<0){const rb=Math.round(b);if(Math.abs(b-rb)>1e-12)return NaN;b=rb}
  if(Math.abs(b)>60)return NaN;
  if(a===0)return b>0?0:NaN;
  const r1=Math.pow(a,b);
  let r2=NaN;
  if(a>0){
    if(Math.abs(a-1)<0.25)r2=Math.exp(b*Math.log1p(a-1));
    else r2=Math.exp(b*Math.log(a));
  }
  const cands=[r1,r2].filter(v=>Number.isFinite(v)&&Math.abs(v)<=CAP);
  if(!cands.length)return NaN;
  if(cands.length===1)return cands[0];
  const gap=Math.abs(cands[0]-cands[1]);
  const scale=Math.max(1,Math.abs(cands[0]),Math.abs(cands[1]));
  return(gap<=1e-10*scale)?(0.5*(cands[0]+cands[1])):cands[0];
}
function erf(x){
  const s=x<0?-1:1;x=Math.abs(x);
  const t=1/(1+.3275911*x);
  return s*(1-((((1.061405429*t-1.453152027)*t+1.421413741)*t-.284496736)*t+.254829592)*t*Math.exp(-x*x))
}
function gamma(z){
  const p=[676.5203681218851,-1259.1392167224028,771.32342877765313,-176.61502916214059,12.507343278686905,-.13857109526572012,9.9843695780195716e-6,1.5056327351493116e-7];
  if(!Number.isFinite(z))return NaN;
  if(z<.5){const s=Math.sin(Math.PI*z);return s===0?NaN:Math.PI/(s*gamma(1-z))}
  z-=1;let x=.99999999999980993;
  for(let i=0;i<p.length;i++)x+=p[i]/(z+i+1);
  const t=z+p.length-.5;
  return Math.sqrt(2*Math.PI)*Math.pow(t,z+.5)*Math.exp(-t)*x
}
function factInt(n){if(n<0||n>170)return NaN;let v=1;for(let i=2;i<=n;i++)v*=i;return v}
function nearInt(x){return Math.abs(x-Math.round(x))<1e-12}
function gcdInt(a,b){a=Math.abs(a);b=Math.abs(b);while(b){const t=a%b;a=b;b=t}return a}

// ---- leafOrder constraint (early pruning like RIES rules) ----
let LEAF_ORDER=""; // "nondecreasing" | ""
function ordLeaf(sym){
  if(!LEAF_ORDER) return {has:0, ok:1, mn:0, mx:0};
  if(/^-?\\d+$/.test(sym)){
    const v=Number(sym);
    if(Number.isFinite(v)) return {has:1, ok:1, mn:v, mx:v};
  }
  return {has:0, ok:1, mn:0, mx:0};
}
function ordUn(st){ return st; }
function ordBin(a,b){
  if(!LEAF_ORDER) return {has:0, ok:1, mn:0, mx:0};
  if(!a.ok || !b.ok) return {has:(a.has|b.has), ok:0, mn:0, mx:0};
  if(a.has && b.has){
    if(a.mx > b.mn) return {has:1, ok:0, mn:0, mx:0};
    return {has:1, ok:1, mn:Math.min(a.mn,b.mn), mx:Math.max(a.mx,b.mx)};
  }
  if(a.has) return a;
  if(b.has) return b;
  return {has:0, ok:1, mn:0, mx:0};
}

// ---- custom ops support ----
let CUSTOM_UN=new Map();
let CUSTOM_BIN=new Map();
let CUSTOM_META=new Map(); // key->{type:"un"/"bin", w, comm}
let CUSTOM_INV_UN=new Map(); // key -> (r)=>[{v}]
let CUSTOM_INV_BIN_L=new Map(); // key -> (r,b)=>x
let CUSTOM_INV_BIN_R=new Map(); // key -> (r,a)=>x
let CUSTOM_PRUNE_UN=new Map();
let CUSTOM_PRUNE_BIN=new Map();

function wUn(op){switch(op){
  case"neg":case"abs":case"sign":return 1;
  case"sqrt":case"cbrt":case"inv":case"floor":case"ceil":case"round":case"frac":case"square":case"cube":return 2;
  case"exp":case"expm1":case"log":case"log10":case"log1p":case"sin":case"cos":case"tan":return 3;
  case"asin":case"acos":case"atan":case"sinh":case"cosh":case"tanh":case"erf":return 4;
  case"fact":return 6;case"gammafn":return 7;default:{
    const m=CUSTOM_META.get(op); if(m&&m.type==="un"&&Number.isFinite(m.w)) return m.w|0; return 3;
  }
}}
function wBin(op){switch(op){
  case"+":case"-":case"*":case"/":return 1;case"^":return 3;case"logab":return 4;
  case"min":case"max":return 2;case"mod":return 3;
  case"atan2":case"hypot":return 4;case"gcd":case"lcm":return 6;default:{
    const m=CUSTOM_META.get(op); if(m&&m.type==="bin"&&Number.isFinite(m.w)) return m.w|0; return 2;
  }
}}
function isComm(op){
  if(op==="+"||op==="*"||op==="min"||op==="max"||op==="gcd"||op==="lcm")return true;
  const m=CUSTOM_META.get(op); return !!(m&&m.type==="bin"&&m.comm);
}

function mkC(sym,val,ord){return{t:0,sym,val,p:0,f:0,d:0,ord:ord||{has:0,ok:1,mn:0,mx:0}}}
function mkU(op,ch){
  // normalize exp/expm1 to canonical forms
  if(op==="exp" && ch){
    const eNode=mkC("e",Math.E,ordLeaf("e"));
    return mkB("^",eNode,ch);
  }
  if(op==="expm1" && ch){
    const eNode=mkC("e",Math.E,ordLeaf("e"));
    const oneNode=mkC("1",1,ordLeaf("1"));
    return mkB("-",mkB("^",eNode,ch),oneNode);
  }
  const isFunc=op!=="neg"&&op!=="abs";
  return{t:1,op,ch,p:(ch&&ch.p)?1:0,f:(isFunc||((ch&&ch.f)?1:0))?1:0,d:(ch?ch.d:0)+1,ord:ordUn(ch.ord)};
}
function mkB(op,l,r){
  if(op==="-"&&ALLOW_ADD&&r&&r.t===1&&r.op==="neg"){
    const rr=r.ch;
    const o=ordBin(l.ord,rr.ord);
    return{t:2,op:"+",l,r:rr,p:((l&&l.p)||(rr&&rr.p))?1:0,f:((l&&l.f)||(rr&&rr.f))?1:0,d:Math.max(l?l.d:0,rr?rr.d:0)+1,ord:o};
  }
  const o=ordBin(l.ord,r.ord);
  return{t:2,op,l,r,p:(op==="^"||(l&&l.p)||(r&&r.p))?1:0,f:((l&&l.f)||(r&&r.f))?1:0,d:Math.max(l?l.d:0,r?r.d:0)+1,ord:o};
}

function applyUn(op,v){switch(op){
  case"neg":return-v;case"abs":return Math.abs(v);case"inv":return v===0?NaN:1/v;
  case"sqrt":return v<0?NaN:Math.sqrt(v);case"cbrt":return Math.cbrt(v);
  case"square":{const r=v*v;return r>CAP?NaN:r}
  case"cube":{const r=v*v*v;return Math.abs(r)>CAP?NaN:r}
  case"exp":return v>80?NaN:Math.exp(v);case"expm1":return v>80?NaN:Math.expm1(v);
  case"log":return v<=0?NaN:Math.log(v);case"log10":return v<=0?NaN:Math.log10(v);case"log1p":return v<=-1?NaN:Math.log1p(v);
  case"sin":return Math.sin(v);case"cos":return Math.cos(v);case"tan":return Math.tan(v);
  case"asin":return(v<-1||v>1)?NaN:Math.asin(v);case"acos":return(v<-1||v>1)?NaN:Math.acos(v);case"atan":return Math.atan(v);
  case"sinh":return Math.abs(v)>80?NaN:Math.sinh(v);case"cosh":return Math.abs(v)>80?NaN:Math.cosh(v);case"tanh":return Math.tanh(v);
  case"floor":return Math.floor(v);case"ceil":return Math.ceil(v);case"round":return Math.round(v);
  case"frac":return v-Math.floor(v);case"sign":return Math.sign(v);
  case"fact":return nearInt(v)?factInt(Math.round(v)):NaN;
  case"gammafn":return v>60?NaN:gamma(v);
  case"erf":return erf(v);
  default:{
    const fn=CUSTOM_UN.get(op);
    if(fn){ try{ return fn(v); }catch(e){ return NaN; } }
    return NaN;
  }
}}
function applyBin(op,a,b){switch(op){
  case"+":return a+b;case"-":return a-b;case"*":return a*b;case"/":return b===0?NaN:a/b;case"^":return safePowStable(a,b);
  case"logab":return (a>0&&a!==1&&b>0)?(Math.log(b)/Math.log(a)):NaN;
  case"min":return Math.min(a,b);case"max":return Math.max(a,b);
  case"atan2":return Math.atan2(a,b);case"hypot":return Math.hypot(a,b);
  case"mod":{if(!nearInt(a)||!nearInt(b))return NaN;const bb=Math.round(b);return bb===0?NaN:((Math.round(a)%bb)+bb)%bb}
  case"gcd":{if(!nearInt(a)||!nearInt(b))return NaN;const aa=Math.round(a),bb=Math.round(b);return(Math.abs(aa)>1e6||Math.abs(bb)>1e6)?NaN:gcdInt(aa,bb)}
  case"lcm":{if(!nearInt(a)||!nearInt(b))return NaN;const aa=Math.round(a),bb=Math.round(b);if(Math.abs(aa)>1e6||Math.abs(bb)>1e6)return NaN;return Math.abs(aa/gcdInt(aa,bb)*bb)}
  default:{
    const fn=CUSTOM_BIN.get(op);
    if(fn){ try{ return fn(a,b); }catch(e){ return NaN; } }
    return NaN;
  }
}}
function evalA(n){
  if(n.t===0)return n.val;
  if(n.t===1)return applyUn(n.op,evalA(n.ch));
  return applyBin(n.op,evalA(n.l),evalA(n.r));
}
function evalAStable(n){
  if(n.t===0)return n.val;
  if(n.t===1)return applyUn(n.op,evalAStable(n.ch));
  const lv=evalAStable(n.l),rv=evalAStable(n.r);
  if(n.op==="^")return safePowStable(lv,rv);
  return applyBin(n.op,lv,rv);
}
function astPowStats(n){
  if(!n)return{cnt:0,risk:0,val:NaN};
  if(n.t===0)return{cnt:0,risk:0,val:n.val};
  if(n.t===1){
    const cs=astPowStats(n.ch);
    return{cnt:cs.cnt,risk:cs.risk,val:applyUn(n.op,cs.val)};
  }
  const ls=astPowStats(n.l),rs=astPowStats(n.r);
  let cnt=ls.cnt+rs.cnt;
  let risk=ls.risk+rs.risk;
  const val=applyBin(n.op,ls.val,rs.val);
  if(n.op==="^"){
    cnt++;
    const b=ls.val,e=rs.val;
    if(Number.isFinite(b)&&Number.isFinite(e)){
      const ab=Math.abs(b),ae=Math.abs(e);
      const nearOne=1/Math.max(1e-6,Math.abs(ab-1));
      const sens=ae/Math.max(1e-6,ab);
      const expAmp=Math.max(0,ae-2);
      const localRisk=Math.min(20,0.05*sens+0.15*expAmp+2e-4*nearOne);
      risk+=localRisk;
    }else{risk+=5;}
  }
  return{cnt,risk,val};
}
function astDepth(n){ return (!n)?0:(n.d||0); }

// pretty
const PREC_ATOM=100,PREC_POSTFIX=96,PREC_UN=90,PREC_POW=80,PREC_MUL=70,PREC_ADD=60,PREC_FUNC=50;
function prec(n){
  if(n.t===0)return PREC_ATOM;
  if(n.t===1){if(n.op==="fact")return PREC_POSTFIX;return PREC_UN;}
  if(n.t===2){
    switch(n.op){case"^":return PREC_POW;case"*":case"/":return PREC_MUL;case"+":case"-":return PREC_ADD;default:return PREC_FUNC;}
  }
  return PREC_FUNC;
}
function needParen(child,parentOp,side){
  if(!parentOp)return false;
  const cp=prec(child);
  let pp;
  switch(parentOp){case"^":pp=PREC_POW;break;case"*":case"/":pp=PREC_MUL;break;case"+":case"-":pp=PREC_ADD;break;default:pp=PREC_FUNC;}
  if(cp>pp)return false;
  if(cp<pp)return true;
  if(parentOp==="-"&&side==="right")return true;
  if(parentOp==="/"&&side==="right")return true;
  if(parentOp==="^"){
    if(side==="left")return true;
    if(side==="right")return child.t===2&&child.op!=="^";
    return false;
  }
  return false;
}

function isNegAtomNode(n){
  return !!(n && n.t===0 && Number.isFinite(n.val) && n.val<0);
}
function absAtomText(n){
  const s=String(n?.sym??"");
  return s.startsWith("-")?s.slice(1):s;
}
function pretty(n,parentOp=null,side=null){
  if(n.t===0)return n.sym;
  if(n.t===1){
    const op=n.op,ch=n.ch;
    if(op==="neg"){
      if(ch&&ch.t===1&&ch.op==="neg") return pretty(ch.ch,parentOp,side);
      if(isNegAtomNode(ch)) return absAtomText(ch);
      const s=pretty(ch,"neg","right");const need=prec(ch)<PREC_UN;return"−"+(need?"("+s+")":s);
    }
    if(op==="sqrt"){const s=pretty(ch,null,null);const need=prec(ch)<PREC_UN;return"√"+(need?"("+s+")":s);}
    if(op==="cbrt"){const s=pretty(ch,null,null);const need=prec(ch)<PREC_UN;return"∛"+(need?"("+s+")":s);}
    if(op==="inv"){const s=pretty(ch,null,null);const need=prec(ch)<PREC_MUL;return"1/"+(need?"("+s+")":s);}
    if(op==="square"){const s=pretty(ch,null,null);const need=prec(ch)<PREC_POSTFIX;return(need?"("+s+")":s)+"²";}
    if(op==="cube"){const s=pretty(ch,null,null);const need=prec(ch)<PREC_POSTFIX;return(need?"("+s+")":s)+"³";}
    if(op==="fact"){const s=pretty(ch,null,null);const need=prec(ch)<PREC_POSTFIX;return(need?"("+s+")":s)+"!";}
    if(op==="exp"){
      const s=pretty(ch,null,null);
      const need=prec(ch)<PREC_POW || (ch&&ch.t===2);
      return "e^"+(need?"("+s+")":s);
    }
    if(op==="expm1"){
      const s=pretty(ch,null,null);
      const need=prec(ch)<PREC_POW || (ch&&ch.t===2);
      return "(e^"+(need?"("+s+")":s)+"−1)";
    }
    const s=pretty(ch,null,null);
    const name=(op==="gammafn")?"Γ":op;
    return name+"("+s+")";
  }
  let l=pretty(n.l,n.op,"left"), r=pretty(n.r,n.op,"right");
  if(needParen(n.l,n.op,"left")) l="("+l+")";
  if(needParen(n.r,n.op,"right")) r="("+r+")";
  if(n.op==="/")return l+"/"+r;
  if(n.op==="*")return l+"*"+r;
  if(n.op==="+"){
    if(n.r&&n.r.t===1&&n.r.op==="neg") return l+"−"+pretty(n.r.ch,n.op,"right");
    if(isNegAtomNode(n.r)) return l+"−"+absAtomText(n.r);
    return l+"+"+r;
  }
  if(n.op==="-")return l+"−"+r;
  if(n.op==="^")return l+"^"+r;
  return n.op+"("+l+","+r+")";
}
function strA(n){return pretty(n,null,null);}

function normalizeAST(n){
  if(!n) return n;
  if(n.t===0) return n;
  if(n.t===1){
    const ch=normalizeAST(n.ch);
    if(n.op==="exp"){
      const eNode=mkC("e",Math.E,ordLeaf("e"));
      return mkB("^",eNode,ch);
    }
    if(n.op==="expm1"){
      const eNode=mkC("e",Math.E,ordLeaf("e"));
      const oneNode=mkC("1",1,ordLeaf("1"));
      return mkB("-",mkB("^",eNode,ch),oneNode);
    }
    if(ch===n.ch) return n;
    return mkU(n.op,ch);
  }
  if(n.t===2){
    const l=normalizeAST(n.l), r=normalizeAST(n.r);
    if(l===n.l&&r===n.r) return n;
    return mkB(n.op,l,r);
  }
  return n;
}

// LaTeX
function latexWrap(s){ return "("+s+")"; }

function latexA(n){
  if(!n)return"";
  if(n.t===0){
    const s=String(n.sym||n.val||"0");
    if(s==="\\u03C0")return"\\\\pi ";
    if(s==="\\u03C6")return"\\\\varphi ";
    if(s==="\\u221A2")return"\\\\sqrt{2}";
    if(s==="\\u221A3")return"\\\\sqrt{3}";
    if(s==="\\u221A5")return"\\\\sqrt{5}";
    if(s==="\\u03B3")return"\\\\gamma ";
    if(s==="G(Catalan)")return"G";
    if(s==="\\u03B6(3)")return"\\\\zeta(3)";
    if(s==="ln(2)")return"\\\\ln 2";
    if(s==="ln(10)")return"\\\\ln 10";
    if(s==="2\\u03C0")return"2\\\\pi ";
    if(s==="\\u03C0/2")return"\\\\frac{\\\\pi}{2}";
    if(s==="\\u03C0/3")return"\\\\frac{\\\\pi}{3}";
    if(s==="\\u03C0/4")return"\\\\frac{\\\\pi}{4}";
    if(s==="1/2")return"\\\\frac{1}{2}";
    if(s==="1/3")return"\\\\frac{1}{3}";
    if(s==="2/3")return"\\\\frac{2}{3}";
    if(s==="1/4")return"\\\\frac{1}{4}";
    if(s==="3/4")return"\\\\frac{3}{4}";
    if(s==="1/5")return"\\\\frac{1}{5}";
    if(s==="2/5")return"\\\\frac{2}{5}";
    if(s==="1/6")return"\\\\frac{1}{6}";
    return s;
  }
  if(n.t===1){
    const ch=latexA(n.ch);
    const chAtom=(!n.ch||n.ch.t===0);
    const wrap=chAtom?ch:"\\\\left("+ch+"\\\\right)";
    switch(n.op){
      case"neg":return"-"+wrap;
      case"abs":return"\\\\left|"+ch+"\\\\right|";
      case"sqrt":return"\\\\sqrt{"+ch+"}";
      case"cbrt":return"\\\\sqrt[3]{"+ch+"}";
      case"inv":return"\\\\frac{1}{"+ch+"}";
      case"square":return"{"+wrap+"}^{2}";
      case"cube":return"{"+wrap+"}^{3}";
      case"fact":return wrap+"!";
      case"gammafn":return"\\\\Gamma\\\\!\\\\left("+ch+"\\\\right)";
      case"exp":return"e^{"+ch+"}";
      case"expm1":return"e^{"+ch+"}-1";
      case"log":return"\\\\ln\\\\!\\\\left("+ch+"\\\\right)";
      case"log10":return"\\\\log_{10}\\\\!\\\\left("+ch+"\\\\right)";
      case"log1p":return"\\\\ln\\\\!\\\\left(1+"+ch+"\\\\right)";
      case"sin":return"\\\\sin\\\\!\\\\left("+ch+"\\\\right)";
      case"cos":return"\\\\cos\\\\!\\\\left("+ch+"\\\\right)";
      case"tan":return"\\\\tan\\\\!\\\\left("+ch+"\\\\right)";
      case"asin":return"\\\\arcsin\\\\!\\\\left("+ch+"\\\\right)";
      case"acos":return"\\\\arccos\\\\!\\\\left("+ch+"\\\\right)";
      case"atan":return"\\\\arctan\\\\!\\\\left("+ch+"\\\\right)";
      case"sinh":return"\\\\sinh\\\\!\\\\left("+ch+"\\\\right)";
      case"cosh":return"\\\\cosh\\\\!\\\\left("+ch+"\\\\right)";
      case"tanh":return"\\\\tanh\\\\!\\\\left("+ch+"\\\\right)";
      case"floor":return"\\\\lfloor "+ch+"\\\\rfloor ";
      case"ceil":return"\\\\lceil "+ch+"\\\\rceil ";
      case"round":return"\\\\mathrm{round}\\\\!\\\\left("+ch+"\\\\right)";
      case"frac":return"\\\\left\\\\{"+ch+"\\\\right\\\\}";
      case"sign":return"\\\\mathrm{sgn}\\\\!\\\\left("+ch+"\\\\right)";
      case"erf":return"\\\\mathrm{erf}\\\\!\\\\left("+ch+"\\\\right)";
      default:return"\\\\mathrm{"+n.op+"}\\\\!\\\\left("+ch+"\\\\right)";
    }
  }
  // binary
  if(n.op==="/"){
    return"\\\\frac{"+latexA(n.l)+"}{"+latexA(n.r)+"}";
  }
  if(n.op==="^"){
    const bl=latexA(n.l);
    const base=(n.l&&n.l.t!==0)?"\\\\left("+bl+"\\\\right)":bl;
    return"{"+base+"}^{"+latexA(n.r)+"}";
  }
  let l=latexA(n.l),r=latexA(n.r);
  if(needParen(n.l,n.op,"left"))l="\\\\left("+l+"\\\\right)";
  if(needParen(n.r,n.op,"right"))r="\\\\left("+r+"\\\\right)";
  if(n.op==="*")return l+"\\\\cdot "+r;
  if(n.op==="+"){
    if(n.r&&n.r.t===1&&n.r.op==="neg")return l+"-"+latexA(n.r.ch);
    if(isNegAtomNode(n.r))return l+"-"+latexA({t:0,sym:absAtomText(n.r),val:Math.abs(n.r.val)});
    return l+"+"+r;
  }
  if(n.op==="-")return l+"-"+r;
  if(n.op==="logab")return"\\\\log_{"+latexA(n.l)+"}\\\\!\\\\left("+latexA(n.r)+"\\\\right)";
  if(n.op==="min")return"\\\\min\\\\!\\\\left("+latexA(n.l)+","+latexA(n.r)+"\\\\right)";
  if(n.op==="max")return"\\\\max\\\\!\\\\left("+latexA(n.l)+","+latexA(n.r)+"\\\\right)";
  if(n.op==="gcd")return"\\\\gcd\\\\!\\\\left("+latexA(n.l)+","+latexA(n.r)+"\\\\right)";
  if(n.op==="lcm")return"\\\\mathrm{lcm}\\\\!\\\\left("+latexA(n.l)+","+latexA(n.r)+"\\\\right)";
  if(n.op==="hypot")return"\\\\mathrm{hypot}\\\\!\\\\left("+latexA(n.l)+","+latexA(n.r)+"\\\\right)";
  if(n.op==="mod")return latexA(n.l)+"\\\\bmod "+latexA(n.r);
  if(n.op==="atan2")return"\\\\mathrm{atan2}\\\\!\\\\left("+latexA(n.l)+","+latexA(n.r)+"\\\\right)";
  return"\\\\mathrm{"+n.op+"}\\\\!\\\\left("+latexA(n.l)+","+latexA(n.r)+"\\\\right)";
}


const TAG_NONE=0,TAG_NEG=1,TAG_EXP=2,TAG_LOG=3,TAG_SQRT=4,TAG_SQ=5,TAG_INV=6,TAG_ABS=7;
const TAG_ADD=17,TAG_SUB=18,TAG_MUL=19,TAG_DIV=20,TAG_POW=21;
const F_ZERO=1<<8, F_ONE=1<<9, F_NEGONE=1<<10, F_INT=1<<11, F_NONNEG=1<<12, F_CONST=1<<13, F_HAS_ABS=1<<14, F_E=1<<15;

function mkFlags(v,tag,isLeaf,extra=0){
  let f=(tag&0xFF)|extra;const e=1e-15;
  if(Math.abs(v)<e)f|=F_ZERO;
  if(Math.abs(v-1)<e)f|=F_ONE;
  if(Math.abs(v+1)<e)f|=F_NEGONE;
  if(Math.abs(v-Math.E)<1e-13)f|=F_E; // 标记常数 e
  if(nearInt(v))f|=F_INT;
  if(v>=0)f|=F_NONNEG;
  if(isLeaf)f|=F_CONST;
  return f
}
function extraUnFlags(op,cf){return((op==="abs")||has(cf,F_HAS_ABS))?F_HAS_ABS:0;}
function extraBinFlags(af,bf){return(af|bf)&F_HAS_ABS;}
function getTag(f){return f&0xFF}
function has(f,b){return(f&b)!==0}
function opTag(op){switch(op){
  case"neg":return TAG_NEG;case"abs":return TAG_ABS;case"inv":return TAG_INV;
  case"exp":case"expm1":return TAG_EXP;case"log":case"log10":case"log1p":return TAG_LOG;
  case"sqrt":return TAG_SQRT;case"square":return TAG_SQ;
  case"+":return TAG_ADD;case"-":return TAG_SUB;case"*":return TAG_MUL;case"/":return TAG_DIV;case"^":return TAG_POW;
  default:return TAG_NONE
}}
function pruneUn(op,cf,cv){
  if(FORBID_UN.has(op)) return true;
  const ct=getTag(cf);
  if(PRUNE_LEVEL===0){
    if(op==="neg"&&ct===TAG_NEG)return true;
    if(op==="inv"&&ct===TAG_INV)return true;
    return false;
  }
  if(op==="neg"&&ct===TAG_NEG)return true;
  if(op==="abs"&&(ct===TAG_ABS||ct===TAG_NEG))return true;
  if(op==="abs"&&has(cf,F_HAS_ABS))return true;
  if(op==="abs"&&has(cf,F_NONNEG))return true;
  if(op==="inv"&&ct===TAG_INV)return true;
  if(op==="exp"&&ct===TAG_LOG)return true;
  if(op==="log"&&ct===TAG_EXP)return true;
  if(op==="sqrt"&&ct===TAG_SQ)return true;
  if(op==="square"&&ct===TAG_SQRT)return true;
  if(op==="neg"&&has(cf,F_ZERO))return true;
  if(op==="sqrt"&&(has(cf,F_ZERO)||has(cf,F_ONE)))return true;
  if(op==="exp"&&has(cf,F_ZERO))return true;
  if(op==="log"&&has(cf,F_ONE))return true;
  if(op==="inv"&&(has(cf,F_ONE)||has(cf,F_NEGONE)))return true;
  if(op==="square"&&(has(cf,F_ZERO)||has(cf,F_ONE)))return true;
  if((op==="floor"||op==="ceil"||op==="round")&&has(cf,F_INT))return true;
  if(op==="frac"&&has(cf,F_INT))return true;
  if(op==="sign"&&(has(cf,F_ZERO)))return true;

  const fn=CUSTOM_PRUNE_UN.get(op);
  if(fn){ try{ if(fn(cf,cv)) return true; }catch(e){} }
  if(CONSTRAINT_UN_FN){ try{ if(CONSTRAINT_UN_FN({op,flags:cf,v:cv,tag:ct})) return true; }catch(e){} }

  return false
}
function pruneBin(op,af,bf,av,bv){
  if(FORBID_BIN.has(op)) return true;
  if(PRUNE_LEVEL===0){
    if((op==="+"||op==="*") && has(af,F_CONST) && has(bf,F_CONST) && av > bv) return true;
    return false;
  }
  if(op==="+"&&(has(af,F_ZERO)||has(bf,F_ZERO))&&!NEED_ZERO)return true;
  if(op==="-"&&has(bf,F_ZERO))return true;
  if(op==="-"&&Math.abs(av-bv)<1e-15)return true;
  if(op==="-"&&has(af,F_ZERO))return true;
  if(op==="*"&&(has(af,F_ZERO)||has(bf,F_ZERO)))return true;
  if(op==="*"&&(has(af,F_ONE)||has(bf,F_ONE))&&!NEED_ONE)return true;
  if(op==="*"&&(has(af,F_NEGONE)||has(bf,F_NEGONE))&&HAS_NEG)return true;
  if(op==="/"&&has(af,F_ZERO))return true;
  if(op==="/"&&(has(bf,F_ONE)||has(bf,F_NEGONE))&&!NEED_ONE && (has(bf,F_NEGONE)?HAS_NEG:true))return true;
  if(op==="/"&&Math.abs(av-bv)<1e-15&&Math.abs(av)>1e-15)return true;
  if(op==="^"&&has(bf,F_ZERO)&&!NEED_ZERO)return true;
  if(op==="^"&&has(bf,F_ONE)&&!NEED_ONE)return true;
  if(op==="^"&&has(af,F_ZERO)&&!NEED_ZERO)return true;
  if(op==="^"&&has(af,F_ONE)&&!NEED_ONE)return true;
  if(op==="^"&&has(af,F_NEGONE)&&has(bf,F_INT))return true;

  // Only prune a + neg(x) if neg(x) is NOT a constant literal (constants can be negative)
  if(op==="+" && HAS_SUB && (getTag(bf)===TAG_NEG||getTag(af)===TAG_NEG)){
    // Allow: constant literals can have negative values (e.g. -3 is leaf, not neg(3))
    const isConstLit=(f)=>has(f,F_CONST);
    if(!isConstLit(af) && !isConstLit(bf)) return true;
  }
  if(op==="*" && HAS_DIV && (getTag(bf)===TAG_INV || getTag(af)===TAG_INV)) return true;
  if(op==="/" && HAS_MUL && getTag(bf)===TAG_INV) return true;

  // 交换律规范化：如果两个操作数都是常数，强制从小到大排列
  if((op==="+"||op==="*") && has(af,F_CONST) && has(bf,F_CONST) && av > bv) return true;


  // commutative normalization for non-const nodes
  if((op==="+"||op==="*") && !has(af,F_CONST) && !has(bf,F_CONST)){
    if(Number.isFinite(av)&&Number.isFinite(bv)&&av>bv+1e-15) return true;
  }
  // associativity canonicalization (keep right-associated form)
  if(op==="+"&&getTag(af)===TAG_ADD) return true;
  if(op==="*"&&getTag(af)===TAG_MUL) return true;
  // subtraction normalization for const leaves when neg exists
  if(op==="-"&&HAS_NEG&&has(af,F_CONST)&&has(bf,F_CONST)&&av<bv) return true;

  const fn=CUSTOM_PRUNE_BIN.get(op);
  if(fn){ try{ if(fn(af,bf,av,bv)) return true; }catch(e){} }
  if(CONSTRAINT_BIN_FN){ try{ if(CONSTRAINT_BIN_FN({op,af,bf,av,bv})) return true; }catch(e){} }

  return false
}

// Reverse inversion (built-in + custom inverses if provided)
// Generalized: covers ALL unary ops so rev layer can propagate through any composition
function invUn(op,r){switch(op){
  case"neg":return[{v:-r}];
  case"abs":return r<0?[]:[{v:r},{v:-r}];
  case"inv":return r===0?[]:[{v:1/r}];
  case"sqrt":return[{v:r*r}];
  case"cbrt":return[{v:r*r*r}];
  case"square":return r<0?[]:[{v:Math.sqrt(r)},{v:-Math.sqrt(r)}];
  case"cube":return[{v:Math.cbrt(r)}];
  case"exp":return r<=0?[]:[{v:Math.log(r)}];
  case"expm1":return[{v:Math.log1p(r)}];
  case"log":return[{v:Math.exp(r)}];
  case"log10":return r<=0?[]:[{v:Math.pow(10,r)}];
  case"log1p":return r<=-1?[]:[{v:Math.expm1(r)}];
  case"sin":{
    // sin(x)=r → x=arcsin(r)+2kπ or x=π-arcsin(r)+2kπ; emit primary branch only
    if(r<-1||r>1)return[];
    const a=Math.asin(r);
    if(!Number.isFinite(a))return[];
    return[{v:a},{v:Math.PI-a}];
  }
  case"cos":{
    // cos(x)=r → x=±arccos(r)
    if(r<-1||r>1)return[];
    const a=Math.acos(r);
    if(!Number.isFinite(a))return[];
    return[{v:a},{v:-a}];
  }
  case"tan":{
    // tan(x)=r → x=arctan(r) (principal)
    return[{v:Math.atan(r)}];
  }
  case"asin":{
    // asin(x)=r, r∈[-π/2,π/2] → x=sin(r)
    if(r<-Math.PI/2-1e-12||r>Math.PI/2+1e-12)return[];
    return[{v:Math.sin(r)}];
  }
  case"acos":{
    // acos(x)=r, r∈[0,π] → x=cos(r)
    if(r<-1e-12||r>Math.PI+1e-12)return[];
    return[{v:Math.cos(r)}];
  }
  case"atan":{
    // atan(x)=r, r∈(-π/2,π/2) → x=tan(r)
    if(Math.abs(r)>=Math.PI/2-1e-12)return[];
    const tv=Math.tan(r);
    if(!Number.isFinite(tv)||Math.abs(tv)>1e12)return[];
    return[{v:tv}];
  }
  case"sinh":return[{v:Math.asinh(r)}];
  case"cosh":{
    // cosh(x)=r, r≥1 → x=±acosh(r)
    if(r<1-1e-12)return[];
    const a=Math.acosh(r);
    if(!Number.isFinite(a))return[];
    return a<1e-12?[{v:0}]:[{v:a},{v:-a}];
  }
  case"tanh":{
    // tanh(x)=r, |r|<1 → x=atanh(r)
    if(r<=-1+1e-12||r>=1-1e-12)return[];
    return[{v:Math.atanh(r)}];
  }
  case"floor":{
    // floor(x)=r → x∈[r,r+1); representative: center r+0.5
    if(!Number.isInteger(r))return[];
    return[{v:r+0.5}];
  }
  case"ceil":{
    if(!Number.isInteger(r))return[];
    return[{v:r-0.5}];
  }
  case"round":{
    if(!Number.isInteger(r))return[];
    return[{v:r}]; // r itself rounds to r
  }
  case"frac":{
    // frac(x)=r, 0≤r<1 → x=r+n for any integer n; return a few representatives
    if(r<0||r>=1)return[];
    if(r<1e-14)return[{v:0},{v:1},{v:-1}];
    return[{v:r},{v:r+1},{v:r-1},{v:r+2}];
  }
  case"sign":return r===0?[{v:0}]:(r>0?[{v:1}]:[{v:-1}]);
  default:{
    const fn=CUSTOM_INV_UN.get(op);
    if(fn){ try{ return fn(r)||[]; }catch(e){ return []; } }
    return [];
  }
}}
function invBinR(op,r,a){switch(op){
  case"+":return r-a;case"-":return a-r;
  case"*":return a===0?NaN:r/a;case"/":return r===0?NaN:a/r;
  case"^":return a<=0||r<=0?NaN:Math.log(r)/Math.log(a);
  case"logab":return r===0?NaN:Math.pow(a,r);
  default:{
    const fn=CUSTOM_INV_BIN_R.get(op);
    if(fn){ try{ return fn(r,a); }catch(e){ return NaN; } }
    return NaN;
  }
}}
function invBinL(op,r,b){switch(op){
  case"+":return r-b;case"-":return r+b;
  case"*":return b===0?NaN:r/b;case"/":return r*b;
  case"^":return b===0||r<=0?NaN:Math.pow(r,1/b);
  case"logab":return (r!==0&&b>0)?Math.pow(b,1/r):NaN;
  default:{
    const fn=CUSTOM_INV_BIN_L.get(op);
    if(fn){ try{ return fn(r,b); }catch(e){ return NaN; } }
    return NaN;
  }
}}

function bbScore(v,D,magA){
  if(!Number.isFinite(v))return 1e9;
  const a=Math.abs(v);
  const mag=magA*Math.log1p(a);
  if(a===0)return mag;
  let best=Math.abs(v-Math.round(v));
  if(best<1e-15)return mag; // integer
  const DD=D|0;
  // Check small denominators first - most values are near simple fractions
  const vAbs=Math.abs(v);
  for(let d=2;d<=DD;d++){
    const vd=v*d;
    const rd=Math.round(vd);
    const err=Math.abs(vd-rd)/d;
    if(err<best){best=err;if(best<1e-15)break;}
  }
  return best+mag;
}

function mkBucket(beam,spillMul){
  // Bounded max-heap by keep score (root = worst / highest keep = most costly item).
  // cap = beam*5 instead of old beam*64 → ~13x memory reduction at c=13.
  // O(log n) insert/update, no periodic sort/spill overhead.
  const cap=Math.max(beam*5,6000);
  const h=[];           // max-heap array
  const kidx=new Map(); // key -> heap index
  function sw(i,j){const a=h[i],b=h[j];h[i]=b;h[j]=a;kidx.set(b.key,i);kidx.set(a.key,j);}
  function up(i){while(i>0){const p=(i-1)>>1;if(h[p].keep>=h[i].keep)break;sw(p,i);i=p;}}
  function dn(i){for(;;){let b=i,l=i*2+1,r=l+1;if(l<h.length&&h[l].keep>h[b].keep)b=l;if(r<h.length&&h[r].keep>h[b].keep)b=r;if(b===i)break;sw(i,b);i=b;}}
  const bucket={
    get size(){return h.length;},
    values(){return h;},
    isFull(){return h.length>=cap;},
    worstKeep(){return h.length>0?h[0].keep:Infinity;}
  };
  function put(key,pack){
    const i=kidx.get(key);
    if(i!==undefined){
      if(pack.keep>=h[i].keep)return false;
      h[i]=pack;pack.key=key;dn(i);return true;
    }
    pack.key=key;
    if(h.length<cap){const i=h.length;h.push(pack);kidx.set(key,i);up(i);return true;}
    if(pack.keep<h[0].keep){kidx.delete(h[0].key);h[0]=pack;kidx.set(key,0);dn(0);return true;}
    return false;
  }
  return{bucket,put};
}

// topK (heap)
function heapPushMax(heap, item, keyFn){
  heap.push(item);
  let i=heap.length-1;
  while(i>0){
    const p=(i-1)>>1;
    if(keyFn(heap[p])>=keyFn(heap[i]))break;
    const t=heap[p];heap[p]=heap[i];heap[i]=t;
    i=p;
  }
}
function heapPopMax(heap, keyFn){
  const top=heap[0];
  const last=heap.pop();
  if(heap.length){
    heap[0]=last;
    let i=0;
    for(;;){
      let l=i*2+1,r=l+1,b=i;
      if(l<heap.length && keyFn(heap[l])>keyFn(heap[b]))b=l;
      if(r<heap.length && keyFn(heap[r])>keyFn(heap[b]))b=r;
      if(b===i)break;
      const t=heap[i];heap[i]=heap[b];heap[b]=t;
      i=b;
    }
  }
  return top;
}
function topK(items,k,scoreFn,lowerBetter=true,filterFn=null){
  k=k|0;
  if(k<=0)return [];
  const heap=[];
  const keyFn=(x)=>x.__sc;
  const inv=lowerBetter?1:-1;
  for(let i=0;i<items.length;i++){
    const it=items[i];
    if(filterFn && !filterFn(it)) continue;
    const sc=scoreFn(it);
    if(!Number.isFinite(sc)) continue;
    it.__sc = sc*inv;
    if(heap.length<k){
      heapPushMax(heap,it,keyFn);
    }else if(it.__sc < heap[0].__sc){
      heap[0]=it;
      let idx=0;
      for(;;){
        let l=idx*2+1,r=l+1,b=idx;
        if(l<heap.length && keyFn(heap[l])>keyFn(heap[b]))b=l;
        if(r<heap.length && keyFn(heap[r])>keyFn(heap[b]))b=r;
        if(b===idx)break;
        const t=heap[idx];heap[idx]=heap[b];heap[b]=t;
        idx=b;
      }
    }
  }
  const out=[];
  while(heap.length) out.push(heapPopMax(heap,keyFn));
  out.reverse();
  return out;
}

function selectTop(items,beam,divRatio,mp,revIdx,allowPow,useBitmask,mode,T_target){
  const out=[];
  const used=new Set();
  // PERF FIX: reduced keepPoolMul to prevent O(n^2) topK calls on huge pools
  // Old: accuracy=18x beam (117K items) causing slow topK ops for 20+ quota categories
  const keepPoolMul = mode==="speed" ? 5 : (mode==="accuracy" ? 8 : 7);
  const keepPoolFloor = mode==="speed" ? 1600 : 3000;
  const keepPoolSize = Math.min(items.length, Math.max(beam*keepPoolMul, keepPoolFloor));
  const quotaPool = keepPoolSize<items.length ? topK(items,keepPoolSize,(x)=>x.keep,true) : items;

  const rootBest=new Map();
  const rootFreq=new Map();
  const rootKey=(it)=>{
    const ast=it&&it.ast;
    if(!ast) return "c";
    if(ast.t===2) return "b:"+ast.op;
    if(ast.t===1) return "u:"+ast.op;
    return "c";
  };
  for(const it of quotaPool){
    const r=rootKey(it);
    rootFreq.set(r,(rootFreq.get(r)||0)+1);
    const old=rootBest.get(r);
    if(old===undefined || it.keep<old) rootBest.set(r,it.keep);
  }
  const opPriorityAdj=(it)=>{
    const r=rootKey(it);
    const freq=rootFreq.get(r)||1;
    const bestKeep=rootBest.get(r);
    const rarity=1/Math.sqrt(freq);
    const quality=bestKeep===undefined ? 0 : (1/(1+bestKeep));
    // Encourage rare/high-quality operator roots so function priorities remain heuristic and unbiased.
    return (mode==="speed"?0.08:0.14)*rarity + (mode==="speed"?0.05:0.08)*quality;
  };

  const take=(arr,limit)=>{
    for(let i=0;i<arr.length&&out.length<beam&&limit>0;i++){
      const it=arr[i];
      const k=it.key;
      if(used.has(k))continue;
      used.add(k);
      out.push(it);
      limit--;
    }
  };

  if(revIdx){
    for(const it of items){
      const mk = it.mkey || (it.mkey = meetPrimaryKey(it.v));
      it.revHit = revIdx.has(mk);
    }
  }else{
    for(const it of items){it.revHit=false;}
  }

  // bitmask: compute required-coverage for quota/keep
  if(useBitmask && REQ_POP>0){
    for(const it of items){
      it.cov = popcnt32((it.mask|0) & REQ_MASK);
    }
  }else{
    for(const it of items){it.cov=0;}
  }

  const nGoal=Math.max(0,Math.floor(beam*mp.qGoal));
  const nBB=Math.max(0,Math.floor(beam*mp.qBB));
  const nMeet=Math.max(0,Math.floor(beam*(revIdx?mp.qMeet:0)));
  const nDiv=Math.max(0,Math.floor(beam*mp.qDiv));
  const nPow=Math.max(0,Math.floor(beam*(mp.qPow||0)));
  const nFunc=Math.max(0,Math.floor(beam*(mp.qFunc||0)));
  const nDepth=Math.max(0,Math.floor(beam*(mp.qDepth||0)));
  const nMagD=Math.max(0,Math.floor(beam*(mp.qMag||0)));
  const nIrr=Math.max(0,Math.floor(beam*(mp.qIrr||0)));
  const nPowBase=Math.max(0,Math.floor(beam*(mp.qPowBase||0)));
  const nPowExp=Math.max(0,Math.floor(beam*(mp.qPowExp||0)));
  const nReq=Math.max(0,Math.floor(beam*(mp.qReq||0)));
  const nFrac=Math.max(0,Math.floor(beam*(mp.qFrac||0)));
  // Quota: values in trig-OUTPUT range [-1,1] — required for sin/cos inverse meets
  const nTrigOut=Math.max(0,Math.floor(beam*(mode==="speed"?0.04:0.10)));
  // Quota: values in trig-ARGUMENT range approx [-2π,2π] — needed as cos/sin arguments
  const nTrigArg=Math.max(0,Math.floor(beam*(mode==="speed"?0.03:0.07)));
  // Quota: values useful as arcsin/arccos/arctan inverses (i.e. in [-π/2..π] range)
  const nInvTrig=Math.max(0,Math.floor(beam*(mode==="speed"?0.03:0.07)));
  const exploreRatio = mode==="speed" ? 0.035 : (mode==="accuracy" ? 0.26 : 0.22);
  const nExplore=Math.max(0, Math.floor(beam*exploreRatio));
  const nSeed=Math.max(0, Math.floor(beam*(mp.qSeed||0)));
  const nNovel=Math.max(0, Math.floor(beam*(mode==="speed"?0.04:0.14)));
  // 新增：变换亲和值配额 — 值接近T的各种变换（√T, ∛T, ln(T)等）的项
  const nTransformAffin=Math.max(0,Math.floor(beam*(mode==="speed"?0.04:0.10)));

  // ── PRIORITY STAGE: Building-block reservoir + mandatory magnitude diversity ──
  // These run BEFORE standard quotas so they can't be crowded out by near-T items.
  // Essential for compositions like f^g where f,g can be any value far from T.

  // 1. Mandatory magnitude coverage: one best item per log2-magnitude bucket (pos + neg).
  //    Ensures the beam always spans all scales: 0.001, 0.01, 0.1, 1, 10, 100...
  const nMandatoryMag = Math.floor(beam * (mode==="speed" ? 0.12 : 0.18));
  {
    const posBuckets=new Map(), negBuckets=new Map();
    for(const it of items){
      const v=it.v; if(!Number.isFinite(v))continue;
      const mb=Math.floor(Math.log2(Math.abs(v)+1e-30));
      if(v>=0){const old=posBuckets.get(mb);if(!old||it.keep<old.keep)posBuckets.set(mb,it);}
      else{const old=negBuckets.get(mb);if(!old||it.keep<old.keep)negBuckets.set(mb,it);}
    }
    take(Array.from(posBuckets.values()).sort((a,b)=>a.keep-b.keep), Math.ceil(nMandatoryMag*0.70));
    take(Array.from(negBuckets.values()).sort((a,b)=>a.keep-b.keep), Math.ceil(nMandatoryMag*0.30));
  }

  // 2. Building-block reservoir: top items scored PURELY by rationality (bb), not goal.
  //    Deliberately includes values far from T — they are bases/exponents for pow, sin args, etc.
  const nBlock = Math.floor(beam * (mode==="speed" ? 0.10 : 0.16));
  if(nBlock>0){
    take(topK(items, nBlock, (x)=>x.bb, true, (x)=>x.bb<0.18), nBlock);
  }

  take(topK(items,nGoal,(x)=>x.goal,true), nGoal);
  if(nMeet>0) take(topK(items,nMeet,(x)=>x.goal,true,(x)=>x.revHit), nMeet);

  // ▼▼▼ 新增：强制保留 revIdx 命中的项，防止它们被 goal 更近的项挤出 beam
  // 这些是 meet 搜索的高价值候选，即使 goal 不是最小也必须保留
  {
    const nRevHitForced = Math.max(0, Math.floor(beam * (mode==="speed"?0.06:0.10)));
    if(nRevHitForced>0){
      take(topK(items, nRevHitForced, (x)=>x.keep, true, (x)=>x.revHit && !used.has(x.key)), nRevHitForced);
    }
  }
  // ▲▲▲

  // Required-coverage quota (fix bitmask漏解 due to beam fragmentation)
  if(useBitmask && REQ_POP>0 && nReq>0){
    take(topK(items,nReq,(x)=>(x.keep - 0.35*(x.cov||0)),true,(x)=> (x.cov||0)>0), nReq);
  }

  // qFrac: keep highly rational values (small bb) in pow-useful range – key for e.g. 25/7 type bases
  if(nFrac>0){
    take(topK(quotaPool,nFrac,(x)=>x.bb,true,(x)=>{
      const v=x.v;
      if(!Number.isFinite(v)||Math.abs(v)<0.05)return false;
      const a=Math.abs(v);
      // Accept: nice fraction-like range (0.1..50), NOT already an integer
      return a<50 && a>0.1 && Math.abs(v-Math.round(v))>1e-9 && x.bb<0.15;
    }), nFrac);
  }

  // Trig-output range: values in [-1,1] are outputs of sin/cos/tanh, needed for inverse-trig meets
  // e.g. cos(tan(e)) ≈ some value → fwd must retain cos(tan(e)) which is in [-1,1]
  if(nTrigOut>0){
    take(topK(quotaPool,nTrigOut,(x)=>(x.goal*0.6+x.bb*0.4),true,(x)=>{
      const a=Math.abs(x.v);
      return Number.isFinite(x.v) && a<=1.0+1e-12;
    }), nTrigOut);
  }

  // Trig-argument range: values in [-2π,2π] useful as sin/cos/tan arguments
  if(nTrigArg>0){
    take(topK(quotaPool,nTrigArg,(x)=>(x.goal*0.5+x.bb*0.5),true,(x)=>{
      const a=Math.abs(x.v);
      return Number.isFinite(x.v) && a<=Math.PI*2+0.1 && a>1e-12;
    }), nTrigArg);
  }

  // Inverse-trig range: values in arcsin/arccos/arctan ranges [-π/2, π]
  // Needed so fwd can match rev[asin(T)], rev[acos(T)], rev[atan(T)] etc.
  if(nInvTrig>0){
    take(topK(quotaPool,nInvTrig,(x)=>(x.goal*0.4+x.bb*0.6),true,(x)=>{
      const v=x.v;
      if(!Number.isFinite(v))return false;
      const a=Math.abs(v);
      // asin/atan range: [-π/2, π/2], acos range [0, π]
      return a<=Math.PI+0.1 && a>1e-14;
    }), nInvTrig);
  }

  if(allowPow && nPow>0) take(topK(quotaPool,nPow,(x)=>(x.goal+0.20*x.bb),true,(x)=>x.hasPow), nPow);

  if(allowPow && nPowBase>0){
    const baseFilter=(x)=>{
      const v=x.v;
      if(!Number.isFinite(v))return false;
      if(v<=0)return false;
      const a=Math.abs(v);
      return a>0.12 && a<24 && Math.abs(a-1)>1e-12;
    };
    take(topK(quotaPool,nPowBase,(x)=>x.bb,true,baseFilter), nPowBase);
  }
  if(allowPow && nPowExp>0){
    const expFilter=(x)=>{
      const v=x.v;
      if(!Number.isFinite(v))return false;
      return Math.abs(v)<24;
    };
    take(topK(quotaPool,nPowExp,(x)=>(x.bb*0.7 + 0.01/(1+(x.depth||0))),false,expFilter), nPowExp);
  }

  if(nFunc>0){
    take(topK(quotaPool,nFunc,(x)=>(x.goal+0.16*x.bb-opPriorityAdj(x)),true,(x)=>x.hasFunc), nFunc);
  }

  if(nDepth>0){
    take(topK(quotaPool,nDepth,(x)=>-(x.depth||0),true), nDepth);
  }

  if(nMagD>0){
    const bins=new Map();
    for(const it of quotaPool){
      const mb=Math.floor(Math.log2(Math.abs(it.v)+1e-30));
      const old=bins.get(mb);
      if(!old||it.keep<old.keep)bins.set(mb,it);
    }
    const magList=Array.from(bins.values());
    magList.sort((a,b)=>a.keep-b.keep);
    take(magList,nMagD);
  }

  if(nIrr>0){
    take(topK(quotaPool,nIrr,(x)=> (x.bb*0.8 - x.goal*0.15 - opPriorityAdj(x)*0.25), false), nIrr);
  }

  take(topK(quotaPool,nBB,(x)=>x.bb,true), nBB);

  if(nSeed>0){
    const seed=topK(quotaPool,nSeed,(x)=>((x.cost||0)*0.7 + x.bb*0.25 + x.goal*0.05 - opPriorityAdj(x)*0.25),true,(x)=>((x.cost||0)<=6)&&!used.has(x.key));
    take(seed,nSeed);
  }

  if(nExplore>0){
    const ex = topK(quotaPool,nExplore,(x)=>((x.goal*0.55)+(x.bb*0.35)-0.03*(x.depth||0)-opPriorityAdj(x)*0.45),true,(x)=>!used.has(x.key));
    take(ex,nExplore);
  }

  if(nNovel>0){
    const bins=new Map();
    for(const it of quotaPool){
      if(used.has(it.key)) continue;
      const root=(it.ast&&it.ast.t===2)?it.ast.op:((it.ast&&it.ast.t===1)?("u:"+it.ast.op):"c");
      const d=(it.depth||0);
      const db=d<3?d:(d<6?6:9);
      const mb=Math.floor(Math.log2(Math.abs(it.v)+1e-30));
      const sig=root+"|"+db+"|"+mb;
      const old=bins.get(sig);
      if(!old || it.keep<old.keep) bins.set(sig,it);
    }
    const arr=Array.from(bins.values()).sort((a,b)=>a.keep-b.keep);
    take(arr,nNovel);
  }

  if(nDiv>0){
    const bins=new Map();
    for(const it of quotaPool){
      if(used.has(it.key))continue;
      const b=Math.floor(Math.log(Math.abs(it.v)+1e-30)*3);
      const old=bins.get(b);
      if(!old||it.keep<old.keep)bins.set(b,it);
    }
    const divArr=Array.from(bins.values()).sort((a,b)=>a.keep-b.keep);
    take(divArr,nDiv);
  }

  // ── POWER-DECOMPOSITION quotas: retain values near T^(1/n) for outer pow/square/cube ──
  // These are critical building blocks for expressions like (f(x))^2 = T → f(x) ≈ √T.
  // Without dedicated quota, the beam discards values near √T as "far from T".
  if(Number.isFinite(T_target) && T_target>0){
    // sqrt quota: retain best items near ±√T (square-type meets)
    const sqT=Math.sqrt(T_target);
    const nSqrt=Math.max(0,Math.floor(beam*(mode==="speed"?0.08:0.14)));
    if(nSqrt>0){
      take(topK(quotaPool,nSqrt,(x)=>{
        const d=Math.min(Math.abs(x.v-sqT),Math.abs(x.v+sqT));
        return d/(1e-12+Math.abs(sqT));
      },true), nSqrt);
    }
    // cbrt quota: retain best items near ∛T (cube-type meets)
    const cbT=Math.cbrt(T_target);
    const nCbrt=Math.max(0,Math.floor(beam*(mode==="speed"?0.05:0.09)));
    if(nCbrt>0){
      take(topK(quotaPool,nCbrt,(x)=>{
        const d=Math.min(Math.abs(x.v-cbT),Math.abs(x.v+cbT));
        return d/(1e-12+Math.abs(cbT));
      },true), nCbrt);
    }
    // T^(1/4) and T^(1/5) quotas for deeper power chains
    for(const n of [4,5]){
      const pT=Math.pow(T_target,1/n);
      if(Number.isFinite(pT) && pT > 1e-10 && pT < 1e8){
        const nP=Math.max(0,Math.floor(beam*(mode==="speed"?0.03:0.06)));
        if(nP>0) take(topK(quotaPool,nP,(x)=>Math.abs(x.v-pT)/(1e-12+pT),true), nP);
      }
    }
    // T/n quotas for additive/multiplicative decompositions (outer */+ meets)
    for(const n of [2,3,Math.PI,Math.E]){
      const vn=T_target/n;
      if(Number.isFinite(vn) && Math.abs(vn)<1e8 && Math.abs(vn)>1e-12){
        const nVn=Math.max(0,Math.floor(beam*(mode==="speed"?0.025:0.05)));
        if(nVn>0) take(topK(quotaPool,nVn,(x)=>Math.abs(x.v-vn)/(1e-12+Math.abs(vn)),true), nVn);
      }
    }
  } else if(Number.isFinite(T_target)){
    // T < 0: try ±|T|^(1/n) for odd n (cube-root of negative)
    const cbT=Math.cbrt(T_target);
    const nCbrt=Math.max(0,Math.floor(beam*(mode==="speed"?0.04:0.08)));
    if(nCbrt>0) take(topK(quotaPool,nCbrt,(x)=>Math.abs(x.v-cbT)/(1e-12+Math.abs(cbT)),true), nCbrt);
  }

  // ── 子表达式目标配额 ──
  // 保留与 T 的多级分解目标值接近的项
  if(Number.isFinite(T_target)){
    const absT4=Math.abs(T_target);
    const subTargets=[];
    if(absT4>0){
      const sqT=Math.sqrt(absT4);
      subTargets.push(sqT,-sqT,Math.cbrt(T_target));
      if(T_target>0) subTargets.push(Math.log(T_target));
      // 二级分解: √T / 常数
      for(const c of [Math.PI,Math.E,2,3]){
        subTargets.push(sqT/c, sqT*c, sqT-c, T_target/c);
        // 三级: e - √T/c
        const mid=sqT/c;
        if(Number.isFinite(mid)) subTargets.push(Math.E-mid, Math.PI-mid);
      }
      // 幂根
      for(let n=4;n<=6;n++){
        const r=Math.pow(absT4,1/n);
        if(Number.isFinite(r)) subTargets.push(r);
      }
    }
    const nSubQ=Math.max(0,Math.floor(beam*(mode==="speed"?0.06:0.12)));
    if(nSubQ>0){
      for(const sv of subTargets){
        if(!Number.isFinite(sv)||Math.abs(sv)>1e8) continue;
        take(topK(quotaPool,Math.max(2,Math.floor(nSubQ/subTargets.length)+1),(x)=>{
          return Math.abs(x.v-sv)/(1e-12+Math.abs(sv)+1);
        },true),Math.max(2,Math.floor(nSubQ/subTargets.length)+1));
      }
    }
  }

  if(out.length<beam){
    take(topK(quotaPool,beam-out.length,(x)=>(x.keep-opPriorityAdj(x)*0.12),true), beam-out.length);
  }

  // ── 新增：变换亲和值配额 — 保留接近T各种变换的项，扩展jumpLookupNear可以找到的候选 ──
  if(nTransformAffin>0 && Number.isFinite(T_target)){
    const transTargets=[];
    const absT2=Math.abs(T_target);
    if(absT2>0) transTargets.push(Math.sqrt(absT2), -Math.sqrt(absT2), Math.cbrt(T_target));
    if(T_target>0) transTargets.push(Math.log(T_target));
    if(absT2>1e-12) transTargets.push(1/T_target);
    if(Math.abs(T_target)<=1) transTargets.push(Math.asin(Math.max(-1,Math.min(1,T_target))));
    transTargets.push(Math.atan(T_target));
    const validTrans=transTargets.filter(v=>Number.isFinite(v)&&Math.abs(v)<1e8);
    for(const tv of validTrans){
      const nThis=Math.max(2,Math.floor(nTransformAffin/validTrans.length));
      if(nThis>0) take(topK(quotaPool,nThis,(x)=>Math.abs(x.v-tv)/(1e-9+Math.abs(tv)+1),true,(x)=>!used.has(x.key)), nThis);
    }
  }

  if(Number.isFinite(T_target)){
    const absT=Math.abs(T_target);
    const subExprTargets=[];
    if(absT>0) subExprTargets.push({val:Math.sqrt(absT),w:0.18});
    if(absT>0) subExprTargets.push({val:-Math.sqrt(absT),w:0.12});
    if(absT>0){
      const sqT=Math.sqrt(absT);
      for(const c of [Math.PI, Math.E, 2, 3, Math.SQRT2]){
        if(c>1e-12){
          subExprTargets.push({val:sqT/c,w:0.10});
          subExprTargets.push({val:sqT*c,w:0.06});
          subExprTargets.push({val:sqT-c,w:0.06});
          subExprTargets.push({val:sqT+c,w:0.04});
        }
      }
    }
    if(absT>0){
      const sqT=Math.sqrt(absT);
      const targets1=[sqT/Math.PI, sqT/Math.E, sqT/2, sqT/3];
      for(const t1 of targets1){
        if(!Number.isFinite(t1)||Math.abs(t1)>1e8) continue;
        const t2=Math.E-t1; if(Number.isFinite(t2)&&Math.abs(t2)<1e6) subExprTargets.push({val:t2,w:0.08});
        const t3=Math.PI-t1; if(Number.isFinite(t3)&&Math.abs(t3)<1e6) subExprTargets.push({val:t3,w:0.06});
        if(t1>0){ const lt=Math.log(t1); if(Number.isFinite(lt)) subExprTargets.push({val:lt,w:0.05}); }
      }
    }
    for(const c of [Math.PI, Math.E, 2, 3, 4, 5, 6, Math.PI*Math.PI, Math.E*Math.E]){
      const v1=T_target/c; if(Number.isFinite(v1)&&Math.abs(v1)<1e8) subExprTargets.push({val:v1,w:0.04});
      const v2=T_target*c; if(Number.isFinite(v2)&&Math.abs(v2)<1e8) subExprTargets.push({val:v2,w:0.03});
    }
    if(T_target>0){
      subExprTargets.push({val:Math.log(T_target),w:0.08});
      subExprTargets.push({val:Math.log(T_target)/2,w:0.05});
    }
    for(let n=2;n<=6;n++){
      const r=Math.pow(absT,1/n);
      if(Number.isFinite(r)) subExprTargets.push({val:r,w:0.06});
      if(Number.isFinite(r)&&r>1e-9) subExprTargets.push({val:-r,w:0.03});
    }
    const nSubExpr=Math.max(0,Math.floor(beam*(mode==="speed"?0.06:0.14)));
    if(nSubExpr>0 && subExprTargets.length>0){
      for(const st of subExprTargets){
        const tv=st.val;
        if(!Number.isFinite(tv)) continue;
        const nThis=Math.max(2,Math.floor(nSubExpr*st.w));
        take(topK(quotaPool,nThis,(x)=>{
          const d=Math.abs(x.v-tv)/(1e-12+Math.abs(tv)+1);
          return d - 0.02*(x.bb<0.1?1:0);
        },true), nThis);
      }
    }
  }

  if(out.length<beam){
    // Fallback to full set for safety so precision does not regress when pool is too narrow.
    take(topK(items,beam-out.length,(x)=>x.keep,true), beam-out.length);
  }
  for(const it of out){
    if(it.__sc!==undefined) delete it.__sc;
    if(it.revHit!==undefined) delete it.revHit;
    if(it.cov!==undefined) delete it.cov;
  }
  return out;
}

onmessage=async(ev)=>{
  const msg=ev.data;
  if(msg.type==="stop"){stopFlag=true;return;}
  if(msg.type!=="start")return;

  stopFlag=false;

  let{
    T,mode,maxC,beam,divRatio,outN,timeLimit,infiniteTime,emitInterval,
    opsUn,opsBin,consts,showCounts,bidir,pruneEquiv,excludeExact,dedupeByValue,
    mt,threads,subSrc,
    customEnable,customCode
  }=msg;

  mode=mode||"speed";
  mode=(mode==="balanced"||mode==="meet"||mode==="free"||mode==="meetfast"||mode==="medium")?"normal":mode;
  mode=(mode==="ries")?"accuracy":mode;
  const mp=modeParams(mode);

  // compile custom
  let customAllow=null,customScoreAdjust=null;
  let ext={constants:[],unaryOps:[],binaryOps:[]};
  let constraints={};
  let customUnary=[], customBinary=[];
  if(!!customEnable){
    try{
      const scope=new Function('"use strict";\\n'+String(customCode||"")+'\\n; return {'
        +'getExtensions:(typeof getExtensions==="function")?getExtensions:null,'
        +'getConstraints:(typeof getConstraints==="function")?getConstraints:null,'
        +'allowCandidate:(typeof allowCandidate==="function")?allowCandidate:null,'
        +'scoreAdjust:(typeof scoreAdjust==="function")?scoreAdjust:null'
      +'};')();

      customAllow=scope.allowCandidate;
      customScoreAdjust=scope.scoreAdjust;
      constraints = scope.getConstraints ? (scope.getConstraints()||{}) : {};
      ext = scope.getExtensions ? (scope.getExtensions()||{}) : {};
    }catch(err){
      postMessage({type:"error",payload:"自定义脚本错误: "+err.message});
      return;
    }
  }

  // normalize constraints
  const leafOrder = String(constraints?.leafOrder||"");
  LEAF_ORDER = (leafOrder==="nondecreasing") ? "nondecreasing" : "";

  const pruneLevelRaw = String(constraints?.pruneLevel||"normal").toLowerCase();
  PRUNE_LEVEL = pruneLevelRaw==="relaxed" ? 0 : (pruneLevelRaw==="aggressive" ? 2 : 1);
  FORBID_UN = new Set(Array.isArray(constraints?.forbidUnary)?constraints.forbidUnary.map(String):[]);
  FORBID_BIN = new Set(Array.isArray(constraints?.forbidBinary)?constraints.forbidBinary.map(String):[]);
  CONSTRAINT_UN_FN = (typeof constraints?.unaryPrune==="function") ? constraints.unaryPrune : null;
  CONSTRAINT_BIN_FN = (typeof constraints?.binaryPrune==="function") ? constraints.binaryPrune : null;
  const CONSTRAINT_UN_SRC = (typeof constraints?.unaryPruneImpl==="string"&&constraints.unaryPruneImpl.trim()) ? constraints.unaryPruneImpl.trim() : (CONSTRAINT_UN_FN ? CONSTRAINT_UN_FN.toString() : "");
  const CONSTRAINT_BIN_SRC = (typeof constraints?.binaryPruneImpl==="string"&&constraints.binaryPruneImpl.trim()) ? constraints.binaryPruneImpl.trim() : (CONSTRAINT_BIN_FN ? CONSTRAINT_BIN_FN.toString() : "");
  if(!CONSTRAINT_UN_FN && CONSTRAINT_UN_SRC){ try{ CONSTRAINT_UN_FN = new Function("ctx","const f=("+CONSTRAINT_UN_SRC+"); return !!f(ctx);"); }catch(e){ CONSTRAINT_UN_FN=null; } }
  if(!CONSTRAINT_BIN_FN && CONSTRAINT_BIN_SRC){ try{ CONSTRAINT_BIN_FN = new Function("ctx","const f=("+CONSTRAINT_BIN_SRC+"); return !!f(ctx);"); }catch(e){ CONSTRAINT_BIN_FN=null; } }

  // normalize extensions (ops only; constants are already in 'consts' list passed from UI)
  function normOpDef(d,kind){
    if(!d||!d.key||!d.impl) return null;
    const o={
      key:String(d.key),
      kind,
      weight: (d.weight|0) || (kind==="un"?3:2),
      commutative: !!d.commutative,
      impl: String(d.impl),
      pruneImpl: d.pruneImpl ? String(d.pruneImpl) : "",
      invImpl: d.invImpl ? String(d.invImpl) : "",
      invLImpl: d.invLImpl ? String(d.invLImpl) : "",
      invRImpl: d.invRImpl ? String(d.invRImpl) : ""
    };
    return o;
  }
  customUnary = Array.isArray(ext?.unaryOps) ? ext.unaryOps.map(d=>normOpDef(d,"un")).filter(Boolean) : [];
  customBinary = Array.isArray(ext?.binaryOps) ? ext.binaryOps.map(d=>normOpDef(d,"bin")).filter(Boolean) : [];

  // install custom ops
  CUSTOM_UN=new Map(); CUSTOM_BIN=new Map(); CUSTOM_META=new Map();
  CUSTOM_INV_UN=new Map(); CUSTOM_INV_BIN_L=new Map(); CUSTOM_INV_BIN_R=new Map();
  CUSTOM_PRUNE_UN=new Map(); CUSTOM_PRUNE_BIN=new Map();
  try{
    for(const d of customUnary){
      CUSTOM_META.set(d.key,{type:"un", w:d.weight, comm:false});
      CUSTOM_UN.set(d.key, new Function("x","return ("+d.impl+");"));
      if(d.pruneImpl) CUSTOM_PRUNE_UN.set(d.key, new Function("flags","x","return !!("+d.pruneImpl+");"));
      if(d.invImpl) CUSTOM_INV_UN.set(d.key, new Function("r","return ("+d.invImpl+")(r);"));
    }
    for(const d of customBinary){
      CUSTOM_META.set(d.key,{type:"bin", w:d.weight, comm:!!d.commutative});
      CUSTOM_BIN.set(d.key, new Function("a","b","return ("+d.impl+");"));
      if(d.pruneImpl) CUSTOM_PRUNE_BIN.set(d.key, new Function("af","bf","a","b","return !!("+d.pruneImpl+");"));
      if(d.invLImpl) CUSTOM_INV_BIN_L.set(d.key, new Function("r","b","return ("+d.invLImpl+")(r,b);"));
      if(d.invRImpl) CUSTOM_INV_BIN_R.set(d.key, new Function("r","a","return ("+d.invRImpl+")(r,a);"));
    }
  }catch(e){
    postMessage({type:"error",payload:"自定义扩展编译失败: "+(e?.message||String(e))});
    return;
  }

  KEYP=mp.keyPrec;
  BESTP=mp.bestPrec;
  MEET_STYLE=mp.meetStyle;
  MEETP=mp.meetPrec;
  MEET_Q=mp.meetQ|0;
  MEET_R=mp.meetR|0;

  emitInterval=Math.max(50,Math.min(60000,emitInterval|0||500));
  const lim=infiniteTime?Infinity:Math.max(0,timeLimit);
  divRatio=Math.max(0,Math.min(1,divRatio||0));
  excludeExact=!!excludeExact;
  dedupeByValue=!!dedupeByValue;
  pruneEquiv=!!pruneEquiv;
  bidir=!!bidir;
  mt=!!mt;
  threads=Math.max(1,Math.min(64,(threads|0)||1));

  // Do NOT shrink forward beam just because bidir is on (prevents missing hard constructions)
  const bidirMul = (bidir && mode==="speed") ? 0.90 : 1.0;

  const beamF=Math.max(50,Math.floor(beam*(mp.beamMul||1)*bidirMul));
  const beamR=Math.max(50,Math.floor(beam*(mp.revBeamMul||1)));
  const subLayerCap=Math.max(32,Math.floor(beamF*(mp.subLayerCapMul||1)));

  const nC=consts.length;
  const constrainedIdx=[];
  for(let i=0;i<nC;i++){
    const mn=consts[i].min??0,mx=consts[i].max??INF;
    if(mn>mx){postMessage({type:"error",payload:consts[i].s+" min>max"});return}
    if(mn>0||mx<INF)constrainedIdx.push(i);
  }

  ALLOW_ADD=Array.isArray(opsBin)&&opsBin.includes("+");
  HAS_NEG=Array.isArray(opsUn)&&opsUn.includes("neg");
  HAS_SUB=Array.isArray(opsBin)&&opsBin.includes("-");
  HAS_DIV=Array.isArray(opsBin)&&opsBin.includes("/");
  HAS_MUL=Array.isArray(opsBin)&&opsBin.includes("*");

  NEED_ZERO=consts.some((x)=>(x.key==="0"||x.s==="0")&&(x.min|0)>0);
  NEED_ONE=consts.some((x)=>(x.key==="1"||x.s==="1")&&(x.min|0)>0);

  const noConstraintFast=constrainedIdx.length===0;

  let useBitmask=!noConstraintFast;
  if(constrainedIdx.length>30)useBitmask=false;
  for(const i of constrainedIdx){
    if((consts[i].min??0)>1||(consts[i].max??INF)>1){useBitmask=false;break}
  }

  // Reduce "constPenalty" only in speed mode; keep breadth in normal/accuracy
  const constPenalty = (mode==="speed" && noConstraintFast) ? Math.max(1, Math.sqrt(Math.max(1,consts.length)/48)) : 1;

  const k=constrainedIdx.length;
  const idx2bit=new Int16Array(nC);idx2bit.fill(-1);
  for(let p=0;p<k;p++)idx2bit[constrainedIdx[p]]=p;

  const minBits=new Uint8Array(k),maxBits=new Uint8Array(k),symBits=new Array(k);
  for(let p=0;p<k;p++){
    const i=constrainedIdx[p];
    minBits[p]=(consts[i].min??0)?1:0;
    maxBits[p]=(consts[i].max??INF)===0?0:1;
    symBits[p]=consts[i].s;
  }

  REQ_MASK=0;
  for(let p=0;p<k;p++){
    if(minBits[p]) REQ_MASK |= (1<<p);
  }
  REQ_POP = REQ_MASK ? popcnt32(REQ_MASK) : 0;

  const EMPTY=new Uint16Array(0);
  let tCount=0,minT=null,maxT=null,symT=null;
  if(!useBitmask){
    tCount=constrainedIdx.length;
    minT=new Uint16Array(tCount);
    maxT=new Uint16Array(tCount);
    symT=new Array(tCount);
    for(let p=0;p<tCount;p++){
      const i=constrainedIdx[p];
      minT[p]=Math.min(INF,Math.max(0,consts[i].min??0));
      maxT[p]=Math.min(INF,Math.max(0,consts[i].max??INF));
      symT[p]=consts[i].s;
    }
  }

  function maskOk(m){for(let p=0;p<k;p++)if(minBits[p]&&((m>>p)&1)===0)return false;return true;}
  function maskStr(m){
    if(!showCounts||k===0)return"";
    const p=[];for(let i=0;i<k;i++)p.push(symBits[i]+":"+((m>>i)&1));
    return"["+p.join(", ")+"]";
  }
  function cntOk(c){for(let i=0;i<tCount;i++)if(c[i]<minT[i])return false;return true;}
  function cntStr(c){
    if(!showCounts||tCount===0)return"";
    const p=[];for(let i=0;i<tCount;i++)p.push(symT[i]+":"+c[i]);
    return"["+p.join(", ")+"]";
  }
  function addCnt(a,b){
    if(tCount===0)return EMPTY;
    const o=new Uint16Array(tCount);
    for(let i=0;i<tCount;i++){
      const s=a[i]+b[i];
      if(s>maxT[i])return null;
      o[i]=s;
    }
    return o;
  }
  function ckFromCnt(cnt){
    let s="";for(let i=0;i<tCount;i++)s+=String.fromCharCode(cnt[i]);return s;
  }
  function cntFromCk(ck){
    const out=new Uint16Array(tCount);
    for(let i=0;i<tCount;i++)out[i]=ck.charCodeAt(i)||0;
    return out;
  }
  const runtimeMode=noConstraintFast?"unconstrained":(useBitmask?"bitmask":"counts");
  function combMask(a,b){return(a&b)?-1:(a|b);}

  const t0=performance.now();
  let lastEmit=t0;
  let visited=0,meetConfirmed=0,meetLookups=0,meetCandidates=0;
  let pruned=0,reEvalFixed=0,dupesKilled=0;
  let meetDbg={
    revIdxKeys:0,revIdxItems:0,fwdIdxKeys:0,fwdIdxItems:0,
    keyHits:0,pairsTried:0,rev2fwdPairs:0,
    rejMaskOverlap:0,rejCntLimit:0,rejEpsCand:0,rejEvalNaN:0,
    rejProbeConfirm:0,rejConfirm:0,revInvBad:0,maxConfirmErr:0,
  };
  let dynamicCandMul=1.0, dynamicConfirmMul=1.0;
  const strategyStats={adaptiveBoosts:0,pruneRelax:0,meetJitter:0,extraDecomp:0,stagnationLayers:0,forcedBoost:0,pressureScore:0};
  // Phase timing debug (accumulated milliseconds per major phase per layer)
  const phaseTiming={buildFwd:0,buildRev:0,meetSweep:0,selectTop:0,decompose:0,meetFwd:0,totalLayers:0};
  function emitPhaseTimingLog(c){
    if(typeof console!=="undefined") console.log(\`[c=\${c}] Phase timing (ms): buildFwd=\${phaseTiming.buildFwd.toFixed(0)} buildRev=\${phaseTiming.buildRev.toFixed(0)} meetSweep=\${phaseTiming.meetSweep.toFixed(0)} selectTop=\${phaseTiming.selectTop.toFixed(0)} decompose=\${phaseTiming.decompose.toFixed(0)} meetFwd=\${phaseTiming.meetFwd.toFixed(0)} layers=\${phaseTiming.totalLayers}\`);
  }

  const best=[];
  let bestDeltaSoFar=Infinity;
  const bestSeen=new Map();
  const nearSeen=new Map();
  const bestByValue=new Map();

  const BEST_POOL_CAP=Math.max(outN*20, 1500);
  const VALUE_VARIANT_CAP=Math.max(4, Math.min(12, Math.floor(outN/6)||4));

  function astSig(ast){
    if(!ast) return "na";
    const d=astDepth(ast);
    const db=d<=2?2:(d<=4?4:(d<=7?7:10));
    if(ast.t===0) return "c|"+String(ast.sym);
    if(ast.t===1) return "u|"+ast.op+"|"+db;
    return "b|"+ast.op+"|"+db+"|"+(ast.p?"p":"np")+"|"+(ast.f?"f":"nf");
  }

  function rebuildBestCaches(){
    bestSeen.clear();
    nearSeen.clear();
    bestByValue.clear();
    const ns=Math.max(2e-6,Math.max(1,Math.abs(T))*2e-8);
    for(let i=0;i<best.length;i++){
      const vk=best[i].v.toPrecision(BESTP);
      let arr=bestByValue.get(vk);
      if(!arr){arr=[];bestByValue.set(vk,arr);}
      arr.push(i);
      const hasPowBest=!!best[i].hasPow;
      const sig=best[i].sig||"na";
      const kkBase=mp.keepMeetDup?(vk+"|"+(best[i].searchType||"fwd")):vk;
      const kk=hasPowBest?(kkBase+"|pow|"+sig):(kkBase+"|"+sig);
      bestSeen.set(kk,i);
      nearSeen.set(Math.round(best[i].v/ns),i);
    }
  }

  function emit(c){
    const now=performance.now();
    if(now-lastEmit>=emitInterval){
      lastEmit=now;
      postMessage({type:"progress",payload:{
        elapsed:Math.round(now-t0),maxC,c,
        visited,pruned,
        meetLookups,meetCandidates,meetConfirmed,
        meetDbg,
        reEvalFixed,dupesKilled,
        mode:runtimeMode,
        mt:(mt&&threads>1)?("ON("+threads+")"):"OFF",
        profile:mode,
        beamF,beamR,
        bestCount:best.length,
        bestDeltaSoFar,
        dynamicCandMul,dynamicConfirmMul,
        strategyStats,phaseTiming,
        best:best.slice(0,outN)
      }});
    }
  }

  function maybeStopOnExact(delta){
    const scale=Math.max(1,Math.abs(T));
    if(Math.abs(delta) <= EXACT_EPS*scale){
      stopFlag=true;
    }
  }

  
function isTinyPowTailNode(n,scale){
  if(!n||n.t!==2||n.op!=="^") return false;
  if(!n.l||n.l.t!==0||!n.r||n.r.t!==0) return false;
  const b=n.l.val,e=n.r.val;
  if(!Number.isFinite(b)||!Number.isFinite(e)) return false;
  if(!nearInt(b)||!nearInt(e)) return false;
  const ib=Math.abs(Math.round(b)), ie=Math.round(e);
  if(ib<2||ib>12||ie>-5) return false;
  const v=Math.pow(ib,ie);
  return Number.isFinite(v) && Math.abs(v)<=Math.max(2e-6,scale*2e-8);
}
function isTinyTailClone(ast,T){
  if(!ast||ast.t!==2) return false;
  if(ast.op!=="+" && ast.op!=="-") return false;
  if(!Number.isFinite(T) || Math.abs(T)<1) return false;
  const scale=Math.max(1,Math.abs(T));
  const lv=evalA(ast.l), rv=evalA(ast.r);
  const near=(x)=>Math.abs(x-T)<=Math.max(8e-5, scale*1.2e-6);
  if(ast.op==="+"||ast.op==="-"){
    if(isTinyPowTailNode(ast.r,scale) && near(lv)) return true;
    if(isTinyPowTailNode(ast.l,scale) && near(rv)) return true;
  }
  return false;
}

function collectLeaves(ast, out){
    if(!ast) return out;
    if(ast.t===0){ out.push(String(ast.sym)); return out; }
    if(ast.t===1) return collectLeaves(ast.ch,out);
    collectLeaves(ast.l,out); collectLeaves(ast.r,out);
    return out;
  }

  function bestInsertSorted(item){
    // Binary insert into sorted best[] by (|delta|, cost)
    const iD=Math.abs(item.delta), iC=item.cost||999;
    let lo=0,hi=best.length;
    while(lo<hi){const mid=(lo+hi)>>1;const mD=Math.abs(best[mid].delta);if(mD<iD||(mD===iD&&(best[mid].cost||999)<=iC))lo=mid+1;else hi=mid;}
    best.splice(lo,0,item);
  }

  function pushBest(obj){
    let v=obj.v;
    if(obj.ast){
      const tv=evalA(obj.ast);
      if(!Number.isFinite(tv)||Math.abs(tv)>CAP)return;
      if(Math.abs(tv-v)>1e-12)reEvalFixed++;
      v=tv;
    }
    const acc=relAcc(v,T);
    if(excludeExact&&acc==="exact")return;
    if(useBitmask){if(!maskOk(obj.mask||0))return;}
    else{if(obj.cnt&&!cntOk(obj.cnt))return;}

    // leafOrder constraint final check too
    if(LEAF_ORDER && obj.ast && obj.ast.ord && !obj.ast.ord.ok) return;
    if(mode!=="speed" && obj.ast && isTinyTailClone(obj.ast,T)) return;

    const delta=v-T;
    const absDelta=Math.abs(delta);
    if(absDelta<bestDeltaSoFar) bestDeltaSoFar=absDelta;
    const sigEarly=astSig(obj.ast);
    const nearStep=Math.max(2e-6,Math.max(1,Math.abs(T))*2e-8);
    const nearKey=Math.round(v/nearStep);
    const prevNear=nearSeen.get(nearKey);
    if(prevNear!==undefined){
      const b=best[prevNear];
      if(b && (b.sig||"na")===sigEarly && Math.abs(b.v-v)<=nearStep*1.2){
        const oldScore=Math.abs(b.delta)+1e-8*(b.cost||0);
        const newScore=Math.abs(delta)+1e-8*(obj.cost||0);
        if(newScore>=oldScore) return;
      }
    }
    const ci=useBitmask?maskStr(obj.mask||0):cntStr(obj.cnt||EMPTY);
    const needCustom = !!(customAllow || customScoreAdjust);
    let expr=null, latex=null, leaves=null;
    if(needCustom){
      expr=obj.ast?strA(normalizeAST(obj.ast)):(obj.s||"?");
      latex=obj.ast?latexA(normalizeAST(obj.ast)):expr;
      leaves = obj.ast ? collectLeaves(obj.ast, []) : [];
    }

    if(customAllow){
      try{
        const ok=customAllow({expr,latex,v,delta,cost:obj.cost,searchType:(obj.searchType||"fwd"),hasPow:!!(obj.ast&&obj.ast.p),countsInfo:ci,leaves});
        if(ok===false)return;
      }catch(_e){return;}
    }

    const scoreAdj=customScoreAdjust?Number(customScoreAdjust({expr,latex,v,delta,cost:obj.cost,searchType:(obj.searchType||"fwd"),hasPow:!!(obj.ast&&obj.ast.p),countsInfo:ci,leaves})||0):0;
    const valKey=v.toPrecision(BESTP);
    const type=obj.searchType||"fwd";
    const hasPow=!!(obj.ast&&obj.ast.p);
    const sig=sigEarly;
    const keyBase=mp.keepMeetDup?(valKey+"|"+type):valKey;
    const key=hasPow?(keyBase+"|pow|"+sig):(keyBase+"|"+sig);

    const idx=bestSeen.get(key);
    if(idx!==undefined){
      const old=best[idx];
      const newCost=(obj.cost||999);
      const oldDelta=Math.abs(old?.delta??INF);
      const newDelta=Math.abs(delta)-scoreAdj;
      const oldPow=old?!!old.hasPow:false;
      const newPow=hasPow;
      const powPrefer=(!oldPow&&newPow&&newDelta<=oldDelta*1.000002&&newCost<=(old?.cost??INF)+4);

      const oldType=old?.searchType||"fwd";
      const meetPrefer=(oldType!=="meet" && type==="meet" && Math.abs(oldDelta-newDelta)<=1e-12 && newCost<=(old?.cost??INF)+2);

      if(old && !powPrefer && !meetPrefer && (oldDelta<newDelta||(oldDelta===newDelta&&old.cost<=newCost))){
        dupesKilled++;return;
      }
      if(!expr){
        expr=obj.ast?strA(normalizeAST(obj.ast)):(obj.s||"?");
        latex=obj.ast?latexA(normalizeAST(obj.ast)):expr;
      }
      best.splice(idx,1);
      bestInsertSorted({expr,latex,v,delta,acc,cost:obj.cost,countsInfo:ci,searchType:type,hasPow,sig});
      if(best.length>BEST_POOL_CAP*1.2)best.length=BEST_POOL_CAP;
      rebuildBestCaches();
      if(acc==="exact") maybeStopOnExact(delta);
      return;
    }

    const sameValIdx=bestByValue.get(valKey);
    if(dedupeByValue && sameValIdx && sameValIdx.length>0){
      let bestIdx=-1,bestCost=Infinity;
      for(const bi of sameValIdx){
        const b=best[bi];
        const cst=(b?.cost||999);
        if(cst<bestCost){bestCost=cst;bestIdx=bi;}
      }
      const newCost=obj.cost||999;
      if(newCost>=bestCost){dupesKilled++;return;}
      if(bestIdx>=0){
        best.splice(bestIdx,1);
        rebuildBestCaches();
      }
    }
    if(sameValIdx && sameValIdx.length>=VALUE_VARIANT_CAP){
      let worstI=sameValIdx[0], worstScore=-Infinity;
      for(const bi of sameValIdx){
        const b=best[bi];
        const s=Math.abs(b.delta)+1e-8*(b.cost||0);
        if(s>worstScore){worstScore=s;worstI=bi;}
      }
      const newScore=Math.abs(delta)+1e-8*(obj.cost||0);
      if(newScore>=worstScore) return;
      best.splice(worstI,1);
      rebuildBestCaches();
    }

    if(!expr){
      expr=obj.ast?strA(normalizeAST(obj.ast)):(obj.s||"?");
      latex=obj.ast?latexA(normalizeAST(obj.ast)):expr;
    }
    bestInsertSorted({expr,latex,v,delta,acc,cost:obj.cost,countsInfo:ci,searchType:type,hasPow,sig});
    if(best.length>BEST_POOL_CAP*1.2)best.length=BEST_POOL_CAP;
    rebuildBestCaches();

    if(acc==="exact") maybeStopOnExact(delta);
  }

  const fwd=Array.from({length:maxC+1},()=>[]);
  const rev=Array.from({length:maxC+1},()=>[]);
  const revIdx=new Map();
  const fwdIdx=new Map();
  // coarse band index: key ignores mantissa quantization (sign|exp|domain prefix)
  // and stores a tiny hot-list. It is used as a breadth fallback when precise meet keys miss.
  const revBandIdx=new Map();
  const fwdBandIdx=new Map();

  function idxBetter(a,b){
    const ac=a?.cost??INF, bc=b?.cost??INF;
    if(ac!==bc) return ac<bc;
    const ak=a?.keep??INF, bk=b?.keep??INF;
    if(ak!==bk) return ak<bk;
    return Math.abs(a?.v??INF) < Math.abs(b?.v??INF);
  }

  function idxInsert(map,key,it,cap){
    let arr=map.get(key);
    if(!arr){arr=[];map.set(key,arr);}

    if(arr.length<cap){
      arr.push(it);
      // Keep hot prefix ordered so meet probing can stop early with higher quality candidates.
      for(let j=arr.length-1;j>0;j--){
        if(idxBetter(arr[j],arr[j-1])){ const t=arr[j-1]; arr[j-1]=arr[j]; arr[j]=t; }
        else break;
      }
      return;
    }

    let wi=0;
    for(let i=1;i<arr.length;i++){
      if(idxBetter(arr[wi],arr[i])) wi=i;
    }

    if(idxBetter(it,arr[wi])){
      arr[wi]=it;
      for(let j=wi;j>0;j--){
        if(idxBetter(arr[j],arr[j-1])){ const t=arr[j-1]; arr[j-1]=arr[j]; arr[j]=t; }
        else break;
      }
    }
  }

  function keyBand(k){
    if(typeof k!=="string" || !k.length) return "";
    if(k==="NaN") return "";
    const p=k.split("|");
    if(p.length===3){
      // base key: sign|exp|q
      return p[0]+"|"+p[1];
    }
    if(p.length>=4){
      // transformed key: prefix|sign|exp|q
      return p[0]+"|"+p[1]+"|"+p[2];
    }
    return "";
  }

  function idxInsertBand(map,key,it,cap){
    const bk=keyBand(key);
    if(!bk) return;
    idxInsert(map,bk,it,cap);
  }

  function addRevIdx(items){
    const cap=Math.max(8,mp.revIdxKeyCap|0||120);
    const perItemCap=Math.max(cap, mp.idxPerItemCap|0||64);
    const maxKeys=Math.max(1, mp.idxKeysPerItem|0||6);
    const bandCap=Math.max(6, Math.floor(cap*0.35));
    // Speed模式: rev索引使用短键(主键+邻域), 避免变换域键导致revIdxKeys爆炸
    // 注: pow/exp/log类op的rev项保留完整键以支持跨域meet
    const speedShortKeys = !!(mp.speedRevMeetPrimaryOnly);
    // 深层联系: revIdx的热前缀质量决定meet成功率
    const sortedItems = items.slice().sort((a,b)=>{
      const ca=a.cost??99, cb=b.cost??99;
      if(ca!==cb) return ca-cb;
      return (a.keep??1e9)-(b.keep??1e9);
    });
    for(const it of sortedItems){
      const p=it.mkey || (it.mkey = meetPrimaryKey(it.v));
      idxInsert(revIdx,p,it,cap);
      idxInsertBand(revBandIdx,p,it,bandCap);
      // Speed模式: 对非pow/func的rev项只用短键
      const isPowLike = (it.srcOp==="^"||it.srcOp==="square"||it.srcOp==="cube"||
                         it.srcOp==="exp"||it.srcOp==="log"||it.srcOp==="sqrt"||it.srcOp==="cbrt");
      const useShort = speedShortKeys && !isPowLike;
      const ks=meetKeysCached(it, useShort);
      let used=0;
      for(let i=0;i<ks.length&&used<maxKeys;i++){
        const k2=ks[i];
        if(k2===p) continue;
        idxInsert(revIdx,k2,it,perItemCap);
        idxInsertBand(revBandIdx,k2,it,bandCap);
        used++;
      }
    }
    meetDbg.revIdxKeys=revIdx.size;
    let total=0;for(const v of revIdx.values())total+=v.length;
    meetDbg.revIdxItems=total;
  }

  function addFwdIdx(items){
    const cap=Math.max(8,mp.fwdIdxKeyCap|0||120);
    const perItemCap=Math.max(cap, mp.idxPerItemCap|0||64);
    const maxKeys=Math.max(1, mp.idxKeysPerItem|0||6);
    const bandCap=Math.max(6, Math.floor(cap*0.35));
    // Speed模式: fwd索引也使用短键减少内存和构建时间
    const speedShortFwd = !!(mp.speedRevMeetPrimaryOnly);
    for(const it of items){
      const p=it.mkey || (it.mkey = meetPrimaryKey(it.v));
      idxInsert(fwdIdx,p,it,cap);
      idxInsertBand(fwdBandIdx,p,it,bandCap);
      // fwd项: pow结构使用完整键, 其他用短键
      const hasPowAst = !!(it.ast && it.ast.p);
      const useShortFwd = speedShortFwd && !hasPowAst;
      const ks=meetKeysCached(it, useShortFwd);
      let used=0;
      for(let i=0;i<ks.length&&used<maxKeys;i++){
        const k2=ks[i];
        if(k2===p) continue;
        idxInsert(fwdIdx,k2,it,perItemCap);
        idxInsertBand(fwdBandIdx,k2,it,bandCap);
        used++;
      }
    }
    meetDbg.fwdIdxKeys=fwdIdx.size;
    let total=0;for(const v of fwdIdx.values())total+=v.length;
    meetDbg.fwdIdxItems=total;
  }

  const _sqrtT = T>0 ? Math.sqrt(T) : NaN;
  const _cbrtT = Number.isFinite(T) ? Math.cbrt(T) : NaN;
  // 预计算T的多种变换值用于keepScore中的亲和力判断
  const _logT = T>0 ? Math.log(T) : NaN;
  const _T4th = T>0 ? Math.pow(T,0.25) : NaN;  // T^(1/4) 用于pow链深层结构
  const _T5th = T>0 ? Math.pow(T,0.2) : NaN;   // T^(1/5) 用于深层幂次
  const _invT = Math.abs(T)>1e-12 ? 1/T : NaN;  // 1/T 用于除法组合
  const _asinT = Math.abs(T)<=1 ? Math.asin(Math.max(-1,Math.min(1,T))) : NaN;  // asin(T)
  const _acosT = Math.abs(T)<=1 ? Math.acos(Math.max(-1,Math.min(1,T))) : NaN;  // acos(T)
  const _atanT = Number.isFinite(T) ? Math.atan(T) : NaN;  // atan(T)
  function keepScore(goal,bb,revHit,mask,v){
    let keep=(mp.keepMode==="goal")?goal:Math.min(goal,bb);
    if(revHit)keep*=(1.0-(mp.meetHitBonus||0));
    if(useBitmask && REQ_POP>0) keep *= reqAdj(mask|0);
    if(bb<0.08 && goal>1e-4) keep -= 0.04*bb;

    if(Number.isFinite(v) && goal>1e-6){
      if(Number.isFinite(_sqrtT)){
        const proxSq=Math.abs(v-_sqrtT)/(1e-9+_sqrtT);
        if(proxSq<0.02) keep -= 0.25*(1-proxSq/0.02);
        else if(proxSq<0.15) keep -= 0.10*(1-proxSq/0.15);
        const nprox=Math.abs(v+_sqrtT)/(1e-9+_sqrtT);
        if(nprox<0.02) keep -= 0.18*(1-nprox/0.02);
      }
      if(Number.isFinite(_cbrtT)){
        const proxCb=Math.abs(v-_cbrtT)/(1e-9+Math.abs(_cbrtT));
        if(proxCb<0.02) keep -= 0.14*(1-proxCb/0.02);
        else if(proxCb<0.12) keep -= 0.05*(1-proxCb/0.12);
      }
      if(Number.isFinite(_T4th) && _T4th>1e-9){
        const prox4=Math.abs(v-_T4th)/(1e-9+_T4th);
        if(prox4<0.02) keep -= 0.10*(1-prox4/0.02);
      }
      if(Number.isFinite(_logT)){
        const proxL=Math.abs(v-_logT)/(1e-9+Math.abs(_logT)+1);
        if(proxL<0.02) keep -= 0.12*(1-proxL/0.02);
      }
      if(Number.isFinite(_invT) && Math.abs(_invT)<1e8){
        const proxInv=Math.abs(v-_invT)/(1e-9+Math.abs(_invT)+1);
        if(proxInv<0.02) keep -= 0.08*(1-proxInv/0.02);
      }

      const absV=Math.abs(v);
      const absT2=Math.abs(T);
      if(Number.isFinite(_sqrtT) && _sqrtT>1e-9){
        for(const c of [Math.PI, Math.E, 2, 3, Math.SQRT2]){
          const vc=v*c;
          const proxMul=Math.abs(vc-_sqrtT)/(1e-9+_sqrtT);
          if(proxMul<0.03) keep -= 0.20*(1-proxMul/0.03);
          else if(proxMul<0.12) keep -= 0.06*(1-proxMul/0.12);
          const vSub=Math.abs(c-v);
          if(vSub<10 && vSub>1e-12){
            const sq=vSub*vSub;
            if(Math.abs(sq-absT2)<absT2*0.05) keep -= 0.12;
          }
        }
      }
      if(absV>0.01 && absV<1e5){
        const vsq=v*v;
        const proxSqV=Math.abs(vsq-absT2)/(1e-9+absT2);
        if(proxSqV<0.01) keep -= 0.30*(1-proxSqV/0.01);
        else if(proxSqV<0.08) keep -= 0.10*(1-proxSqV/0.08);
        for(const c of [Math.PI, Math.E, 2]){
          const target=absT2/c;
          const prox=Math.abs(vsq-target)/(1e-9+target);
          if(prox<0.02) keep -= 0.12*(1-prox/0.02);
        }
      }
      if(absV>0.1 && absV<200){
        const vcb=v*v*v;
        const proxCbV=Math.abs(vcb-T)/(1e-9+absT2);
        if(proxCbV<0.02) keep -= 0.15*(1-proxCbV/0.02);
      }
      if(absV<20){
        const ev=Math.exp(v);
        if(Number.isFinite(ev)){
          const proxExp=Math.abs(ev-absT2)/(1e-9+absT2);
          if(proxExp<0.02) keep -= 0.14*(1-proxExp/0.02);
        }
      }
      if(absV>0.1 && absV<12){
        for(const frac of [0.5, 1/3, 2/3, 0.25, 0.75, 1/5, 1/6, 1/7]){
          if(Math.abs(v-frac)<0.015) keep -= 0.08;
          if(Math.abs(v+frac)<0.015) keep -= 0.05;
        }
      }
    }

    // 组合亲和力：值可以与已知常数组合接近 T 的变换值
    if(Number.isFinite(v)&&Number.isFinite(_sqrtT)&&_sqrtT>1e-9&&goal>1e-6){
      for(const c of [Math.PI,Math.E,2,3,Math.SQRT2]){
        // v*c ≈ √T
        const vc=v*c;
        const prox=Math.abs(vc-_sqrtT)/(1e-9+_sqrtT);
        if(prox<0.03) keep-=0.18*(1-prox/0.03);
        else if(prox<0.10) keep-=0.05*(1-prox/0.10);
        // c-v ≈ 有用的中间值
        const cv2=c-v;
        if(Number.isFinite(cv2)&&Math.abs(cv2)<100){
          const sq=cv2*cv2;
          if(Math.abs(sq-Math.abs(T))<Math.abs(T)*0.05) keep-=0.10;
        }
      }
      // v^2 ≈ T
      if(Math.abs(v)>0.01&&Math.abs(v)<1e5){
        const vsq=v*v;
        const proxSq=Math.abs(vsq-Math.abs(T))/(1e-9+Math.abs(T));
        if(proxSq<0.01) keep-=0.25*(1-proxSq/0.01);
        else if(proxSq<0.06) keep-=0.08*(1-proxSq/0.06);
      }
      // e^v ≈ T
      if(Math.abs(v)<20){
        const ev=Math.exp(v);
        if(Number.isFinite(ev)){
          const proxExp=Math.abs(ev-Math.abs(T))/(1e-9+Math.abs(T));
          if(proxExp<0.02) keep-=0.12*(1-proxExp/0.02);
        }
      }
    }

    return keep;
  }

  const keyOf=(v,mask,ck)=>{
    const vk=vKey(v);
    if(useBitmask) return vk+"|"+(mask|0);
    if(tCount===0) return vk;
    return vk+"|"+(ck||"");
  };

  function meetKeysCached(node,skipTransform=false){
    if(!skipTransform && node.mkeys!=null) return node.mkeys;
    if(skipTransform && node.mkeysShort!=null) return node.mkeysShort;
    // Recompute depth lazily if stripped
    const dep=(node.depth!=null)?node.depth:astDepth(node.ast);
    const ks = meetKeys(node.v,node.goal,dep,skipTransform);
    if(!skipTransform) node.mkeys = ks;
    else node.mkeysShort = ks;
    return ks;
  }

  function astCost(n){
    if(!n) return 0;
    if(n.t===0) return 1;
    if(n.t===1) return astCost(n.ch)+wUn(n.op);
    return astCost(n.l)+astCost(n.r)+wBin(n.op);
  }

  // Shared reverse scoring utility (used by seed hints + buildRev expansion).
  function revScore(v){
    const ab=Math.abs(v);
    const mag=Math.log1p(ab);
    const trigOutBonus=(ab<=1.0&&ab>1e-15)?0.22:0;
    const trigArgBonus=(ab<=Math.PI*2+0.1)?0.10:0;
    const rbb=bbScore(v,18,0.012);
    const ratBonus=rbb<0.06?0.18:(rbb<0.18?0.07:0);

    let tTransformBonus=0;
    if(Number.isFinite(_sqrtT) && _sqrtT>1e-9){
      const d=Math.abs(v-_sqrtT)/(1e-9+_sqrtT);
      if(d<0.05) tTransformBonus=Math.max(tTransformBonus,0.30*(1-d/0.05));
    }
    if(Number.isFinite(_cbrtT) && Math.abs(_cbrtT)>1e-9){
      const d=Math.abs(v-_cbrtT)/(1e-9+Math.abs(_cbrtT));
      if(d<0.05) tTransformBonus=Math.max(tTransformBonus,0.20*(1-d/0.05));
    }
    if(Number.isFinite(_logT)){
      const d=Math.abs(v-_logT)/(1e-9+Math.abs(_logT)+1);
      if(d<0.05) tTransformBonus=Math.max(tTransformBonus,0.18*(1-d/0.05));
    }
    if(Number.isFinite(_T4th) && _T4th>1e-9){
      const d=Math.abs(v-_T4th)/(1e-9+_T4th);
      if(d<0.05) tTransformBonus=Math.max(tTransformBonus,0.12*(1-d/0.05));
    }

    if(Number.isFinite(_sqrtT) && _sqrtT>1e-9){
      for(const c of [Math.PI, Math.E, 2, 3]){
        const tv=_sqrtT/c;
        if(Number.isFinite(tv)){
          const d=Math.abs(v-tv)/(1e-9+Math.abs(tv)+1);
          if(d<0.05) tTransformBonus=Math.max(tTransformBonus,0.22*(1-d/0.05));
        }
      }
      for(const c of [Math.PI, Math.E, 2]){
        const tv=_sqrtT/c;
        if(Number.isFinite(tv)){
          const sub=Math.E-tv;
          if(Number.isFinite(sub)){
            const d=Math.abs(v-sub)/(1e-9+Math.abs(sub)+1);
            if(d<0.08) tTransformBonus=Math.max(tTransformBonus,0.16*(1-d/0.08));
          }
        }
      }
    }
    if(ab>0.01 && ab<100){
      for(let n=-3;n<=5;n++){
        const en=Math.exp(n);
        if(Math.abs(v-en)<0.1*en) tTransformBonus=Math.max(tTransformBonus,0.08);
      }
    }
    // T^(1/5) 用于 f^5=T 结构
    if(Number.isFinite(_T5th) && _T5th>1e-9){
      const d=Math.abs(v-_T5th)/(1e-9+_T5th);
      if(d<0.05) tTransformBonus=Math.max(tTransformBonus,0.10*(1-d/0.05));
    }
    // 1/T 用于除法组合 f/g=T
    if(Number.isFinite(_invT) && Math.abs(_invT)<1e8){
      const d=Math.abs(v-_invT)/(1e-9+Math.abs(_invT)+1);
      if(d<0.05) tTransformBonus=Math.max(tTransformBonus,0.12*(1-d/0.05));
    }
    // asin(T), acos(T), atan(T) — 若T在[-1,1]时特别有价值
    if(Number.isFinite(_asinT)){
      const d=Math.abs(v-_asinT)/(1e-9+Math.abs(_asinT)+0.1);
      if(d<0.05) tTransformBonus=Math.max(tTransformBonus,0.18*(1-d/0.05));
    }
    if(Number.isFinite(_acosT)){
      const d=Math.abs(v-_acosT)/(1e-9+Math.abs(_acosT)+0.1);
      if(d<0.05) tTransformBonus=Math.max(tTransformBonus,0.18*(1-d/0.05));
    }
    if(Number.isFinite(_atanT)){
      const d=Math.abs(v-_atanT)/(1e-9+Math.abs(_atanT)+0.1);
      if(d<0.05) tTransformBonus=Math.max(tTransformBonus,0.14*(1-d/0.05));
    }


    // 多步分解亲和力
    if(Number.isFinite(_sqrtT)&&_sqrtT>1e-9){
      for(const c of [Math.PI,Math.E,2,3]){
        const tv=_sqrtT/c;
        if(Number.isFinite(tv)){
          const d=Math.abs(v-tv)/(1e-9+Math.abs(tv)+1);
          if(d<0.05) tTransformBonus=Math.max(tTransformBonus,0.20*(1-d/0.05));
        }
        // e - √T/c (关键中间值)
        const sub=Math.E-tv;
        if(Number.isFinite(sub)){
          const d2=Math.abs(v-sub)/(1e-9+Math.abs(sub)+1);
          if(d2<0.06) tTransformBonus=Math.max(tTransformBonus,0.15*(1-d2/0.06));
        }
      }
    }

    return Math.max(0.001, mag - trigOutBonus - trigArgBonus - ratBonus - tTransformBonus);
  }

  function pickInterestingAtoms(limit=10){
    const atoms=[];
    for(const c of consts){
      const v=Number(c.v);
      if(!Number.isFinite(v)) continue;
      if(Math.abs(v)<1e-12 || Math.abs(v)>32) continue;
      const frac=Math.abs(v-Math.round(v));
      const irrScore=(frac>1e-8&&frac<1-1e-8)?1:0;
      const magPenalty=Math.abs(Math.log2(Math.abs(v)+1e-12));
      const score=irrScore*2.0 - 0.18*magPenalty;
      atoms.push({c,score});
    }
    atoms.sort((a,b)=>b.score-a.score);
    return atoms.slice(0,Math.max(2,limit)).map(x=>x.c);
  }

  function getConstNodeByValue(val){
    for(const c of consts){
      if(Math.abs(Number(c.v)-val)<=1e-12) return mkC(c.s,c.v,ordLeaf(c.s));
    }
    return mkC(String(val),val,ordLeaf(String(val)));
  }

  // 引擎侧不再注入“引导模板合成”候选，避免把特定结构硬编码到搜索结果中。
  // 所有解都必须来自统一的前向/反向/meet 搜索流程。


  // init layer c=1
  {
    const{bucket,put}=mkBucket(beamF,mp.spillMul);
    for(let i=0;i<nC;i++){
      const v=consts[i].v;visited++;
      if(!Number.isFinite(v)||Math.abs(v)>CAP)continue;
      const goal=Math.abs(v-T);
      const bb=bbScore(v,mp.bbD,mp.bbMagA);
      const mk = bidir ? meetPrimaryKey(v) : "";
      const revHit=bidir?revIdx.has(mk):false;

      if(useBitmask){
        const bit=idx2bit[i];
        let mask=0;
        if(bit>=0){if(!maxBits[bit])continue;mask=1<<bit;}
        const keep=keepScore(goal,bb,revHit,mask,v);
        const flags=mkFlags(v,TAG_NONE,true);
        const ast=mkC(consts[i].s,v,ordLeaf(consts[i].s));
        if(LEAF_ORDER && ast.ord && !ast.ord.ok) continue;
        put(keyOf(v,mask,""),{v,goal,bb,keep,ast,mask,flags,mkey:mk});
      }else{
        let cnt=EMPTY;
        const pos=idx2bit[i];
        if(pos>=0){cnt=new Uint16Array(tCount);cnt[pos]=1;if(cnt[pos]>maxT[pos])continue;}
        const ck=tCount?ckFromCnt(cnt):"";
        const keep=(mp.keepMode==="goal")?goal:Math.min(goal,bb);
        const flags=mkFlags(v,TAG_NONE,true);
        const ast=mkC(consts[i].s,v,ordLeaf(consts[i].s));
        if(LEAF_ORDER && ast.ord && !ast.ord.ok) continue;
        put(keyOf(v,0,ck),{v,goal,bb,keep,ast,cnt,ck,flags,mkey:mk});
      }
    }

    const items=Array.from(bucket.values());
    for(const it of items){it.hasPow=!!(it.ast&&it.ast.p);it.hasFunc=!!(it.ast&&it.ast.f);it.depth=astDepth(it.ast);}
    const picked=selectTop(items,beamF,divRatio,mp,(bidir?revIdx:null),Array.isArray(opsBin)&&opsBin.includes("^"),useBitmask,mode,T);
    for(const it of picked){it.cost=1;}
    fwd[1]=picked;
    addFwdIdx(fwd[1]);

    for(const e of fwd[1]){e.searchType="fwd";pushBest({v:e.v,ast:e.ast,mask:e.mask,cnt:e.cnt,cost:1,searchType:"fwd"});}
    emit(1);
  }

  // seed reverse
  if(bidir){
    const seedMask=0;
    const seedCnt=tCount?new Uint16Array(tCount):EMPTY;
    const seedCk=tCount?ckFromCnt(seedCnt):"";
    const mk = meetPrimaryKey(T);
    rev[0]=[{v:T,wA:(a)=>a,mask:seedMask,cnt:seedCnt,ck:seedCk,flags:mkFlags(T,TAG_NONE,true),cost:0,score:0,srcOp:"seed",mkey:mk}];

    // Target-anchored reverse hints: seed a tiny frontier of transformed targets so
    // hard composed structures can meet earlier without waiting many reverse layers.
    // This improves breadth structurally (not parameter-only) while staying bounded.
    const hinted=new Set();
    const hintCountByCost=new Map();
    const maxHintTotal=220;  // ↑ from 72: more budget for multi-step decompositions
    let hintTotal=0;
    function pushRevHint(v,cost,wA,srcOp){
      if(!Number.isFinite(v) || Math.abs(v)>CAP) return;
      cost=cost|0;
      if(cost<=0 || cost>maxC) return;
      const hk=vKey(v)+"|"+cost+"|"+srcOp;
      if(hinted.has(hk)) return;
      hinted.add(hk);
      const n=(hintCountByCost.get(cost)||0);
      const capPerCost = (cost<=4)?24:14;  // ↑ from 18/10
      if(n>=capPerCost || hintTotal>=maxHintTotal) return;
      hintCountByCost.set(cost,n+1);
      hintTotal++;
      const mkey=meetPrimaryKey(v);
      const score=revScore(v);
      const node=useBitmask
        ?{v,wA,mask:seedMask,flags:mkFlags(v,TAG_NONE,false),keep:score,goal:score,bb:score,cost,srcOp,mkey}
        :{v,wA,cnt:seedCnt,ck:seedCk,flags:mkFlags(v,TAG_NONE,false),keep:score,goal:score,bb:score,cost,srcOp,mkey};
      if(!rev[cost]) rev[cost]=[];
      rev[cost].push(node);
    }

    // ── Power-decomposition multi-step hints ──
    // These seed rev with transformed versions of T (e.g. √T, ∛T, etc.)
    // so that fwd[k] can meet rev[c-k] via outer square/cube/power.
    // Critical for finding (f(x))^2 = T type structures.
    const favAtoms=pickInterestingAtoms(8);
    const _unHintOps_early=["square","sqrt","cube","cbrt","exp","log"];
    for(const op of _unHintOps_early){
      if(!Array.isArray(opsUn)||!opsUn.includes(op)) continue;
      const invs=invUn(op,T);
      if(!Array.isArray(invs)) continue;
      const w=wUn(op);
      for(const obj of invs){
        const vv=obj&&obj.v;
        if(!Number.isFinite(vv)||Math.abs(vv)>CAP) continue;
        // Level-1: op(x)=T → x=vv
        const wA1=(a)=>mkU(op,a);
        pushRevHint(vv,w,wA1,"earlyhint_"+op);
        // Level-2: for atoms c, try: op(c * x) = T → x = vv/c  and  op(c + x) = T → x = vv - c
        for(const cst of favAtoms){
          const cv=Number(cst.v);
          if(!Number.isFinite(cv)||cv===0) continue;
          const cAst=mkC(cst.s,cst.v,ordLeaf(cst.s));
          if(Array.isArray(opsBin)&&opsBin.includes("*")){
            const x2=invBinR("*",vv,cv); // c*x=vv → x=vv/c
            if(Number.isFinite(x2)&&Math.abs(x2)<CAP){
              const wA2=(a)=>mkU(op,mkB("*",cAst,a));
              pushRevHint(x2,w+wBin("*"),wA2,"earlyhint2_"+op+"_mul");
            }
          }
          if(Array.isArray(opsBin)&&opsBin.includes("+")){
            const x3=invBinR("+",vv,cv); // c+x=vv → x=vv-c
            if(Number.isFinite(x3)&&Math.abs(x3)<CAP){
              const wA3=(a)=>mkU(op,mkB("+",cAst,a));
              pushRevHint(x3,w+wBin("+"),wA3,"earlyhint2_"+op+"_add");
            }
          }
          if(op==="square"&&Array.isArray(opsBin)&&opsBin.includes("*")){
            // (c*x)^2=T → x=√T/c
            const sqT=Math.sqrt(T);
            if(Number.isFinite(sqT)&&T>0){
              const x4=sqT/cv;
              if(Number.isFinite(x4)&&Math.abs(x4)<CAP){
                const wA4=(a)=>mkB("^",mkB("*",cAst,a),mkC("2",2,ordLeaf("2")));
                pushRevHint(x4,wBin("^")+wBin("*"),wA4,"earlyhint2_sq_cmul");
              }
            }
          }
        }
        // Level-2b: for sqrt result vv, also add √(vv) and -√(vv) hints
        if(op==="square"&&T>0&&Number.isFinite(vv)&&vv>0){
          // Already covered by sqT above; also add negative sqrt
          const wA_neg=(a)=>mkU("square",mkU("neg",a));
          pushRevHint(vv,w,wA_neg,"earlyhint_sq_neg");
        }
      }
    }

    // ── 2-step binary hints: T = a OP b where b comes from a combination ──
    // e.g. T = (fwd_expr)^2 → seed rev with fwd-side half at cost c/2

    for(const cst of favAtoms){
      const cv=Number(cst.v);
      if(!Number.isFinite(cv)) continue;
      const cAst=mkC(cst.s,cst.v,ordLeaf(cst.s));
      if(Array.isArray(opsBin)){
        if(opsBin.includes("*") && cv!==0){
          const x=invBinR("*",T,cv);
          pushRevHint(x,wBin("*"),(a)=>mkB("*",cAst,a),"hint_mul_r");
        }
        if(opsBin.includes("/") && cv!==0){
          const x=invBinR("/",T,cv);
          pushRevHint(x,wBin("/"),(a)=>mkB("/",cAst,a),"hint_div_r");
          const y=invBinL("/",T,cv);
          pushRevHint(y,wBin("/"),(a)=>mkB("/",a,cAst),"hint_div_l");
        }
        if(opsBin.includes("+") ){
          const x=invBinR("+",T,cv);
          pushRevHint(x,wBin("+"),(a)=>mkB("+",cAst,a),"hint_add_r");
        }
        if(opsBin.includes("-") ){
          const x=invBinR("-",T,cv);
          pushRevHint(x,wBin("-"),(a)=>mkB("-",cAst,a),"hint_sub_r");
          const y=invBinL("-",T,cv);
          pushRevHint(y,wBin("-"),(a)=>mkB("-",a,cAst),"hint_sub_l");
        }
        if(opsBin.includes("^") && T>0 && cv>0 && Math.abs(cv-1)>1e-12){
          const x=invBinR("^",T,cv);
          pushRevHint(x,wBin("^"),(a)=>mkB("^",cAst,a),"hint_pow_exp");
          const y=invBinL("^",T,cv);
          pushRevHint(y,wBin("^"),(a)=>mkB("^",a,cAst),"hint_pow_base");
        }
      }
    }

    if(Array.isArray(opsUn)){
      const unHintOps=["log","exp","sqrt","cbrt","square","cube","sin","cos","tan","asin","acos","atan"];
      for(const op of unHintOps){
        if(!opsUn.includes(op)) continue;
        const invs=invUn(op,T);
        if(!Array.isArray(invs)) continue;
        const w=wUn(op);
        for(const obj of invs){
          const vv=obj&&obj.v;
          pushRevHint(vv,w,(a)=>mkU(op,a),"hint_"+op);
        }
      }
    }

    {
      const deepBudget=100;
      let deepUsed=0;
      const L0=[];
      // T=x^2
      if(T>0&&Array.isArray(opsUn)&&opsUn.includes("square"))
        L0.push({v:Math.sqrt(T),c:wUn("square"),w:(a)=>mkU("square",a)});
      if(T>0) L0.push({v:-Math.sqrt(T),c:wUn("square"),w:(a)=>mkU("square",mkU("neg",a))});
      // T=x^3
      if(Array.isArray(opsUn)&&opsUn.includes("cube"))
        L0.push({v:Math.cbrt(T),c:wUn("cube"),w:(a)=>mkU("cube",a)});
      // T=exp(x)
      if(T>0&&Array.isArray(opsUn)&&opsUn.includes("exp"))
        L0.push({v:Math.log(T),c:wUn("exp"),w:(a)=>mkU("exp",a)});
      // T=x^n via ^
      if(Array.isArray(opsBin)&&opsBin.includes("^")){
        for(const n of [2,3,4,5]){
          const r=Math.pow(Math.abs(T),1/n);
          if(Number.isFinite(r)&&r<1e8){
            const nA=mkC(String(n),n,ordLeaf(String(n)));
            L0.push({v:r,c:wBin("^"),w:(a)=>mkB("^",a,nA)});
          }
        }
      }

      for(const t0 of L0){
        if(!Number.isFinite(t0.v)||deepUsed>=deepBudget) continue;
        for(const cst of favAtoms){
          if(deepUsed>=deepBudget) break;
          const cv=Number(cst.v),cA=mkC(cst.s,cst.v,ordLeaf(cst.s));
          if(!Number.isFinite(cv)||Math.abs(cv)<1e-14) continue;

          // t0.v = c*x
          if(Array.isArray(opsBin)&&opsBin.includes("*")){
            const x=t0.v/cv;
            if(Number.isFinite(x)&&Math.abs(x)<CAP){
              const tc=t0.c+wBin("*");
              const wA=(a)=>t0.w(mkB("*",cA,a));
              pushRevHint(x,tc,wA,"deep2_mul");deepUsed++;

              // 三级: x = c2 - z
              for(const c2 of favAtoms.slice(0,4)){
                if(deepUsed>=deepBudget) break;
                const cv2=Number(c2.v),cA2=mkC(c2.s,c2.v,ordLeaf(c2.s));
                if(!Number.isFinite(cv2)) continue;
                if(Array.isArray(opsBin)&&opsBin.includes("-")){
                  const z=cv2-x;
                  if(Number.isFinite(z)&&Math.abs(z)<CAP){
                    pushRevHint(z,tc+wBin("-"),(a)=>t0.w(mkB("*",cA,mkB("-",cA2,a))),"deep3_sub");
                    deepUsed++;
                  }
                }
                if(Array.isArray(opsBin)&&opsBin.includes("+")){
                  const z=x-cv2;
                  if(Number.isFinite(z)&&Math.abs(z)<CAP){
                    pushRevHint(z,tc+wBin("+"),(a)=>t0.w(mkB("*",cA,mkB("+",cA2,a))),"deep3_add");
                    deepUsed++;
                  }
                }
              }
            }
          }
          // t0.v = c+x
          if(Array.isArray(opsBin)&&opsBin.includes("+")){
            const x=t0.v-cv;
            if(Number.isFinite(x)&&Math.abs(x)<CAP){
              pushRevHint(x,t0.c+wBin("+"),(a)=>t0.w(mkB("+",cA,a)),"deep2_add");
              deepUsed++;
            }
          }
          // t0.v = c-x
          if(Array.isArray(opsBin)&&opsBin.includes("-")){
            const x=cv-t0.v;
            if(Number.isFinite(x)&&Math.abs(x)<CAP){
              pushRevHint(x,t0.c+wBin("-"),(a)=>t0.w(mkB("-",cA,a)),"deep2_sub");
              deepUsed++;
            }
          }
          // t0.v = x^c (幂分解)
          if(Array.isArray(opsBin)&&opsBin.includes("^")&&Math.abs(cv)>0.1&&Math.abs(cv)<20){
            const base=Math.pow(t0.v,1/cv);
            if(Number.isFinite(base)&&Math.abs(base)<CAP&&base>0){
              pushRevHint(base,t0.c+wBin("^"),(a)=>t0.w(mkB("^",a,cA)),"deep2_pow");
              deepUsed++;
            }
          }
        }
      }
    }

    for(let c=0;c<=maxC;c++){
      if(Array.isArray(rev[c]) && rev[c].length) addRevIdx(rev[c]);
    }
  }

  function tryMeetPair(f,r){
    const tc=f.cost+r.cost;
    if(tc>maxC)return;

    if(useBitmask){if((f.mask&r.mask)!==0){meetDbg.rejMaskOverlap++;return;}}
    else{const c=addCnt(f.cnt??EMPTY,r.cnt??EMPTY);if(!c){meetDbg.rejCntLimit++;return;}}

    const scale=Math.max(1,Math.abs(T),Math.abs(f.v),Math.abs(r.v));
    const matchGap=Math.abs(f.v-r.v);

    // === 超快速预过滤: 基于量级差异，深层联系: 
    // 如果fwd和rev的值在log域相差超过一定范围，它们的meet误差会被非线性放大
    // 这比计算isPowRelated更廉价，可以提前拒绝大量明显不匹配的pair
    // 对于matchGap/scale > 2e-7的pair，confirm成功概率极低(经验值)
    if(matchGap > 2e-7 * scale && tc > 10) { meetDbg.rejEpsCand++; return; }

    // ▼▼▼ 快速通道：matchGap 极小时直接进入 trueVal 确认，跳过 probe 估算
    const ultraCloseGap = 3e-13 * scale;
    const ultraClose = (matchGap <= ultraCloseGap);

    // 高复杂度+大幅值时的快速拒绝，减少无效confirm
    if(!ultraClose && tc>=12){
      const m=Math.max(Math.abs(f.v),Math.abs(r.v));
      if(m>80 && matchGap>6e-11*scale){ meetDbg.rejEpsCand++; return; }
    }

    const isPowRelated = (r.srcOp==="^") || (f.hasPow) || (r.wA && r.srcOp==="pow");
    if(meetDbg.maxConfirmErr > 100 && isPowRelated){
      const fMag=Math.abs(f.v), rMag=Math.abs(r.v);
      if(fMag>10 && rMag>10 && matchGap > 1e-9*scale){
        meetDbg.rejEpsCand++;
        return;
      }
    }
    if(meetDbg.maxConfirmErr > 1000){
      if(isPowRelated && matchGap > 3e-11*scale){
        meetDbg.rejEpsCand++;
        return;
      }
    }
    // FIXED: for pow-related candidates, apply much stricter initial reject to avoid
    // runaway evaluation of e.g. base^exponent that produces astronomically large errors
    // (maxConfirmErr was ~1e12 indicating this was a real problem)
    if(isPowRelated && Math.abs(f.v)>50 && Math.abs(r.v)>50) { meetDbg.rejEpsCand++; return; }
    // 历史误差自适应: maxConfirmErr 极大时更激进过滤 pow
    if(meetDbg.maxConfirmErr>500 && isPowRelated){
      const fM=Math.abs(f.v),rM=Math.abs(r.v);
      if(fM>15&&rM>15&&matchGap>2e-10*scale){meetDbg.rejEpsCand++;return;}
    }
    if(meetDbg.maxConfirmErr>5000 && isPowRelated && matchGap>5e-12*scale){
      meetDbg.rejEpsCand++;return;
    }
    // ▼▼▼ 新增：多级 pow 幅值预过滤，大幅削减无效 confirm (原64868次)
    // 当 pow 关系表达式的值域较大时，微小 matchGap 在确认阶段会被非线性放大为巨大误差
    if(isPowRelated){
      const fMag = Math.abs(f.v), rMag = Math.abs(r.v);
      const powScale = Math.max(fMag, rMag);
      // 级别1: 极大值情形 — pow结果爆炸式放大，过滤掉非常接近但不可靠的候选
      if(powScale > 200 && matchGap > 5e-8 * scale) { meetDbg.rejEpsCand++; return; }
      // 级别2: 大值情形
      if(powScale > 30 && matchGap > 3e-8 * scale) { meetDbg.rejEpsCand++; return; }
      // 级别3: 对任何 pow 相关，要求 matchGap 比普通情形更紧
      if(matchGap > 8e-9 * scale && tc > 8) { meetDbg.rejEpsCand++; return; }
    }
    // ▲▲▲ 结束新增
    // isTrigRelated: if either side involves trig ops, allow slightly larger cand epsilon
    // because trig functions have larger float sensitivity near extrema
    const isTrigRelated = (f.ast && f.ast.f) ||
      (r.srcOp==="sin"||r.srcOp==="cos"||r.srcOp==="tan"||
       r.srcOp==="asin"||r.srcOp==="acos"||r.srcOp==="atan"||
       r.srcOp==="sinh"||r.srcOp==="cosh"||r.srcOp==="tanh");
    const binSlack=(MEET_STYLE==="bin")?((mp.binSlackMul??1)*Math.max(1,MEET_R)/Math.max(1,MEET_Q))*scale:0;
    const speedTight=(mode==="speed"&&((strategyStats.pressureScore||0)>=2||meetDbg.maxConfirmErr>1e9))?0.55:1.0;
    const epsCand=(4e-10*mp.candEpsMul*dynamicCandMul*speedTight*(isPowRelated?2.8:1.0))*scale+binSlack;
    if(matchGap>epsCand){meetDbg.rejEpsCand++;return;}
    meetCandidates++;

    const combinedAST=r.wA?r.wA(f.ast):f.ast;

    if(LEAF_ORDER && combinedAST && combinedAST.ord && !combinedAST.ord.ok) return;

    const hasFunc=!!(combinedAST&&combinedAST.f);
    const powStat=astPowStats(combinedAST);
    const powCnt=powStat.cnt;
    const powRisk=powStat.risk;
    const powTighten=Math.min(1.0,(1/(1+0.18*powCnt+0.06*powRisk))*(hasFunc?1.12:1.0));

    const forceDeeperConfirm=(strategyStats.pressureScore>=2 && (isPowRelated || hasFunc));
    const skipProbe =
      ultraClose || // ◀ 极近匹配直接跳过 probe
      ((mode!=="speed") && (matchGap<=epsCand*0.10 && (tc<=Math.max(8,Math.floor(maxC*0.72)) || forceDeeperConfirm))) ||
      ((mode==="speed") && (matchGap<=epsCand*0.06 && tc<=6)) ||
      ((mode!=="speed") && forceDeeperConfirm && matchGap<=epsCand*0.22);

    let probeVal=f.v;
    if(!skipProbe){
      const probeAST=r.wA?r.wA(mkC("#",f.v,ordLeaf("#"))):mkC("#",f.v,ordLeaf("#"));
      probeVal=evalA(probeAST);
      if(!Number.isFinite(probeVal)||Math.abs(probeVal)>CAP){meetDbg.rejEvalNaN++;return;}

      const epsProbeBase=(8e-10*mp.confirmEpsMul*dynamicConfirmMul)*Math.max(1,Math.abs(T),Math.abs(probeVal))*(1+tc*0.03);
      const epsProbeGap=matchGap*(1.7+tc*0.09)*powTighten*(isPowRelated?1.6:1.0);
      const epsProbe=Math.max(epsProbeBase,epsProbeGap,mp.confirmAbsFloor||0);
      const probeErr=Math.abs(probeVal-T);
      if(probeErr>epsProbe){
        if(!forceDeeperConfirm || probeErr>epsProbe*1.45){
          meetDbg.rejProbeConfirm++;
          if(probeErr>meetDbg.maxConfirmErr)meetDbg.maxConfirmErr=probeErr;
          return;
        }
      }
    }

    const trueVal=evalA(combinedAST);
    if(!Number.isFinite(trueVal)||Math.abs(trueVal)>CAP){meetDbg.rejEvalNaN++;return;}

    if(!skipProbe){
      const structuralDrift=Math.abs(trueVal-probeVal);
      const driftCap=matchGap*(3.4+tc*0.18)*(1+powCnt*0.22)/(1+0.10*powRisk)+3e-12*scale;
      if(structuralDrift>driftCap){
        if(!forceDeeperConfirm || structuralDrift>driftCap*1.35){
          meetDbg.rejProbeConfirm++;
          if(structuralDrift>meetDbg.maxConfirmErr)meetDbg.maxConfirmErr=structuralDrift;
          return;
        }
      }
    }

    const epsConfirmBase=(7e-10*mp.confirmEpsMul*dynamicConfirmMul)*Math.max(1,Math.abs(T),Math.abs(trueVal))*(1+tc*0.025);
    const epsConfirmGap=matchGap*(2.2+tc*0.11)*powTighten*(isPowRelated?1.5:1.0);
    const epsConfirm=Math.max(epsConfirmBase,epsConfirmGap,mp.confirmAbsFloor||0);
    const err=Math.abs(trueVal-T);
    if(err>epsConfirm){
      meetDbg.rejConfirm++;
      if(err>meetDbg.maxConfirmErr)meetDbg.maxConfirmErr=err;
      return;
    }

    if(powCnt>0){
      const stableVal=evalAStable(combinedAST);
      if(!Number.isFinite(stableVal)||Math.abs(stableVal)>CAP){meetDbg.rejEvalNaN++;return;}
      const stableGap=Math.abs(stableVal-trueVal);
      const stableCap=Math.max(3e-12*scale,matchGap*(0.55+tc*0.03)/(1+0.22*powRisk));
      if(stableGap>stableCap){
        meetDbg.rejConfirm++;
        if(stableGap>meetDbg.maxConfirmErr)meetDbg.maxConfirmErr=stableGap;
        return;
      }
    }

    meetConfirmed++;
    if(useBitmask){
      pushBest({v:trueVal,ast:combinedAST,mask:(f.mask|r.mask),cost:tc,searchType:"meet"});
    }else{
      const cnt=addCnt(f.cnt??EMPTY,r.cnt??EMPTY);
      pushBest({v:trueVal,ast:combinedAST,cnt,cost:tc,searchType:"meet"});
    }
  }

  function jitterMeetProbeReverse(r,lim2Cap,seenNode){
    if(!bidir) return;
    const scale=Math.max(1,Math.abs(r.v),Math.abs(T));
    const eps=Math.max(3e-10*scale, Math.abs(r.v)*3e-10);
    const probes=[r.v+eps,r.v-eps,r.v*(1+2e-10),r.v*(1-2e-10)];
    const seenKey=new Set();
    for(const pv of probes){
      if(!Number.isFinite(pv) || Math.abs(pv)>CAP) continue;
      const pkey=meetPrimaryKey(pv);
      if(seenKey.has(pkey)) continue;
      seenKey.add(pkey);
      const fl=fwdIdx.get(pkey);
      if(!fl) continue;
      strategyStats.meetJitter++;
      meetDbg.keyHits++;
      const lim2=Math.min(fl.length,lim2Cap);
      for(let i=0;i<lim2;i++){
        const cand=fl[i];
        if(seenNode.has(cand)) continue;
        seenNode.add(cand);
        meetDbg.rev2fwdPairs++;
        meetDbg.pairsTried++;
        tryMeetPair(cand,r);
        if(stopFlag) return;
      }
    }
  }

  function tryBandProbe(target, bandMap, lim2Cap, seenNode, pairCb){
    const tVal=target&&Number.isFinite(target.v)?target.v:NaN;
    const tAbs=Math.abs(tVal);
    const relTol=Math.max(8/Math.max(256,MEET_Q), (Math.max(1,MEET_R)+2)/Math.max(256,MEET_Q));
    const baseBudget=(strategyStats.pressureScore>=1)?10:18;
    const budget=Math.max(6, baseBudget - Math.max(0,(target?.cost|0)-8));
    let consumed=0;
    const keys=meetKeysCached(target);
    const seenBand=new Set();
    let hitCount=0;
    for(const k of keys){
      if(consumed>=budget) break;
      const bk=keyBand(k);
      if(!bk || seenBand.has(bk)) continue;
      seenBand.add(bk);
      const arr=bandMap.get(bk);
      if(!arr) continue;
      meetDbg.keyHits++;
      const lim=Math.min(arr.length,Math.max(4,Math.floor(lim2Cap*0.35)));
      for(let i=0;i<lim;i++){
        if(consumed>=budget) break;
        const cand=arr[i];
        if(seenNode.has(cand)) continue;
        const cv=(cand&&Number.isFinite(cand.v))?cand.v:NaN;
        if(!Number.isFinite(cv)) continue;
        const cAbs=Math.abs(cv);
        const sc=Math.max(1,tAbs,cAbs);
        if(Math.abs(cv-tVal)>relTol*sc) continue;
        seenNode.add(cand);
        pairCb(cand);
        consumed++;
        hitCount++;
        if(stopFlag) return hitCount;
      }
    }
    return hitCount;
  }

  function tryMeetReverseWithFwdIdx(r){
    if(!bidir)return;
    const limKey=Math.max(8,mp.meetKeyProbeCap|0||120);
    // Speed模式: 对非pow/func的rev项只用短键(主键+邻域), 减少buildRev的meet开销
    // pow/func相关的rev项仍用完整键确保质量
    const isPowOrFunc = (r.srcOp==="^"||r.srcOp==="square"||r.srcOp==="cube"||
                          r.srcOp==="exp"||r.srcOp==="log"||r.srcOp==="sqrt"||
                          r.srcOp==="cbrt");
    const skipTransform = !!(mp.speedRevMeetPrimaryOnly) && !isPowOrFunc;
    // Speed模式: 每个rev项最多尝试N对
    const maxPairsPerItem = mp.speedMeetMaxPairsPerItem ? (mp.speedMeetMaxPairsPerItem|0) : 99999;
    let totalPairsThisItem = 0;
    const pkey=meetPrimaryKey(r.v);
    const primary=fwdIdx.get(pkey);
    let hit=false;
    const seenNode=new Set();
    if(primary){
      hit=true;
      meetDbg.keyHits++;
      const lim2=Math.min(primary.length,limKey);
      for(let i=0;i<lim2;i++){
        if(totalPairsThisItem>=maxPairsPerItem) return;
        const cand=primary[i];
        if(seenNode.has(cand)) continue;
        seenNode.add(cand);
        meetDbg.rev2fwdPairs++;
        meetDbg.pairsTried++;
        totalPairsThisItem++;
        tryMeetPair(cand,r);
        if(stopFlag) return;
      }
    }
    if(hit && !mp.meetStage2) return;

    const keys = meetKeysCached(r, skipTransform);
    meetLookups+=keys.length;
    const seen=new Set([pkey]);
    for(const k2 of keys){
      if(totalPairsThisItem>=maxPairsPerItem) return;
      if(seen.has(k2))continue;seen.add(k2);
      const fl=fwdIdx.get(k2);
      if(!fl)continue;
      meetDbg.keyHits++;
      const lim2=Math.min(fl.length,limKey);
      for(let i=0;i<lim2;i++){
        if(totalPairsThisItem>=maxPairsPerItem) return;
        const cand=fl[i];
        if(seenNode.has(cand)) continue;
        seenNode.add(cand);
        meetDbg.rev2fwdPairs++;
        meetDbg.pairsTried++;
        totalPairsThisItem++;
        tryMeetPair(cand,r);
        if(stopFlag) return;
      }
    }
    if(!stopFlag && !hit && totalPairsThisItem<maxPairsPerItem){
      const bandHits=tryBandProbe(r,fwdBandIdx,limKey,seenNode,(cand)=>{
        if(totalPairsThisItem>=maxPairsPerItem) return;
        meetDbg.rev2fwdPairs++;
        meetDbg.pairsTried++;
        totalPairsThisItem++;
        tryMeetPair(cand,r);
      });
      if(bandHits>0) strategyStats.meetJitter++;
    }
    if(!stopFlag && strategyStats.stagnationLayers>=3) jitterMeetProbeReverse(r,limKey,seenNode);
  }

  function jitterMeetProbeForward(f,lim2Cap,seenNode){
    if(!bidir) return;
    const scale=Math.max(1,Math.abs(f.v),Math.abs(T));
    const eps=Math.max(3e-10*scale, Math.abs(f.v)*3e-10);
    const probes=[f.v+eps,f.v-eps,f.v*(1+2e-10),f.v*(1-2e-10)];
    const seenKey=new Set();
    for(const pv of probes){
      if(!Number.isFinite(pv) || Math.abs(pv)>CAP) continue;
      const pkey=meetPrimaryKey(pv);
      if(seenKey.has(pkey)) continue;
      seenKey.add(pkey);
      const rl=revIdx.get(pkey);
      if(!rl) continue;
      strategyStats.meetJitter++;
      meetDbg.keyHits++;
      const lim2=Math.min(rl.length,lim2Cap);
      for(let i=0;i<lim2;i++){
        const cand=rl[i];
        if(seenNode.has(cand)) continue;
        seenNode.add(cand);
        meetDbg.pairsTried++;
        tryMeetPair(f,cand);
        if(stopFlag) return;
      }
    }
  }

  function tryMeetFwdWithRevIdx(f){
    if(!bidir)return;
    const lim2Cap=Math.max(8,mp.meetKeyProbeCap|0||120);
    // Speed模式: 每个fwd项最多尝试N对，防止单项消耗过多时间(原来无限制)
    const maxPairsPerItem = mp.speedMeetMaxPairsPerItem ? (mp.speedMeetMaxPairsPerItem|0) : 99999;
    // Speed模式: 使用短键列表(主键+邻域, 跳过变换域键L/S/Q/C等)
    const skipTransform = !!(mp.speedRevMeetPrimaryOnly);
    let totalPairsThisItem = 0;
    const pkey=meetPrimaryKey(f.v);
    const primary=revIdx.get(pkey);
    let hit=false;
    const seenNode=new Set();
    if(primary){
      hit=true;
      meetDbg.keyHits++;
      const lim2=Math.min(primary.length,lim2Cap);
      for(let i=0;i<lim2;i++){
        if(totalPairsThisItem>=maxPairsPerItem) return;
        const cand=primary[i];
        if(seenNode.has(cand)) continue;
        seenNode.add(cand);
        meetDbg.pairsTried++;
        totalPairsThisItem++;
        tryMeetPair(f,cand);
        if(stopFlag) return;
      }
    }
    if(hit && !mp.meetStage2) return;

    const keys = meetKeysCached(f, skipTransform);
    meetLookups+=keys.length;
    const seen=new Set([pkey]);
    for(const k2 of keys){
      if(totalPairsThisItem>=maxPairsPerItem) return;
      if(seen.has(k2))continue;seen.add(k2);
      const rl=revIdx.get(k2);
      if(!rl)continue;
      meetDbg.keyHits++;
      const lim2=Math.min(rl.length,lim2Cap);
      for(let i=0;i<lim2;i++){
        if(totalPairsThisItem>=maxPairsPerItem) return;
        const cand=rl[i];
        if(seenNode.has(cand)) continue;
        seenNode.add(cand);
        meetDbg.pairsTried++;
        totalPairsThisItem++;
        tryMeetPair(f,cand);
        if(stopFlag) return;
      }
    }
    if(!stopFlag && !hit && totalPairsThisItem<maxPairsPerItem){
      const bandHits=tryBandProbe(f,revBandIdx,lim2Cap,seenNode,(cand)=>{
        if(totalPairsThisItem>=maxPairsPerItem) return;
        meetDbg.pairsTried++;
        totalPairsThisItem++;
        tryMeetPair(f,cand);
      });
      if(bandHits>0) strategyStats.meetJitter++;
    }
    if(!stopFlag && strategyStats.stagnationLayers>=3) jitterMeetProbeForward(f,lim2Cap,seenNode);
  }
  
// [插入位置：在 tryMeetFwdWithRevIdx 函数结束后，buildRev 函数开始前]

  // --- 跳跃式发现（goal-driven jump, inspired by RIES-style target transforms）---
  function jumpLookupNear(targetVal, maxHits){
    if(!Number.isFinite(targetVal) || Math.abs(targetVal)>CAP) return [];
    const lim=Math.max(6, maxHits|0||24);
    const keys=meetKeys(targetVal,Math.abs(targetVal-T),6);
    const seen=new Set();
    const cand=[];

    const pushCand=(it,srcBias)=>{
      if(!it || !it.ast) return;
      if(seen.has(it.ast)) return;
      seen.add(it.ast);
      const d=Math.abs((it.v||0)-targetVal)/(1+Math.abs(targetVal));
      const score=d + 0.018*(it.keep||0) + 0.002*(it.cost||0) + srcBias;
      cand.push({it,score});
    };

    for(const k of keys){
      const arr=fwdIdx.get(k);
      if(!arr) continue;
      const limArr=Math.min(arr.length,Math.max(10,Math.floor(lim*1.4)));
      for(let i=0;i<limArr;i++) pushCand(arr[i],0.0);
    }

    // band fallback improves sub-goal constant lookup when precise mantissa key misses
    if(cand.length<lim){
      const seenBand=new Set();
      for(const k of keys){
        const bk=keyBand(k);
        if(!bk || seenBand.has(bk)) continue;
        seenBand.add(bk);
        const arr=fwdBandIdx.get(bk);
        if(!arr) continue;
        const limBand=Math.min(arr.length,Math.max(8,Math.floor(lim*0.7)));
        for(let i=0;i<limBand;i++) pushCand(arr[i],0.012);
      }
    }

    // Also search for log(targetVal) in index - for power base candidates
    if(targetVal>0){
      const logTarget=Math.log(targetVal);
      if(Number.isFinite(logTarget)){
        const logKeys=meetKeys(logTarget,1,3);
        for(const k of logKeys){
          if(k.startsWith("L|")) continue;
          const arr=fwdIdx.get(k);
          if(!arr) continue;
          const limLog=Math.min(arr.length,Math.max(6,Math.floor(lim*0.6)));
          for(let i=0;i<limLog;i++) pushCand(arr[i],0.02);
        }
      }
    }

    // 新增：搜索 -targetVal（减法组合）和 1/targetVal（除法组合）
    if(cand.length < lim * 2){
      // -target → useful for a-b=target, b = a-target; store b≈-target
      const negTarget = -targetVal;
      if(Math.abs(negTarget) < CAP){
        const negKeys = meetKeys(negTarget, 1, 2);
        for(const k of negKeys.slice(0,3)){
          const arr = fwdIdx.get(k);
          if(!arr) continue;
          const lim2 = Math.min(arr.length, Math.max(4,Math.floor(lim*0.4)));
          for(let i=0;i<lim2;i++) pushCand(arr[i], 0.04);
        }
      }
      // 1/target → useful for a/b=target, b = a/target; store b≈1/target
      if(Math.abs(targetVal)>1e-10 && Math.abs(1/targetVal)<1e10){
        const invTarget = 1/targetVal;
        const invKeys = meetKeys(invTarget, 1, 2);
        for(const k of invKeys.slice(0,3)){
          const arr = fwdIdx.get(k);
          if(!arr) continue;
          const lim3 = Math.min(arr.length, Math.max(4,Math.floor(lim*0.4)));
          for(let i=0;i<lim3;i++) pushCand(arr[i], 0.04);
        }
      }
    }

    if(!cand.length) return [];
    cand.sort((a,b)=>a.score-b.score);
    const out=[];
    for(let i=0;i<cand.length && out.length<lim;i++) out.push(cand[i].it);
    return out;
  }

  function mergeMaskOrCnt(a,b){
    if(useBitmask){
      const m=combMask(a.mask,b.mask);
      return m>=0?m:null;
    }
    return addCnt(a.cnt??EMPTY,b.cnt??EMPTY);
  }

  function pushUnaryTargetCandidate(op,b){
    if(!b || !b.ast) return;
    const v=applyUn(op,b.v);
    if(!Number.isFinite(v) || Math.abs(v)>CAP) return;
    const cost=(b.cost|0)+wUn(op);
    if(cost>maxC+2) return;
    const ast=mkU(op,b.ast);
    if(LEAF_ORDER && ast.ord && !ast.ord.ok) return;
    const scale=Math.max(1,Math.abs(T),Math.abs(v));
    const eps=3e-10*scale*(1+cost*0.06);
    if(Math.abs(v-T)>eps && cost>maxC) return;
    if(useBitmask) pushBest({v,ast,cost,searchType:"meet",mask:b.mask});
    else pushBest({v,ast,cost,searchType:"meet",cnt:b.cnt});
  }

  function tryUnaryTargetTransforms(jm,J){
    if(!Array.isArray(opsUn) || !opsUn.length) return;
    const hasUn=(op)=>opsUn.includes(op);
    const twopi=2*Math.PI;

    const emit=(op,tv,hits)=>{ for(const b of J(tv,hits)) pushUnaryTargetCandidate(op,b); };

    if(hasUn("exp") && T>0) emit("exp",Math.log(T),Math.max(10,Math.floor(14*jm)));
    if(hasUn("log") && Number.isFinite(T)){
      const ev=Math.exp(T);
      if(Number.isFinite(ev) && ev>0 && Math.abs(ev)<1e12) emit("log",ev,Math.max(8,Math.floor(12*jm)));
    }
    if(hasUn("sin") && Math.abs(T)<=1){
      const a=Math.asin(T);
      if(Number.isFinite(a)){
        for(let k=-3;k<=3;k++){
          emit("sin",a+k*twopi,Math.max(9,Math.floor(12*jm)));
          emit("sin",(Math.PI-a)+k*twopi,Math.max(9,Math.floor(12*jm)));
        }
      }
    }
    if(hasUn("cos") && Math.abs(T)<=1){
      const a=Math.acos(T);
      if(Number.isFinite(a)) for(let k=-3;k<=3;k++){
        emit("cos",a+k*twopi,Math.max(9,Math.floor(11*jm)));
        emit("cos",-a+k*twopi,Math.max(9,Math.floor(11*jm)));
      }
    }
    if(hasUn("tan")){
      const a=Math.atan(T);
      if(Number.isFinite(a)) for(let k=-3;k<=3;k++) emit("tan",a+k*Math.PI,Math.max(9,Math.floor(11*jm)));
    }
    if(hasUn("sinh")) emit("sinh",Math.asinh(T),Math.max(9,Math.floor(13*jm)));
    if(hasUn("tanh") && Math.abs(T)<1) emit("tanh",Math.atanh(T),Math.max(8,Math.floor(12*jm)));
    if(hasUn("asin")) emit("asin",Math.sin(T),Math.max(8,Math.floor(10*jm)));
    if(hasUn("acos")) emit("acos",Math.cos(T),Math.max(8,Math.floor(10*jm)));
    if(hasUn("atan")) emit("atan",Math.tan(T),Math.max(8,Math.floor(10*jm)));
  }

  function pushJumpPair(a,b,op,swap=false){
    const L=swap?b:a;
    const R=swap?a:b;
    const merged=mergeMaskOrCnt(L,R);
    if(merged==null) return;
    const ast=mkB(op,L.ast,R.ast);
    if(LEAF_ORDER && ast.ord && !ast.ord.ok) return;
    const v=evalA(ast);
    if(!Number.isFinite(v) || Math.abs(v)>CAP) return;
    const opCost=wBin(op);
    const cost=(L.cost|0)+(R.cost|0)+opCost;
    if(cost>maxC+2) return;
    const scale=Math.max(1,Math.abs(T),Math.abs(v));
    const eps=2.8e-10*scale*(1+cost*0.05);
    if(Math.abs(v-T)>eps && cost>maxC) return;

    if(useBitmask){
      pushBest({v,ast,cost,searchType:"meet",mask:merged});
    }else{
      pushBest({v,ast,cost,searchType:"meet",cnt:merged});
    }
  }


  function selectDecompAnchors(layerItems,layerCost,jm){
    if(!Array.isArray(layerItems) || !layerItems.length) return [];
    const cap=Math.max(16,Math.floor(beamF*((mode==="speed")?0.035:(mode==="accuracy"?0.09:0.055))*Math.max(0.75,jm)));
    const seen=new Set();
    const out=[];
    const add=(it)=>{
      if(!it||!it.ast) return;
      if(seen.has(it.ast)) return;
      seen.add(it.ast);
      out.push(it);
    };

    const src=layerItems.slice(0,Math.min(layerItems.length,cap*2));
    // keep best-by-keep skeleton
    src.sort((a,b)=>(a.keep??INF)-(b.keep??INF));
    for(let i=0;i<src.length && out.length<Math.floor(cap*0.35);i++) add(src[i]);

    // magnitude diversity bins
    const magBins=new Map();
    for(const it of src){
      const mb=Math.floor(Math.log2(Math.abs(it.v)+1e-30));
      const old=magBins.get(mb);
      if(!old || (it.keep??INF)<(old.keep??INF)) magBins.set(mb,it);
    }
    for(const it of Array.from(magBins.values()).sort((a,b)=>(a.keep??INF)-(b.keep??INF))){
      add(it); if(out.length>=Math.floor(cap*0.62)) break;
    }

    // operator-shape diversity
    const shapeBins=new Map();
    for(const it of src){
      const root=(it.ast&&it.ast.t===2)?('b:'+it.ast.op):((it.ast&&it.ast.t===1)?('u:'+it.ast.op):'c');
      const d=it.depth||astDepth(it.ast);
      const dk=d<3?2:(d<6?5:8);
      const k=root+'|'+dk;
      const old=shapeBins.get(k);
      if(!old || (it.keep??INF)<(old.keep??INF)) shapeBins.set(k,it);
    }
    for(const it of Array.from(shapeBins.values()).sort((a,b)=>(a.keep??INF)-(b.keep??INF))){
      add(it); if(out.length>=cap) break;
    }

    // cross-layer anchors: deepen node linkage when stagnant/pressured
    if((strategyStats.stagnationLayers>=2 || strategyStats.pressureScore>=3) && Number.isFinite(layerCost)){
      for(let d=1;d<=2;d++){
        const li=fwd[layerCost-d];
        if(!Array.isArray(li)||!li.length) continue;
        const lim=Math.min(li.length, Math.max(10,Math.floor(cap*(d===1?0.24:0.16))));
        for(let i=0;i<lim && out.length<Math.floor(cap*1.12);i++) add(li[i]);
      }
    }

    if(out.length>Math.floor(cap*1.12)) out.length=Math.floor(cap*1.12);
    return out;
  }

  function tryTargetDecomposition(layerItems,T,layerCost){
    if(!Number.isFinite(T) || fwdIdx.size<8 || !layerItems || !layerItems.length) return;

    const jm=Math.max(0.3, mp.jumpMul||1);
    if(jm<0.45) return;
    const anchors=selectDecompAnchors(layerItems,layerCost,jm);
    if(!anchors.length) return;
    const limHard=(mode==="speed")?96:((mode==="accuracy")?240:140);
    const limItems=Math.min(anchors.length, limHard, Math.max(16,Math.floor(beamF*((mode==="speed")?0.025:(mode==="accuracy"?0.08:0.04))*jm)));
    if(mode==="speed" && (anchors[0]?.cost||0)<4) return;
    if(Number.isFinite(layerCost) && ((mode==="speed"&&layerCost<5)||(mode!=="accuracy"&&layerCost<4))) return;
    const logT=(T>0)?Math.log(T):NaN;
    const jumpCache=new Map();
    const dynHitsMul=1+Math.min(0.85, strategyStats.stagnationLayers*0.12 + (strategyStats.pressureScore||0)*0.18);
    const J=(tv,h)=>{
      const kk=meetPrimaryKey(tv)+"|"+(h|0);
      const c=jumpCache.get(kk);
      if(c) return c;
      const arr=jumpLookupNear(tv,h);
      jumpCache.set(kk,arr);
      return arr;
    };
    const jumpHard=(mode==="speed")?36:((mode==="accuracy")?84:56);
    const JH=(tv,base)=>J(tv,Math.min(jumpHard,Math.max(4,Math.floor(base*dynHitsMul))));
    const JU=(tv,base)=>J(tv,Math.min(jumpHard,Math.max(4,Math.floor(base*(0.72+0.18*dynHitsMul)))));

    tryUnaryTargetTransforms(jm,JU);
    const decStart=performance.now();
    const decBudget=(mode==="speed")?24:((mode==="accuracy")?62:38);

    for(let i=0;i<limItems;i++){
      const a=anchors[i];
      const v=a.v;
      if(!Number.isFinite(v)) continue;
      const av=Math.abs(v);

      // T = a + x / a - x
      if(HAS_SUB || ALLOW_ADD){
        for(const b of JH(T-v,Math.max(8,Math.floor(14*jm)))) pushJumpPair(a,b,"+");
        for(const b of JH(v-T,Math.max(6,Math.floor(10*jm)))) pushJumpPair(a,b,"-");
        for(const b of JH(T+v,Math.max(6,Math.floor(10*jm)))) pushJumpPair(b,a,"-");
      }

      // T = a * x, a / x, x / a
      if(HAS_MUL && av>1e-12){
        for(const b of JH(T/v,20)) pushJumpPair(a,b,"*");
      }
      if(HAS_DIV && av>1e-12){
        for(const b of JH(v/T,Math.max(6,Math.floor(10*jm)))) if(Math.abs(T)>1e-12) pushJumpPair(a,b,"/");
        for(const b of JH(T*v,Math.max(6,Math.floor(10*jm)))) pushJumpPair(b,a,"/");
      }

      // T = a^x or x^a (pow-heavy targets)
      if(Array.isArray(opsBin) && opsBin.includes("^") && T>0){
        if(v>0 && Math.abs(v-1)>1e-12){
          const tx=logT/Math.log(v);
          const hits=Math.max(20,Math.floor(24*jm));
          for(const b of JH(tx,hits)) pushJumpPair(a,b,"^");
          // Also search for x in neighbourhood of tx ± small offsets for rounding resilience
          if(Number.isFinite(tx) && Math.abs(tx)<50){
            for(const b of JH(tx+1e-9,8)) pushJumpPair(a,b,"^");
            for(const b of JH(tx-1e-9,8)) pushJumpPair(a,b,"^");
          }
        }
        // x^a = T → x = T^(1/a)
        if(av>1e-12 && Math.abs(v)<60){
          const base=Math.pow(T,1/v);
          const hits=Math.max(16,Math.floor(20*jm));
          for(const b of JH(base,hits)) pushJumpPair(b,a,"^");
        }
        // Also try log-ratio approach: given a, if T = base^a → base = T^(1/a)
        // And for fractional exponents: T^(a/b) style via known fwd values
        if(Number.isFinite(logT) && av>0.05 && av<50 && Math.abs(v-1)>1e-9){
          // Try T^(1/v) and T^v as potential other-side expressions
          const t_inv_v=Math.pow(T,1/v);
          const t_v=Math.pow(T,v);
          if(Number.isFinite(t_inv_v) && Math.abs(t_inv_v)<1e10)
            for(const b of JH(t_inv_v,Math.max(8,Math.floor(12*jm)))) pushJumpPair(b,a,"^");
          if(Number.isFinite(t_v) && Math.abs(t_v)<1e10)
            for(const b of JH(t_v,Math.max(6,Math.floor(10*jm)))) pushJumpPair(a,b,"^");
        }
      }

      // T = logab(a,x) or logab(x,a)
      if(Array.isArray(opsBin) && opsBin.includes("logab") && Number.isFinite(logT) && T!==0){
        if(v>0 && Math.abs(v-1)>1e-12){
          const tx=Math.pow(v,T);
          for(const b of JH(tx,Math.max(6,Math.floor(10*jm)))) pushJumpPair(a,b,"logab");
        }
        if(v>0){
          const base=Math.pow(v,1/T);
          for(const b of JH(base,8)) pushJumpPair(b,a,"logab");
        }
      }

      if(stopFlag) return;
      if((i&7)===0 && (performance.now()-decStart)>decBudget) return;
    }
  }

  function deepStructureProbe(c){
    if(!bidir||fwdIdx.size<10||c<6) return;
    const t0p=performance.now();
    const timeBudget=(mode==="speed")?10:(mode==="accuracy"?40:20);
    let pairs=0;
    const pairCap=(mode==="speed")?150:(mode==="accuracy"?800:400);
    const absT=Math.abs(T);
    if(!Number.isFinite(absT)||absT<1e-15) return;

    // 从 consts 中提取可用常数
    const atoms=[];
    for(const cc of consts){
      const cv=Number(cc.v);
      if(Number.isFinite(cv)&&Math.abs(cv)<1e6) atoms.push({s:cc.s,v:cv});
    }

    // 生成多级逆变换目标链
    // Level 0: T 的直接逆变换
    const targets=[];
    function addTarget(v,cost,wrap,depth){
      if(!Number.isFinite(v)||Math.abs(v)>1e10||cost>maxC-2) return;
      targets.push({v,cost,wrap,depth});
    }

    // 一元逆: T = f(x) → x = f^{-1}(T)
    const unOps=["square","cube","exp","log","sqrt","cbrt","neg","inv","sin","cos","tan","asin","acos","atan"];
    for(const op of unOps){
      if(!Array.isArray(opsUn)||!opsUn.includes(op)) continue;
      const invs=invUn(op,T);
      if(!Array.isArray(invs)) continue;
      const w=wUn(op);
      for(const inv of invs){
        if(!Number.isFinite(inv.v)) continue;
        addTarget(inv.v,w,(a)=>mkU(op,a),1);
      }
    }

    // 二元逆: T = a OP x 或 T = x OP a，其中 a 是已知常数
    for(const at of atoms){
      const cv=at.v,cAst=getConstNodeByValue(cv);
      if(Array.isArray(opsBin)){
        for(const op of opsBin){
          const w=wBin(op);
          // T = c OP x → x = invBinR(op,T,c)
          const x1=invBinR(op,T,cv);
          if(Number.isFinite(x1)&&Math.abs(x1)<1e10)
            addTarget(x1,w+1,(a)=>mkB(op,cAst,a),1);
          // T = x OP c → x = invBinL(op,T,c)
          if(!isComm(op)){
            const x2=invBinL(op,T,cv);
            if(Number.isFinite(x2)&&Math.abs(x2)<1e10)
              addTarget(x2,w+1,(a)=>mkB(op,a,cAst),1);
          }
        }
      }
    }

    // Level 1→2: 对每个 level-0 目标再做一层分解
    const L0len=targets.length;
    for(let i=0;i<L0len;i++){
      const t0=targets[i];
      if(t0.depth>1) continue;
      // 一元逆
      for(const op of unOps){
        if(!Array.isArray(opsUn)||!opsUn.includes(op)) continue;
        const invs=invUn(op,t0.v);
        if(!Array.isArray(invs)) continue;
        const w=wUn(op);
        for(const inv of invs){
          const wrap2=(a)=>t0.wrap(mkU(op,a));
          addTarget(inv.v,t0.cost+w,wrap2,2);
        }
      }
      // 二元逆（仅用核心常数，限制爆炸）
      const coreAtoms=atoms.filter(a=>
        Math.abs(a.v-Math.PI)<1e-12||Math.abs(a.v-Math.E)<1e-12||
        (Number.isInteger(a.v)&&Math.abs(a.v)<=5&&a.v!==0)
      );
      for(const at of coreAtoms){
        const cv=at.v,cAst=getConstNodeByValue(cv);
        if(!Array.isArray(opsBin)) continue;
        for(const op of ["+","-","*","/"]){
          if(!opsBin.includes(op)) continue;
          const w=wBin(op);
          const x1=invBinR(op,t0.v,cv);
          if(Number.isFinite(x1)&&Math.abs(x1)<1e10)
            addTarget(x1,t0.cost+w+1,(a)=>t0.wrap(mkB(op,cAst,a)),2);
          if(!isComm(op)){
            const x2=invBinL(op,t0.v,cv);
            if(Number.isFinite(x2)&&Math.abs(x2)<1e10)
              addTarget(x2,t0.cost+w+1,(a)=>t0.wrap(mkB(op,a,cAst)),2);
          }
        }
      }
    }

    // Level 2→3: 再深一层（仅限核心操作）
    const L1len=targets.length;
    for(let i=L0len;i<L1len;i++){
      const t1=targets[i];
      if(t1.depth>2||t1.cost>maxC*0.6) continue;
      for(const op of ["square","sqrt","exp","log","neg","inv"]){
        if(!Array.isArray(opsUn)||!opsUn.includes(op)) continue;
        const invs=invUn(op,t1.v);
        if(!Array.isArray(invs)) continue;
        for(const inv of invs){
          const wrap3=(a)=>t1.wrap(mkU(op,a));
          addTarget(inv.v,t1.cost+wUn(op),wrap3,3);
        }
      }
      // 二元（仅 * 和 ^，限制宽度）
      for(const at of atoms.slice(0,6)){
        const cv=at.v,cAst=getConstNodeByValue(cv);
        if(Math.abs(cv)<1e-14) continue;
        for(const op of ["*","^"]){
          if(!Array.isArray(opsBin)||!opsBin.includes(op)) continue;
          const x1=invBinR(op,t1.v,cv);
          if(Number.isFinite(x1)&&Math.abs(x1)<1e10)
            addTarget(x1,t1.cost+wBin(op)+1,(a)=>t1.wrap(mkB(op,cAst,a)),3);
        }
      }
    }

    // 去重并按 cost 排序
    const seen=new Map();
    for(const t of targets){
      const qk=Math.round(t.v*1e7);
      const old=seen.get(qk);
      if(!old||t.cost<old.cost) seen.set(qk,t);
    }
    const sorted=Array.from(seen.values()).sort((a,b)=>a.cost-b.cost);

    // 在 fwdIdx 中查找每个目标
    for(const tgt of sorted){
      if(pairs>=pairCap||stopFlag) break;
      if(performance.now()-t0p>timeBudget) break;

      const cands=jumpLookupNear(tgt.v,Math.max(6,16-tgt.depth*3));
      for(const cand of cands){
        if(!cand||!cand.ast||pairs>=pairCap) continue;
        const innerCost=cand.cost||astCost(cand.ast);
        const totalCost=innerCost+tgt.cost;
        if(totalCost>maxC) continue;

        const merged=useBitmask?(cand.mask||0):cand.cnt;

        const combined=tgt.wrap(cand.ast);
        if(!combined) continue;
        if(LEAF_ORDER&&combined.ord&&!combined.ord.ok) continue;

        const v=evalAStable(combined);
        if(!Number.isFinite(v)||Math.abs(v)>CAP) continue;
        pairs++;

        const err=Math.abs(v-T);
        const threshold=Math.max(bestDeltaSoFar*8,1e-8*Math.max(1,absT));
        if(err>threshold) continue;

        if(useBitmask) pushBest({v,ast:combined,mask:merged,cost:totalCost,searchType:"meet"});
        else pushBest({v,ast:combined,cnt:merged||EMPTY,cost:totalCost,searchType:"meet"});
      }
    }
  }


  function refinementCombiner(c){
    return; // disabled: remove small-number add/sub approximation mechanism

    if(c<6||best.length<2) return;
    const t0r=performance.now();
    const timeBudget2=(mode==="speed")?5:12;
    let refined=0;
    const maxRefine=40;

    // 收集各层中"接近T"和"接近0"的项
    const nearT=[],nearZero=[];
    const tScale=Math.max(1,Math.abs(T));
    for(let fc=1;fc<=Math.min(c,maxC);fc++){
      const ff=fwd[fc];
      if(!ff) continue;
      const lim=Math.min(ff.length,40);
      for(let i=0;i<lim;i++){
        const it=ff[i];
        if(!it||!it.ast) continue;
        const g=Math.abs(it.v-T);
        if(g<tScale*0.01&&g>1e-15) nearT.push(it);
        const av=Math.abs(it.v);
        if(av<tScale*0.01&&av>1e-15) nearZero.push(it);
      }
    }
    nearT.sort((a,b)=>Math.abs(a.v-T)-Math.abs(b.v-T));
    nearZero.sort((a,b)=>Math.abs(a.v)-Math.abs(b.v));

    const ntLim=Math.min(nearT.length,10);
    const nzLim=Math.min(nearZero.length,16);

    for(let i=0;i<ntLim&&refined<maxRefine;i++){
      if(performance.now()-t0r>timeBudget2) break;
      const nt=nearT[i];
      for(let j=0;j<nzLim&&refined<maxRefine;j++){
        const nz=nearZero[j];
        const tc=(nt.cost||0)+(nz.cost||0)+1;
        if(tc>maxC) continue;
        const mg=mergeMaskOrCnt(nt,nz);
        if(mg==null) continue;

        // 加法修正
        const sum=nt.v+nz.v;
        if(Math.abs(sum-T)<Math.abs(nt.v-T)){
          const ast=mkB("+",nt.ast,nz.ast);
          if(!(LEAF_ORDER&&ast.ord&&!ast.ord.ok)){
            const v=evalA(ast);
            if(Number.isFinite(v)&&Math.abs(v-T)<Math.abs(nt.v-T)){
              refined++;
              if(useBitmask) pushBest({v,ast,mask:mg,cost:tc,searchType:"meet"});
              else pushBest({v,ast,cnt:mg,cost:tc,searchType:"meet"});
            }
          }
        }
        // 减法修正
        if(HAS_SUB){
          const diff=nt.v-nz.v;
          if(Math.abs(diff-T)<Math.abs(nt.v-T)){
            const ast=mkB("-",nt.ast,nz.ast);
            if(!(LEAF_ORDER&&ast.ord&&!ast.ord.ok)){
              const v=evalA(ast);
              if(Number.isFinite(v)&&Math.abs(v-T)<Math.abs(nt.v-T)){
                refined++;
                if(useBitmask) pushBest({v,ast,mask:mg,cost:tc,searchType:"meet"});
                else pushBest({v,ast,cnt:mg,cost:tc,searchType:"meet"});
              }
            }
          }
        }
        // 乘法修正（nz ≈ 修正因子）
        if(HAS_MUL&&Math.abs(nz.v)>1e-15){
          const tcm=(nt.cost||0)+(nz.cost||0)+wBin("*");
          if(tcm<=maxC){
            // T/nt.v ≈ 需要的修正因子
            const needed=T/nt.v;
            if(Math.abs(nz.v-needed)<Math.abs(needed)*0.1){
              const prod=nt.v*nz.v;
              if(Math.abs(prod-T)<Math.abs(nt.v-T)){
                const ast=mkB("*",nt.ast,nz.ast);
                if(!(LEAF_ORDER&&ast.ord&&!ast.ord.ok)){
                  const v=evalA(ast);
                  if(Number.isFinite(v)&&Math.abs(v-T)<Math.abs(nt.v-T)){
                    refined++;
                    if(useBitmask) pushBest({v,ast,mask:mg,cost:tcm,searchType:"meet"});
                    else pushBest({v,ast,cnt:mg,cost:tcm,searchType:"meet"});
                  }
                }
              }
            }
          }
        }
      }
    }

    // 也试: nearT[i] 除以 nearT[j] 得到修正比
    if(HAS_DIV && ntLim>=2){
      for(let i=0;i<Math.min(ntLim,6)&&refined<maxRefine;i++){
        if(performance.now()-t0r>timeBudget2) break;
        const a=nearT[i];
        // 查找 fwd 中 v ≈ T/a.v (即乘法分解)
        if(Math.abs(a.v)>1e-12){
          const target=T/a.v;
          const hits=jumpLookupNear(target,6);
          for(const h of hits){
            if(!h||!h.ast||refined>=maxRefine) continue;
            const tc2=(a.cost||0)+(h.cost||0)+wBin("*");
            if(tc2>maxC) continue;
            const mg2=mergeMaskOrCnt(a,h);
            if(mg2==null) continue;
            const ast=mkB("*",a.ast,h.ast);
            if(LEAF_ORDER&&ast.ord&&!ast.ord.ok) continue;
            const v=evalA(ast);
            if(!Number.isFinite(v)) continue;
            if(Math.abs(v-T)<Math.abs(a.v-T)){
              refined++;
              if(useBitmask) pushBest({v,ast,mask:mg2,cost:tc2,searchType:"meet"});
              else pushBest({v,ast,cnt:mg2,cost:tc2,searchType:"meet"});
            }
          }
        }
      }
    }
  }


  // ═══════════════════════════════════════════════════════════════════════
  // 【顿悟】errorCorrectionSearch - 误差修正顿悟搜索
  // 核心思想：若 expr ≈ T，误差 δ = T − expr_val，则寻找 expr2 ≈ δ
  // 使得 expr + expr2 精确等于 T。这是最强的精度提升策略。
  // 同时处理乘法修正：若 expr * k ≈ T，寻找 k ≈ T/expr_val。
  // ═══════════════════════════════════════════════════════════════════════
  function errorCorrectionSearch(c){
    return; // disabled: remove small-number add/sub approximation mechanism

    if(best.length<1) return;
    const tStart=performance.now();
    const timeCap=(mode==="speed")?10:(mode==="accuracy"?32:18);
    const scale=Math.max(1,Math.abs(T));
    let found=0;
    const maxFound=(mode==="speed")?24:(mode==="accuracy")?80:48;

    // 收集当前所有fwd层中接近T的项（误差 < 5%T）
    const nearT=[];
    for(let fc=1;fc<=Math.min(c,maxC);fc++){
      const ff=fwd[fc]; if(!ff) continue;
      for(let i=0;i<Math.min(ff.length,48);i++){
        const it=ff[i]; if(!it||!it.ast) continue;
        const err=Math.abs(it.v-T);
        if(err<scale*0.12 && err>scale*1e-11) nearT.push(it);
      }
    }
    if(!nearT.length) return;
    nearT.sort((a,b)=>Math.abs(a.v-T)-Math.abs(b.v-T));

    for(const nt of nearT.slice(0,20)){
      if(found>=maxFound||stopFlag||performance.now()-tStart>timeCap) break;
      const delta=T-nt.v;            // additive error
      const ratio=T/nt.v;            // multiplicative error

      // ── 加法修正：寻找 expr2 ≈ delta ──
      if(Math.abs(delta)>scale*1e-12 && Math.abs(delta)<scale*0.12 && ALLOW_ADD){
        const candidates=jumpLookupNear(delta, 28);
        for(const ec of candidates){
          if(!ec||!ec.ast||found>=maxFound) break;
          const tc=(nt.cost||0)+(ec.cost||0)+wBin("+");
          if(tc>maxC) continue;
          const merged=mergeMaskOrCnt(nt,ec); if(merged==null) continue;
          const ast2=mkB("+",nt.ast,ec.ast);
          if(LEAF_ORDER&&ast2.ord&&!ast2.ord.ok) continue;
          const v2=evalA(ast2);
          if(!Number.isFinite(v2)||Math.abs(v2)>CAP) continue;
          const err2=Math.abs(v2-T);
          if(err2<Math.abs(delta)*0.98){ // 必须比原始更精确
            found++;
            const sv=evalAStable(ast2);
            const fv=Number.isFinite(sv)?sv:v2;
            if(useBitmask) pushBest({v:fv,ast:ast2,mask:merged,cost:tc,searchType:"meet"});
            else pushBest({v:fv,ast:ast2,cnt:merged,cost:tc,searchType:"meet"});
          }
        }
      }

      // ── 减法修正：寻找 expr2 ≈ -delta (i.e. expr - expr2 ≈ T) ──
      if(Math.abs(delta)>scale*1e-12 && HAS_SUB){
        const negDelta=nt.v-T;
        if(Math.abs(negDelta)>scale*1e-12){
          const candidates2=jumpLookupNear(negDelta, 16);
          for(const ec of candidates2){
            if(!ec||!ec.ast||found>=maxFound) break;
            const tc=(nt.cost||0)+(ec.cost||0)+wBin("-");
            if(tc>maxC) continue;
            const merged=mergeMaskOrCnt(nt,ec); if(merged==null) continue;
            const ast2=mkB("-",nt.ast,ec.ast);
            if(LEAF_ORDER&&ast2.ord&&!ast2.ord.ok) continue;
            const v2=evalA(ast2);
            if(!Number.isFinite(v2)||Math.abs(v2)>CAP) continue;
            if(Math.abs(v2-T)<Math.abs(delta)*0.98){
              found++;
              const sv=evalAStable(ast2);
              const fv=Number.isFinite(sv)?sv:v2;
              if(useBitmask) pushBest({v:fv,ast:ast2,mask:merged,cost:tc,searchType:"meet"});
              else pushBest({v:fv,ast:ast2,cnt:merged,cost:tc,searchType:"meet"});
            }
          }
        }
      }

      // ── 乘法修正：若 ratio ≈ k，寻找 expr2 ≈ k ──
      if(HAS_MUL && Math.abs(ratio)>0.5 && Math.abs(ratio)<2.0 && Math.abs(ratio-1)>1e-8
         && Number.isFinite(ratio)){
        const candidates3=jumpLookupNear(ratio, 20);
        for(const ec of candidates3){
          if(!ec||!ec.ast||found>=maxFound) break;
          const tc=(nt.cost||0)+(ec.cost||0)+wBin("*");
          if(tc>maxC) continue;
          const merged=mergeMaskOrCnt(nt,ec); if(merged==null) continue;
          const ast2=mkB("*",nt.ast,ec.ast);
          if(LEAF_ORDER&&ast2.ord&&!ast2.ord.ok) continue;
          const v2=evalA(ast2);
          if(!Number.isFinite(v2)||Math.abs(v2)>CAP) continue;
          if(Math.abs(v2-T)<Math.abs(nt.v-T)*0.98){
            found++;
            const sv=evalAStable(ast2);
            const fv=Number.isFinite(sv)?sv:v2;
            if(useBitmask) pushBest({v:fv,ast:ast2,mask:merged,cost:tc,searchType:"meet"});
            else pushBest({v:fv,ast:ast2,cnt:merged,cost:tc,searchType:"meet"});
          }
        }
      }

      // ── 单元修正：对接近T的表达式直接尝试所有单元逆变换 ──
      if(Array.isArray(opsUn)){
        for(const op of opsUn){
          if(found>=maxFound||performance.now()-tStart>timeCap) break;
          // 计算 op(nt.v) 并与T比较，如果接近则候选值更接近T
          const applied=applyUn(op,nt.v);
          if(!Number.isFinite(applied)||Math.abs(applied)>CAP) continue;
          const tc=(nt.cost||0)+wUn(op);
          if(tc>maxC) continue;
          if(Math.abs(applied-T)<Math.abs(nt.v-T)*0.9){
            const ast2=mkU(op,nt.ast);
            if(LEAF_ORDER&&ast2.ord&&!ast2.ord.ok) continue;
            const sv=evalAStable(ast2);
            const fv=Number.isFinite(sv)?sv:applied;
            found++;
            if(useBitmask) pushBest({v:fv,ast:ast2,mask:nt.mask||0,cost:tc,searchType:"meet"});
            else pushBest({v:fv,ast:ast2,cnt:nt.cnt||EMPTY,cost:tc,searchType:"meet"});
          }
        }
      }
    }
  }

  // ═══════════════════════════════════════════════════════════════════════
  // 【联结】crossBeamAlgebraicScan - 横向梁代数扫描
  // 核心：对fwd各层的项目两两组合检测是否接近T
  // 利用已排序的beam，O(n log n) 实现 a op b ≈ T
  // ═══════════════════════════════════════════════════════════════════════
  function crossBeamAlgebraicScan(c){
    if(c<3) return;
    const tStart=performance.now();
    const timeCap=(mode==="speed")?8:(mode==="accuracy"?28:14);
    const scale=Math.max(1,Math.abs(T));
    const eps=scale*3e-6;
    let tried=0;
    const maxTried=(mode==="speed")?400:(mode==="accuracy")?1200:700;

    // 收集当前层的top候选（按goal排序）
    const pool=[];
    const cHalf=Math.min(c,maxC);
    for(let fc=1;fc<=cHalf;fc++){
      const ff=fwd[fc]; if(!ff||!ff.length) continue;
      const limF=Math.min(ff.length, mode==="speed"?24:48);
      for(let i=0;i<limF;i++){
        const it=ff[i]; if(it&&it.ast) pool.push(it);
      }
    }
    if(pool.length<2) return;
    pool.sort((a,b)=>(a.goal||0)-(b.goal||0));
    const N=Math.min(pool.length, mode==="speed"?60:120);

    // ── 二分搜索辅助：在已排序数组中找最接近target的项 ──
    function bsearch(arr,target,valFn){
      let lo=0,hi=arr.length-1,best=-1,bestD=Infinity;
      while(lo<=hi){
        const mid=(lo+hi)>>1;
        const v=valFn(arr[mid]);
        const d=Math.abs(v-target);
        if(d<bestD){bestD=d;best=mid;}
        if(v<target) lo=mid+1; else hi=mid-1;
      }
      return best;
    }

    // ── 对每个池中的项 a，寻找 b 使 a+b≈T, a*b≈T, a/b≈T ──
    const sorted_v=pool.slice(0,N).sort((a,b)=>a.v-b.v);

    for(let i=0;i<sorted_v.length;i++){
      if(tried>=maxTried||stopFlag||performance.now()-tStart>timeCap) break;
      const a=sorted_v[i];
      const av=a.v;
      if(!Number.isFinite(av)) continue;

      // a + b ≈ T → b ≈ T - a
      if(ALLOW_ADD){
        const target=T-av;
        const bi=bsearch(sorted_v,target,(x)=>x.v);
        const window=Math.min(4,sorted_v.length);
        for(let di=-window;di<=window;di++){
          const idx2=bi+di;
          if(idx2<0||idx2>=sorted_v.length||idx2===i) continue;
          const b=sorted_v[idx2];
          if(!b.ast) continue;
          const tc=(a.cost||0)+(b.cost||0)+wBin("+");
          if(tc>maxC) continue;
          const v2=av+b.v;
          if(Math.abs(v2-T)>eps) continue;
          tried++;
          const merged=mergeMaskOrCnt(a,b); if(merged==null) continue;
          const ast2=mkB("+",a.ast,b.ast);
          if(LEAF_ORDER&&ast2.ord&&!ast2.ord.ok) continue;
          const sv=evalAStable(ast2);
          if(!Number.isFinite(sv)) continue;
          if(useBitmask) pushBest({v:sv,ast:ast2,mask:merged,cost:tc,searchType:"meet"});
          else pushBest({v:sv,ast:ast2,cnt:merged,cost:tc,searchType:"meet"});
          if(stopFlag) return;
        }
      }

      // a * b ≈ T → b ≈ T/a
      if(HAS_MUL && Math.abs(av)>1e-10){
        const target=T/av;
        if(Number.isFinite(target)&&Math.abs(target)<1e10){
          const bi=bsearch(sorted_v,target,(x)=>x.v);
          for(let di=-3;di<=3;di++){
            const idx2=bi+di;
            if(idx2<0||idx2>=sorted_v.length||idx2===i) continue;
            const b=sorted_v[idx2];
            if(!b.ast) continue;
            const tc=(a.cost||0)+(b.cost||0)+wBin("*");
            if(tc>maxC) continue;
            const v2=av*b.v;
            if(Math.abs(v2-T)>eps) continue;
            tried++;
            const merged=mergeMaskOrCnt(a,b); if(merged==null) continue;
            const ast2=mkB("*",a.ast,b.ast);
            if(LEAF_ORDER&&ast2.ord&&!ast2.ord.ok) continue;
            const sv=evalAStable(ast2);
            if(!Number.isFinite(sv)) continue;
            if(useBitmask) pushBest({v:sv,ast:ast2,mask:merged,cost:tc,searchType:"meet"});
            else pushBest({v:sv,ast:ast2,cnt:merged,cost:tc,searchType:"meet"});
            if(stopFlag) return;
          }
        }
      }

      // a ^ b ≈ T (只当T>0且a>0)
      if(Array.isArray(opsBin)&&opsBin.includes("^")&&T>0&&av>0&&Math.abs(av-1)>1e-10){
        const target=Math.log(T)/Math.log(av);
        if(Number.isFinite(target)&&Math.abs(target)<50){
          const bi=bsearch(sorted_v,target,(x)=>x.v);
          for(let di=-3;di<=3;di++){
            const idx2=bi+di;
            if(idx2<0||idx2>=sorted_v.length||idx2===i) continue;
            const b=sorted_v[idx2];
            if(!b.ast) continue;
            const tc=(a.cost||0)+(b.cost||0)+wBin("^");
            if(tc>maxC) continue;
            const v2=safePowStable(av,b.v);
            if(!Number.isFinite(v2)||Math.abs(v2-T)>eps*100) continue;
            tried++;
            const merged=mergeMaskOrCnt(a,b); if(merged==null) continue;
            const ast2=mkB("^",a.ast,b.ast);
            if(LEAF_ORDER&&ast2.ord&&!ast2.ord.ok) continue;
            const sv=evalAStable(ast2);
            if(!Number.isFinite(sv)) continue;
            if(useBitmask) pushBest({v:sv,ast:ast2,mask:merged,cost:tc,searchType:"meet"});
            else pushBest({v:sv,ast:ast2,cnt:merged,cost:tc,searchType:"meet"});
            if(stopFlag) return;
          }
        }
      }
    }
  }

  // ═══════════════════════════════════════════════════════════════════════
  // 【启发】heuristicConstantRelationSearch - 常数关联启发搜索
  // 利用已知数学常数之间的代数关系：若某fwd值 v 与 T 的比接近常数的某次幂，
  // 则直接构造表达式。类似 PSLQ 算法的整系数关系检测。
  // ═══════════════════════════════════════════════════════════════════════
  function heuristicConstantRelationSearch(c){
    if(c<4||!Number.isFinite(T)||Math.abs(T)<1e-15) return;
    const tStart=performance.now();
    const timeCap=(mode==="speed")?6:(mode==="accuracy"?20:10);
    const scale=Math.max(1,Math.abs(T));
    let found=0;
    const maxFound=(mode==="speed")?30:80;

    // 所有已启用的常数
    const allConsts=consts.filter(c=>Number.isFinite(Number(c.v)));
    // 所有整数幂：-6..6（避免极端值）
    const smallInts=[-5,-4,-3,-2,-1,0,1,2,3,4,5];
    const rationalFracs=[[1,2],[1,3],[2,3],[1,4],[3,4],[1,5],[2,5],[1,6],[1,7],[1,8]];

    // 检验：v 是否接近 T 乘以某个已知表达式
    function tryProdCombo(v,ast,cost,mask_or_cnt){
      if(!Number.isFinite(v)||Math.abs(v)>CAP||cost>maxC) return;
      const err=Math.abs(v-T);
      if(err<scale*3e-6){
        found++;
        const sv=evalAStable(ast);
        const fv=Number.isFinite(sv)?sv:v;
        if(useBitmask) pushBest({v:fv,ast,mask:mask_or_cnt||0,cost,searchType:"meet"});
        else pushBest({v:fv,ast,cnt:mask_or_cnt||EMPTY,cost,searchType:"meet"});
      }
    }

    // 收集fwd中高质量候选
    const pool2=[];
    for(let fc=1;fc<=Math.min(c,maxC);fc++){
      const ff=fwd[fc]; if(!ff) continue;
      for(let i=0;i<Math.min(ff.length,32);i++){
        const it=ff[i]; if(it&&it.ast&&Math.abs(it.v)>1e-15) pool2.push(it);
      }
    }

    for(const it of pool2){
      if(found>=maxFound||stopFlag||performance.now()-tStart>timeCap) break;
      const v=it.v;

      // ── 整数幂修正：T = v * c^n ──
      for(const cc of allConsts){
        const cv=Number(cc.v);
        if(!Number.isFinite(cv)||Math.abs(cv)<1e-12||Math.abs(cv-1)<1e-12) continue;
        const cAst=getConstNodeByValue(cv);
        const baseCost=1; // leaf cost
        for(const n of smallInts){
          if(n===0) continue;
          const cn=Math.pow(cv,Math.abs(n));
          if(!Number.isFinite(cn)||cn>1e10) continue;
          const target=(n>0)?(v*cn):(v/cn);
          if(!Number.isFinite(target)||Math.abs(target-T)>scale*3e-6) continue;
          const nAst=mkC(String(Math.abs(n)),Math.abs(n),ordLeaf(String(Math.abs(n))));
          const powAst=(n>0)?mkB("^",cAst,nAst):mkB("^",cAst,mkU("neg",nAst));
          const tc=(it.cost||0)+wBin("*")+wBin("^")+baseCost+1;
          if(tc>maxC) continue;
          const finalAst=mkB("*",it.ast,powAst);
          if(LEAF_ORDER&&finalAst.ord&&!finalAst.ord.ok) continue;
          tryProdCombo(target,finalAst,tc,useBitmask?(it.mask||0):(it.cnt||EMPTY));
        }
      }

      // ── 有理数倍数：T = v * (p/q) ──
      if(HAS_DIV && found<maxFound){
        for(const [p,q] of rationalFracs){
          const target_pq=v*p/q;
          if(!Number.isFinite(target_pq)||Math.abs(target_pq-T)>scale*3e-6) continue;
          const pAst=mkC(String(p),p,ordLeaf(String(p)));
          const qAst=mkC(String(q),q,ordLeaf(String(q)));
          const fracAst=mkB("/",pAst,qAst);
          const tc=(it.cost||0)+wBin("*")+wBin("/")+2;
          if(tc>maxC) continue;
          const finalAst=mkB("*",it.ast,fracAst);
          if(LEAF_ORDER&&finalAst.ord&&!finalAst.ord.ok) continue;
          tryProdCombo(target_pq,finalAst,tc,useBitmask?(it.mask||0):(it.cnt||EMPTY));
        }
      }
    }
  }

  // ═══════════════════════════════════════════════════════════════════════
  // 【跳跃】advancedDeepNestingProbe - 强化深层嵌套探针（L3+L4）
  // 在原 deepNestingProbe 的基础上增加L3（三重逆变换）和二元跳跃
  // ═══════════════════════════════════════════════════════════════════════
  function advancedDeepNestingProbe(c){
    if(!bidir||fwdIdx.size<10||c<7) return;
    const tStart=performance.now();
    const timeCap=(mode==="speed")?10:(mode==="accuracy")?40:20;
    let pairsTried=0;
    const maxPairs=(mode==="speed")?180:(mode==="accuracy")?800:400;
    const absT=Math.abs(T);
    if(!Number.isFinite(absT)||absT<1e-12) return;

    const knownConsts=[
      {s:"π",v:Math.PI},{s:"e",v:Math.E},{s:"2",v:2},{s:"3",v:3},
      {s:"√2",v:Math.SQRT2},{s:"1",v:1},{s:"4",v:4},{s:"5",v:5},{s:"1/2",v:0.5},
      {s:"6",v:6},{s:"7",v:7},{s:"8",v:8},{s:"φ",v:(1+Math.sqrt(5))/2},
    ].filter(cc=>consts.some(uc=>Math.abs(Number(uc.v)-cc.v)<1e-14));

    const unOps=Array.isArray(opsUn)?opsUn:[];
    const binOps=Array.isArray(opsBin)?opsBin:[];
    const unInvOps2=["sqrt","cbrt","square","cube","exp","log","neg","inv",
                     "sin","cos","tan","asin","acos","atan","sinh","cosh","tanh"];

    // ── 构建L0（与原deepNestingProbe相同）──
    const L0=[];
    if(absT>0&&unOps.includes("square")){
      L0.push({v:Math.sqrt(absT),c:wUn("square"),w:(a)=>mkU("square",a)});
      L0.push({v:-Math.sqrt(absT),c:wUn("square"),w:(a)=>mkU("square",mkU("neg",a))});
    }
    if(unOps.includes("cube")) L0.push({v:Math.cbrt(T),c:wUn("cube"),w:(a)=>mkU("cube",a)});
    if(T>0&&unOps.includes("exp")) L0.push({v:Math.log(T),c:wUn("exp"),w:(a)=>mkU("exp",a)});
    if(binOps.includes("^")){
      for(const n of [2,3,4,5,6]){
        const r=Math.pow(absT,1/n);
        if(Number.isFinite(r)&&r<1e8){
          const nAst=mkC(String(n),n,ordLeaf(String(n)));
          L0.push({v:r,c:wBin("^"),w:(a)=>mkB("^",a,nAst)});
          if(n%2===0) L0.push({v:-r,c:wBin("^"),w:(a)=>mkB("^",mkU("neg",a),nAst)});
        }
      }
    }
    // 补充: inv(T), neg(T)
    if(Math.abs(T)>1e-12&&unOps.includes("inv"))
      L0.push({v:1/T,c:wUn("inv"),w:(a)=>mkU("inv",a)});
    if(unOps.includes("neg"))
      L0.push({v:-T,c:wUn("neg"),w:(a)=>mkU("neg",a)});
    // asin/acos/asin branches
    if(Math.abs(T)<=1&&unOps.includes("sin"))
      L0.push({v:Math.asin(Math.max(-1,Math.min(1,T))),c:wUn("sin"),w:(a)=>mkU("sin",a)});
    if(Math.abs(T)<=1&&unOps.includes("cos"))
      L0.push({v:Math.acos(Math.max(-1,Math.min(1,T))),c:wUn("cos"),w:(a)=>mkU("cos",a)});

    // ── 构建L1: 对L0施加一层常数二元运算 ──
    const L1=[];
    for(const t0 of L0){
      if(!Number.isFinite(t0.v)||Math.abs(t0.v)>1e8) continue;
      for(const cc of knownConsts){
        const cv=cc.v, cAst=getConstNodeByValue(cv);
        if(HAS_MUL&&Math.abs(cv)>1e-14){
          const x=t0.v/cv;
          if(Number.isFinite(x)&&Math.abs(x)<1e8) L1.push({v:x,c:t0.c+wBin("*"),w:(a)=>t0.w(mkB("*",cAst,a))});
        }
        if(ALLOW_ADD||HAS_SUB){
          const x=t0.v-cv;
          if(Number.isFinite(x)&&Math.abs(x)<1e8) L1.push({v:x,c:t0.c+wBin("+"),w:(a)=>t0.w(mkB("+",cAst,a))});
        }
        if(HAS_SUB){
          const x=cv-t0.v;
          if(Number.isFinite(x)&&Math.abs(x)<1e8) L1.push({v:x,c:t0.c+wBin("-"),w:(a)=>t0.w(mkB("-",cAst,a))});
        }
        if(HAS_DIV&&Math.abs(cv)>1e-14){
          const x=t0.v*cv;
          if(Number.isFinite(x)&&Math.abs(x)<1e8) L1.push({v:x,c:t0.c+wBin("/"),w:(a)=>t0.w(mkB("/",a,cAst))});
          const x2=cv/Math.max(1e-14,Math.abs(t0.v))*(t0.v>0?1:-1);
          if(Number.isFinite(x2)&&Math.abs(x2)<1e8) L1.push({v:x2,c:t0.c+wBin("/"),w:(a)=>t0.w(mkB("/",cAst,a))});
        }
      }
    }

    // ── 构建L2: 对L1施加单元逆变换 ──
    const L2=[];
    for(const t1 of L1){
      if(!Number.isFinite(t1.v)||Math.abs(t1.v)>1e8||t1.c>maxC-2) continue;
      for(const op of unInvOps2){
        if(!unOps.includes(op)) continue;
        const invs=invUn(op,t1.v); if(!Array.isArray(invs)) continue;
        for(const inv of invs){
          if(!Number.isFinite(inv.v)||Math.abs(inv.v)>1e8) continue;
          const tc=t1.c+wUn(op); if(tc>maxC) continue;
          L2.push({v:inv.v,c:tc,w:(a)=>t1.w(mkU(op,a))});
        }
      }
    }

    // ── 构建L3（新增）: 对L2再施加一层常数二元运算 ──
    const L3=[];
    for(const t2 of L2.slice(0, Math.min(L2.length, 120))){
      if(!Number.isFinite(t2.v)||Math.abs(t2.v)>1e8||t2.c>maxC-3) continue;
      for(const cc of knownConsts.slice(0,6)){ // 只用高频常数减少爆炸
        const cv=cc.v, cAst=getConstNodeByValue(cv);
        if(HAS_MUL&&Math.abs(cv)>1e-14&&Math.abs(cv-1)>1e-10){
          const x=t2.v/cv;
          if(Number.isFinite(x)&&Math.abs(x)<1e8&&t2.c+wBin("*")<=maxC)
            L3.push({v:x,c:t2.c+wBin("*"),w:(a)=>t2.w(mkB("*",cAst,a))});
        }
        if((ALLOW_ADD||HAS_SUB)&&Math.abs(cv)<50){
          const x=t2.v-cv;
          if(Number.isFinite(x)&&Math.abs(x)<1e8&&t2.c+wBin("+")<=maxC)
            L3.push({v:x,c:t2.c+wBin("+"),w:(a)=>t2.w(mkB("+",cAst,a))});
        }
      }
    }

    // ── 去重并排序 ──
    const allTargets=[...L0,...L1,...L2,...L3];
    const seen2=new Map(), ded2=[];
    for(const t of allTargets){
      if(!Number.isFinite(t.v)) continue;
      const qk=Math.round(t.v*1e5);
      if(seen2.has(qk)){const old=seen2.get(qk);if(t.c<old.c){seen2.set(qk,t);ded2[ded2.indexOf(old)]=t;}}
      else{seen2.set(qk,t);ded2.push(t);}
    }
    ded2.sort((a,b)=>a.c-b.c);

    // ── 查找fwd中的匹配 ──
    for(const tgt of ded2){
      if(pairsTried>=maxPairs||stopFlag||performance.now()-tStart>timeCap) break;
      const candidates=jumpLookupNear(tgt.v,Math.max(12,26-(tgt.c||1)));
      for(const cand of candidates){
        if(pairsTried>=maxPairs) break;
        if(!cand||!cand.ast) continue;
        const innerCost=cand.cost||astCost(cand.ast);
        const totalCost=innerCost+tgt.c;
        if(totalCost>maxC) continue;
        const combined=tgt.w(cand.ast);
        if(!combined) continue;
        if(LEAF_ORDER&&combined.ord&&!combined.ord.ok) continue;
        const v=evalA(combined);
        if(!Number.isFinite(v)||Math.abs(v)>CAP) continue;
        pairsTried++;
        const err=Math.abs(v-T);
        if(err>Math.max(1,Math.abs(T))*0.02) continue;
        const stableV=evalAStable(combined);
        if(!Number.isFinite(stableV)) continue;
        const stableErr=Math.abs(stableV-T);
        const threshold=Math.max(bestDeltaSoFar*12,1e-5*Math.max(1,Math.abs(T)));
        if(stableErr>threshold) continue;
        if(useBitmask) pushBest({v:stableV,ast:combined,mask:cand.mask||0,cost:totalCost,searchType:"meet"});
        else pushBest({v:stableV,ast:combined,cnt:cand.cnt||EMPTY,cost:totalCost,searchType:"meet"});
      }
    }
  }

  // ═══════════════════════════════════════════════════════════════════════
  // 【精度】precisionRefinement - 精度淬火
  // 对找到的近似解，通过添加极小修正项提升到更高精度
  // 使用"误差放大"技术：将误差乘以整数因子后在fwd中寻找匹配
  // ═══════════════════════════════════════════════════════════════════════
  function precisionRefinement(c){
    return; // disabled: remove small-number add/sub approximation mechanism

    if(best.length<1||c<6) return;
    const tStart=performance.now();
    const timeCap=(mode==="speed")?6:(mode==="accuracy"?24:12);
    const scale=Math.max(1,Math.abs(T));
    let refined=0;
    const maxRefined=(mode==="speed")?20:(mode==="accuracy"?60:36);

    // 取最佳解中误差最小的几个
    const topBest=best.slice(0,Math.min(best.length,8));
    for(const bst of topBest){
      if(refined>=maxRefined||stopFlag||performance.now()-tStart>timeCap) break;
      const bv=bst.v;
      const delta=T-bv;
      if(!Number.isFinite(delta)||Math.abs(delta)<scale*1e-13||Math.abs(delta)>scale*1e-3) continue;

      // 在fwd所有层中找 expr ≈ delta，然后将解组合提高精度
      // 也试 n*delta 的倍数（1..8），然后用 /n 修正
      for(const n of [1,2,3,4,5,6,7,8,9,10]){
        if(stopFlag||performance.now()-tStart>timeCap) break;
        const target=delta*n;
        if(!Number.isFinite(target)||Math.abs(target)>scale) continue;
        const candidates=jumpLookupNear(target,24);
        for(const ec of candidates){
          if(!ec||!ec.ast||refined>=maxRefined) break;
          // 如果找到 ec ≈ n*delta，则 (bst_ast + ec/n) ≈ T
          // 为简化：只处理 n=1 时直接加，n>1 时需要 ec/n
          if(n===1){
            // 无法访问bst的ast（只有v,delta），但可以从fwd找最接近bv的项
            const bstFwdCands=jumpLookupNear(bv,12);
            for(const fc of bstFwdCands){
              if(!fc||!fc.ast||refined>=maxRefined) break;
              if(!ALLOW_ADD) break;
              const tc=(fc.cost||0)+(ec.cost||0)+wBin("+");
              if(tc>maxC) continue;
              const merged=mergeMaskOrCnt(fc,ec); if(merged==null) continue;
              const ast2=mkB("+",fc.ast,ec.ast);
              if(LEAF_ORDER&&ast2.ord&&!ast2.ord.ok) continue;
              const v2=evalA(ast2);
              if(!Number.isFinite(v2)||Math.abs(v2)>CAP) continue;
              if(Math.abs(v2-T)<Math.abs(delta)*0.9){
                refined++;
                const sv=evalAStable(ast2);
                const fv=Number.isFinite(sv)?sv:v2;
                if(useBitmask) pushBest({v:fv,ast:ast2,mask:merged,cost:tc,searchType:"meet"});
                else pushBest({v:fv,ast:ast2,cnt:merged,cost:tc,searchType:"meet"});
              }
            }
          } else if(HAS_DIV){
            // ec ≈ n*delta → ec/n ≈ delta
            const nAst=mkC(String(n),n,ordLeaf(String(n)));
            const ecDivN=mkB("/",ec.ast,nAst);
            const ecDivNv=ec.v/n;
            // 找最接近bv的fwd项
            const bstFwdCands=jumpLookupNear(bv,8);
            for(const fc of bstFwdCands){
              if(!fc||!fc.ast||refined>=maxRefined) break;
              if(!ALLOW_ADD) break;
              const tc=(fc.cost||0)+(ec.cost||0)+wBin("+")+wBin("/")+1;
              if(tc>maxC) continue;
              const merged=mergeMaskOrCnt(fc,ec); if(merged==null) continue;
              const ast2=mkB("+",fc.ast,ecDivN);
              if(LEAF_ORDER&&ast2.ord&&!ast2.ord.ok) continue;
              const v2=evalA(ast2);
              if(!Number.isFinite(v2)||Math.abs(v2)>CAP) continue;
              if(Math.abs(v2-T)<Math.abs(delta)*0.9){
                refined++;
                const sv=evalAStable(ast2);
                const fv=Number.isFinite(sv)?sv:v2;
                if(useBitmask) pushBest({v:fv,ast:ast2,mask:merged,cost:tc,searchType:"meet"});
                else pushBest({v:fv,ast:ast2,cnt:merged,cost:tc,searchType:"meet"});
              }
            }
          }
        }
      }
    }
  }

  function powerChainProbe(c){
    if(c<5||!Array.isArray(opsBin)||!opsBin.includes("^")) return;
    if(!Number.isFinite(T)||T<=0) return;
    const t0pc=performance.now();
    const timeCap=(mode==="speed")?6:15;
    let tried=0;
    const maxTry=60;
    const logT=Math.log(T);

    // 对 fwd 中的 base 候选，计算 log_base(T) 作为目标指数
    for(let fc=1;fc<=Math.min(c-wBin("^"),maxC)&&tried<maxTry;fc++){
      const ff=fwd[fc];
      if(!ff) continue;
      for(let i=0;i<Math.min(ff.length,20)&&tried<maxTry;i++){
        if(performance.now()-t0pc>timeCap) return;
        const base=ff[i];
        if(!base||!base.ast) continue;
        const bv=base.v;
        if(!Number.isFinite(bv)||bv<=0||bv>200||Math.abs(bv-1)<1e-12) continue;

        const neededExp=logT/Math.log(bv);
        if(!Number.isFinite(neededExp)||Math.abs(neededExp)>40) continue;

        const exps=jumpLookupNear(neededExp,6);
        for(const exp of exps){
          if(!exp||!exp.ast||tried>=maxTry) continue;
          const tc=(base.cost||fc)+(exp.cost||0)+wBin("^");
          if(tc>maxC) continue;
          const mg=mergeMaskOrCnt(base,exp);
          if(mg==null) continue;

          const ast=mkB("^",base.ast,exp.ast);
          if(LEAF_ORDER&&ast.ord&&!ast.ord.ok) continue;
          const v=evalAStable(ast);
          if(!Number.isFinite(v)||Math.abs(v)>CAP) continue;
          tried++;
          if(Math.abs(v-T)>Math.abs(T)*0.01) continue;

          if(useBitmask) pushBest({v,ast,mask:mg,cost:tc,searchType:"meet"});
          else pushBest({v,ast,cnt:mg||EMPTY,cost:tc,searchType:"meet"});
        }

        // 也搜: T = c * base^exp
        for(const at of consts.slice(0,5)){
          const cv=Number(at.v);
          if(!Number.isFinite(cv)||Math.abs(cv)<1e-14||Math.abs(cv-1)<1e-12) continue;
          const tv=T/cv;
          if(tv<=0) continue;
          const ne2=Math.log(tv)/Math.log(bv);
          if(!Number.isFinite(ne2)||Math.abs(ne2)>40) continue;
          const exps2=jumpLookupNear(ne2,4);
          for(const exp2 of exps2){
            if(!exp2||!exp2.ast||tried>=maxTry) continue;
            const cAst=getConstNodeByValue(cv);
            const tc2=(base.cost||fc)+(exp2.cost||0)+wBin("^")+wBin("*")+1;
            if(tc2>maxC) continue;
            const inner=mkB("^",base.ast,exp2.ast);
            const ast2=mkB("*",cAst,inner);
            const v2=evalAStable(ast2);
            if(!Number.isFinite(v2)||Math.abs(v2)>CAP) continue;
            tried++;
            if(Math.abs(v2-T)>Math.abs(T)*0.005) continue;
            if(useBitmask) pushBest({v:v2,ast:ast2,mask:(base.mask||0)|(exp2.mask||0),cost:tc2,searchType:"meet"});
            else pushBest({v:v2,ast:ast2,cnt:EMPTY,cost:tc2,searchType:"meet"});
          }
        }
      }
    }
  }


  function buildRev(c){
    if(!bidir)return;
    const{bucket,put}=mkBucket(beamR,mp.spillMul);
    for(const op of opsUn){
      const w=wUn(op),sc=c-w;
      if(sc<0||!rev[sc]||!rev[sc].length)continue;
      const src=rev[sc];
      const lim2=Math.min(src.length,beamR);
      for(let i=0;i<lim2;i++){
        const a=src[i];
        if(pruneEquiv&&pruneUn(op,a.flags,a.v)){pruned++;continue;}
        const invs=invUn(op,a.v);
        for(const inv of invs){
          visited++;
          const v=inv.v;
          if(!Number.isFinite(v)||Math.abs(v)>CAP)continue;
          const out=applyUn(op,v);
          const s=Math.max(1,Math.abs(a.v),Math.abs(out));
          if(!Number.isFinite(out)||Math.abs(out-a.v)>1e-10*s){meetDbg.revInvBad++;continue;}
          const nf=mkFlags(v,opTag(op),false);
          const pW=a.wA;
          const nW=pW?(fa=>pW(mkU(op,fa))):(fa=>mkU(op,fa));
          const score=revScore(v);
          const mk = meetPrimaryKey(v);
          const cand = useBitmask
            ? {v,wA:nW,mask:a.mask,flags:nf,keep:score,goal:score,bb:score,cost:c,srcOp:op,mkey:mk}
            : {v,wA:nW,cnt:a.cnt,ck:(a.ck||""),flags:nf,keep:score,goal:score,bb:score,cost:c,srcOp:op,mkey:mk};

          put(keyOf(v,useBitmask?cand.mask:0,useBitmask?"":cand.ck),cand);
          // *** Critical fix: trigger immediate meet for ALL unary ops, not just inv/sqrt ***
          // This allows the rev layer to participate in meet as soon as any op produces it
          tryMeetReverseWithFwdIdx(cand);
          if(stopFlag) return;

          // For periodic trig ops: also try ±1 period so fwd values offset by 2π/π can meet
          // This is crucial for cos(tan(e)) + additive compositions
          if((op==="sin"||op==="cos")&&Math.abs(v)<CAP){
            const twopi=2*Math.PI;
            for(const dk of[-1,1]){
              const v2=v+dk*twopi;
              if(!Number.isFinite(v2)||Math.abs(v2)>CAP)continue;
              const out2=applyUn(op,v2);
              const s2=Math.max(1,Math.abs(a.v),Math.abs(out2));
              if(!Number.isFinite(out2)||Math.abs(out2-a.v)>1e-10*s2)continue;
              const nf2=mkFlags(v2,opTag(op),false);
              const mk2=meetPrimaryKey(v2);
              const cand2=useBitmask
                ?{v:v2,wA:nW,mask:a.mask,flags:nf2,keep:revScore(v2),goal:revScore(v2),bb:revScore(v2),cost:c,srcOp:op,mkey:mk2}
                :{v:v2,wA:nW,cnt:a.cnt,ck:(a.ck||""),flags:nf2,keep:revScore(v2),goal:revScore(v2),bb:revScore(v2),cost:c,srcOp:op,mkey:mk2};
              put(keyOf(v2,useBitmask?cand2.mask:0,useBitmask?"":cand2.ck),cand2);
              tryMeetReverseWithFwdIdx(cand2);
              if(stopFlag)return;
            }
          }
          if(op==="tan"&&Math.abs(v)<CAP){
            const pi=Math.PI;
            for(const dk of[-1,1]){
              const v2=v+dk*pi;
              if(!Number.isFinite(v2)||Math.abs(v2)>CAP)continue;
              const out2=applyUn(op,v2);
              const s2=Math.max(1,Math.abs(a.v),Math.abs(out2));
              if(!Number.isFinite(out2)||Math.abs(out2-a.v)>1e-10*s2)continue;
              const nf2=mkFlags(v2,opTag(op),false);
              const mk2=meetPrimaryKey(v2);
              const cand2=useBitmask
                ?{v:v2,wA:nW,mask:a.mask,flags:nf2,keep:revScore(v2),goal:revScore(v2),bb:revScore(v2),cost:c,srcOp:op,mkey:mk2}
                :{v:v2,wA:nW,cnt:a.cnt,ck:(a.ck||""),flags:nf2,keep:revScore(v2),goal:revScore(v2),bb:revScore(v2),cost:c,srcOp:op,mkey:mk2};
              put(keyOf(v2,useBitmask?cand2.mask:0,useBitmask?"":cand2.ck),cand2);
              tryMeetReverseWithFwdIdx(cand2);
              if(stopFlag)return;
            }
          }
        }
      }
    }

    const sBin=opsBin.slice(); // include custom binary too
    for(const op of sBin){
      const w=wBin(op);
      for(let rc=0;rc<=c-w-1;rc++){
        const fc=c-w-rc;
        const rs=rev[rc],fs=fwd[fc];
        if(!rs||!fs||!rs.length||!fs.length)continue;

        const base=Math.floor(Math.sqrt(beamR));
        const isPow = (op==="^");
        // adaptive lane caps: keep broad exploration, but avoid quadratic blow-up
        // when index pressure is already high (observed in long accuracy runs).
        const pressureLane = (strategyStats.pressureScore>=1) ? 0.78 : 1.0;
        const laneMul=(isPow?2.0:1.2)*pressureLane;
        const laneMin=Math.max(isPow?64:32, Math.floor(base*(isPow?0.42:0.28)));
        const laneMax=Math.max(laneMin, Math.floor(base*(isPow?2.0:1.35)));
        const cR=Math.min(rs.length,laneMax,Math.max(laneMin,Math.floor(base*laneMul)));
        const cF=Math.min(fs.length,laneMax,Math.max(laneMin,Math.floor(base*laneMul)));

        for(let ir=0;ir<cR;ir++){
          const r=rs[ir];
          for(let jf=0;jf<cF;jf++){
            const f=fs[jf];visited++;

            // Pre-filter: skip inverse when operands are extreme
            const rAbs=Math.abs(r.v), fAbs=Math.abs(f.v);
            if(rAbs>1e8 && fAbs>1e8) continue;
            if(op==="^" && (fAbs<1e-12 || fAbs>50 || rAbs>1e6)) continue;
            if(op==="/" && fAbs<1e-14) continue;

            const x1=invBinR(op,r.v,f.v);
            if(Number.isFinite(x1)&&Math.abs(x1)<=CAP){
              const out1=applyBin(op,f.v,x1);
              const s1=Math.max(1,Math.abs(r.v),Math.abs(out1));
              if(!Number.isFinite(out1)||Math.abs(out1-r.v)>1e-10*s1){meetDbg.revInvBad++;}
              else if(useBitmask){
                const m=combMask(f.mask,r.mask);
                if(m>=0){
                  const pW=r.wA,fA=f.ast;
                  const nW=pW?(fa=>pW(mkB(op,fA,fa))):(fa=>mkB(op,fA,fa));
                  const score=revScore(x1)*(isPow?0.40:1.0);
                  const mk = meetPrimaryKey(x1);
                  const cand={v:x1,wA:nW,mask:m,flags:mkFlags(x1,TAG_NONE,false,extraBinFlags(r.flags,f.flags)),keep:score,goal:score,bb:score,cost:c,srcOp:op,mkey:mk};
                  put(keyOf(x1,m,""),cand);
                  if(isPow) tryMeetReverseWithFwdIdx(cand);
                  if(stopFlag) return;
                }
              }else{
                const cnt=addCnt(f.cnt??EMPTY,r.cnt??EMPTY);
                if(cnt){
                  const ck=ckFromCnt(cnt);
                  const pW=r.wA,fA=f.ast;
                  const nW=pW?(fa=>pW(mkB(op,fA,fa))):(fa=>mkB(op,fA,fa));
                  const score=revScore(x1)*(isPow?0.40:1.0);
                  const mk = meetPrimaryKey(x1);
                  const cand={v:x1,wA:nW,cnt,ck,flags:mkFlags(x1,TAG_NONE,false,extraBinFlags(r.flags,f.flags)),keep:score,goal:score,bb:score,cost:c,srcOp:op,mkey:mk};
                  put(keyOf(x1,0,ck),cand);
                  if(isPow) tryMeetReverseWithFwdIdx(cand);
                  if(stopFlag) return;
                }
              }
            }

            if(!isComm(op)){
              const x2=invBinL(op,r.v,f.v);
              if(Number.isFinite(x2)&&Math.abs(x2)<=CAP){
                const out2=applyBin(op,x2,f.v);
                const s2=Math.max(1,Math.abs(r.v),Math.abs(out2));
                if(!Number.isFinite(out2)||Math.abs(out2-r.v)>1e-10*s2){meetDbg.revInvBad++;}
                else if(useBitmask){
                  const m=combMask(f.mask,r.mask);
                  if(m>=0){
                    const pW=r.wA,fA=f.ast;
                    const nW=pW?(fa=>pW(mkB(op,fa,fA))):(fa=>mkB(op,fa,fA));
                    const score=revScore(x2)*(isPow?0.40:1.0);
                    const mk = meetPrimaryKey(x2);
                    const cand={v:x2,wA:nW,mask:m,flags:mkFlags(x2,TAG_NONE,false,extraBinFlags(r.flags,f.flags)),keep:score,goal:score,bb:score,cost:c,srcOp:op,mkey:mk};
                    put(keyOf(x2,m,""),cand);
                    if(isPow) tryMeetReverseWithFwdIdx(cand);
                    if(stopFlag) return;
                  }
                }else{
                  const cnt=addCnt(f.cnt??EMPTY,r.cnt??EMPTY);
                  if(cnt){
                    const ck=ckFromCnt(cnt);
                    const pW=r.wA,fA=f.ast;
                    const nW=pW?(fa=>pW(mkB(op,fa,fA))):(fa=>mkB(op,fa,fA));
                    const score=revScore(x2)*(isPow?0.40:1.0);
                    const mk = meetPrimaryKey(x2);
                    const cand={v:x2,wA:nW,cnt,ck,flags:mkFlags(x2,TAG_NONE,false,extraBinFlags(r.flags,f.flags)),keep:score,goal:score,bb:score,cost:c,srcOp:op,mkey:mk};
                    put(keyOf(x2,0,ck),cand);
                    if(isPow) tryMeetReverseWithFwdIdx(cand);
                    if(stopFlag) return;
                  }
                }
              }
            }

            if(stopFlag) return;
          }
        }
      }
    }

    const items=Array.from(bucket.values());
    items.sort((a,b)=>a.keep-b.keep);
    const picked=items.slice(0,beamR);
    for(const it of picked){it.cost=c;it.__sc=undefined;it.revHit=undefined;it.cov=undefined;}
    rev[c]=picked;
    addRevIdx(rev[c]);
    // Free cached mkeys after indexing - saves ~6 strings per item
    for(const it of rev[c]){if(it.mkeys)it.mkeys=null;}
  }

  function meetSweepWithNewReverseLayer(rc){
    if(!bidir)return;
    const rr=rev[rc];
    if(!rr||!rr.length)return;

    let powCnt=0;
    const rProbe=Math.min(rr.length,80);
    for(let i=0;i<rProbe;i++) if(rr[i].srcOp==="^") powCnt++;
    const powFrac = rProbe? (powCnt/rProbe) : 0;

    const sweepMul = (powFrac>0.10) ? (mp.meetSweepPowMul||mp.meetSweepMul) : (mp.meetSweepMul||0.1);
    const perLayerCap=Math.max(32,Math.floor(beamF*sweepMul));

    const rLim=Math.min(rr.length,Math.max(12,mp.meetSweepRevCap|0||160));
    const maxFc=Math.min(maxC-rc,rc);
    if(maxFc<1||rLim<1)return;

    const localIdx=new Map();
    const localKeyCap=Math.max(2,Math.min(10,(mp.idxKeysPerItem|0)||6));
    for(let j=0;j<rLim;j++){
      const r=rr[j];
      const pk=r.mkey || (r.mkey = meetPrimaryKey(r.v));
      let arr=localIdx.get(pk);
      if(!arr){arr=[];localIdx.set(pk,arr);} 
      arr.push(r);

      const ks=meetKeysCached(r);
      let used=0;
      for(let ki=0;ki<ks.length&&used<localKeyCap;ki++){
        const k2=ks[ki];
        if(k2===pk) continue;
        let arr2=localIdx.get(k2);
        if(!arr2){arr2=[];localIdx.set(k2,arr2);} 
        arr2.push(r);
        used++;
      }
    }

    const skipTransformSweep = !!(mp.speedRevMeetPrimaryOnly);
    for(let fc=1;fc<=maxFc;fc++){
      const ff=fwd[fc];
      if(!ff||!ff.length)continue;
      const lim2=Math.min(ff.length,perLayerCap);
      for(let i=0;i<lim2;i++){
        const f=ff[i];
        const keys = meetKeysCached(f, skipTransformSweep);
        meetLookups+=keys.length;
        let seen=null;
        if(keys.length>1)seen=new Set();
        let seenRLocal=null;
        for(const k2 of keys){
          if(seen){if(seen.has(k2))continue;seen.add(k2);}
          const rl=localIdx.get(k2);
          if(!rl)continue;
          meetDbg.keyHits++;
          const seenR = seenRLocal || (seenRLocal=new Set());
          for(let j=0;j<rl.length;j++){
            const rrj=rl[j];
            if(seenR.has(rrj)) continue;
            seenR.add(rrj);
            meetDbg.pairsTried++;
            tryMeetPair(f,rrj);
            if(stopFlag) return;
          }
        }
      }
    }

    // 深层联系: meetSweep只覆盖fc=1..maxFc, 但maxFc=min(maxC-rc,rc)
    // 当rc较大时，fc > rc 的层也可以配对（只要fc+rc <= maxC）
    // 标准sweep因为maxFc被rc限制而错过这些配对
    // 补充扫描: fc∈(maxFc, maxC-rc]范围内的层，充分利用所有fwd层数据
    if(strategyStats.stagnationLayers>=1){
      const extraFcEnd=Math.min(maxC-rc, fwd.length-1);
      const extraFcStart=maxFc+1;
      if(extraFcStart<=extraFcEnd){
        const extraPerLayer=Math.max(8,Math.floor(perLayerCap*0.40));
        for(let fc=extraFcStart;fc<=extraFcEnd;fc++){
          const ff=fwd[fc];
          if(!ff||!ff.length)continue;
          const lim2=Math.min(ff.length,extraPerLayer);
          for(let i=0;i<lim2;i++){
            const f=ff[i];
            const pkey=f.mkey || (f.mkey = meetPrimaryKey(f.v));
            const rl=localIdx.get(pkey);
            if(!rl)continue;
            meetDbg.keyHits++;
            const seenR=new Set();
            for(let j=0;j<rl.length;j++){
              const rrj=rl[j];
              if(seenR.has(rrj)) continue;
              seenR.add(rrj);
              meetDbg.pairsTried++;
              tryMeetPair(f,rrj);
              if(stopFlag) return;
            }
          }
        }
      }
    }
  }

  // MT pool (custom ops supported)
  let subWorkers=[];
  async function initSubWorkers(){
    if(!(mt&&threads>1))return;
    if(!subSrc)return;
    const url=URL.createObjectURL(new Blob([subSrc],{type:"text/javascript"}));
    subWorkers=Array.from({length:threads-1},()=>new Worker(url));

    const initMsg={
      type:"init",keyPrec:KEYP,useBitmask,noConstraintFast,tCount,
      maxT:useBitmask?null:(maxT?Array.from(maxT):null),
      opsUn,opsBin,pruneEquiv,needZero:NEED_ZERO,needOne:NEED_ONE,
      hasNeg:HAS_NEG,hasSub:HAS_SUB,hasDiv:HAS_DIV,hasMul:HAS_MUL,
      reqMask:REQ_MASK, reqPop:REQ_POP,
      leafOrder:LEAF_ORDER,
      pruneLevel:PRUNE_LEVEL,
      forbidUn:Array.from(FORBID_UN),
      forbidBin:Array.from(FORBID_BIN),
      constraintUnSrc:CONSTRAINT_UN_SRC,
      constraintBinSrc:CONSTRAINT_BIN_SRC,
      customUnary, customBinary
    };

    await Promise.all(subWorkers.map(w=>new Promise((resolve)=>{
      const h=(ev)=>{if(ev.data?.type==="inited"){w.removeEventListener("message",h);resolve();}};
      w.addEventListener("message",h);
      w.postMessage(initMsg);
    })));
    sendLayerToSubs(1);
  }
  function termSubWorkers(){for(const w of subWorkers)w.terminate();subWorkers=[];}

  function packLayer(cost){
    const src=fwd[cost];
    const lim2=Math.min(src.length,subLayerCap);
    const v=new Float64Array(lim2);
    const flags=new Int32Array(lim2);
    const ordHas = LEAF_ORDER ? new Uint8Array(lim2) : null;
    const ordOk  = LEAF_ORDER ? new Uint8Array(lim2) : null;
    const ordMin = LEAF_ORDER ? new Int32Array(lim2) : null;
    const ordMax = LEAF_ORDER ? new Int32Array(lim2) : null;

    if(useBitmask){
      const mask=new Int32Array(lim2);
      for(let i=0;i<lim2;i++){
        const it=src[i];
        v[i]=it.v;mask[i]=it.mask|0;flags[i]=it.flags|0;
        if(LEAF_ORDER){
          const o=it.ast?.ord;
          ordHas[i]=o?.has?1:0;
          ordOk[i]=o?.ok?1:0;
          ordMin[i]=o?.mn|0;
          ordMax[i]=o?.mx|0;
        }
      }
      const layer={len:lim2,v,mask,flags};
      if(LEAF_ORDER){ layer.ordHas=ordHas; layer.ordOk=ordOk; layer.ordMin=ordMin; layer.ordMax=ordMax; }
      return layer;
    }else{
      if(noConstraintFast){
        for(let i=0;i<lim2;i++){
          const it=src[i];
          v[i]=it.v;flags[i]=it.flags|0;
          if(LEAF_ORDER){
            const o=it.ast?.ord;
            ordHas[i]=o?.has?1:0; ordOk[i]=o?.ok?1:0; ordMin[i]=o?.mn|0; ordMax[i]=o?.mx|0;
          }
        }
        const layer={len:lim2,v,flags};
        if(LEAF_ORDER){ layer.ordHas=ordHas; layer.ordOk=ordOk; layer.ordMin=ordMin; layer.ordMax=ordMax; }
        return layer;
      }
      const cnt=new Uint16Array(lim2*tCount);
      for(let i=0;i<lim2;i++){
        const it=src[i];
        v[i]=it.v;flags[i]=it.flags|0;
        const base=i*tCount;
        const cvec=it.cnt;
        for(let j=0;j<tCount;j++)cnt[base+j]=cvec[j];
        if(LEAF_ORDER){
          const o=it.ast?.ord;
          ordHas[i]=o?.has?1:0; ordOk[i]=o?.ok?1:0; ordMin[i]=o?.mn|0; ordMax[i]=o?.mx|0;
        }
      }
      const layer={len:lim2,v,cnt,flags};
      if(LEAF_ORDER){ layer.ordHas=ordHas; layer.ordOk=ordOk; layer.ordMin=ordMin; layer.ordMax=ordMax; }
      return layer;
    }
  }
  function sendLayerToSubs(cost){
    if(subWorkers.length===0)return;
    const layer=packLayer(cost);
    for(const w of subWorkers){w.postMessage({type:"setLayer",cost,layer});}
  }

  async function computeLayerMT(c,capUn,capBin){
    const{bucket,put}=mkBucket(beamF,mp.spillMul);
    const estLoad=(capUn*opsUn.length)+(capBin*opsBin.length);
    const opDensity=Math.max(1,(opsUn.length*1.4+opsBin.length));
    const loadUnit=Math.max(3000,Math.floor((mode==="speed"?6200:7000)/Math.sqrt(opDensity/8)));
    const activeSub=Math.min(subWorkers.length, Math.max(1, Math.ceil(estLoad/loadUnit)));
    const workersUse=activeSub>0?subWorkers.slice(0,activeSub):[];
    const W=workersUse.length+1;
    const allowPow=Array.isArray(opsBin)&&opsBin.includes("^");

    // main-thread stripe 0 (simple)
    for(const op of opsUn){
      const w=wUn(op),sc=c-w;
      if(sc<1)continue;
      const src=fwd[sc];if(!src||!src.length)continue;
      const lim2=Math.min(src.length,capUn);
      for(let i=0;i<lim2;i+=W){
        const a=src[i];
        if(pruneEquiv&&pruneUn(op,a.flags,a.v)){pruned++;continue;}
        const v=applyUn(op,a.v);visited++;
        if(!Number.isFinite(v)||Math.abs(v)>CAP)continue;
        const goal=Math.abs(v-T);
        if(goal>pruneGoalThresh)continue;
        const bb=bbScore(v,mp.bbD,mp.bbMagA);
        const mk = bidir ? meetPrimaryKey(v) : "";
        const revHit=bidir?revIdx.has(mk):false;
        const ast=mkU(op,a.ast);
        if(LEAF_ORDER && ast.ord && !ast.ord.ok) continue;

        if(useBitmask){
          const keep=keepScore(goal,bb,revHit,a.mask,v);
          put(keyOf(v,a.mask,""),{v,goal,bb,keep,ast,mask:a.mask,flags:mkFlags(v,opTag(op),false,extraUnFlags(op,a.flags)),mkey:mk});
        }else{
          const keep=(mp.keepMode==="goal")?goal:Math.min(goal,bb);
          put(keyOf(v,0,a.ck),{v,goal,bb,keep,ast,cnt:a.cnt,ck:a.ck,flags:mkFlags(v,opTag(op),false,extraUnFlags(op,a.flags)),mkey:mk});
        }
      }
    }

    for(const op of opsBin){
      const w=wBin(op),rem=c-w;
      if(rem<2)continue;
      const comm=isComm(op);
      const icMax = comm ? Math.floor(rem/2) : (rem-1);
      for(let ic=1;ic<=icMax;ic++){
        const jc=rem-ic;
        const A=fwd[ic],B=fwd[jc];
        if(!A.length||!B.length)continue;
        const cA=Math.min(A.length,capBin),cB=Math.min(B.length,capBin);
        for(let ia=0;ia<cA;ia+=W){
          const a=A[ia];
          const stB=(comm&&ic===jc)?ia:0;
          for(let ib=stB;ib<cB;ib++){
            const b=B[ib];
            if(pruneEquiv&&pruneBin(op,a.flags,b.flags,a.v,b.v)){pruned++;continue;}
            visited++;
            if(useBitmask){
              if((a.mask&b.mask)!==0)continue;
              const mask=a.mask|b.mask;
              const v=applyBin(op,a.v,b.v);
              if(!Number.isFinite(v)||Math.abs(v)>CAP)continue;
              const goal=Math.abs(v-T);
              // PERF: fast pre-filter before expensive mkB/bbScore
              if(goal>pruneGoalThresh)continue;
              const bb=bbScore(v,mp.bbD,mp.bbMagA);
              const mk = bidir ? meetPrimaryKey(v) : "";
              const revHit=bidir?revIdx.has(mk):false;
              const keep=keepScore(goal,bb,revHit,mask,v);
              // PERF: skip if bucket full and this item is definitely worse
              if(bucket.isFull() && keep>=bucket.worstKeep() && !revHit) continue;
              const ast=mkB(op,a.ast,b.ast);
              if(LEAF_ORDER && ast.ord && !ast.ord.ok) continue;
              put(keyOf(v,mask,""),{v,goal,bb,keep,ast,mask,flags:mkFlags(v,opTag(op),false,extraBinFlags(a.flags,b.flags)),mkey:mk});
            }else{
              const cnt=addCnt(a.cnt??EMPTY,b.cnt??EMPTY);
              if(!cnt)continue;
              const v=applyBin(op,a.v,b.v);
              if(!Number.isFinite(v)||Math.abs(v)>CAP)continue;
              if(Math.abs(v-T)>pruneGoalThresh)continue;
              const ast=mkB(op,a.ast,b.ast);
              if(LEAF_ORDER && ast.ord && !ast.ord.ok) continue;
              const goal=Math.abs(v-T);
              const bb=bbScore(v,mp.bbD,mp.bbMagA);
              const mk = bidir ? meetPrimaryKey(v) : "";
              const revHit=bidir?revIdx.has(mk):false;
              const keep=(mp.keepMode==="goal")?goal:Math.min(goal,bb);
              const ck=ckFromCnt(cnt);
              put(keyOf(v,0,ck),{v,goal,bb,keep,ast,cnt,ck,flags:mkFlags(v,opTag(op),false,extraBinFlags(a.flags,b.flags)),mkey:mk});
            }
          }
        }
      }
    }

    const tasks=workersUse.map((w,idx)=>new Promise((resolve)=>{
      const workerId=idx+1;
      const h=(ev)=>{if(ev.data?.type==="taskDone"){w.removeEventListener("message",h);resolve(ev.data.payload);}};
      w.addEventListener("message",h);
      w.postMessage({
        type:"task",T,c,beam:beamF,
        capUn,capBin,
        workerId,workerCount:W,
        bbD:mp.bbD,bbMagA:mp.bbMagA,
        keepMode: mp.keepMode==="goal" ? "goal" : "min"
      });
    }));
    const results=await Promise.all(tasks);

    for(const res of results){
      visited+=res.visited;
      pruned+=res.pruned;
      for(const it of res.items){
        const v=it.v;
        const mk = bidir ? meetPrimaryKey(v) : "";
        const revHit=bidir?revIdx.has(mk):false;

        if(useBitmask){
          const key=keyOf(v,it.mask,"");
          if(it.kind==="u"){
            const a=fwd[it.ac][it.ai];
            const ast=mkU(it.op,a.ast);
            if(LEAF_ORDER && ast.ord && !ast.ord.ok) continue;
            const keep=keepScore(it.goal,it.bb,revHit,it.mask,v);
            put(key,{v,goal:it.goal,bb:it.bb,keep,ast,mask:it.mask|0,flags:mkFlags(v,opTag(it.op),false,extraUnFlags(it.op,a.flags)),mkey:mk});
          }else{
            const a=fwd[it.ac][it.ai],b=fwd[it.bc][it.bi];
            const ast=mkB(it.op,a.ast,b.ast);
            if(LEAF_ORDER && ast.ord && !ast.ord.ok) continue;
            const keep=keepScore(it.goal,it.bb,revHit,it.mask,v);
            put(key,{v,goal:it.goal,bb:it.bb,keep,ast,mask:it.mask|0,flags:mkFlags(v,opTag(it.op),false,extraBinFlags(a.flags,b.flags)),mkey:mk});
          }
        }else{
          const ck=it.ck||"";
          const key=keyOf(v,0,ck);
          const cnt=(tCount?cntFromCk(ck):EMPTY);
          const keep=(mp.keepMode==="goal")?it.goal:Math.min(it.goal,it.bb);
          if(it.kind==="u"){
            const a=fwd[it.ac][it.ai];
            const ast=mkU(it.op,a.ast);
            if(LEAF_ORDER && ast.ord && !ast.ord.ok) continue;
            put(key,{v,goal:it.goal,bb:it.bb,keep,ast,cnt,ck,flags:mkFlags(v,opTag(it.op),false,extraUnFlags(it.op,a.flags)),mkey:mk});
          }else{
            const a=fwd[it.ac][it.ai],b=fwd[it.bc][it.bi];
            const ast=mkB(it.op,a.ast,b.ast);
            if(LEAF_ORDER && ast.ord && !ast.ord.ok) continue;
            put(key,{v,goal:it.goal,bb:it.bb,keep,ast,cnt,ck,flags:mkFlags(v,opTag(it.op),false,extraBinFlags(a.flags,b.flags)),mkey:mk});
          }
        }
      }
    }

    const items=Array.from(bucket.values());
    for(const it of items){it.hasPow=!!(it.ast&&it.ast.p);it.hasFunc=!!(it.ast&&it.ast.f);it.depth=astDepth(it.ast);}
    const picked=selectTop(items,beamF,divRatio,mp,(bidir?revIdx:null),allowPow,useBitmask,mode,T);
    for(const it of picked){
      it.cost=c;
      // Strip transient fields not needed for future expansion
      it.hasPow=undefined; it.hasFunc=undefined; it.depth=undefined;
      it.__sc=undefined; it.revHit=undefined; it.cov=undefined;
    }
    return picked;
  }

  await initSubWorkers();

  // Dynamic goal threshold: skip items much worse than best found so far
  // Updated each complexity level; starts at Infinity
  // pruneGoalThresh: start at 2×|T| scale. Values within this range OR with low bb (rational)
  // are kept. Updated each layer. See tFloor logic below that prevents it going too tight.
  let pruneGoalThresh=Infinity; // Start with no goal pruning; tighten after first solutions found
  let stagnationLayers=0;
  let prevLayerBest=Infinity;
  let prevVisited=0, prevMeetCand=0, prevMeetOK=0, prevProbeRej=0, prevConfirmRej=0;
  for(let c=2;c<=maxC;c++){
    if(stopFlag)break;
    if(performance.now()-t0>lim)break;

    phaseTiming.totalLayers++;
    const _t0Rev=performance.now();
    if(bidir){
      buildRev(c);
      phaseTiming.buildRev+=performance.now()-_t0Rev;
      if(stopFlag)break;
      const _t0Sweep=performance.now();
      meetSweepWithNewReverseLayer(c);
      phaseTiming.meetSweep+=performance.now()-_t0Sweep;
      if(stopFlag)break;
    } else {
      phaseTiming.buildRev+=performance.now()-_t0Rev;
    }

    const bestNow=Math.max(1e-18,Math.abs(bestDeltaSoFar));
    if(bestNow < prevLayerBest*0.995) stagnationLayers=0; else stagnationLayers=Math.min(10,stagnationLayers+1);
    prevLayerBest=Math.min(prevLayerBest,bestNow);

    const dVisited=Math.max(1,visited-prevVisited);
    const dMeetCand=Math.max(0,meetCandidates-prevMeetCand);
    const dMeetOK=Math.max(0,meetConfirmed-prevMeetOK);
    const dProbeRej=Math.max(0,meetDbg.rejProbeConfirm-prevProbeRej);
    const meetYield=dMeetOK/Math.max(1,dMeetCand);
    const probeRejRate=dProbeRej/Math.max(1,dMeetCand);
    // ▼▼▼ 新增：confirm 拒绝率 — 反映候选质量
    const dConfirmRej=Math.max(0,(meetDbg.rejConfirm||0)-prevConfirmRej);
    const confirmRejRate=dConfirmRej/Math.max(1,dMeetCand);
    prevConfirmRej=meetDbg.rejConfirm||0;
    // ▲▲▲
    const pressureScore=(stagnationLayers>=1?1:0) + (meetYield<0.016?1:0) + (probeRejRate>0.50?1:0) + (dVisited>110000 && dMeetOK<3?1:0)
      // ▼ 额外压力：confirm 拒绝率极高说明候选质量太低，触发 boost
      + (confirmRejRate>0.70?1:0);
    strategyStats.stagnationLayers=stagnationLayers;
    strategyStats.pressureScore=pressureScore;

    const forcedBoost=(c%2===0 && pressureScore>=2) || (c%4===0 && meetYield<0.010);
    if(forcedBoost) strategyStats.forcedBoost++;

    const explorePressure=1+Math.min(2.6, pressureScore*0.42 + (forcedBoost?0.70:0));
    const stagnationBoost=(1+Math.min(1.9,stagnationLayers*0.22))*explorePressure;
    {
      const totalCand=Math.max(1,meetCandidates);
      const rejRate=(meetDbg.rejConfirm||0)/totalCand;
      if(rejRate>0.85&&totalCand>200){
        // 高拒绝率：候选太差，收紧而非放松
        dynamicCandMul=Math.max(0.35,1.0-Math.min(0.55,(rejRate-0.85)*6));
        dynamicConfirmMul=Math.max(0.45,1.0-Math.min(0.45,(rejRate-0.85)*5));
      } else if(stagnationLayers>=2&&rejRate<0.40&&(meetDbg.maxConfirmErr||0)<5e5){
        // 低拒绝率+停滞：可以放松
        dynamicCandMul=1+Math.min(0.8,stagnationLayers*0.08+pressureScore*0.14+(forcedBoost?0.20:0));
        dynamicConfirmMul=1+Math.min(1.5,stagnationLayers*0.12+pressureScore*0.25+(forcedBoost?0.35:0));
      } else {
        dynamicCandMul=1+Math.min(0.35,stagnationLayers*0.03+pressureScore*0.05);
        dynamicConfirmMul=1+Math.min(0.55,stagnationLayers*0.04+pressureScore*0.08);
        if((meetDbg.maxConfirmErr||0)>1e7){
          dynamicCandMul=Math.min(dynamicCandMul,0.78);
          dynamicConfirmMul=Math.min(dynamicConfirmMul,0.85);
        }
      }
    }

    let capUn=Math.max(180,Math.floor(beamF*(mp.capUnMul||2.0)/4/constPenalty*stagnationBoost));
    let capBin=Math.max(120,Math.floor(beamF*(mp.capBinMul||1.8)/6/constPenalty*stagnationBoost));
    capUn=Math.max(50,Math.floor(capUn*mp.capMul));
    capBin=Math.max(45,Math.floor(capBin*mp.capMul));
    if(stagnationLayers>0 || strategyStats.pressureScore>0) strategyStats.adaptiveBoosts++;

    if(subWorkers.length>0){
      fwd[c]=await computeLayerMT(c,capUn,capBin);
    }else{
      const{bucket,put}=mkBucket(beamF,mp.spillMul);
      const allowPow=Array.isArray(opsBin)&&opsBin.includes("^");

      for(const op of opsUn){
        const w=wUn(op),sc=c-w;
        if(sc<1)continue;
        const src=fwd[sc];if(!src||!src.length)continue;
        const lim2=Math.min(src.length,capUn);
        for(let i=0;i<lim2;i++){
          const a=src[i];
          if(pruneEquiv&&pruneUn(op,a.flags,a.v)){pruned++;continue;}
          const v=applyUn(op,a.v);visited++;
          if(!Number.isFinite(v)||Math.abs(v)>CAP)continue;
          const goal=Math.abs(v-T);
          if(goal>pruneGoalThresh)continue;
          const bb=bbScore(v,mp.bbD,mp.bbMagA);
          const mk = bidir ? meetPrimaryKey(v) : "";
          const revHit=bidir?revIdx.has(mk):false;

          if(useBitmask){
            const keep=keepScore(goal,bb,revHit,a.mask,v);
            // PERF: skip AST creation if bucket full and item is definitely worse
            if(bucket.isFull() && keep>=bucket.worstKeep() && !revHit) continue;
            const ast=mkU(op,a.ast);
            if(LEAF_ORDER && ast.ord && !ast.ord.ok) continue;
            put(keyOf(v,a.mask,""),{v,goal,bb,keep,ast,mask:a.mask,flags:mkFlags(v,opTag(op),false,extraUnFlags(op,a.flags)),mkey:mk});
          }else{
            const rBonus=(bb<0.08&&goal>0.001)?0.04*bb:0;
            const keep=(mp.keepMode==="goal")?(goal-rBonus):Math.min(goal,bb)-rBonus;
            if(bucket.isFull() && keep>=bucket.worstKeep() && !revHit) continue;
            const ast=mkU(op,a.ast);
            if(LEAF_ORDER && ast.ord && !ast.ord.ok) continue;
            put(keyOf(v,0,a.ck),{v,goal,bb,keep,ast,cnt:a.cnt,ck:a.ck,flags:mkFlags(v,opTag(op),false,extraUnFlags(op,a.flags)),mkey:mk});
          }

          if((visited&8191)===0)emit(c);
          if(stopFlag||performance.now()-t0>lim)break;
        }
      }

      for(const op of opsBin){
        const w=wBin(op),rem=c-w;
        if(rem<2)continue;
        const comm=isComm(op);
        const icMax = comm ? Math.floor(rem/2) : (rem-1);
        for(let ic=1;ic<=icMax;ic++){
          const jc=rem-ic;
          const A=fwd[ic],B=fwd[jc];
          if(!A.length||!B.length)continue;
          const cA=Math.min(A.length,capBin),cB=Math.min(B.length,capBin);
          for(let ia=0;ia<cA;ia++){
            const a=A[ia];
            const stB=(comm&&ic===jc)?ia:0;
            for(let ib=stB;ib<cB;ib++){
              const b=B[ib];
              if(pruneEquiv&&pruneBin(op,a.flags,b.flags,a.v,b.v)){pruned++;continue;}
              visited++;

              if(useBitmask){
                if((a.mask&b.mask)!==0)continue;
                const mask=a.mask|b.mask;
                const v=applyBin(op,a.v,b.v);
                if(!Number.isFinite(v)||Math.abs(v)>CAP)continue;
                if(Math.abs(v-T)>pruneGoalThresh)continue;
                const ast=mkB(op,a.ast,b.ast);
                if(LEAF_ORDER && ast.ord && !ast.ord.ok) continue;
                const goal=Math.abs(v-T);
                const bb=bbScore(v,mp.bbD,mp.bbMagA);
                const mk = bidir ? meetPrimaryKey(v) : "";
                const revHit=bidir?revIdx.has(mk):false;
                const keep=keepScore(goal,bb,revHit,mask,v);
                put(keyOf(v,mask,""),{v,goal,bb,keep,ast,mask,flags:mkFlags(v,opTag(op),false,extraBinFlags(a.flags,b.flags)),mkey:mk});
              }else{
                const cnt=addCnt(a.cnt??EMPTY,b.cnt??EMPTY);
                if(!cnt)continue;
                const v=applyBin(op,a.v,b.v);
                if(!Number.isFinite(v)||Math.abs(v)>CAP)continue;
                if(Math.abs(v-T)>pruneGoalThresh)continue;
                const ast=mkB(op,a.ast,b.ast);
                if(LEAF_ORDER && ast.ord && !ast.ord.ok) continue;
                const goal=Math.abs(v-T);
                const bb=bbScore(v,mp.bbD,mp.bbMagA);
                const mk = bidir ? meetPrimaryKey(v) : "";
                const revHit=bidir?revIdx.has(mk):false;
                const keep=(mp.keepMode==="goal")?goal:Math.min(goal,bb);
                const ck=ckFromCnt(cnt);
                put(keyOf(v,0,ck),{v,goal,bb,keep,ast,cnt,ck,flags:mkFlags(v,opTag(op),false,extraBinFlags(a.flags,b.flags)),mkey:mk});
              }

              if((visited&8191)===0)emit(c);
              if(stopFlag||performance.now()-t0>lim)break;
            }
            if(stopFlag||performance.now()-t0>lim)break;
          }
          if(stopFlag||performance.now()-t0>lim)break;
        }
      }

      const _t0ST=performance.now();
      const items=Array.from(bucket.values());
      for(const it of items){it.hasPow=!!(it.ast&&it.ast.p);it.hasFunc=!!(it.ast&&it.ast.f);it.depth=astDepth(it.ast);}
      const picked=selectTop(items,beamF,divRatio,mp,(bidir?revIdx:null),allowPow,useBitmask,mode,T);
      phaseTiming.selectTop+=performance.now()-_t0ST;
      for(const it of picked){it.cost=c;}
      fwd[c]=picked;
    }

    sendLayerToSubs(c);

    addFwdIdx(fwd[c]);
    // Free cached mkeys after indexing
    for(const it of fwd[c]){if(it.mkeys)it.mkeys=null;}
    const _t0Dec=performance.now();
    tryTargetDecomposition(fwd[c], T, c);
    if(c%2===0||stagnationLayers>=2) deepStructureProbe(c);
    if(c%3===0||strategyStats.pressureScore>=2) powerChainProbe(c);

    // ═══ 新增顿悟/启发/联结/跳跃探针 ═══
    // 【联结】横向梁代数扫描: c>=4时每2层, 或停滞时每层
    if(c>=4 && !stopFlag && (c%2===0 || stagnationLayers>=2)) crossBeamAlgebraicScan(c);
    // 【启发】常数关联启发: c>=5时每3层, 精度模式每2层
    if(c>=5 && !stopFlag && (c%3===0 || (mode==="accuracy"&&c%2===0))) heuristicConstantRelationSearch(c);
    // 【跳跃】强化深层嵌套（L3+L4）: c>=7时每2层
    if(c>=7 && !stopFlag && (c%2===1 || stagnationLayers>=3)) advancedDeepNestingProbe(c);
    phaseTiming.decompose+=performance.now()-_t0Dec;
    if((mode==="speed"?stagnationLayers>=4:stagnationLayers>=3) || strategyStats.pressureScore>=3){
      const doExtraDecomp = strategyStats.pressureScore>=4 || (mode!=="speed"&&c%3===0) || (mode==="speed"&&c%4===0&&strategyStats.pressureScore>=3);
      if(doExtraDecomp){
        const prev=fwd[Math.max(1,c-1)]||[];
        if(prev.length){
          const cap=Math.max(6,Math.min(Math.floor(beamF*0.03),Math.floor(prev.length*0.10)));
          tryTargetDecomposition(prev.slice(0,cap), T, Math.max(1,c-1));
          strategyStats.extraDecomp++;
        }
      }
    }

    const _t0MeetFwd=performance.now();

    // ▼▼▼ 智能直连发现 (Smart Direct-Connect Discovery)
    // 与其让每个fwd项探针revIdx（O(fwdItems × keysPerItem × probeLen)），
    // 不如反向：对rev[1..c-1]中的高质量项，直接计算它需要什么fwd值，用主键一次命中。
    // 这是O(revItems × 1) vs 原来的O(fwdItems × 15 × probeLen)。
    // Speed模式: 只在c>=4时启用(rev层已有足够候选), 时间预算严格
    if(bidir && mode==="speed" && c>=4 && !stopFlag){
      const directTimeCap = 8; // ms预算
      const directStart = performance.now();
      const directMaxRev = Math.min(80, beamR);
      for(let rc=0; rc<=Math.min(c-1, maxC); rc++){
        if(performance.now()-directStart > directTimeCap) break;
        const rr2 = rev[rc]; if(!rr2||!rr2.length) continue;
        const needed = c-rc; // fwd层cost必须为needed
        const ff2 = fwd[needed]; if(!ff2||!ff2.length) continue;
        const rLim = Math.min(rr2.length, directMaxRev);
        for(let ri=0;ri<rLim;ri++){
          if(performance.now()-directStart > directTimeCap) break;
          const r2 = rr2[ri];
          // 对每个rev项，直接查fwd中是否有值接近r2.v的候选
          const pkey2 = r2.mkey || (r2.mkey = meetPrimaryKey(r2.v));
          const fl2 = fwdIdx.get(pkey2);
          if(!fl2) continue;
          const lim3 = Math.min(fl2.length, 12);
          for(let fi=0;fi<lim3;fi++){
            const f2 = fl2[fi];
            // 必须cost匹配
            if(!f2 || (f2.cost||0)!==needed) continue;
            meetDbg.pairsTried++;
            meetDbg.rev2fwdPairs++;
            tryMeetPair(f2, r2);
            if(stopFlag) break;
          }
          if(stopFlag) break;
        }
        if(stopFlag) break;
      }
    }
    // ▲▲▲ 结束智能直连发现

    // ▼▼▼ meetFwd 自适应采样：只对「最接近T的top-K」+「已在revIdx中命中的」项目做meet
    // 原来对全部 beamF=6800 项做 tryMeetFwdWithRevIdx，占总时间85%
    // 现在通过采样将 meet 候选削减至约 40%+revHit，大幅降低时间
    {
      const sampleRatio = mp.meetFwdSampleRatio != null ? mp.meetFwdSampleRatio : 0.50;
      const meetFwdCap = Math.max(96, Math.floor(beamF * sampleRatio));
      for(const e of fwd[c]){
        pushBest({v:e.v,ast:e.ast,mask:e.mask,cnt:e.cnt,cost:e.cost,searchType:"fwd"});
        if(stopFlag)break;
      }
      if(bidir && !stopFlag){
        const sorted = fwd[c].slice().sort((a,b)=>(a.goal||0)-(b.goal||0));
        const meetSet = new Set();
        const sampleRatio2 = mp.meetFwdSampleRatio != null ? mp.meetFwdSampleRatio : 0.50;
        const meetFwdCap2 = Math.max(88, Math.floor(beamF * sampleRatio2));
        const topK3 = Math.min(sorted.length, meetFwdCap2);
        for(let i=0;i<topK3;i++) meetSet.add(sorted[i]);

        for(const e of fwd[c]){
          if(!meetSet.has(e)){
            const mk2 = e.mkey || (e.mkey = meetPrimaryKey(e.v));
            if(revIdx.has(mk2)){
              meetSet.add(e);
            } else if(!mp.speedMeetScanPrimaryOnly) {
              // 非speed模式: 检查全部变换域键(代价高但召回率高)
              const ks = meetKeysCached(e);
              for(let ki=1;ki<ks.length;ki++){
                if(revIdx.has(ks[ki])){ meetSet.add(e); break; }
              }
            } else {
              // speed模式: 只检查邻域键(2*MEET_R个), 跳过L/S/Q等变换域
              const ks = meetKeysCached(e, true); // skipTransform=true
              for(let ki=1;ki<ks.length;ki++){
                if(revIdx.has(ks[ki])){ meetSet.add(e); break; }
              }
            }
          }
        }

        if(Number.isFinite(T)){
          const subTargets2=[];
          const absT3=Math.abs(T);
          if(absT3>0){
            subTargets2.push(Math.sqrt(absT3));
            subTargets2.push(-Math.sqrt(absT3));
            subTargets2.push(Math.cbrt(T));
            if(T>0) subTargets2.push(Math.log(T));
            for(const cc of [Math.PI,Math.E,2,3]){
              subTargets2.push(Math.sqrt(absT3)/cc);
              subTargets2.push(T/cc);
            }
          }

          for(const sv of subTargets2){
            if(!Number.isFinite(sv)||Math.abs(sv)>1e8) continue;
            let bestDist=Infinity, bestItem=null;
            const scanLim=Math.min(sorted.length, Math.floor(meetFwdCap2*1.5));
            for(let i=0;i<scanLim;i++){
              const d=Math.abs(sorted[i].v-sv);
              if(d<bestDist){bestDist=d;bestItem=sorted[i];}
            }
            if(bestItem && bestDist<Math.abs(sv)*0.05+0.01){
              meetSet.add(bestItem);
            }
          }
        }

        if(mode==="speed" && meetSet.size>220){
          const trimmed=Array.from(meetSet).sort((a,b)=>(a.goal||0)-(b.goal||0)).slice(0,220);
          meetSet.clear();
          for(const it of trimmed) meetSet.add(it);
        }
        // Speed模式: 整个meetFwd阶段的总对数预算, 防止整层meet时间失控
        const meetFwdTotalBudget = mp.speedMeetMaxPairsPerItem ?
          Math.max(900, (meetSet.size * (mp.speedMeetMaxPairsPerItem|0))) : Infinity;
        let meetFwdTotalPairs = 0;
        // 将meetSet按goal排序(goal小的优先probe, 最可能match)
        const meetSetArr = Array.from(meetSet).sort((a,b)=>(a.goal||0)-(b.goal||0));
        const meetLayerStart=performance.now();
        const meetLayerCap=(mode==="speed"?(mp.speedMeetLayerTimeCapMs||26):Infinity);
        for(const e of meetSetArr){
          if(meetFwdTotalPairs >= meetFwdTotalBudget) break;
          if((performance.now()-meetLayerStart)>meetLayerCap) break;
          const pairsBefore = meetDbg.pairsTried;
          tryMeetFwdWithRevIdx(e);
          meetFwdTotalPairs += (meetDbg.pairsTried - pairsBefore);
          if(stopFlag)break;
        }
      }
    }
    // ▲▲▲ 结束 meetFwd 自适应采样
    phaseTiming.meetFwd+=performance.now()-_t0MeetFwd;

    emit(c);
    // Update goal prune threshold: allow up to relax×best_delta BUT never below T-scale floor.
    // CRITICAL: building blocks like π, e, √2 may be far from T but needed for f^g compositions.
    // Floor = max(|T|, 1) × 0.5 ensures values within T's order of magnitude are ALWAYS kept.
    // FIXED 漏解: floor must preserve ALL leaf constants as building blocks
    // Old: 0.5*|T| would cut pi/e when T=25 after finding solutions near T
    // New: ensure any leaf constant (like pi, e, sqrt2) can always be a subexpression.
    // Also ensure values near √T, ∛T are never pruned (critical for (f(x))^n = T meets).
    const _leafMaxGoal = consts.reduce((m,c)=>Math.max(m,Math.abs(Number(c.v)-T)),0);
    const _sqrtTGoal = Number.isFinite(_sqrtT) ? Math.abs(_sqrtT-T) : 0;
    const _cbrtTGoal = Number.isFinite(_cbrtT) ? Math.abs(_cbrtT-T) : 0;
    const _powerGoal = Math.max(_sqrtTGoal * 1.2, _cbrtTGoal * 1.2);
    const tFloor = Math.max(_leafMaxGoal * 3.0, Math.abs(T) * 2.0, _powerGoal * 1.5, 30);
    if(best.length>0){
      const relax=1+Math.min(8.0,stagnationLayers*0.55 + strategyStats.pressureScore*0.82);
      pruneGoalThresh=Math.max(Math.abs(best[0].delta)*(80*relax)+1e-9, tFloor);
      if(stagnationLayers>0 || strategyStats.pressureScore>0) strategyStats.pruneRelax++;
    } else {
      pruneGoalThresh = Math.max(pruneGoalThresh, tFloor);
    }
    prevVisited=visited; prevMeetCand=meetCandidates; prevMeetOK=meetConfirmed; prevProbeRej=meetDbg.rejProbeConfirm;
    // prevConfirmRej 已在 pressureScore 计算中更新
    await new Promise(r=>setTimeout(r,0));
  }

  termSubWorkers();

  postMessage({type:"done",payload:{
    elapsed:Math.round(performance.now()-t0),maxC,c:maxC,
    visited,pruned,
    meetLookups,meetCandidates,meetConfirmed,
    meetDbg,
    reEvalFixed,dupesKilled,
    mode:runtimeMode,
    mt:(mt&&threads>1)?("ON("+threads+")"):"OFF",
    profile:mode,
    beamF,beamR,
    bestCount:best.length,
    bestDeltaSoFar,
    dynamicCandMul,dynamicConfirmMul,
    strategyStats,phaseTiming,
    best:best.slice(0,outN)
  }});
};
`;
  const url=URL.createObjectURL(new Blob([workerSrc],{type:"text/javascript"}));
  const w=new Worker(url);
  w.__blobUrl=url;
  return w;
}

// ---------- run ----------
let worker=null;
let lastT=24;
let runToken=0;

function killWorkerImmediate(){
  if(worker){
    try{ worker.terminate(); }catch(e){}
    try{ if(worker.__blobUrl) URL.revokeObjectURL(worker.__blobUrl); }catch(e){}
    worker=null;
  }
}

$("btnStart").onclick=()=>{
  const T=parseTarget($("target").value);
  if(!Number.isFinite(T)){alert("目标值无效");return}
  lastT=T;

  const mode=normalizeMode($("mode").value);
  const engineMode=mapUiModeToEngine(mode);
  $("mode").value=mode;

  let bidir=$("bidir").checked;
  if(mode==="normal"||mode==="speed")bidir=true;

  const maxC=Math.max(1,Math.min(200,Number($("maxC").value||30)));
  const beam=Math.max(50,Math.min(50000,Number($("beam").value||4000)));
  const divRatio=Math.max(0,Math.min(1,Number($("divRatio").value||.25)));
  const outN=Math.max(1,Math.min(200,Number($("outN").value||30)));
  const infiniteTime=$("infiniteTime").checked;
  const timeLimit=infiniteTime?0:Math.max(0,Number($("timeLimit").value||0));
  const emitInterval=Math.max(50,Math.min(60000,Number($("emitInterval").value||500)));
  const showCounts=$("showCounts").checked;
  const pruneEquiv=$("pruneEquiv").checked;
  const excludeExact=$("excludeExact").checked;
  const dedupeByValue=$("dedupeByValue")?.checked||false;
  let mt=$("mt").checked;
  const threads=Math.max(1,Math.min(64,Number($("threads").value||1)));
  const latexMode=$("latexMode").checked;
  const customEnable=$("customEnable").checked;
  const customCode=$("customBox").value||"";

  
  
  // 1. 先应用自定义扩展 (原代码位置不变，但要确保这块在 getOps 之前)
  try{
    if(customEnable){
      const scope = safeEvalCustom(customCode);
      const ext = scope.getExtensions ? normalizeExt(scope.getExtensions()) : {constants:[],unaryOps:[],binaryOps:[]};
      const st=collectUIState();
      CONST_LIST = BASE_CONST_LIST.slice();
      OP_LIST = BASE_OP_LIST.slice();
      mergeExtensionsToLists(ext);
      mountConsts(); mountOps();
      applyUIState(st);
    }
  }catch(e){
    alert("自定义扩展加载失败: "+(e?.message||String(e)));
    return;
  }

  // 2. 【关键修改】在扩展加载完毕、UI刷新后，再获取 Ops！
  // 这样 Worker 才能收到用户新增的函数
  tuneOpsByMode(mode);
  const{opsUn,opsBin}=getOps(); 
  if(!opsUn.length&&!opsBin.length){alert("请至少选择一个运算");return}

  let consts;
  try{consts=getConsts()}catch(e){alert(e.message);return}

  try{localStorage.setItem(LS_KEY,JSON.stringify(collectUIState()));}catch(e){}

  runToken++;
  const token=runToken;

  killWorkerImmediate();
  worker=buildWorker();

  $("btnStart").disabled=true;
  $("btnStart").classList.add("running");
  $("btnStop").disabled=false;
  $("pruneStats").style.display="none";
  $("copyMsg").style.display="none";
  updateRuntimePanel({c:0,maxC,elapsed:0,visited:0});
  $("progressCard").classList.add("active");
  $("status").style.display="none";

  worker.onmessage=async(ev)=>{
    if(token!==runToken) return;
    const{type,payload}=ev.data;
    if(type==="error"){
      alert(payload);
      $("btnStart").disabled=false;
      $("btnStop").disabled=true;
      return;
    }
    if(type==="progress"||type==="done"){
      const rows=payload.best||[];
      const ba=rows.length?Math.abs(rows[0].delta):NaN;
      const elapsedMs=Math.max(1,Number(payload.elapsed||0));
      const vps=Math.round((Number(payload.visited||0)*1000)/elapsedMs);
      updateRuntimePanel(payload);
      const debugOn=$("debugMode").checked;
      if(debugOn){
        $("status").style.display="flex";
        statusPills({
          T:fmt(lastT),status:type,profile:mode,mode:payload.mode,
          mt:payload.mt||"OFF",c:(payload.c??0)+"/"+payload.maxC,
          elapsed_ms:payload.elapsed,visited:payload.visited,vps:vps,
          pruned:payload.pruned||0,bestCount:payload.bestCount||rows.length,
          best_delta:Number.isFinite(ba)?fmt(ba):"n/a",
          best_delta_ever:Number.isFinite(payload.bestDeltaSoFar)?fmt(payload.bestDeltaSoFar):"n/a",
          meetLookups:payload.meetLookups||0,meetCand:payload.meetCandidates||0,
          meetOK:payload.meetConfirmed||0,beam:((payload.beamF||0)+"/"+(payload.beamR||0)),
          candMul:fmt(payload.dynamicCandMul||1),cfmMul:fmt(payload.dynamicConfirmMul||1),pressure:payload.strategyStats?.pressureScore??0
        });
        const ps=$("pruneStats");
        ps.style.display="block";
        ps.innerHTML=
          "<b>AST重求值修正：</b>"+(payload.reEvalFixed||0).toLocaleString()+
          " &nbsp;|&nbsp; <b>输出同值合并：</b>"+(payload.dupesKilled||0).toLocaleString()+
          " &nbsp;|&nbsp; <b>吞吐(v/s)：</b>"+vps.toLocaleString();
        if(payload.strategyStats){
          const st=payload.strategyStats;
          ps.innerHTML+=`<br><b>策略统计</b> boost=${st.adaptiveBoosts} forced=${st.forcedBoost} pruneRelax=${st.pruneRelax} jitter=${st.meetJitter} extraDecomp=${st.extraDecomp} stagnation=${st.stagnationLayers} pressure=${st.pressureScore}`;
        }
        if(payload.meetDbg){
          const d=payload.meetDbg;
          ps.innerHTML+=
            "<br><b>MEET Debug</b> "+
            `revIdxKeys=${d.revIdxKeys} revIdxItems=${d.revIdxItems} fwdIdxKeys=${d.fwdIdxKeys} fwdIdxItems=${d.fwdIdxItems}<br>`+
            `keyHits=${d.keyHits} pairsTried=${d.pairsTried} rev2fwdPairs=${d.rev2fwdPairs}<br>`+
            `rej(mask=${d.rejMaskOverlap}, cnt=${d.rejCntLimit}, eps=${d.rejEpsCand}, evalNaN=${d.rejEvalNaN}, probe=${d.rejProbeConfirm}, confirm=${d.rejConfirm}) `+
            `revInvBad=${d.revInvBad} maxConfirmErr=${d.maxConfirmErr}`;
        }
        if(payload.phaseTiming){
          const pt=payload.phaseTiming;
          const total=pt.buildFwd+pt.buildRev+pt.meetSweep+pt.selectTop+pt.decompose+pt.meetFwd;
          ps.innerHTML+=
            `<br><b>⏱ Phase Timing (ms累计)</b> `+
            `buildFwd=${pt.buildFwd.toFixed(0)} `+
            `buildRev=${pt.buildRev.toFixed(0)} `+
            `meetSweep=${pt.meetSweep.toFixed(0)} `+
            `selectTop=${pt.selectTop.toFixed(0)} `+
            `decompose=${pt.decompose.toFixed(0)} `+
            `meetFwd=${pt.meetFwd.toFixed(0)} `+
            `(已分析${pt.totalLayers}层, 总计=${total.toFixed(0)}ms)`;
        }
      }else{
        $("status").style.display="none";
        $("status").innerHTML="";
        $("pruneStats").style.display="none";
      }
      await renderResults(rows,showCounts,debugOn,latexMode);
      if(type==="done"){
        $("btnStart").disabled=false;
        $("btnStart").classList.remove("running");
        $("btnStop").disabled=true;
        $("progressCard").classList.remove("active");
        killWorkerImmediate();
      }
    }
  };

  worker.postMessage({
    type:"start",
    T,mode:engineMode,maxC,beam,divRatio,outN,
    timeLimit,infiniteTime,emitInterval,
    opsUn,opsBin,consts,
    showCounts,bidir,
    pruneEquiv,excludeExact,dedupeByValue,
    mt,threads,
    customEnable,customCode,
    subSrc:SUBWORKER_CODE
  });
};

$("btnStop").onclick=()=>{
  runToken++;
  killWorkerImmediate();
  $("btnStop").disabled=true;
  $("btnStart").disabled=false;
  $("btnStart").classList.remove("running");
  $("progressCard").classList.remove("active");

  const debugOn=$("debugMode").checked;
  if(debugOn){
    $("status").style.display="flex";
    statusPills({status:"stopped", T:fmt(lastT)});
  }
};

// init
mountConsts();
mountOps();

// load saved config first
try{
  const st=JSON.parse(localStorage.getItem(LS_KEY)||"null");
  if(st){
    // if saved custom enabled, apply its extensions before mounting state
    if(st.customEnable && st.customBox){
      try{
        const scope=safeEvalCustom(st.customBox);
        const ext=scope.getExtensions?normalizeExt(scope.getExtensions()):{constants:[],unaryOps:[],binaryOps:[]};
        mergeExtensionsToLists(ext);
        mountConsts(); mountOps();
      }catch(e){}
    }
    applyUIState(st);
  }
}catch(e){}

tuneOpsByMode($("mode").value);
$("timeLimit").disabled=$("infiniteTime").checked;
updateMtHint();
hookAutoSave();
// Animate custom-details open/close
document.querySelectorAll('.custom-details').forEach(function(det){
  var summary=det.querySelector('summary');
  var body=det.querySelector('.custom-details-body');
  // Init already-open details
  if(det.open){body.style.maxHeight='none';body.style.opacity='1';body.style.padding='12px 14px';}
  function doOpen(){
    det.setAttribute('open','');
    body.style.maxHeight=body.scrollHeight+'px';
    body.style.opacity='1';
    body.style.padding='12px 14px';
    setTimeout(function(){body.style.maxHeight='none';},310);
  }
  function doClose(){
    body.style.maxHeight=body.scrollHeight+'px';
    body.style.opacity='1';
    body.style.padding='12px 14px';
    requestAnimationFrame(function(){
      requestAnimationFrame(function(){
        body.style.maxHeight='0';
        body.style.opacity='0';
        body.style.padding='0 14px';
        setTimeout(function(){det.removeAttribute('open');},310);
      });
    });
  }
  summary.addEventListener('click',function(e){
    e.preventDefault();
    if(det.open) doClose(); else doOpen();
  });
});
updateRuntimePanel({c:0,maxC:Number($("maxC").value||0),elapsed:0,visited:0});

document.querySelectorAll("thead th.sortable").forEach((th)=>{
  th.addEventListener("click",()=>{
    const key=th.dataset.sortKey;
    if(!key) return;
    if(sortState.key===key) sortState.dir=(sortState.dir==="asc"?"desc":"asc");
    else { sortState.key=key; sortState.dir="asc"; }
    updateSortHeaders();
    setTypeColumnVisible($("debugMode").checked);
    const frame=++renderFrame;
    th.classList.add("sorting");
    requestAnimationFrame(()=>{
      if(frame!==renderFrame) return;
      renderResults(lastRows,$("showCounts").checked,$("debugMode").checked,$("latexMode").checked,{silentSort:true})
        .finally(()=>th.classList.remove("sorting"));
    });
  });
});
updateSortHeaders();
})();
</script>
</body>
</html>
