<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>RIES Solver</title>
  <style>
    :root{color-scheme:light dark}
    body{
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial,"Noto Sans","PingFang SC","Hiragino Sans GB","Microsoft Yahei",sans-serif;
      margin:18px;
      overflow-x:hidden;
    }
    h1{font-size:16px;margin:0 0 12px}
    .box{
      border:1px solid rgba(127,127,127,.35);
      padding:12px;
      border-radius:10px;
      max-width:100%;
      overflow-x:auto;
      -webkit-overflow-scrolling:touch;
    }
    .row{display:flex;flex-wrap:wrap;gap:10px 12px;align-items:end}
    .row > div{flex:1 1 160px;min-width:0;max-width:100%}
    @media(max-width:560px){ .row > div{flex:1 1 100%} }
    label{display:block;font-size:12px;opacity:.85;margin-bottom:4px}
    input[type="text"],input[type="number"],select,textarea{
      padding:6px 8px;width:100%;max-width:100%;
      box-sizing:border-box;
    }
    input[type="checkbox"]{transform:translateY(1px)}
    button{padding:8px 12px;cursor:pointer}
    button:disabled{opacity:.6;cursor:not-allowed}
    .muted{opacity:.8;font-size:12px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace}
    .status{display:flex;flex-wrap:wrap;gap:10px 12px;margin-top:10px}
    .pill{padding:4px 8px;border:1px solid rgba(127,127,127,.35);border-radius:999px;font-size:12px}
    .split{display:grid;grid-template-columns:1.1fr .9fr;gap:12px}
    @media(max-width:1100px){.split{grid-template-columns:1fr}}
    .split > .box{min-width:0}
    .constWrap{max-height:360px;overflow:auto;border:1px solid rgba(127,127,127,.25);border-radius:10px}
    .constTable{width:100%;border-collapse:collapse;min-width:420px}
    .constTable th,.constTable td{border-bottom:1px solid rgba(127,127,127,.15);padding:6px;font-size:12px}
    .constTable th{position:sticky;top:0;background:color-mix(in srgb,Canvas 92%,transparent);z-index:2}
    .miniInp{width:70px;min-width:70px;padding:4px 6px;box-sizing:border-box}
    .opsGrid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:6px 10px}
    .opsGrid label{display:flex;gap:8px;align-items:center;margin:0;font-size:12px}
    @media(max-width:640px){.opsGrid{grid-template-columns:repeat(2,minmax(0,1fr));}}
    .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .warn{color:#b45309}
    .pruneStats{margin-top:8px;padding:8px 12px;background:rgba(127,127,127,.08);border-radius:8px;font-size:12px}
    .runtimePanel{margin-top:10px;padding:10px;border:1px solid rgba(127,127,127,.25);border-radius:10px}
    .runtimeMeta{display:flex;gap:14px;flex-wrap:wrap;font-size:12px;margin-bottom:8px}
    .runtimeBar{height:10px;background:rgba(127,127,127,.2);border-radius:999px;overflow:hidden}
    .runtimeBarFill{height:100%;width:0%;background:linear-gradient(90deg,#22c55e,#16a34a);transition:width .2s ease}
    .tableWrap{
      margin-top:12px;border:1px solid rgba(127,127,127,.25);
      border-radius:10px;overflow-x:auto;
      -webkit-overflow-scrolling:touch;
      max-width:100%;
    }
    table{
      width:100%;
      border-collapse:collapse;
      min-width:0;
      table-layout:auto;
    }
    th,td{
      border-bottom:1px solid rgba(127,127,127,.25);
      padding:8px 6px;
      vertical-align:top;
      white-space:nowrap;
    }
    th{text-align:left;font-size:12px;opacity:.85}
    td{font-size:13px}
    .right{text-align:right}
    td.expr{
      white-space:normal;
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .countsLine{margin-top:3px;font-size:11px;opacity:.85}
    .tag{display:inline-block;padding:1px 6px;border-radius:4px;font-size:10px}
    .tag-fwd{background:#dbeafe;color:#1e40af}
    .tag-meet{background:#d1fae5;color:#065f46}
    @media(prefers-color-scheme:dark){
      .tag-fwd{background:#1e3a5f;color:#93c5fd}
      .tag-meet{background:#064e3b;color:#6ee7b7}
    }
    .copyBtn{padding:6px 10px;font-size:12px}
    .copyTiny{padding:4px 8px;font-size:12px}
    .noteBox{margin-top:10px;padding:10px;border:1px dashed rgba(127,127,127,.35);border-radius:10px;font-size:12px;line-height:1.35}
    .noteBox code{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;font-size:12px}
  </style>
</head>
<body>
<h1>RIES Solver</h1>

<div class="box">
  <div class="row">
    <div><label>ç›®æ ‡å€¼ T</label><input id="target" type="text" value="24" class="mono"/></div>

    <div>
      <label>æ¨¡å¼</label>
      <select id="mode">
        <option value="normal" selected>æ™®é€šæ¨¡å¼</option>
        <option value="speed">é€Ÿåº¦æ¨¡å¼</option>
        <option value="accuracy">ç²¾åº¦æ¨¡å¼</option>
      </select>
      <div class="muted" style="margin-top:6px;line-height:1.25">
        æ™®é€šæ¨¡å¼ï¼šé»˜è®¤æ¨èï¼Œå…¼é¡¾ååä¸è¦†ç›–ã€‚é€Ÿåº¦æ¨¡å¼ï¼šæ›´æ¿€è¿›ï¼Œä¼˜å…ˆæ€§èƒ½ã€‚ç²¾åº¦æ¨¡å¼ï¼šæ›´å¼ºè°ƒä¿ç•™æ„ä»¶/è¦†ç›–è´¨é‡ï¼ˆå‚è€ƒ RIES çš„â€œä¿ç•™é‡è¦ä¸­é—´å¼â€ç­–ç•¥ï¼‰ã€‚
      </div>
    </div>

    <div><label>æœ€å¤§å¤æ‚åº¦</label><input id="maxC" type="number" value="24" min="1" max="200"/></div>
    <div><label>Beam</label><input id="beam" type="number" value="4000" min="50" max="50000"/></div>
    <div><label>Diversityæ¯”ä¾‹</label><input id="divRatio" type="number" value="0.25" min="0" max="1" step="0.05"/></div>
    <div><label>è¾“å‡ºæ¡æ•°</label><input id="outN" type="number" value="30" min="1" max="200"/></div>
    <div><label>æ›´æ–°é—´éš”ms</label><input id="emitInterval" type="number" value="500" min="50" max="60000"/></div>

    <div>
      <label>æ—¶é—´ä¸Šé™ms</label><input id="timeLimit" type="number" value="12000" min="0" max="600000"/>
      <label style="margin:4px 0 0;display:flex;gap:8px;align-items:center">
        <input id="infiniteTime" type="checkbox"/><span class="muted">æ— é™</span>
      </label>
    </div>

    <div>
      <label>æœç´¢é€‰é¡¹</label>
      <label style="margin:0;display:flex;gap:8px;align-items:center"><input id="bidir" type="checkbox" checked/><span class="muted">åŒå‘æœç´¢ï¼ˆmeetï¼‰</span></label>
      <label style="margin:0;display:flex;gap:8px;align-items:center"><input id="showCounts" type="checkbox" checked/><span class="muted">æ˜¾ç¤ºå¸¸æ•°è®¡æ•°</span></label>
      <label style="margin:0;display:flex;gap:8px;align-items:center"><input id="pruneEquiv" type="checkbox" checked/><span class="muted">æ’ç­‰å¼å‰ªæ</span></label>
      <label style="margin:0;display:flex;gap:8px;align-items:center"><input id="excludeExact" type="checkbox"/><span class="muted">æ’é™¤ exact</span></label>
      <label style="margin:0;display:flex;gap:8px;align-items:center"><input id="debugMode" type="checkbox"/><span class="muted">Debug æ˜¾ç¤ºè¯¦ç»†ç»Ÿè®¡</span></label>
      <label style="margin:0;display:flex;gap:8px;align-items:center"><input id="latexMode" type="checkbox"/><span class="muted">LaTeX æ¨¡å¼ï¼ˆåœ¨çº¿æ¸²æŸ“ï¼‰</span></label>
    </div>

    <div>
      <label>å¤šçº¿ç¨‹</label>
      <label style="margin:0;display:flex;gap:8px;align-items:center"><input id="mt" type="checkbox" checked/><span class="muted">å¯ç”¨</span></label>
      <div style="display:flex;gap:8px;align-items:center;margin-top:6px">
        <input id="threads" type="number" value="6" min="1" max="64" style="max-width:140px"/>
        <span class="muted">çº¿ç¨‹</span>
        <span class="muted warn" id="mtHint"></span>
      </div>
    </div>

    <div class="toolbar">
      <button id="btnResetConstraints" title="æ¸…ç©ºæ‰€æœ‰ min/max çº¦æŸå¹¶æ¢å¤å¸¸æ•°/å‡½æ•°é»˜è®¤å‹¾é€‰">æ¢å¤é»˜è®¤çº¦æŸ</button>
    </div>
  </div>

  <div style="height:10px"></div>

  <div class="split">
    <div class="box">
      <div class="toolbar">
        <div class="muted">å¸¸æ•° + æ¬¡æ•°é™åˆ¶</div>
        <button id="cAll">å…¨é€‰</button>
        <button id="cNone">å…¨ä¸é€‰</button>
      </div>
      <div class="constWrap" style="margin-top:8px">
        <table class="constTable">
          <thead><tr><th style="width:56px">å¯ç”¨</th><th style="width:120px">ç¬¦å·</th><th>æ•°å€¼</th><th style="width:120px">min</th><th style="width:120px">max</th></tr></thead>
          <tbody id="constBody"></tbody>
        </table>
      </div>
    </div>

    <div class="box">
      <div class="toolbar"><div class="muted">è¿ç®— / å‡½æ•°</div><button id="oAll">å…¨é€‰</button><button id="oNone">å…¨ä¸é€‰</button></div>
      <div class="opsGrid" id="opsBox" style="margin-top:8px"></div>
    </div>
  </div>

  <div style="height:10px"></div>

  <div class="box">
    <label style="display:flex;gap:8px;align-items:center;margin:0 0 6px 0">
      <input id="customEnable" type="checkbox"/>
      <span class="muted">è‡ªå®šä¹‰çº¦æŸ / æ‰©å±•ï¼ˆJSï¼Œæ”¯æŒæ–°å¢å¸¸æ•°/å‡½æ•°/é€†å˜æ¢ï¼Œä¸”å°½é‡å‚ä¸å‰ªæã€å¤šçº¿ç¨‹ä¸ä¼˜åŒ–ï¼‰</span>
    </label>
    <div class="toolbar" style="margin-bottom:8px">
      <button id="btnApplyCustom">åº”ç”¨è‡ªå®šä¹‰æ‰©å±•åˆ°UIï¼ˆæ–°å¢å¸¸æ•°/å‡½æ•°ï¼‰</button>
      <span class="muted">æç¤ºï¼šå¯ç”¨åä¼šåœ¨â€œå¸¸æ•°è¡¨/è¿ç®—è¡¨â€é‡Œå‡ºç°ä½ æ–°å¢çš„é¡¹ç›®</span>
    </div>
    <textarea id="customBox" class="mono" style="min-height:160px"></textarea>

<details class="noteBox" style="cursor:pointer">
      <summary style="font-weight:bold;opacity:.9">ğŸ“Œ ç‚¹å‡»æŸ¥çœ‹ï¼šè‡ªå®šä¹‰è„šæœ¬æ•™ç¨‹ä¸ç¤ºä¾‹</summary>
      <div style="margin-top:8px;cursor:auto">
        ä½ å¯ä»¥åœ¨è„šæœ¬é‡Œå®šä¹‰ä»¥ä¸‹å‡½æ•°ï¼ˆéƒ½å¯é€‰ï¼‰ï¼š
        <ul style="margin:6px 0 0 18px;padding:0">
          <li><code>getExtensions()</code>ï¼šè¿”å›æ–°å¢å¸¸æ•°/ä¸€å…ƒ/äºŒå…ƒå‡½æ•°å®šä¹‰ã€‚</li>
          <li><code>getConstraints()</code>ï¼šè¿”å›å‰ªæçº¦æŸï¼ˆå¦‚ <code>leafOrder:"nondecreasing"</code>ï¼‰ã€‚</li>
          <li><code>allowCandidate(ctx)</code>ï¼šæœ€ç»ˆç»“æœè¿‡æ»¤ã€‚</li>
          <li><code>scoreAdjust(ctx)</code>ï¼šç»™ç»“æœè°ƒåˆ†ã€‚</li>
        </ul>
        <div style="margin-top:8px;padding-top:8px;border-top:1px dashed rgba(127,127,127,0.2)">
          <b>ç¤ºä¾‹ï¼š</b>æ–°å¢å¸¸æ•° Ï„=2Ï€ï¼Œæ–°å¢ä¸€å…ƒ <code>sinc(x)=sin(x)/x</code>ï¼š
<pre class="mono" style="white-space:pre-wrap;margin:5px 0 0;font-size:11px;opacity:.85">
function getExtensions(){
  return {
    constants: [ {key:"tau", sym:"Ï„", val:2*Math.PI, on:false} ],
    unaryOps: [
      {key:"sinc", label:"sinc", on:false, weight:4,
       impl:"(x===0?1:Math.sin(x)/x)",
       // å®šä¹‰é€†å˜æ¢è®©åŒå‘æœç´¢ç”Ÿæ•ˆï¼šsinc(x)=r => x=...
       invImpl:"(r)=>[{v:r===0?0:Math.asin(Math.min(1,Math.max(-1,r)))}]" }
    ]
  };
}
function getConstraints(){ return { leafOrder:"nondecreasing" }; }
</pre>
        </div>
      </div>
    </details>

  <div class="runtimePanel" id="runtimePanel">
    <div class="runtimeMeta">
      <span id="rtComplexity">å¤æ‚åº¦ï¼š0/0</span>
      <span id="rtElapsed">æ—¶é—´ï¼š0 ms</span>
      <span id="rtVisited">visitedï¼š0</span>
    </div>
    <div class="runtimeBar"><div class="runtimeBarFill" id="rtBar"></div></div>
  </div>

  <div class="status" id="status" style="display:none"></div>
  <div class="pruneStats" id="pruneStats" style="display:none"></div>
</div>

<!-- Buttons moved here: above results table -->
<div class="toolbar" style="margin-top:12px; justify-content: flex-start; gap: 15px;">
  <button id="btnStart" style="min-width: 100px; background: #22c55e; color: white; font-weight: bold;">å¼€å§‹æœç´¢</button>
  <button id="btnStop" disabled style="min-width: 100px;">åœæ­¢</button>
</div>

<div class="toolbar" style="margin-top:10px; padding-top: 10px; border-top: 1px dashed rgba(127,127,127,0.2)">
  <button class="copyBtn" id="btnCopyAllExpr">å¤åˆ¶å…¨éƒ¨ï¼ˆè¡¨è¾¾å¼ï¼‰</button>
  <button class="copyBtn" id="btnCopyAllTable">å¤åˆ¶å…¨éƒ¨ï¼ˆå«æ•°å€¼ï¼‰</button>
  <span class="muted" id="copyMsg"></span>
</div>

<div class="tableWrap">
  <table>
    <thead>
      <tr>
        <th style="width:6%">type</th>
        <th>expression</th>
        <th style="width:12%">value</th>
        <th style="width:10%">distance</th>
        <th style="width:10%">accuracy</th>
        <th class="right" style="width:4%">C</th>
        <th style="width:2%">copy</th>
      </tr>
    </thead>
    <tbody id="tbody"></tbody>
  </table>
</div>

<script>
(()=>{
const $=id=>document.getElementById(id);

function fmt(x){
  if(!Number.isFinite(x))return String(x);
  if(Object.is(x,-0))x=0;
  const a=Math.abs(x);
  if(a===0)return"0";
  if(a>=1e7||a<1e-6)return x.toExponential(10);
  return x.toPrecision(14).replace(/(\.\d*?[1-9])0+$/,'$1').replace(/\.0+$/,'');
}

// ----------- base constants / ops (UI) -----------
const BASE_CONST_LIST=[
  ...Array.from({length:41},(_,i)=>{const v=i-10;return{key:String(v),sym:String(v),val:v,on:(v>=0&&v<=10)}}),
  {key:"1/2",sym:"1/2",val:.5,on:true},{key:"1/3",sym:"1/3",val:1/3,on:false},{key:"2/3",sym:"2/3",val:2/3,on:false},
  {key:"1/4",sym:"1/4",val:.25,on:false},{key:"3/4",sym:"3/4",val:.75,on:false},
  {key:"1/5",sym:"1/5",val:.2,on:false},{key:"2/5",sym:"2/5",val:.4,on:false},{key:"1/6",sym:"1/6",val:1/6,on:false},
  {key:"pi",sym:"Ï€",val:Math.PI,on:true},{key:"2pi",sym:"2Ï€",val:2*Math.PI,on:false},
  {key:"pi/2",sym:"Ï€/2",val:Math.PI/2,on:false},{key:"pi/3",sym:"Ï€/3",val:Math.PI/3,on:false},{key:"pi/4",sym:"Ï€/4",val:Math.PI/4,on:false},
  {key:"e",sym:"e",val:Math.E,on:true},{key:"phi",sym:"Ï†",val:(1+Math.sqrt(5))/2,on:false},
  {key:"sqrt2",sym:"âˆš2",val:Math.SQRT2,on:true},{key:"sqrt3",sym:"âˆš3",val:Math.sqrt(3),on:false},{key:"sqrt5",sym:"âˆš5",val:Math.sqrt(5),on:false},
  {key:"ln2",sym:"ln(2)",val:Math.LN2,on:false},{key:"ln10",sym:"ln(10)",val:Math.LN10,on:false},
  {key:"gamma",sym:"Î³",val:.5772156649015328606,on:false},
  {key:"catalan",sym:"G(Catalan)",val:.91596559417721901505,on:false},
  {key:"zeta3",sym:"Î¶(3)",val:1.2020569031595942854,on:false},
];

const BASE_OP_LIST=[
  {key:"+",label:"+",kind:"bin",on:true},{key:"-",label:"-",kind:"bin",on:true},
  {key:"*",label:"*",kind:"bin",on:true},{key:"/",label:"/",kind:"bin",on:true},{key:"^",label:"^",kind:"bin",on:true},
  {key:"min",label:"min(a,b)",kind:"bin",on:false},{key:"max",label:"max(a,b)",kind:"bin",on:false},
  {key:"atan2",label:"atan2",kind:"bin",on:false},{key:"hypot",label:"hypot",kind:"bin",on:false},
  {key:"mod",label:"mod",kind:"bin",on:false},{key:"gcd",label:"gcd",kind:"bin",on:false},{key:"lcm",label:"lcm",kind:"bin",on:false},
  {key:"neg",label:"neg(-x)",kind:"un",on:true},{key:"abs",label:"abs",kind:"un",on:true},
  {key:"inv",label:"inv(1/x)",kind:"un",on:false},
  {key:"sqrt",label:"sqrt",kind:"un",on:true},{key:"cbrt",label:"cbrt",kind:"un",on:false},
  {key:"square",label:"square",kind:"un",on:false},{key:"cube",label:"cube",kind:"un",on:false},
  {key:"exp",label:"exp",kind:"un",on:true},{key:"expm1",label:"expm1",kind:"un",on:false},
  {key:"log",label:"log",kind:"un",on:true},{key:"log10",label:"log10",kind:"un",on:false},{key:"log1p",label:"log1p",kind:"un",on:false},
  {key:"sin",label:"sin",kind:"un",on:false},{key:"cos",label:"cos",kind:"un",on:false},{key:"tan",label:"tan",kind:"un",on:false},
  {key:"asin",label:"asin",kind:"un",on:false},{key:"acos",label:"acos",kind:"un",on:false},{key:"atan",label:"atan",kind:"un",on:false},
  {key:"sinh",label:"sinh",kind:"un",on:false},{key:"cosh",label:"cosh",kind:"un",on:false},{key:"tanh",label:"tanh",kind:"un",on:false},
  {key:"floor",label:"floor",kind:"un",on:false},{key:"ceil",label:"ceil",kind:"un",on:false},
  {key:"round",label:"round",kind:"un",on:false},{key:"frac",label:"frac",kind:"un",on:false},{key:"sign",label:"sign",kind:"un",on:false},
  {key:"fact",label:"fact(!)",kind:"un",on:false},{key:"gammafn",label:"Î“(x)",kind:"un",on:false},{key:"erf",label:"erf",kind:"un",on:false},
];

let CONST_LIST = BASE_CONST_LIST.slice();
let OP_LIST = BASE_OP_LIST.slice();

// ----------- custom extension loader -----------
function safeEvalCustom(code){
  const src = String(code||"");
  const fn = new Function('"use strict";\n'+src+'\n;return {'
    +'getExtensions:(typeof getExtensions==="function")?getExtensions:null,'
    +'getConstraints:(typeof getConstraints==="function")?getConstraints:null,'
    +'allowCandidate:(typeof allowCandidate==="function")?allowCandidate:null,'
    +'scoreAdjust:(typeof scoreAdjust==="function")?scoreAdjust:null'
    +'};');
  return fn();
}

function normalizeExt(ext){
  if(!ext||typeof ext!=="object") return {constants:[],unaryOps:[],binaryOps:[]};
  const out={constants:[],unaryOps:[],binaryOps:[]};
  if(Array.isArray(ext.constants)) out.constants = ext.constants.slice();
  if(Array.isArray(ext.unaryOps)) out.unaryOps = ext.unaryOps.slice();
  if(Array.isArray(ext.binaryOps)) out.binaryOps = ext.binaryOps.slice();
  return out;
}

function mergeExtensionsToLists(ext){
  // Avoid key collisions: if collision, last wins but keep stable ordering.
  const cMap=new Map(CONST_LIST.map(c=>[c.key,c]));
  for(const c of (ext.constants||[])){
    if(!c||!c.key) continue;
    const cc={key:String(c.key),sym:String(c.sym??c.key),val:Number(c.val),on:!!c.on, custom:true};
    if(!Number.isFinite(cc.val)) continue;
    cMap.set(cc.key,cc);
  }
  CONST_LIST = Array.from(cMap.values());

  const oMap=new Map(OP_LIST.map(o=>[o.key,o]));
  for(const u of (ext.unaryOps||[])){
    if(!u||!u.key) continue;
    oMap.set(String(u.key), {key:String(u.key), label:String(u.label??u.key), kind:"un", on:!!u.on, custom:true});
  }
  for(const b of (ext.binaryOps||[])){
    if(!b||!b.key) continue;
    oMap.set(String(b.key), {key:String(b.key), label:String(b.label??b.key), kind:"bin", on:!!b.on, custom:true});
  }
  OP_LIST = Array.from(oMap.values());
}

// ----------- UI mount -----------
function mountConsts(){
  const tb=$("constBody");tb.innerHTML="";
  for(const c of CONST_LIST){
    const tr=document.createElement("tr");
    const t1=document.createElement("td"),ch=document.createElement("input");
    ch.type="checkbox";ch.className="cstOn";ch.dataset.key=c.key;ch.checked=!!c.on;t1.appendChild(ch);
    const t2=document.createElement("td");t2.className="mono";t2.textContent=c.sym;
    const t3=document.createElement("td");t3.className="mono";t3.textContent=fmt(c.val);
    const t4=document.createElement("td"),i1=document.createElement("input");
    i1.type="text";i1.placeholder="0";i1.className="miniInp cstMin mono";i1.dataset.key=c.key;t4.appendChild(i1);
    const t5=document.createElement("td"),i2=document.createElement("input");
    i2.type="text";i2.placeholder="âˆ";i2.className="miniInp cstMax mono";i2.dataset.key=c.key;t5.appendChild(i2);
    tr.append(t1,t2,t3,t4,t5);tb.appendChild(tr);
  }
}
function mountOps(){
  const b=$("opsBox");b.innerHTML="";
  for(const o of OP_LIST){
    const l=document.createElement("label"),ch=document.createElement("input");
    ch.type="checkbox";ch.className="opOn";ch.dataset.key=o.key;ch.checked=!!o.on;
    const s=document.createElement("span");s.textContent=o.label;
    l.append(ch,s);b.appendChild(l);
  }
}
function setAll(cls,v){document.querySelectorAll("."+cls).forEach(x=>x.checked=v);}
$("cAll").onclick=()=>setAll("cstOn",true);
$("cNone").onclick=()=>setAll("cstOn",false);
$("oAll").onclick=()=>setAll("opOn",true);
$("oNone").onclick=()=>setAll("opOn",false);

function resetConstraintsToDefault(){
  // reset lists back to base (custom extensions removed)
  CONST_LIST = BASE_CONST_LIST.slice();
  OP_LIST = BASE_OP_LIST.slice();
  mountConsts();
  mountOps();

  // constants: restore default enable + clear min/max
  for(const c of CONST_LIST){
    const key=c.key;
    const ch=document.querySelector('.cstOn[data-key="'+CSS.escape(key)+'"]');
    const mn=document.querySelector('.cstMin[data-key="'+CSS.escape(key)+'"]');
    const mx=document.querySelector('.cstMax[data-key="'+CSS.escape(key)+'"]');
    if(ch) ch.checked=!!c.on;
    if(mn) mn.value="";
    if(mx) mx.value="";
  }
  // ops: restore default enable
  for(const o of OP_LIST){
    const ch=document.querySelector('.opOn[data-key="'+CSS.escape(o.key)+'"]');
    if(ch) ch.checked=!!o.on;
  }
  scheduleSave();
}
$("btnResetConstraints").onclick=()=>{ resetConstraintsToDefault(); };

$("btnApplyCustom").onclick=()=>{
  try{
    CONST_LIST = BASE_CONST_LIST.slice();
    OP_LIST = BASE_OP_LIST.slice();
    if($("customEnable").checked){
      const scope = safeEvalCustom($("customBox").value);
      const ext = scope.getExtensions ? normalizeExt(scope.getExtensions()) : {constants:[],unaryOps:[],binaryOps:[]};
      mergeExtensionsToLists(ext);
    }
    const st = collectUIState(); // keep selections if possible
    mountConsts(); mountOps();
    applyUIState(st);
    scheduleSave();
  }catch(e){
    alert("åº”ç”¨è‡ªå®šä¹‰æ‰©å±•å¤±è´¥: "+(e?.message||String(e)));
  }
};

function statusPills(o){
  const el=$("status");el.innerHTML="";
  for(const [k,v] of Object.entries(o)){
    const d=document.createElement("div");
    d.className="pill mono";
    d.textContent=`${k}: ${v}`;
    el.appendChild(d);
  }
}

function updateRuntimePanel(payload){
  const c=Math.max(0, Number(payload?.c||0));
  const maxC=Math.max(1, Number(payload?.maxC||1));
  const elapsed=Math.max(0, Number(payload?.elapsed||0));
  const visited=Math.max(0, Number(payload?.visited||0));
  const pct=Math.max(0, Math.min(100, (c/maxC)*100));
  $("rtComplexity").textContent=`å¤æ‚åº¦ï¼š${c}/${maxC}`;
  $("rtElapsed").textContent=`æ—¶é—´ï¼š${Math.round(elapsed)} ms`;
  $("rtVisited").textContent=`visitedï¼š${visited.toLocaleString()}`;
  $("rtBar").style.width=`${pct.toFixed(1)}%`;
}

// ---------- LaTeX render (MathJax) ----------
let latexScriptLoading=null;
async function ensureLatexRenderer(){
  if(window.MathJax?.typesetPromise) return true;
  if(!navigator.onLine) return false;
  if(latexScriptLoading) return latexScriptLoading;

  window.MathJax = window.MathJax || {
    tex: { inlineMath: [['\\(','\\)']] },
    svg: { fontCache: 'global' },
    options: { renderActions: { addMenu: [] } }
  };

  latexScriptLoading = new Promise((resolve)=>{
    const sc=document.createElement('script');
    sc.src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js';
    sc.async=true;
    sc.onload=()=>resolve(!!window.MathJax?.typesetPromise);
    sc.onerror=()=>resolve(false);
    document.head.appendChild(sc);
  });
  return latexScriptLoading;
}

function parseTarget(s){
  s=String(s).trim();
  if(s==="pi"||s==="Ï€")return Math.PI;
  if(s==="e")return Math.E;
  if(s==="phi"||s==="Ï†")return(1+Math.sqrt(5))/2;
  if(s==="sqrt2"||s==="âˆš2")return Math.SQRT2;
  if(s==="sqrt3"||s==="âˆš3")return Math.sqrt(3);
  if(s==="sqrt5"||s==="âˆš5")return Math.sqrt(5);
  return Number(s);
}
function parseNNI(r,ie=false){
  const t=String(r??"").trim();
  if(t==="")return{ok:true,val:ie?Infinity:0};
  if(!/^[0-9]+$/.test(t))return{ok:false,err:t};
  return{ok:true,val:Number(t)};
}
function getOps(){
  const en=new Set([...document.querySelectorAll(".opOn")].filter(x=>x.checked).map(x=>x.dataset.key));
  return{
    opsUn:OP_LIST.filter(o=>o.kind==="un"&&en.has(o.key)).map(o=>o.key),
    opsBin:OP_LIST.filter(o=>o.kind==="bin"&&en.has(o.key)).map(o=>o.key),
  };
}

function normalizeMode(mode){
  if(mode==="balanced"||mode==="meet") return "normal";
  if(mode==="free"||mode==="meetfast") return "speed";
  if(mode==="ries") return "accuracy";
  if(mode==="normal"||mode==="speed"||mode==="accuracy") return mode;
  return "normal";
}
function tuneOpsByMode(mode){ normalizeMode(mode); }

function getConsts(){
  const en=new Set([...document.querySelectorAll(".cstOn")].filter(x=>x.checked).map(x=>x.dataset.key));
  const mnM=new Map([...document.querySelectorAll(".cstMin")].map(x=>[x.dataset.key,x.value]));
  const mxM=new Map([...document.querySelectorAll(".cstMax")].map(x=>[x.dataset.key,x.value]));
  const out=[];
  for(const c of CONST_LIST){
    if(!en.has(c.key))continue;
    const mnP=parseNNI(mnM.get(c.key),false);if(!mnP.ok)throw new Error(c.sym+" min");
    const mxP=parseNNI(mxM.get(c.key),true); if(!mxP.ok)throw new Error(c.sym+" max");
    const mn=Math.floor(mnP.val),mx=mxP.val===Infinity?65535:Math.floor(mxP.val);
    if(mn>mx)throw new Error(c.sym+" min>max");
    out.push({key:c.key,s:c.sym,v:c.val,min:mn,max:mx});
  }
  if(!out.length)throw new Error("è¯·è‡³å°‘å¯ç”¨ä¸€ä¸ªå¸¸æ•°");
  return out;
}

async function copyText(text){
  text=String(text??"");
  const setMsg=(s)=>{ $("copyMsg").textContent=s; setTimeout(()=>{$("copyMsg").textContent="";}, 1200); };
  try{
    if(navigator.clipboard && navigator.clipboard.writeText){
      await navigator.clipboard.writeText(text);
      setMsg("å·²å¤åˆ¶"); return true;
    }
  }catch(e){}
  try{
    const ta=document.createElement("textarea");
    ta.value=text; ta.style.position="fixed"; ta.style.left="-9999px"; ta.style.top="0";
    document.body.appendChild(ta); ta.focus(); ta.select();
    const ok=document.execCommand("copy"); document.body.removeChild(ta);
    if(ok){ setMsg("å·²å¤åˆ¶"); return true; }
  }catch(e){}
  try{ window.prompt("å¤åˆ¶ä»¥ä¸‹æ–‡æœ¬ï¼š", text); setMsg("å·²æ‰“å¼€å¤åˆ¶æ¡†"); return false;
  }catch(e){ setMsg("å¤åˆ¶å¤±è´¥"); return false; }
}

let lastRows=[];
$("btnCopyAllExpr").onclick=()=>{ if(!lastRows.length)return; copyText(lastRows.map(r=>r.expr).join("\n")); };
$("btnCopyAllTable").onclick=()=>{
  if(!lastRows.length)return;
  const lines=lastRows.map(r=>{
    const d=(r.delta>=0?"+":"")+fmt(r.delta);
    return `${r.expr}\t= ${fmt(r.v)}\tÎ” ${d}\tC ${r.cost}\t${r.acc}`;
  });
  copyText(lines.join("\n"));
};

async function renderResults(rows,showCounts,debugOn=false,latexMode=false){
  lastRows=rows||[];
  const tb=$("tbody");tb.innerHTML="";
  const frag=document.createDocumentFragment();
  const useLatex = latexMode && await ensureLatexRenderer();
  for(const r of rows){
    const tr=document.createElement("tr");
    const t1=document.createElement("td");
    const tg=document.createElement("span");
    const tp=r.searchType||"fwd";
    if(debugOn){
      tg.className="tag "+(tp==="meet"?"tag-meet":"tag-fwd");
      tg.textContent=tp;
      t1.appendChild(tg);
    }
    const t2=document.createElement("td");
    t2.className="mono expr";
    t2.textContent=r.expr;

    if(useLatex && r.latex){
      const lx=document.createElement("div");
      lx.className="countsLine";
      lx.textContent=`\\(${r.latex}\\)`;
      t2.appendChild(lx);
    }

    if(showCounts && r.countsInfo){
      const d=document.createElement("div");
      d.className="mono countsLine";
      d.textContent=r.countsInfo;
      t2.appendChild(d);
    }
    const t3=document.createElement("td");t3.className="mono";t3.textContent=fmt(r.v);
    const t4=document.createElement("td");t4.className="mono";t4.textContent=(r.delta>=0?"+":"")+fmt(r.delta);
    const t5=document.createElement("td");t5.className="mono";t5.textContent=r.acc;
    const t6=document.createElement("td");t6.className="mono right";t6.textContent=String(r.cost);
    const t7=document.createElement("td");
    const b=document.createElement("button");
    b.className="copyTiny"; b.textContent="å¤åˆ¶"; b.onclick=()=>copyText(r.expr);
    t7.appendChild(b);
    tr.append(t1,t2,t3,t4,t5,t6,t7);
    frag.appendChild(tr);
  }
  tb.appendChild(frag);
  if(useLatex && window.MathJax?.typesetPromise){
    try{ await window.MathJax.typesetPromise([tb]); }catch(e){}
  }
}

// ---------- localStorage ----------
const LS_KEY="ries_solver_cfg_v10";
function collectUIState(){
  const ops={};
  document.querySelectorAll(".opOn").forEach(ch=>{ops[ch.dataset.key]=!!ch.checked;});
  const consts={};
  document.querySelectorAll(".cstOn").forEach(ch=>{
    const key=ch.dataset.key;
    const mn=document.querySelector('.cstMin[data-key="'+CSS.escape(key)+'"]')?.value ?? "";
    const mx=document.querySelector('.cstMax[data-key="'+CSS.escape(key)+'"]')?.value ?? "";
    consts[key]={on:!!ch.checked,min:mn,max:mx};
  });
  return {
    target:$("target").value, mode:$("mode").value,
    maxC:$("maxC").value, beam:$("beam").value,
    divRatio:$("divRatio").value, outN:$("outN").value,
    emitInterval:$("emitInterval").value, timeLimit:$("timeLimit").value,
    infiniteTime:$("infiniteTime").checked, bidir:$("bidir").checked,
    showCounts:$("showCounts").checked, pruneEquiv:$("pruneEquiv").checked,
    excludeExact:$("excludeExact").checked, debugMode:$("debugMode").checked,
    latexMode:$("latexMode").checked, customEnable:$("customEnable").checked,
    customBox:$("customBox").value, mt:$("mt").checked, threads:$("threads").value,
    ops,consts
  };
}
function applyUIState(st){
  if(!st||typeof st!=="object")return;
  if(st.target!=null)$("target").value=st.target;
  if(st.mode!=null)$("mode").value=normalizeMode(st.mode);
  if(st.maxC!=null)$("maxC").value=st.maxC;
  if(st.beam!=null)$("beam").value=st.beam;
  if(st.divRatio!=null)$("divRatio").value=st.divRatio;
  if(st.outN!=null)$("outN").value=st.outN;
  if(st.emitInterval!=null)$("emitInterval").value=st.emitInterval;
  if(st.timeLimit!=null)$("timeLimit").value=st.timeLimit;
  if(st.infiniteTime!=null)$("infiniteTime").checked=!!st.infiniteTime;
  if(st.bidir!=null)$("bidir").checked=!!st.bidir;
  if(st.showCounts!=null)$("showCounts").checked=!!st.showCounts;
  if(st.pruneEquiv!=null)$("pruneEquiv").checked=!!st.pruneEquiv;
  if(st.excludeExact!=null)$("excludeExact").checked=!!st.excludeExact;
  if(st.debugMode!=null)$("debugMode").checked=!!st.debugMode;
  if(st.latexMode!=null)$("latexMode").checked=!!st.latexMode;
  if(st.customEnable!=null)$("customEnable").checked=!!st.customEnable;
  if(st.customBox!=null)$("customBox").value=String(st.customBox);
  if(st.mt!=null)$("mt").checked=!!st.mt;
  if(st.threads!=null)$("threads").value=st.threads;
  if(st.ops){
    document.querySelectorAll(".opOn").forEach(ch=>{
      const k=ch.dataset.key;
      if(k in st.ops) ch.checked=!!st.ops[k];
    });
  }
  if(st.consts){
    document.querySelectorAll(".cstOn").forEach(ch=>{
      const k=ch.dataset.key;
      if(st.consts[k]){
        ch.checked=!!st.consts[k].on;
        const mn=document.querySelector('.cstMin[data-key="'+CSS.escape(k)+'"]');
        const mx=document.querySelector('.cstMax[data-key="'+CSS.escape(k)+'"]');
        if(mn) mn.value=st.consts[k].min ?? "";
        if(mx) mx.value=st.consts[k].max ?? "";
      }
    });
  }
  tuneOpsByMode($("mode").value);
}
let saveTimer=null;
function scheduleSave(){
  if(saveTimer)clearTimeout(saveTimer);
  saveTimer=setTimeout(()=>{
    try{localStorage.setItem(LS_KEY, JSON.stringify(collectUIState()));}catch(e){}
  },250);
}
function hookAutoSave(){
  const ids=["target","mode","maxC","beam","divRatio","outN","emitInterval","timeLimit","infiniteTime","bidir","showCounts","pruneEquiv","excludeExact","debugMode","latexMode","customEnable","customBox","mt","threads"];
  ids.forEach(id=>{
    const el=$(id);
    el.addEventListener("input",scheduleSave);
    el.addEventListener("change",scheduleSave);
  });
  document.addEventListener("input",(e)=>{
    if(e.target?.classList?.contains("cstOn")||e.target?.classList?.contains("cstMin")||e.target?.classList?.contains("cstMax")||e.target?.classList?.contains("opOn")){
      scheduleSave();
    }
  });
}

function updateMtHint(){
  const hc=navigator.hardwareConcurrency||4;
  $("threads").max=String(Math.max(1,Math.min(64,hc)));
  $("mtHint").textContent=$("mt").checked?("å»ºè®®â‰¤"+$("threads").max):"";
}
$("mt").addEventListener("change",()=>{updateMtHint();scheduleSave();});
$("threads").addEventListener("input",()=>{updateMtHint();scheduleSave();});
$("mode").addEventListener("change",()=>{
  const mode=normalizeMode($("mode").value);
  $("mode").value=mode;
  tuneOpsByMode(mode);
  if(["normal","speed","accuracy"].includes(mode)) $("bidir").checked=true;
  scheduleSave();
});
$("infiniteTime").addEventListener("change",()=>{$("timeLimit").disabled=$("infiniteTime").checked;scheduleSave();});

// ================= SubWorker code (supports reqMask + custom ops + leafOrder pruning) =================
const SUBWORKER_CODE = `
let stopFlag=false;
const CAP=1e12;

let KEYP=12;
let USE_BITMASK=true;
let NO_CONSTRAINT_FAST=false;
let TCOUNT=0;
let MAXT=null;
let OPS_UN=[], OPS_BIN=[];
let PRUNE=true;
let NEED_ZERO=false, NEED_ONE=false;
let HAS_NEG=true, HAS_DIV=true, HAS_MUL=true, HAS_SUB=true;

// bitmask-coverage retention (fix "bitmaskæ¼è§£" due to beam fragmentation)
let REQ_MASK=0, REQ_POP=0;
function popcnt32(x){
  x = x - ((x >>> 1) & 0x55555555);
  x = (x & 0x33333333) + ((x >>> 2) & 0x33333333);
  return (((x + (x >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24;
}
function reqAdj(mask){
  if(!REQ_MASK) return 1.0;
  const cov = popcnt32((mask|0) & REQ_MASK);
  return 1.0 / (1.0 + 0.35 * cov);
}

// leafOrder constraint
let LEAF_ORDER=""; // "nondecreasing" or ""
function ordLeaf(sym){
  if(!LEAF_ORDER) return {has:0, ok:1, mn:0, mx:0};
  if(/^-?\\d+$/.test(sym)){
    const v=Number(sym);
    if(Number.isFinite(v)){
      return {has:1, ok:1, mn:v, mx:v};
    }
  }
  return {has:0, ok:1, mn:0, mx:0};
}
function ordUn(st){ return st; }
function ordBin(a,b){
  if(!LEAF_ORDER) return {has:0, ok:1, mn:0, mx:0};
  if(!a.ok || !b.ok) return {has:(a.has|b.has), ok:0, mn:0, mx:0};
  if(a.has && b.has){
    if(a.mx > b.mn) return {has:1, ok:0, mn:0, mx:0};
    return {has:1, ok:1, mn:Math.min(a.mn,b.mn), mx:Math.max(a.mx,b.mx)};
  }
  if(a.has) return a;
  if(b.has) return b;
  return {has:0, ok:1, mn:0, mx:0};
}

// custom ops
let CUSTOM_UN=new Map();
let CUSTOM_BIN=new Map();
let CUSTOM_META=new Map(); // key -> {w, comm, type}
let CUSTOM_PRUNE_UN=new Map();
let CUSTOM_PRUNE_BIN=new Map();

function vKey(v){ if(!Number.isFinite(v))return "NaN"; if(Object.is(v,-0))v=0; return v.toPrecision(KEYP); }
function nearInt(x){ return Math.abs(x - Math.round(x)) < 1e-12; }
function safePowStable(a,b){
  if(!Number.isFinite(a)||!Number.isFinite(b))return NaN;
  if(a<0){const rb=Math.round(b);if(Math.abs(b-rb)>1e-12)return NaN;b=rb;}
  if(Math.abs(b)>60)return NaN;
  const r1=Math.pow(a,b);
  if(!Number.isFinite(r1)||Math.abs(r1)>CAP)return NaN;
  const bp=Math.round(b);
  if(Math.abs(b-bp)<1e-10 && Math.abs(bp)<=24){
    let r=1,base=a,e=Math.abs(bp);
    while(e>0){if(e&1)r*=base;base*=base;if(!Number.isFinite(r)||!Number.isFinite(base)||Math.abs(r)>CAP||Math.abs(base)>CAP)return NaN;e>>=1;}
    if(bp<0)r=1/r;
    return(!Number.isFinite(r)||Math.abs(r)>CAP)?NaN:r;
  }
  return r1;
}
function gcdInt(a,b){a=Math.abs(a);b=Math.abs(b);while(b){const t=a%b;a=b;b=t;}return a;}

function applyUn(op,v){
  switch(op){
    case "neg":return -v;case "abs":return Math.abs(v);case "inv":return v===0?NaN:1/v;
    case "sqrt":return v<0?NaN:Math.sqrt(v);case "cbrt":return Math.cbrt(v);
    case "square":{const r=v*v;return r>CAP?NaN:r;}
    case "cube":{const r=v*v*v;return Math.abs(r)>CAP?NaN:r;}
    case "exp":return v>80?NaN:Math.exp(v);case "expm1":return v>80?NaN:Math.expm1(v);
    case "log":return v<=0?NaN:Math.log(v);case "log10":return v<=0?NaN:Math.log10(v);case "log1p":return v<=-1?NaN:Math.log1p(v);
    case "sin":return Math.sin(v);case "cos":return Math.cos(v);case "tan":return Math.tan(v);
    case "asin":return(v<-1||v>1)?NaN:Math.asin(v);case "acos":return(v<-1||v>1)?NaN:Math.acos(v);case "atan":return Math.atan(v);
    case "sinh":return Math.abs(v)>80?NaN:Math.sinh(v);case "cosh":return Math.abs(v)>80?NaN:Math.cosh(v);case "tanh":return Math.tanh(v);
    case "floor":return Math.floor(v);case "ceil":return Math.ceil(v);case "round":return Math.round(v);
    case "frac":return v-Math.floor(v);case "sign":return Math.sign(v);
    default:{
      const fn=CUSTOM_UN.get(op);
      if(fn){ try{ return fn(v); }catch(e){ return NaN; } }
      return NaN;
    }
  }
}
function applyBin(op,a,b){
  switch(op){
    case "+":return a+b;case "-":return a-b;case "*":return a*b;case "/":return b===0?NaN:a/b;
    case "^":return safePowStable(a,b);
    case "min":return Math.min(a,b);case "max":return Math.max(a,b);
    case "atan2":return Math.atan2(a,b);case "hypot":return Math.hypot(a,b);
    case "mod":{if(!nearInt(a)||!nearInt(b))return NaN;const bb=Math.round(b);return bb===0?NaN:((Math.round(a)%bb)+bb)%bb;}
    case "gcd":{if(!nearInt(a)||!nearInt(b))return NaN;const aa=Math.round(a),bb=Math.round(b);return(Math.abs(aa)>1e6||Math.abs(bb)>1e6)?NaN:gcdInt(aa,bb);}
    case "lcm":{if(!nearInt(a)||!nearInt(b))return NaN;const aa=Math.round(a),bb=Math.round(b);if(Math.abs(aa)>1e6||Math.abs(bb)>1e6)return NaN;return Math.abs(aa/gcdInt(aa,bb)*bb);}
    default:{
      const fn=CUSTOM_BIN.get(op);
      if(fn){ try{ return fn(a,b); }catch(e){ return NaN; } }
      return NaN;
    }
  }
}
function wUn(op){
  switch(op){
    case "neg":case "abs":case "sign":return 1;
    case "sqrt":case "cbrt":case "inv":case "floor":case "ceil":case "round":case "frac":case "square":case "cube":return 2;
    case "exp":case "expm1":case "log":case "log10":case "log1p":case "sin":case "cos":case "tan":return 3;
    case "asin":case "acos":case "atan":case "sinh":case "cosh":case "tanh":return 4;
    default:{
      const m=CUSTOM_META.get(op);
      if(m && m.type==="un" && Number.isFinite(m.w)) return m.w|0;
      return 3;
    }
  }
}
function wBin(op){
  switch(op){
    case "+":case "-":case "*":case "/":return 1;
    case "^":return 3;
    case "min":case "max":return 2;
    case "mod":return 3;
    case "atan2":case "hypot":return 4;
    case "gcd":case "lcm":return 6;
    default:{
      const m=CUSTOM_META.get(op);
      if(m && m.type==="bin" && Number.isFinite(m.w)) return m.w|0;
      return 2;
    }
  }
}
function isComm(op){
  if(op==="+"||op==="*"||op==="min"||op==="max"||op==="gcd"||op==="lcm")return true;
  const m=CUSTOM_META.get(op);
  return !!(m && m.type==="bin" && m.comm);
}

const TAG_NONE=0,TAG_NEG=1,TAG_EXP=2,TAG_LOG=3,TAG_SQRT=4,TAG_SQ=5,TAG_INV=6,TAG_ABS=7;
const TAG_ADD=17,TAG_SUB=18,TAG_MUL=19,TAG_DIV=20,TAG_POW=21;
const F_ZERO=1<<8,F_ONE=1<<9,F_NEGONE=1<<10,F_INT=1<<11,F_NONNEG=1<<12,F_CONST=1<<13,F_HAS_ABS=1<<14;
function getTag(f){return f&0xFF;}
function has(f,b){return(f&b)!==0;}
function pruneUn(op,cf,cv){
  const ct=getTag(cf);
  if(op==="neg"&&ct===TAG_NEG)return true;
  if(op==="abs"&&(ct===TAG_ABS||ct===TAG_NEG))return true;
  if(op==="abs"&&has(cf,F_HAS_ABS))return true;
  if(op==="abs"&&has(cf,F_NONNEG))return true;
  if(op==="inv"&&ct===TAG_INV)return true;
  if(op==="exp"&&ct===TAG_LOG)return true;
  if(op==="log"&&ct===TAG_EXP)return true;
  if(op==="sqrt"&&ct===TAG_SQ)return true;
  if(op==="square"&&ct===TAG_SQRT)return true;
  if(op==="neg"&&has(cf,F_ZERO))return true;
  if(op==="sqrt"&&(has(cf,F_ZERO)||has(cf,F_ONE)))return true;
  if(op==="exp"&&has(cf,F_ZERO))return true;
  if(op==="log"&&has(cf,F_ONE))return true;
  if(op==="inv"&&(has(cf,F_ONE)||has(cf,F_NEGONE)))return true;
  if(op==="square"&&(has(cf,F_ZERO)||has(cf,F_ONE)))return true;
  if((op==="floor"||op==="ceil"||op==="round")&&has(cf,F_INT))return true;
  if(op==="frac"&&has(cf,F_INT))return true;
  if(op==="sign"&&(has(cf,F_ZERO)))return true;

  const fn=CUSTOM_PRUNE_UN.get(op);
  if(fn){ try{ if(fn(cf,cv)) return true; }catch(e){} }

  return false;
}
function pruneBin(op,af,bf,av,bv){
  if(op==="+"&&(has(af,F_ZERO)||has(bf,F_ZERO)) && !NEED_ZERO)return true;
  if(op==="-"&&has(bf,F_ZERO))return true;
  if(op==="-"&&Math.abs(av-bv)<1e-15)return true;
  if(op==="-"&&has(af,F_ZERO))return true;
  if(op==="*"&&(has(af,F_ZERO)||has(bf,F_ZERO)))return true;
  if(op==="*"&&(has(af,F_ONE)||has(bf,F_ONE)) && !NEED_ONE)return true;
  if(op==="*"&&(has(af,F_NEGONE)||has(bf,F_NEGONE))&&HAS_NEG)return true;
  if(op==="/"&&has(af,F_ZERO))return true;
  if(op==="/"&&(has(bf,F_ONE)||has(bf,F_NEGONE)) && !NEED_ONE && (has(bf,F_NEGONE)?HAS_NEG:true))return true;
  if(op==="/"&&Math.abs(av-bv)<1e-15&&Math.abs(av)>1e-15)return true;
  if(op==="^"&&has(bf,F_ZERO) && !NEED_ZERO)return true;
  if(op==="^"&&has(bf,F_ONE)  && !NEED_ONE)return true;
  if(op==="^"&&has(af,F_ZERO) && !NEED_ZERO)return true;
  if(op==="^"&&has(af,F_ONE)  && !NEED_ONE)return true;
  if(op==="^"&&has(af,F_NEGONE)&&has(bf,F_INT))return true;

  if(op==="*"&&(getTag(af)===TAG_INV||getTag(bf)===TAG_INV) && HAS_DIV)return true;

  const fn=CUSTOM_PRUNE_BIN.get(op);
  if(fn){ try{ if(fn(af,bf,av,bv)) return true; }catch(e){} }

  return false;
}

function bbScore(v, D, magA){
  if(!Number.isFinite(v))return 1e9;
  const a=Math.abs(v);
  const mag=magA*Math.log1p(a);
  if(a===0)return mag;
  let best=Math.abs(v-Math.round(v));
  const DD=D|0;
  for(let d=2;d<=DD;d++){
    const rd=Math.round(v*d);
    const err=Math.abs(v*d-rd)/d;
    if(err<best)best=err;
    if(best<1e-15)break;
  }
  return best+mag;
}

let layers=new Map();

function mkBucket(beam){
  const bucket=new Map();
  const spLim=Math.max(beam*64,50000);
  const keepSp=Math.max(beam*20,16000);
  function spill(){
    const v=Array.from(bucket.values());
    v.sort((a,b)=>a.keep-b.keep);
    bucket.clear();
    for(let i=0;i<Math.min(keepSp,v.length);i++)bucket.set(v[i].key,v[i]);
  }
  function put(key,pack){
    const old=bucket.get(key);
    if(old&&pack.keep>=old.keep)return;
    pack.key=key;
    bucket.set(key,pack);
    if(bucket.size>spLim)spill();
  }
  return{bucket,put};
}

onmessage=(ev)=>{
  const msg=ev.data;
  if(msg.type==="init"){
    KEYP=msg.keyPrec|0;
    USE_BITMASK=!!msg.useBitmask;
    NO_CONSTRAINT_FAST=!!msg.noConstraintFast;
    TCOUNT=msg.tCount|0;
    MAXT=msg.maxT?new Uint16Array(msg.maxT):null;
    OPS_UN=msg.opsUn||[];
    OPS_BIN=msg.opsBin||[];
    PRUNE=!!msg.pruneEquiv;
    NEED_ZERO=!!msg.needZero;
    NEED_ONE=!!msg.needOne;
    HAS_NEG=!!msg.hasNeg; HAS_SUB=!!msg.hasSub; HAS_DIV=!!msg.hasDiv; HAS_MUL=!!msg.hasMul;

    REQ_MASK = (msg.reqMask|0) || 0;
    REQ_POP  = (msg.reqPop|0) || 0;

    LEAF_ORDER = String(msg.leafOrder||"") || "";

    // compile custom ops
    CUSTOM_UN=new Map(); CUSTOM_BIN=new Map(); CUSTOM_META=new Map();
    CUSTOM_PRUNE_UN=new Map(); CUSTOM_PRUNE_BIN=new Map();
    try{
      const cu=msg.customUnary||[];
      for(const d of cu){
        if(!d||!d.key||!d.impl) continue;
        const key=String(d.key);
        CUSTOM_META.set(key,{type:"un", w:(d.weight|0)||3, comm:false});
        CUSTOM_UN.set(key, new Function("x","return ("+String(d.impl)+");"));
        if(d.pruneImpl) CUSTOM_PRUNE_UN.set(key, new Function("flags","x","return !!("+String(d.pruneImpl)+");"));
      }
      const cb=msg.customBinary||[];
      for(const d of cb){
        if(!d||!d.key||!d.impl) continue;
        const key=String(d.key);
        CUSTOM_META.set(key,{type:"bin", w:(d.weight|0)||2, comm:!!d.commutative});
        CUSTOM_BIN.set(key, new Function("a","b","return ("+String(d.impl)+");"));
        if(d.pruneImpl) CUSTOM_PRUNE_BIN.set(key, new Function("af","bf","a","b","return !!("+String(d.pruneImpl)+");"));
      }
    }catch(e){}

    layers=new Map();
    postMessage({type:"inited"});
    return;
  }
  if(msg.type==="setLayer"){
    layers.set(msg.cost|0,msg.layer);
    return;
  }
  if(msg.type==="task"){
    const{T,c,beam,capUn,capBin,workerId,workerCount,bbD,bbMagA,keepMode}=msg;
    const{bucket,put}=mkBucket(beam);
    let visited=0,pruned=0;

    function keepScoreSub(goal,bb){ return (keepMode==="goal")?goal:Math.min(goal,bb); }

    const keyOf=(v,maskOrCk)=>{
      const vk=vKey(v);
      if(USE_BITMASK) return vk+"|"+maskOrCk;
      if(NO_CONSTRAINT_FAST) return vk;
      return vk+"|"+maskOrCk;
    };

    for(const op of OPS_UN){
      const w=wUn(op),sc=c-w;
      if(sc<1)continue;
      const src=layers.get(sc);
      if(!src||!src.len)continue;
      const lim=Math.min(src.len,capUn);
      for(let i=workerId;i<lim;i+=workerCount){
        const av=src.v[i],af=src.flags?src.flags[i]:0;
        if(PRUNE&&pruneUn(op,af,av)){pruned++;continue;}
        const v=applyUn(op,av);visited++;
        if(!Number.isFinite(v)||Math.abs(v)>CAP)continue;
        const goal=Math.abs(v-T);
        const bb=bbScore(v,bbD,bbMagA);
        let keep=keepScoreSub(goal,bb);

        if(USE_BITMASK){
          const mask=src.mask[i]|0;
          if(LEAF_ORDER && src.ordOk && src.ordOk[i]===0) continue;
          keep *= reqAdj(mask);
          put(keyOf(v,mask),{v,goal,bb,keep,mask,kind:"u",op,ac:sc,ai:i});
        }else{
          if(NO_CONSTRAINT_FAST){
            put(keyOf(v,0),{v,goal,bb,keep,ck:"",kind:"u",op,ac:sc,ai:i});
          }else{
            // counts mode used only when enabled in main (not in this file by default)
            put(keyOf(v,""),{v,goal,bb,keep,ck:"",kind:"u",op,ac:sc,ai:i});
          }
        }
      }
    }

    for(const op of OPS_BIN){
      const w=wBin(op),rem=c-w;
      if(rem<2)continue;
      const comm=isComm(op);
      const icMax = comm ? Math.floor(rem/2) : (rem-1);
      for(let ic=1;ic<=icMax;ic++){
        const jc=rem-ic;
        const A=layers.get(ic),B=layers.get(jc);
        if(!A||!B||!A.len||!B.len)continue;
        const cA=Math.min(A.len,capBin),cB=Math.min(B.len,capBin);
        for(let ia=workerId;ia<cA;ia+=workerCount){
          const av=A.v[ia],af=A.flags?A.flags[ia]:0;
          const stB=(comm&&ic===jc)?ia:0;
          for(let ib=stB;ib<cB;ib++){
            const bv=B.v[ib],bf=B.flags?B.flags[ib]:0;
            if(PRUNE&&pruneBin(op,af,bf,av,bv)){pruned++;continue;}

            if(USE_BITMASK){
              const am=A.mask[ia]|0,bm=B.mask[ib]|0;
              if((am&bm)!==0)continue;

              if(LEAF_ORDER){
                if(A.ordOk && A.ordOk[ia]===0) continue;
                if(B.ordOk && B.ordOk[ib]===0) continue;
                // cheap nondecreasing order: if both have leaves then check A.max <= B.min
                if(A.ordHas && B.ordHas && A.ordHas[ia] && B.ordHas[ib]){
                  const aMx=A.ordMax[ia], bMn=B.ordMin[ib];
                  if(aMx > bMn) continue;
                }
              }

              const mask=am|bm;
              const v=applyBin(op,av,bv);visited++;
              if(!Number.isFinite(v)||Math.abs(v)>CAP)continue;
              const goal=Math.abs(v-T);
              const bb=bbScore(v,bbD,bbMagA);
              let keep=keepScoreSub(goal,bb);
              keep *= reqAdj(mask);
              put(keyOf(v,mask),{v,goal,bb,keep,mask,kind:"b",op,ac:ic,ai:ia,bc:jc,bi:ib});
            }else{
              const v=applyBin(op,av,bv);visited++;
              if(!Number.isFinite(v)||Math.abs(v)>CAP)continue;
              const goal=Math.abs(v-T);
              const bb=bbScore(v,bbD,bbMagA);
              const keep=keepScoreSub(goal,bb);
              put(keyOf(v,0),{v,goal,bb,keep,ck:"",kind:"b",op,ac:ic,ai:ia,bc:jc,bi:ib});
            }
          }
        }
      }
    }

    postMessage({type:"taskDone",payload:{visited,pruned,items:Array.from(bucket.values())}});
  }
};
`;

// ================= Worker builder =================
function buildWorker(){
const workerSrc = `
let stopFlag=false;

const CAP=1e12, EXACT_EPS=5e-15, INF=65535;

function modeParams(mode){
  if(mode==="speed") return {
    keyPrec:10, bestPrec:10, keepMode:"goal",
    bbD:18, bbMagA:0.032,
    qGoal:0.40,qBB:0.10,qMeet:0.10,qDiv:0.06,qPow:0.07,qFunc:0.05,qDepth:0.10,qMag:0.08,qIrr:0.06,
    qPowBase:0.10, qPowExp:0.08,
    qReq:0.08,
    meetStyle:"bin", meetPrec:10, meetQ:4096, meetR:7,
    revBeamMul:1.8, meetHitBonus:0.14,
    candEpsMul:3.0, confirmEpsMul:1.0, binSlackMul:0.18, confirmAbsFloor:2e-6,
    spillMul:0.55, capMul:0.9, keepMeetDup:false,
    meetSweepMul:0.16, meetSweepPowMul:0.32,
    beamMul:0.85, subLayerCapMul:0.95,
    revIdxKeyCap:140, fwdIdxKeyCap:140, meetKeyProbeCap:160, meetSweepRevCap:180,
    capUnMul:2.2, capBinMul:1.9
  };
  if(mode==="accuracy") return {
    keyPrec:14, bestPrec:12, keepMode:"min",
    bbD:72, bbMagA:0.018,
    qGoal:0.20,qBB:0.18,qMeet:0.12,qDiv:0.08,qPow:0.14,qFunc:0.10,qDepth:0.14,qMag:0.09,qIrr:0.07,
    qPowBase:0.16, qPowExp:0.12,
    qReq:0.14,
    meetStyle:"bin", meetPrec:12, meetQ:16384, meetR:6,
    revBeamMul:2.0, meetHitBonus:0.10,
    candEpsMul:1.45, confirmEpsMul:1.0, binSlackMul:0.30, confirmAbsFloor:0.0,
    spillMul:1.6, capMul:1.35, keepMeetDup:false,
    meetSweepMul:0.24, meetSweepPowMul:0.42,
    beamMul:1.05, subLayerCapMul:1.35,
    revIdxKeyCap:200, fwdIdxKeyCap:200, meetKeyProbeCap:220, meetSweepRevCap:260,
    capUnMul:2.9, capBinMul:2.4
  };
  return {
    keyPrec:12, bestPrec:11, keepMode:"min",
    bbD:44, bbMagA:0.02,
    qGoal:0.20,qBB:0.12,qMeet:0.20,qDiv:0.06,qPow:0.12,qFunc:0.08,qDepth:0.14,qMag:0.10,qIrr:0.06,
    qPowBase:0.14, qPowExp:0.10,
    qReq:0.12,
    meetStyle:"bin", meetPrec:10, meetQ:8192, meetR:10,
    revBeamMul:2.8, meetHitBonus:0.22,
    candEpsMul:3.6, confirmEpsMul:1.0, binSlackMul:0.14, confirmAbsFloor:0.0,
    spillMul:1.55, capMul:1.25, keepMeetDup:false,
    meetSweepMul:0.34, meetSweepPowMul:0.60,
    beamMul:1.0, subLayerCapMul:1.25,
    revIdxKeyCap:260, fwdIdxKeyCap:260, meetKeyProbeCap:280, meetSweepRevCap:360,
    capUnMul:2.5, capBinMul:2.1
  };
}

let KEYP=12, BESTP=11;
let ALLOW_ADD=true, NEED_ZERO=false, NEED_ONE=false;
let HAS_NEG=true, HAS_SUB=true, HAS_DIV=true, HAS_MUL=true;

// bitmask coverage retention (RIES-like: preserve required constructs)
let REQ_MASK=0, REQ_POP=0;
function popcnt32(x){
  x = x - ((x >>> 1) & 0x55555555);
  x = (x & 0x33333333) + ((x >>> 2) & 0x33333333);
  return (((x + (x >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24;
}
function reqAdj(mask){
  if(!REQ_MASK) return 1.0;
  const cov = popcnt32((mask|0) & REQ_MASK);
  return 1.0 / (1.0 + 0.35 * cov);
}

function vKey(v){if(!Number.isFinite(v))return"NaN";if(Object.is(v,-0))v=0;return v.toPrecision(KEYP)}

let MEET_STYLE="prec";
let MEETP=10;
let MEET_Q=8192;
let MEET_R=2;

function meetKeyPrec(v){if(!Number.isFinite(v))return"NaN";if(Object.is(v,-0))v=0;return v.toPrecision(MEETP)}
function meetKeyBinPrimary(v){
  if(!Number.isFinite(v))return"NaN";
  if(Object.is(v,-0))v=0;
  if(v===0)return"0|0|0";
  const sign=v<0?1:0;
  const a=Math.abs(v);
  const e=Math.floor(Math.log2(a));
  const scale=Math.pow(2,e);
  const x=a/scale;
  const q=Math.round(x*MEET_Q);
  return""+sign+"|"+e+"|"+q;
}
function meetPrimaryKey(v){
  return MEET_STYLE==="bin"?meetKeyBinPrimary(v):meetKeyPrec(v);
}
// broaden meet keys: bin neighborhood + precision key (improves meet on pow-heavy targets)
// [æ›¿æ¢ function meetKeys]

// é¢„åˆ†é…æ•°ç»„é¿å… GC
const _meetKeyOut = []; 
function meetKeys(v){
  if(MEET_STYLE!=="bin") return [meetKeyPrec(v)];
  if(!Number.isFinite(v)) return ["NaN"];
  if(Object.is(v,-0)) v=0;
  if(v===0) return ["0|0|0","0"];
  
  // æ¸…ç©ºæ•°ç»„è€Œä¸æ˜¯æ–°å»º
  _meetKeyOut.length = 0;
  
  const sign=v<0?1:0;
  const a=Math.abs(v);
  // å¿«é€Ÿè®¡ç®— log2
  const e=Math.floor(Math.log2(a));
  const scale=Math.pow(2,e);
  const x=a/scale;
  
  // æ ¸å¿ƒä¼˜åŒ–ï¼šåªåœ¨å…³é”®åŒºé—´ç”Ÿæˆ key
  const q0 = Math.round(x * MEET_Q);
  
  // ç”Ÿæˆä¸»è¦ key
  _meetKeyOut.push(""+sign+"|"+e+"|"+q0);
  
  // ç”Ÿæˆé‚»å±… key (å‡å°‘èŒƒå›´ï¼Œæå‡é€Ÿåº¦ï¼ŒMeet_R ä» 2 é™ä¸º 1 è¶³å¤Ÿäº†ï¼Œå› ä¸ºæœ‰ç²¾åº¦è¡¥æ•‘)
  // å¦‚æœä½ éœ€è¦æ›´å®½çš„å®¹é”™ï¼Œä¿æŒåŸæ¥çš„é€»è¾‘ï¼Œä½†å°½é‡å°‘ push
  if(MEET_R > 0) {
      _meetKeyOut.push(""+sign+"|"+e+"|"+(q0-1));
      _meetKeyOut.push(""+sign+"|"+e+"|"+(q0+1));
  }
  
  // æ€»æ˜¯åŠ å…¥é«˜ç²¾åº¦ Key ä½œä¸ºå¤‡é€‰
  _meetKeyOut.push(meetKeyPrec(v));
  
  // è¿”å›å‰¯æœ¬ä»¥é˜²è¦†ç›–ï¼ˆå› ä¸ºæˆ‘ä»¬æ˜¯å¤šå¤„è°ƒç”¨ï¼‰ï¼Œæˆ–è€…ç¡®ä¿è°ƒç”¨æ–¹ç«‹å³ä½¿ç”¨
  // ä¸ºäº†å®‰å…¨èµ·è§ï¼Œè¿™é‡Œè¿˜æ˜¯è¿”å› sliceï¼Œä½†æ¯”ä¹‹å‰æ¯æ¬¡éƒ½ new å¾ˆå¤š string å¥½ä¸€ç‚¹
  return _meetKeyOut.slice(); 
}

function relAcc(v,T){
  const r=Math.abs(v-T)/Math.max(1,Math.abs(T));
  if(r<EXACT_EPS||r===0)return"exact";
  const n=1/r;
  if(!Number.isFinite(n))return"exact";
  return n>1e6?n.toExponential(4):n.toPrecision(6).replace(/\\\\.0+$/,"");
}

function safePowStable(a,b){
  if(!Number.isFinite(a)||!Number.isFinite(b))return NaN;
  if(a<0){const rb=Math.round(b);if(Math.abs(b-rb)>1e-12)return NaN;b=rb}
  if(Math.abs(b)>60)return NaN;
  if(a===0)return b>0?0:NaN;
  const r1=Math.pow(a,b);
  let r2=NaN;
  if(a>0){
    if(Math.abs(a-1)<0.25)r2=Math.exp(b*Math.log1p(a-1));
    else r2=Math.exp(b*Math.log(a));
  }
  const cands=[r1,r2].filter(v=>Number.isFinite(v)&&Math.abs(v)<=CAP);
  if(!cands.length)return NaN;
  if(cands.length===1)return cands[0];
  const gap=Math.abs(cands[0]-cands[1]);
  const scale=Math.max(1,Math.abs(cands[0]),Math.abs(cands[1]));
  return(gap<=1e-10*scale)?(0.5*(cands[0]+cands[1])):cands[0];
}
function erf(x){
  const s=x<0?-1:1;x=Math.abs(x);
  const t=1/(1+.3275911*x);
  return s*(1-((((1.061405429*t-1.453152027)*t+1.421413741)*t-.284496736)*t+.254829592)*t*Math.exp(-x*x))
}
function gamma(z){
  const p=[676.5203681218851,-1259.1392167224028,771.32342877765313,-176.61502916214059,12.507343278686905,-.13857109526572012,9.9843695780195716e-6,1.5056327351493116e-7];
  if(!Number.isFinite(z))return NaN;
  if(z<.5){const s=Math.sin(Math.PI*z);return s===0?NaN:Math.PI/(s*gamma(1-z))}
  z-=1;let x=.99999999999980993;
  for(let i=0;i<p.length;i++)x+=p[i]/(z+i+1);
  const t=z+p.length-.5;
  return Math.sqrt(2*Math.PI)*Math.pow(t,z+.5)*Math.exp(-t)*x
}
function factInt(n){if(n<0||n>170)return NaN;let v=1;for(let i=2;i<=n;i++)v*=i;return v}
function nearInt(x){return Math.abs(x-Math.round(x))<1e-12}
function gcdInt(a,b){a=Math.abs(a);b=Math.abs(b);while(b){const t=a%b;a=b;b=t}return a}

// ---- leafOrder constraint (early pruning like RIES rules) ----
let LEAF_ORDER=""; // "nondecreasing" | ""
function ordLeaf(sym){
  if(!LEAF_ORDER) return {has:0, ok:1, mn:0, mx:0};
  if(/^-?\\d+$/.test(sym)){
    const v=Number(sym);
    if(Number.isFinite(v)) return {has:1, ok:1, mn:v, mx:v};
  }
  return {has:0, ok:1, mn:0, mx:0};
}
function ordUn(st){ return st; }
function ordBin(a,b){
  if(!LEAF_ORDER) return {has:0, ok:1, mn:0, mx:0};
  if(!a.ok || !b.ok) return {has:(a.has|b.has), ok:0, mn:0, mx:0};
  if(a.has && b.has){
    if(a.mx > b.mn) return {has:1, ok:0, mn:0, mx:0};
    return {has:1, ok:1, mn:Math.min(a.mn,b.mn), mx:Math.max(a.mx,b.mx)};
  }
  if(a.has) return a;
  if(b.has) return b;
  return {has:0, ok:1, mn:0, mx:0};
}

// ---- custom ops support ----
let CUSTOM_UN=new Map();
let CUSTOM_BIN=new Map();
let CUSTOM_META=new Map(); // key->{type:"un"/"bin", w, comm}
let CUSTOM_INV_UN=new Map(); // key -> (r)=>[{v}]
let CUSTOM_INV_BIN_L=new Map(); // key -> (r,b)=>x
let CUSTOM_INV_BIN_R=new Map(); // key -> (r,a)=>x
let CUSTOM_PRUNE_UN=new Map();
let CUSTOM_PRUNE_BIN=new Map();

function wUn(op){switch(op){
  case"neg":case"abs":case"sign":return 1;
  case"sqrt":case"cbrt":case"inv":case"floor":case"ceil":case"round":case"frac":case"square":case"cube":return 2;
  case"exp":case"expm1":case"log":case"log10":case"log1p":case"sin":case"cos":case"tan":return 3;
  case"asin":case"acos":case"atan":case"sinh":case"cosh":case"tanh":case"erf":return 4;
  case"fact":return 6;case"gammafn":return 7;default:{
    const m=CUSTOM_META.get(op); if(m&&m.type==="un"&&Number.isFinite(m.w)) return m.w|0; return 3;
  }
}}
function wBin(op){switch(op){
  case"+":case"-":case"*":case"/":return 1;case"^":return 3;
  case"min":case"max":return 2;case"mod":return 3;
  case"atan2":case"hypot":return 4;case"gcd":case"lcm":return 6;default:{
    const m=CUSTOM_META.get(op); if(m&&m.type==="bin"&&Number.isFinite(m.w)) return m.w|0; return 2;
  }
}}
function isComm(op){
  if(op==="+"||op==="*"||op==="min"||op==="max"||op==="gcd"||op==="lcm")return true;
  const m=CUSTOM_META.get(op); return !!(m&&m.type==="bin"&&m.comm);
}

function mkC(sym,val,ord){return{t:0,sym,val,p:0,f:0,d:0,ord:ord||{has:0,ok:1,mn:0,mx:0}}}
function mkU(op,ch){
  const isFunc=op!=="neg"&&op!=="abs";
  return{t:1,op,ch,p:(ch&&ch.p)?1:0,f:(isFunc||((ch&&ch.f)?1:0))?1:0,d:(ch?ch.d:0)+1,ord:ordUn(ch.ord)};
}
function mkB(op,l,r){
  if(op==="-"&&ALLOW_ADD&&r&&r.t===1&&r.op==="neg"){
    const rr=r.ch;
    const o=ordBin(l.ord,rr.ord);
    return{t:2,op:"+",l,r:rr,p:((l&&l.p)||(rr&&rr.p))?1:0,f:((l&&l.f)||(rr&&rr.f))?1:0,d:Math.max(l?l.d:0,rr?rr.d:0)+1,ord:o};
  }
  const o=ordBin(l.ord,r.ord);
  return{t:2,op,l,r,p:(op==="^"||(l&&l.p)||(r&&r.p))?1:0,f:((l&&l.f)||(r&&r.f))?1:0,d:Math.max(l?l.d:0,r?r.d:0)+1,ord:o};
}

function applyUn(op,v){switch(op){
  case"neg":return-v;case"abs":return Math.abs(v);case"inv":return v===0?NaN:1/v;
  case"sqrt":return v<0?NaN:Math.sqrt(v);case"cbrt":return Math.cbrt(v);
  case"square":{const r=v*v;return r>CAP?NaN:r}
  case"cube":{const r=v*v*v;return Math.abs(r)>CAP?NaN:r}
  case"exp":return v>80?NaN:Math.exp(v);case"expm1":return v>80?NaN:Math.expm1(v);
  case"log":return v<=0?NaN:Math.log(v);case"log10":return v<=0?NaN:Math.log10(v);case"log1p":return v<=-1?NaN:Math.log1p(v);
  case"sin":return Math.sin(v);case"cos":return Math.cos(v);case"tan":return Math.tan(v);
  case"asin":return(v<-1||v>1)?NaN:Math.asin(v);case"acos":return(v<-1||v>1)?NaN:Math.acos(v);case"atan":return Math.atan(v);
  case"sinh":return Math.abs(v)>80?NaN:Math.sinh(v);case"cosh":return Math.abs(v)>80?NaN:Math.cosh(v);case"tanh":return Math.tanh(v);
  case"floor":return Math.floor(v);case"ceil":return Math.ceil(v);case"round":return Math.round(v);
  case"frac":return v-Math.floor(v);case"sign":return Math.sign(v);
  case"fact":return nearInt(v)?factInt(Math.round(v)):NaN;
  case"gammafn":return v>60?NaN:gamma(v);
  case"erf":return erf(v);
  default:{
    const fn=CUSTOM_UN.get(op);
    if(fn){ try{ return fn(v); }catch(e){ return NaN; } }
    return NaN;
  }
}}
function applyBin(op,a,b){switch(op){
  case"+":return a+b;case"-":return a-b;case"*":return a*b;case"/":return b===0?NaN:a/b;case"^":return safePowStable(a,b);
  case"min":return Math.min(a,b);case"max":return Math.max(a,b);
  case"atan2":return Math.atan2(a,b);case"hypot":return Math.hypot(a,b);
  case"mod":{if(!nearInt(a)||!nearInt(b))return NaN;const bb=Math.round(b);return bb===0?NaN:((Math.round(a)%bb)+bb)%bb}
  case"gcd":{if(!nearInt(a)||!nearInt(b))return NaN;const aa=Math.round(a),bb=Math.round(b);return(Math.abs(aa)>1e6||Math.abs(bb)>1e6)?NaN:gcdInt(aa,bb)}
  case"lcm":{if(!nearInt(a)||!nearInt(b))return NaN;const aa=Math.round(a),bb=Math.round(b);if(Math.abs(aa)>1e6||Math.abs(bb)>1e6)return NaN;return Math.abs(aa/gcdInt(aa,bb)*bb)}
  default:{
    const fn=CUSTOM_BIN.get(op);
    if(fn){ try{ return fn(a,b); }catch(e){ return NaN; } }
    return NaN;
  }
}}
function evalA(n){
  if(n.t===0)return n.val;
  if(n.t===1)return applyUn(n.op,evalA(n.ch));
  return applyBin(n.op,evalA(n.l),evalA(n.r));
}
function evalAStable(n){
  if(n.t===0)return n.val;
  if(n.t===1)return applyUn(n.op,evalAStable(n.ch));
  const lv=evalAStable(n.l),rv=evalAStable(n.r);
  if(n.op==="^")return safePowStable(lv,rv);
  return applyBin(n.op,lv,rv);
}
function astPowStats(n){
  if(!n)return{cnt:0,risk:0,val:NaN};
  if(n.t===0)return{cnt:0,risk:0,val:n.val};
  if(n.t===1){
    const cs=astPowStats(n.ch);
    return{cnt:cs.cnt,risk:cs.risk,val:applyUn(n.op,cs.val)};
  }
  const ls=astPowStats(n.l),rs=astPowStats(n.r);
  let cnt=ls.cnt+rs.cnt;
  let risk=ls.risk+rs.risk;
  const val=applyBin(n.op,ls.val,rs.val);
  if(n.op==="^"){
    cnt++;
    const b=ls.val,e=rs.val;
    if(Number.isFinite(b)&&Number.isFinite(e)){
      const ab=Math.abs(b),ae=Math.abs(e);
      const nearOne=1/Math.max(1e-6,Math.abs(ab-1));
      const sens=ae/Math.max(1e-6,ab);
      const expAmp=Math.max(0,ae-2);
      const localRisk=Math.min(20,0.05*sens+0.15*expAmp+2e-4*nearOne);
      risk+=localRisk;
    }else{risk+=5;}
  }
  return{cnt,risk,val};
}
function astDepth(n){ return (!n)?0:(n.d||0); }

// pretty
const PREC_ATOM=100,PREC_POSTFIX=96,PREC_UN=90,PREC_POW=80,PREC_MUL=70,PREC_ADD=60,PREC_FUNC=50;
function prec(n){
  if(n.t===0)return PREC_ATOM;
  if(n.t===1){if(n.op==="fact")return PREC_POSTFIX;return PREC_UN;}
  if(n.t===2){
    switch(n.op){case"^":return PREC_POW;case"*":case"/":return PREC_MUL;case"+":case"-":return PREC_ADD;default:return PREC_FUNC;}
  }
  return PREC_FUNC;
}
function needParen(child,parentOp,side){
  if(!parentOp)return false;
  const cp=prec(child);
  let pp;
  switch(parentOp){case"^":pp=PREC_POW;break;case"*":case"/":pp=PREC_MUL;break;case"+":case"-":pp=PREC_ADD;break;default:pp=PREC_FUNC;}
  if(cp>pp)return false;
  if(cp<pp)return true;
  if(parentOp==="-"&&side==="right")return true;
  if(parentOp==="/"&&side==="right")return true;
  if(parentOp==="^"){
    if(side==="left")return true;
    if(side==="right")return child.t===2&&child.op!=="^";
    return false;
  }
  return false;
}
function pretty(n,parentOp=null,side=null){
  if(n.t===0)return n.sym;
  if(n.t===1){
    const op=n.op,ch=n.ch;
    if(op==="neg"){const s=pretty(ch,"neg","right");const need=prec(ch)<PREC_UN;return"âˆ’"+(need?"("+s+")":s);}
    if(op==="sqrt"){const s=pretty(ch,null,null);const need=prec(ch)<PREC_UN;return"âˆš"+(need?"("+s+")":s);}
    if(op==="cbrt"){const s=pretty(ch,null,null);const need=prec(ch)<PREC_UN;return"âˆ›"+(need?"("+s+")":s);}
    if(op==="inv"){const s=pretty(ch,null,null);const need=prec(ch)<PREC_MUL;return"1/"+(need?"("+s+")":s);}
    if(op==="square"){const s=pretty(ch,null,null);const need=prec(ch)<PREC_POSTFIX;return(need?"("+s+")":s)+"Â²";}
    if(op==="cube"){const s=pretty(ch,null,null);const need=prec(ch)<PREC_POSTFIX;return(need?"("+s+")":s)+"Â³";}
    if(op==="fact"){const s=pretty(ch,null,null);const need=prec(ch)<PREC_POSTFIX;return(need?"("+s+")":s)+"!";}
    const s=pretty(ch,null,null);
    const name=(op==="gammafn")?"Î“":op;
    return name+"("+s+")";
  }
  const op=n.op;
  if(op==="min"||op==="max"||op==="atan2"||op==="hypot"||op==="mod"||op==="gcd"||op==="lcm"){
    return op+"("+pretty(n.l,null,null)+","+pretty(n.r,null,null)+")";
  }
  const L=n.l,R=n.r;
  const ls=pretty(L,op,"left"),rs=pretty(R,op,"right");
  if(op==="+"&&R&&R.t===1&&R.op==="neg"){
    const rs2=pretty(R.ch,op,"right");
    const rout2=needParen(R.ch,op,"right")?"("+rs2+")":rs2;
    const lout2=needParen(L,op,"left")?"("+ls+")":ls;
    return lout2+"-"+rout2;
  }
  if(op==="-"&&ALLOW_ADD&&R&&R.t===1&&R.op==="neg"){
    const rs2=pretty(R.ch,"+","right");
    const rout2=needParen(R.ch,"+","right")?"("+rs2+")":rs2;
    const lout2=needParen(L,"+","left")?"("+ls+")":ls;
    return lout2+"+"+rout2;
  }
  const lout=needParen(L,op,"left")?"("+ls+")":ls;
  const rout=needParen(R,op,"right")?"("+rs+")":rs;
  return lout+op+rout;
}
function strA(n){return pretty(n,null,null);}

// LaTeX
function latexA(n){
  if(!n)return"";
  if(n.t===0){
    const s=String(n.sym||n.val||"0");
    if(s==="Ï€")return"\\\\pi";
    if(s==="Ï†")return"\\\\varphi";
    if(s==="âˆš2")return"\\\\sqrt{2}";
    if(s==="âˆš3")return"\\\\sqrt{3}";
    if(s==="âˆš5")return"\\\\sqrt{5}";
    return s;
  }
  if(n.t===1){
    const ch0=latexA(n.ch);
    const needP=(n.ch&&n.ch.t===2);
    const ch=needP?("("+ch0+")"):ch0;
    switch(n.op){
      case"neg":return"-"+ch;
      case"sqrt":return"\\\\sqrt{"+ch0+"}";
      case"cbrt":return"\\\\sqrt[3]{"+ch0+"}";
      case"inv":return"\\\\frac{1}{"+ch0+"}";
      case"square":return"{"+ch+"}^{2}";
      case"cube":return"{"+ch+"}^{3}";
      case"fact":return ch+"!";
      case"gammafn":return"\\\\Gamma\\\\left("+ch0+"\\\\right)";
      default:return"\\\\mathrm{"+n.op+"}\\\\left("+ch0+"\\\\right)";
    }
  }
  if(n.op==="^"){
    // ä¿®å¤ï¼šå¦‚æœåº•æ•°æœ¬èº«ä¹Ÿæ˜¯å¹‚è¿ç®—ï¼ˆæˆ–å…¶ä»–å¤æ‚è¿ç®—ï¼‰ï¼Œå¿…é¡»å¼ºåˆ¶åŠ æ‹¬å·ï¼Œé¿å…æ¸²æŸ“æˆå¹‚å¡”
    const needParenBase = (n.l && (n.l.t!==0 || n.l.op==="^")); 
    // æˆ–è€…æ›´ä¸¥æ ¼ï¼šåªè¦åº•æ•°ä¸æ˜¯å•çº¯çš„æ•°å­—/ç¬¦å·ï¼Œå°±åŠ æ‹¬å·ï¼Œé˜²æ­¢ ((a+b)^2)^2 è¿™ç§æ­§ä¹‰
    const baseStr = latexA(n.l);
    const base = (needParenBase || (n.l && n.l.t===2)) ? ("\\\\left("+baseStr+"\\\\right)") : baseStr;
    const exp  = latexA(n.r);
    return "{"+base+"}^{"+exp+"}";
  }

  let l=latexA(n.l), r=latexA(n.r);
  if(needParen(n.l,n.op,"left")) l="("+l+")";
  if(needParen(n.r,n.op,"right")) r="("+r+")";
  if(n.op==="/" )return"\\\\frac{"+latexA(n.l)+"}{"+latexA(n.r)+"}";
  if(n.op==="*")return l+"\\\\cdot "+r;
  if(n.op==="+")return l+"+"+r;
  if(n.op==="-")return l+"-"+r;
  return"\\\\mathrm{"+n.op+"}\\\\left("+latexA(n.l)+","+latexA(n.r)+"\\\\right)";
}

const TAG_NONE=0,TAG_NEG=1,TAG_EXP=2,TAG_LOG=3,TAG_SQRT=4,TAG_SQ=5,TAG_INV=6,TAG_ABS=7;
const TAG_ADD=17,TAG_SUB=18,TAG_MUL=19,TAG_DIV=20,TAG_POW=21;
const F_ZERO=1<<8, F_ONE=1<<9, F_NEGONE=1<<10, F_INT=1<<11, F_NONNEG=1<<12, F_CONST=1<<13, F_HAS_ABS=1<<14, F_E=1<<15;

function mkFlags(v,tag,isLeaf,extra=0){
  let f=(tag&0xFF)|extra;const e=1e-15;
  if(Math.abs(v)<e)f|=F_ZERO;
  if(Math.abs(v-1)<e)f|=F_ONE;
  if(Math.abs(v+1)<e)f|=F_NEGONE;
  if(Math.abs(v-Math.E)<1e-13)f|=F_E; // æ ‡è®°å¸¸æ•° e
  if(nearInt(v))f|=F_INT;
  if(v>=0)f|=F_NONNEG;
  if(isLeaf)f|=F_CONST;
  return f
}
function extraUnFlags(op,cf){return((op==="abs")||has(cf,F_HAS_ABS))?F_HAS_ABS:0;}
function extraBinFlags(af,bf){return(af|bf)&F_HAS_ABS;}
function getTag(f){return f&0xFF}
function has(f,b){return(f&b)!==0}
function opTag(op){switch(op){
  case"neg":return TAG_NEG;case"abs":return TAG_ABS;case"inv":return TAG_INV;
  case"exp":case"expm1":return TAG_EXP;case"log":case"log10":case"log1p":return TAG_LOG;
  case"sqrt":return TAG_SQRT;case"square":return TAG_SQ;
  case"+":return TAG_ADD;case"-":return TAG_SUB;case"*":return TAG_MUL;case"/":return TAG_DIV;case"^":return TAG_POW;
  default:return TAG_NONE
}}
function pruneUn(op,cf,cv){
  const ct=getTag(cf);
  if(op==="neg"&&ct===TAG_NEG)return true;
  if(op==="abs"&&(ct===TAG_ABS||ct===TAG_NEG))return true;
  if(op==="abs"&&has(cf,F_HAS_ABS))return true;
  if(op==="abs"&&has(cf,F_NONNEG))return true;
  if(op==="inv"&&ct===TAG_INV)return true;
  if(op==="exp"&&ct===TAG_LOG)return true;
  if(op==="log"&&ct===TAG_EXP)return true;
  if(op==="sqrt"&&ct===TAG_SQ)return true;
  if(op==="square"&&ct===TAG_SQRT)return true;
  if(op==="neg"&&has(cf,F_ZERO))return true;
  if(op==="sqrt"&&(has(cf,F_ZERO)||has(cf,F_ONE)))return true;
  if(op==="exp"&&has(cf,F_ZERO))return true;
  if(op==="log"&&has(cf,F_ONE))return true;
  if(op==="inv"&&(has(cf,F_ONE)||has(cf,F_NEGONE)))return true;
  if(op==="square"&&(has(cf,F_ZERO)||has(cf,F_ONE)))return true;
  if((op==="floor"||op==="ceil"||op==="round")&&has(cf,F_INT))return true;
  if(op==="frac"&&has(cf,F_INT))return true;
  if(op==="sign"&&(has(cf,F_ZERO)))return true;

  const fn=CUSTOM_PRUNE_UN.get(op);
  if(fn){ try{ if(fn(cf,cv)) return true; }catch(e){} }

  return false
}
function pruneBin(op,af,bf,av,bv){
  if(op==="+"&&(has(af,F_ZERO)||has(bf,F_ZERO))&&!NEED_ZERO)return true;
  if(op==="-"&&has(bf,F_ZERO))return true;
  if(op==="-"&&Math.abs(av-bv)<1e-15)return true;
  if(op==="-"&&has(af,F_ZERO))return true;
  if(op==="*"&&(has(af,F_ZERO)||has(bf,F_ZERO)))return true;
  if(op==="*"&&(has(af,F_ONE)||has(bf,F_ONE))&&!NEED_ONE)return true;
  if(op==="*"&&(has(af,F_NEGONE)||has(bf,F_NEGONE))&&HAS_NEG)return true;
  if(op==="/"&&has(af,F_ZERO))return true;
  if(op==="/"&&(has(bf,F_ONE)||has(bf,F_NEGONE))&&!NEED_ONE && (has(bf,F_NEGONE)?HAS_NEG:true))return true;
  if(op==="/"&&Math.abs(av-bv)<1e-15&&Math.abs(av)>1e-15)return true;
  if(op==="^"&&has(bf,F_ZERO)&&!NEED_ZERO)return true;
  if(op==="^"&&has(bf,F_ONE)&&!NEED_ONE)return true;
  if(op==="^"&&has(af,F_ZERO)&&!NEED_ZERO)return true;
  if(op==="^"&&has(af,F_ONE)&&!NEED_ONE)return true;
  if(op==="^"&&has(af,F_NEGONE)&&has(bf,F_INT))return true;

  if(op==="+" && HAS_SUB && (getTag(bf)===TAG_NEG || getTag(af)===TAG_NEG)) return true;
  if(op==="*" && HAS_DIV && (getTag(bf)===TAG_INV || getTag(af)===TAG_INV)) return true;
  if(op==="/" && HAS_MUL && getTag(bf)===TAG_INV) return true;
    if(op==="+"&&(has(af,F_ZERO)||has(bf,F_ZERO)) && !NEED_ZERO)return true;
  if(op==="-"&&has(bf,F_ZERO))return true;
  if(op==="-"&&Math.abs(av-bv)<1e-15)return true;
  if(op==="*"&&(has(af,F_ZERO)||has(bf,F_ZERO)))return true;
  
  // --- æ–°å¢ä¸¥æ ¼ä»£æ•°å‰ªæ ---
  if(op==="*" && (has(af,F_ONE)||has(bf,F_ONE))) return true; // ç¦æ­¢ x*1, 1*x
  if(op==="/" && has(bf,F_ONE)) return true; // ç¦æ­¢ x/1
  
  if(op==="^"){
    if(has(bf,F_ONE)) return true; // ç¦æ­¢ x^1 (è§£å†³ f ä¸ f^1 é‡å¤)
    if(has(bf,F_ZERO)) return true; // ç¦æ­¢ x^0
    if(has(af,F_ONE)) return true; // ç¦æ­¢ 1^x
    // å¦‚æœå¯ç”¨äº†ä¸€å…ƒå‡½æ•° expï¼Œåˆ™ç¦æ­¢äºŒå…ƒè¿ç®— e^x (è§£å†³ e^f ä¸ exp(f) é‡å¤)
    if(has(af,F_E) && OPS_UN.includes("exp")) return true; 
  }
  
  // äº¤æ¢å¾‹è§„èŒƒåŒ–ï¼šå¦‚æœä¸¤ä¸ªæ“ä½œæ•°éƒ½æ˜¯å¸¸æ•°ï¼Œå¼ºåˆ¶ä»å°åˆ°å¤§æ’åˆ— (ries æ ¸å¿ƒä¼˜åŒ–)
  if((op==="+"||op==="*") && has(af,F_CONST) && has(bf,F_CONST) && av > bv) return true;

  const fn=CUSTOM_PRUNE_BIN.get(op);
  if(fn){ try{ if(fn(af,bf,av,bv)) return true; }catch(e){} }

  return false
}

// Reverse inversion (built-in + custom inverses if provided)
function invUn(op,r){switch(op){
  case"neg":return[{v:-r}];
  case"abs":return r<0?[]:[{v:r},{v:-r}];
  case"inv":return r===0?[]:[{v:1/r}];
  case"sqrt":return[{v:r*r}];
  case"square":return r<0?[]:[{v:Math.sqrt(r)},{v:-Math.sqrt(r)}];
  case"exp":return r<=0?[]:[{v:Math.log(r)}];
  case"log":return[{v:Math.exp(r)}];
  default:{
    const fn=CUSTOM_INV_UN.get(op);
    if(fn){ try{ return fn(r)||[]; }catch(e){ return []; } }
    return [];
  }
}}
function invBinR(op,r,a){switch(op){
  case"+":return r-a;case"-":return a-r;
  case"*":return a===0?NaN:r/a;case"/":return r===0?NaN:a/r;
  case"^":return a<=0||r<=0?NaN:Math.log(r)/Math.log(a);
  default:{
    const fn=CUSTOM_INV_BIN_R.get(op);
    if(fn){ try{ return fn(r,a); }catch(e){ return NaN; } }
    return NaN;
  }
}}
function invBinL(op,r,b){switch(op){
  case"+":return r-b;case"-":return r+b;
  case"*":return b===0?NaN:r/b;case"/":return r*b;
  case"^":return b===0||r<=0?NaN:Math.pow(r,1/b);
  default:{
    const fn=CUSTOM_INV_BIN_L.get(op);
    if(fn){ try{ return fn(r,b); }catch(e){ return NaN; } }
    return NaN;
  }
}}

function bbScore(v,D,magA){
  if(!Number.isFinite(v))return 1e9;
  const a=Math.abs(v);
  const mag=magA*Math.log1p(a);
  if(a===0)return mag;
  let best=Math.abs(v-Math.round(v));
  const DD=D|0;
  for(let d=2;d<=DD;d++){
    const rd=Math.round(v*d);
    const err=Math.abs(v*d-rd)/d;
    if(err<best)best=err;
    if(best<1e-15)break;
  }
  return best+mag;
}

function mkBucket(beam,spillMul){
  const bucket=new Map();
  const spLim=Math.max(beam*64,50000);
  const keepSp=Math.max(beam*20,16000);
  const hard=Math.floor(spLim*Math.max(0.35,Math.min(2.0,spillMul||1.0)));
  function spill(){
    const v=Array.from(bucket.values());
    v.sort((a,b)=>a.keep-b.keep);
    bucket.clear();
    for(let i=0;i<Math.min(keepSp,v.length);i++)bucket.set(v[i].key,v[i]);
  }
  return{
    bucket,
    put(key,pack){
      const old=bucket.get(key);
      if(old&&pack.keep>=old.keep)return false;
      pack.key=key;
      bucket.set(key,pack);
      if(bucket.size>hard)spill();
      return true;
    }
  };
}

// topK (heap)
function heapPushMax(heap, item, keyFn){
  heap.push(item);
  let i=heap.length-1;
  while(i>0){
    const p=(i-1)>>1;
    if(keyFn(heap[p])>=keyFn(heap[i]))break;
    const t=heap[p];heap[p]=heap[i];heap[i]=t;
    i=p;
  }
}
function heapPopMax(heap, keyFn){
  const top=heap[0];
  const last=heap.pop();
  if(heap.length){
    heap[0]=last;
    let i=0;
    for(;;){
      let l=i*2+1,r=l+1,b=i;
      if(l<heap.length && keyFn(heap[l])>keyFn(heap[b]))b=l;
      if(r<heap.length && keyFn(heap[r])>keyFn(heap[b]))b=r;
      if(b===i)break;
      const t=heap[i];heap[i]=heap[b];heap[b]=t;
      i=b;
    }
  }
  return top;
}
function topK(items,k,scoreFn,lowerBetter=true,filterFn=null){
  k=k|0;
  if(k<=0)return [];
  const heap=[];
  const keyFn=(x)=>x.__sc;
  const inv=lowerBetter?1:-1;
  for(let i=0;i<items.length;i++){
    const it=items[i];
    if(filterFn && !filterFn(it)) continue;
    const sc=scoreFn(it);
    if(!Number.isFinite(sc)) continue;
    it.__sc = sc*inv;
    if(heap.length<k){
      heapPushMax(heap,it,keyFn);
    }else if(it.__sc < heap[0].__sc){
      heap[0]=it;
      let idx=0;
      for(;;){
        let l=idx*2+1,r=l+1,b=idx;
        if(l<heap.length && keyFn(heap[l])>keyFn(heap[b]))b=l;
        if(r<heap.length && keyFn(heap[r])>keyFn(heap[b]))b=r;
        if(b===idx)break;
        const t=heap[idx];heap[idx]=heap[b];heap[b]=t;
        idx=b;
      }
    }
  }
  const out=[];
  while(heap.length) out.push(heapPopMax(heap,keyFn));
  out.reverse();
  return out;
}

function selectTop(items,beam,divRatio,mp,revIdx,allowPow,useBitmask){
  const out=[];
  const used=new Set();
  const take=(arr,limit)=>{
    for(let i=0;i<arr.length&&out.length<beam&&limit>0;i++){
      const it=arr[i];
      const k=it.key;
      if(used.has(k))continue;
      used.add(k);
      out.push(it);
      limit--;
    }
  };

  if(revIdx){
    for(const it of items){
      const mk = it.mkey || (it.mkey = meetPrimaryKey(it.v));
      it.revHit = revIdx.has(mk);
    }
  }else{
    for(const it of items){it.revHit=false;}
  }

  // bitmask: compute required-coverage for quota/keep
  if(useBitmask && REQ_POP>0){
    for(const it of items){
      it.cov = popcnt32((it.mask|0) & REQ_MASK);
    }
  }else{
    for(const it of items){it.cov=0;}
  }

  const nGoal=Math.max(0,Math.floor(beam*mp.qGoal));
  const nBB=Math.max(0,Math.floor(beam*mp.qBB));
  const nMeet=Math.max(0,Math.floor(beam*(revIdx?mp.qMeet:0)));
  const nDiv=Math.max(0,Math.floor(beam*mp.qDiv));
  const nPow=Math.max(0,Math.floor(beam*(mp.qPow||0)));
  const nFunc=Math.max(0,Math.floor(beam*(mp.qFunc||0)));
  const nDepth=Math.max(0,Math.floor(beam*(mp.qDepth||0)));
  const nMagD=Math.max(0,Math.floor(beam*(mp.qMag||0)));
  const nIrr=Math.max(0,Math.floor(beam*(mp.qIrr||0)));
  const nPowBase=Math.max(0,Math.floor(beam*(mp.qPowBase||0)));
  const nPowExp=Math.max(0,Math.floor(beam*(mp.qPowExp||0)));
  const nReq=Math.max(0,Math.floor(beam*(mp.qReq||0)));

  take(topK(items,nGoal,(x)=>x.goal,true), nGoal);
  if(nMeet>0) take(topK(items,nMeet,(x)=>x.goal,true,(x)=>x.revHit), nMeet);

  // Required-coverage quota (fix bitmaskæ¼è§£ due to beam fragmentation)
  if(useBitmask && REQ_POP>0 && nReq>0){
    take(topK(items,nReq,(x)=>(x.keep - 0.35*(x.cov||0)),true,(x)=> (x.cov||0)>0), nReq);
  }

  if(allowPow && nPow>0) take(topK(items,nPow,(x)=>(x.goal+0.20*x.bb),true,(x)=>x.hasPow), nPow);

  if(allowPow && nPowBase>0){
    const baseFilter=(x)=>{
      const v=x.v;
      if(!Number.isFinite(v))return false;
      if(v<=0)return false;
      const a=Math.abs(v);
      return a>0.12 && a<24 && Math.abs(a-1)>1e-12;
    };
    take(topK(items,nPowBase,(x)=>x.bb,true,baseFilter), nPowBase);
  }
  if(allowPow && nPowExp>0){
    const expFilter=(x)=>{
      const v=x.v;
      if(!Number.isFinite(v))return false;
      return Math.abs(v)<24;
    };
    take(topK(items,nPowExp,(x)=>(x.bb*0.7 + 0.01/(1+(x.depth||0))),false,expFilter), nPowExp);
  }

  if(nFunc>0) take(topK(items,nFunc,(x)=>(x.goal+0.16*x.bb),true,(x)=>x.hasFunc), nFunc);

  if(nDepth>0){
    take(topK(items,nDepth,(x)=>-(x.depth||0),true), nDepth);
  }

  if(nMagD>0){
    const bins=new Map();
    for(const it of items){
      const mb=Math.floor(Math.log2(Math.abs(it.v)+1e-30));
      const old=bins.get(mb);
      if(!old||it.keep<old.keep)bins.set(mb,it);
    }
    const magList=Array.from(bins.values());
    magList.sort((a,b)=>a.keep-b.keep);
    take(magList,nMagD);
  }

  if(nIrr>0){
    take(topK(items,nIrr,(x)=> (x.bb*0.8 - x.goal*0.15), false), nIrr);
  }

  take(topK(items,nBB,(x)=>x.bb,true), nBB);

  if(nDiv>0){
    const bins=new Map();
    for(const it of items){
      if(used.has(it.key))continue;
      const b=Math.floor(Math.log(Math.abs(it.v)+1e-30)*3);
      const old=bins.get(b);
      if(!old||it.keep<old.keep)bins.set(b,it);
    }
    const divArr=Array.from(bins.values()).sort((a,b)=>a.keep-b.keep);
    take(divArr,nDiv);
  }

  if(out.length<beam){
    take(topK(items,beam-out.length,(x)=>x.keep,true), beam-out.length);
  }
  return out;
}

onmessage=async(ev)=>{
  const msg=ev.data;
  if(msg.type==="stop"){stopFlag=true;return;}
  if(msg.type!=="start")return;

  stopFlag=false;

  let{
    T,mode,maxC,beam,divRatio,outN,timeLimit,infiniteTime,emitInterval,
    opsUn,opsBin,consts,showCounts,bidir,pruneEquiv,excludeExact,
    mt,threads,subSrc,
    customEnable,customCode
  }=msg;

  mode=mode||"normal";
  mode=(mode==="balanced"||mode==="meet")?"normal":mode;
  mode=(mode==="free"||mode==="meetfast")?"speed":mode;
  mode=(mode==="ries")?"accuracy":mode;
  const mp=modeParams(mode);

  // compile custom
  let customAllow=null,customScoreAdjust=null;
  let ext={constants:[],unaryOps:[],binaryOps:[]};
  let constraints={};
  let customUnary=[], customBinary=[];
  if(!!customEnable){
    try{
      const scope=new Function('"use strict";\\n'+String(customCode||"")+'\\n; return {'
        +'getExtensions:(typeof getExtensions==="function")?getExtensions:null,'
        +'getConstraints:(typeof getConstraints==="function")?getConstraints:null,'
        +'allowCandidate:(typeof allowCandidate==="function")?allowCandidate:null,'
        +'scoreAdjust:(typeof scoreAdjust==="function")?scoreAdjust:null'
      +'};')();

      customAllow=scope.allowCandidate;
      customScoreAdjust=scope.scoreAdjust;
      constraints = scope.getConstraints ? (scope.getConstraints()||{}) : {};
      ext = scope.getExtensions ? (scope.getExtensions()||{}) : {};
    }catch(err){
      postMessage({type:"error",payload:"è‡ªå®šä¹‰è„šæœ¬é”™è¯¯: "+err.message});
      return;
    }
  }

  // normalize constraints
  const leafOrder = String(constraints?.leafOrder||"");
  LEAF_ORDER = (leafOrder==="nondecreasing") ? "nondecreasing" : "";

  // normalize extensions (ops only; constants are already in 'consts' list passed from UI)
  function normOpDef(d,kind){
    if(!d||!d.key||!d.impl) return null;
    const o={
      key:String(d.key),
      kind,
      weight: (d.weight|0) || (kind==="un"?3:2),
      commutative: !!d.commutative,
      impl: String(d.impl),
      pruneImpl: d.pruneImpl ? String(d.pruneImpl) : "",
      invImpl: d.invImpl ? String(d.invImpl) : "",
      invLImpl: d.invLImpl ? String(d.invLImpl) : "",
      invRImpl: d.invRImpl ? String(d.invRImpl) : ""
    };
    return o;
  }
  customUnary = Array.isArray(ext?.unaryOps) ? ext.unaryOps.map(d=>normOpDef(d,"un")).filter(Boolean) : [];
  customBinary = Array.isArray(ext?.binaryOps) ? ext.binaryOps.map(d=>normOpDef(d,"bin")).filter(Boolean) : [];

  // install custom ops
  CUSTOM_UN=new Map(); CUSTOM_BIN=new Map(); CUSTOM_META=new Map();
  CUSTOM_INV_UN=new Map(); CUSTOM_INV_BIN_L=new Map(); CUSTOM_INV_BIN_R=new Map();
  CUSTOM_PRUNE_UN=new Map(); CUSTOM_PRUNE_BIN=new Map();
  try{
    for(const d of customUnary){
      CUSTOM_META.set(d.key,{type:"un", w:d.weight, comm:false});
      CUSTOM_UN.set(d.key, new Function("x","return ("+d.impl+");"));
      if(d.pruneImpl) CUSTOM_PRUNE_UN.set(d.key, new Function("flags","x","return !!("+d.pruneImpl+");"));
      if(d.invImpl) CUSTOM_INV_UN.set(d.key, new Function("r","return ("+d.invImpl+")(r);"));
    }
    for(const d of customBinary){
      CUSTOM_META.set(d.key,{type:"bin", w:d.weight, comm:!!d.commutative});
      CUSTOM_BIN.set(d.key, new Function("a","b","return ("+d.impl+");"));
      if(d.pruneImpl) CUSTOM_PRUNE_BIN.set(d.key, new Function("af","bf","a","b","return !!("+d.pruneImpl+");"));
      if(d.invLImpl) CUSTOM_INV_BIN_L.set(d.key, new Function("r","b","return ("+d.invLImpl+")(r,b);"));
      if(d.invRImpl) CUSTOM_INV_BIN_R.set(d.key, new Function("r","a","return ("+d.invRImpl+")(r,a);"));
    }
  }catch(e){
    postMessage({type:"error",payload:"è‡ªå®šä¹‰æ‰©å±•ç¼–è¯‘å¤±è´¥: "+(e?.message||String(e))});
    return;
  }

  KEYP=mp.keyPrec;
  BESTP=mp.bestPrec;
  MEET_STYLE=mp.meetStyle;
  MEETP=mp.meetPrec;
  MEET_Q=mp.meetQ|0;
  MEET_R=mp.meetR|0;

  emitInterval=Math.max(50,Math.min(60000,emitInterval|0||500));
  const lim=infiniteTime?Infinity:Math.max(0,timeLimit);
  divRatio=Math.max(0,Math.min(1,divRatio||0));
  excludeExact=!!excludeExact;
  pruneEquiv=!!pruneEquiv;
  bidir=!!bidir;
  mt=!!mt;
  threads=Math.max(1,Math.min(64,(threads|0)||1));

  // Do NOT shrink forward beam just because bidir is on (prevents missing hard constructions)
  const bidirMul = (bidir && mode==="speed") ? 0.90 : 1.0;

  const beamF=Math.max(50,Math.floor(beam*(mp.beamMul||1)*bidirMul));
  const beamR=Math.max(50,Math.floor(beam*(mp.revBeamMul||1)));
  const subLayerCap=Math.max(32,Math.floor(beamF*(mp.subLayerCapMul||1)));

  const nC=consts.length;
  const constrainedIdx=[];
  for(let i=0;i<nC;i++){
    const mn=consts[i].min??0,mx=consts[i].max??INF;
    if(mn>mx){postMessage({type:"error",payload:consts[i].s+" min>max"});return}
    if(mn>0||mx<INF)constrainedIdx.push(i);
  }

  ALLOW_ADD=Array.isArray(opsBin)&&opsBin.includes("+");
  HAS_NEG=Array.isArray(opsUn)&&opsUn.includes("neg");
  HAS_SUB=Array.isArray(opsBin)&&opsBin.includes("-");
  HAS_DIV=Array.isArray(opsBin)&&opsBin.includes("/");
  HAS_MUL=Array.isArray(opsBin)&&opsBin.includes("*");

  NEED_ZERO=consts.some((x)=>(x.key==="0"||x.s==="0")&&(x.min|0)>0);
  NEED_ONE=consts.some((x)=>(x.key==="1"||x.s==="1")&&(x.min|0)>0);

  const noConstraintFast=constrainedIdx.length===0;

  let useBitmask=!noConstraintFast;
  if(constrainedIdx.length>30)useBitmask=false;
  for(const i of constrainedIdx){
    if((consts[i].min??0)>1||(consts[i].max??INF)>1){useBitmask=false;break}
  }

  // Reduce "constPenalty" only in speed mode; keep breadth in normal/accuracy
  const constPenalty = (mode==="speed" && noConstraintFast) ? Math.max(1, Math.sqrt(Math.max(1,consts.length)/48)) : 1;

  const k=constrainedIdx.length;
  const idx2bit=new Int16Array(nC);idx2bit.fill(-1);
  for(let p=0;p<k;p++)idx2bit[constrainedIdx[p]]=p;

  const minBits=new Uint8Array(k),maxBits=new Uint8Array(k),symBits=new Array(k);
  for(let p=0;p<k;p++){
    const i=constrainedIdx[p];
    minBits[p]=(consts[i].min??0)?1:0;
    maxBits[p]=(consts[i].max??INF)===0?0:1;
    symBits[p]=consts[i].s;
  }

  REQ_MASK=0;
  for(let p=0;p<k;p++){
    if(minBits[p]) REQ_MASK |= (1<<p);
  }
  REQ_POP = REQ_MASK ? popcnt32(REQ_MASK) : 0;

  const EMPTY=new Uint16Array(0);
  let tCount=0,minT=null,maxT=null,symT=null;
  if(!useBitmask){
    tCount=constrainedIdx.length;
    minT=new Uint16Array(tCount);
    maxT=new Uint16Array(tCount);
    symT=new Array(tCount);
    for(let p=0;p<tCount;p++){
      const i=constrainedIdx[p];
      minT[p]=Math.min(INF,Math.max(0,consts[i].min??0));
      maxT[p]=Math.min(INF,Math.max(0,consts[i].max??INF));
      symT[p]=consts[i].s;
    }
  }

  function maskOk(m){for(let p=0;p<k;p++)if(minBits[p]&&((m>>p)&1)===0)return false;return true;}
  function maskStr(m){
    if(!showCounts||k===0)return"";
    const p=[];for(let i=0;i<k;i++)p.push(symBits[i]+":"+((m>>i)&1));
    return"["+p.join(", ")+"]";
  }
  function cntOk(c){for(let i=0;i<tCount;i++)if(c[i]<minT[i])return false;return true;}
  function cntStr(c){
    if(!showCounts||tCount===0)return"";
    const p=[];for(let i=0;i<tCount;i++)p.push(symT[i]+":"+c[i]);
    return"["+p.join(", ")+"]";
  }
  function addCnt(a,b){
    if(tCount===0)return EMPTY;
    const o=new Uint16Array(tCount);
    for(let i=0;i<tCount;i++){
      const s=a[i]+b[i];
      if(s>maxT[i])return null;
      o[i]=s;
    }
    return o;
  }
  function ckFromCnt(cnt){
    let s="";for(let i=0;i<tCount;i++)s+=String.fromCharCode(cnt[i]);return s;
  }
  function cntFromCk(ck){
    const out=new Uint16Array(tCount);
    for(let i=0;i<tCount;i++)out[i]=ck.charCodeAt(i)||0;
    return out;
  }
  const runtimeMode=noConstraintFast?"unconstrained":(useBitmask?"bitmask":"counts");
  function combMask(a,b){return(a&b)?-1:(a|b);}

  const t0=performance.now();
  let lastEmit=t0;
  let visited=0,meetConfirmed=0,meetLookups=0,meetCandidates=0;
  let pruned=0,reEvalFixed=0,dupesKilled=0;
  let meetDbg={
    revIdxKeys:0,revIdxItems:0,fwdIdxKeys:0,fwdIdxItems:0,
    keyHits:0,pairsTried:0,rev2fwdPairs:0,
    rejMaskOverlap:0,rejCntLimit:0,rejEpsCand:0,rejEvalNaN:0,
    rejProbeConfirm:0,rejConfirm:0,revInvBad:0,maxConfirmErr:0,
  };

  const best=[];
  const bestSeen=new Map();

  function emit(c){
    const now=performance.now();
    if(now-lastEmit>=emitInterval){
      lastEmit=now;
      postMessage({type:"progress",payload:{
        elapsed:Math.round(now-t0),maxC,c,
        visited,pruned,
        meetLookups,meetCandidates,meetConfirmed,
        meetDbg,
        reEvalFixed,dupesKilled,
        mode:runtimeMode,
        mt:(mt&&threads>1)?("ON("+threads+")"):"OFF",
        profile:mode,
        beamF,beamR,
        best:best.slice(0,outN)
      }});
    }
  }

  function maybeStopOnExact(delta){
    const scale=Math.max(1,Math.abs(T));
    if(Math.abs(delta) <= EXACT_EPS*scale){
      stopFlag=true;
    }
  }

  function collectLeaves(ast, out){
    if(!ast) return out;
    if(ast.t===0){ out.push(String(ast.sym)); return out; }
    if(ast.t===1) return collectLeaves(ast.ch,out);
    collectLeaves(ast.l,out); collectLeaves(ast.r,out);
    return out;
  }

  function pushBest(obj){
    let v=obj.v;
    if(obj.ast){
      const tv=evalA(obj.ast);
      if(!Number.isFinite(tv)||Math.abs(tv)>CAP)return;
      if(Math.abs(tv-v)>1e-12)reEvalFixed++;
      v=tv;
    }
    const acc=relAcc(v,T);
    if(excludeExact&&acc==="exact")return;
    if(useBitmask){if(!maskOk(obj.mask||0))return;}
    else{if(obj.cnt&&!cntOk(obj.cnt))return;}

    // leafOrder constraint final check too
    if(LEAF_ORDER && obj.ast && obj.ast.ord && !obj.ast.ord.ok) return;

    const expr=obj.ast?strA(obj.ast):(obj.s||"?");
    const latex=obj.ast?latexA(obj.ast):expr;
    const delta=v-T;
    const ci=useBitmask?maskStr(obj.mask||0):cntStr(obj.cnt||EMPTY);
    const leaves = obj.ast ? collectLeaves(obj.ast, []) : [];

    if(customAllow){
      try{
        const ok=customAllow({expr,latex,v,delta,cost:obj.cost,searchType:(obj.searchType||"fwd"),hasPow:!!(obj.ast&&obj.ast.p),countsInfo:ci,leaves});
        if(ok===false)return;
      }catch(_e){return;}
    }

    const scoreAdj=customScoreAdjust?Number(customScoreAdjust({expr,latex,v,delta,cost:obj.cost,searchType:(obj.searchType||"fwd"),hasPow:!!(obj.ast&&obj.ast.p),countsInfo:ci,leaves})||0):0;
    const valKey=v.toPrecision(BESTP);
    const type=obj.searchType||"fwd";
    const hasPow=!!(obj.ast&&obj.ast.p);
    const keyBase=mp.keepMeetDup?(valKey+"|"+type):valKey;
    const key=hasPow?(keyBase+"|pow"):keyBase;

    const idx=bestSeen.get(key);
    if(idx!==undefined){
      const old=best[idx];
      const newCost=(obj.cost||999);
      const oldDelta=Math.abs(old?.delta??INF);
      const newDelta=Math.abs(delta)-scoreAdj;
      const oldPow=old?!!old.hasPow:false;
      const newPow=hasPow;
      const powPrefer=(!oldPow&&newPow&&newDelta<=oldDelta*1.000002&&newCost<=(old?.cost??INF)+4);

      const oldType=old?.searchType||"fwd";
      const meetPrefer=(oldType!=="meet" && type==="meet" && Math.abs(oldDelta-newDelta)<=1e-12 && newCost<=(old?.cost??INF)+2);

      if(old && !powPrefer && !meetPrefer && (oldDelta<newDelta||(oldDelta===newDelta&&old.cost<=newCost))){
        dupesKilled++;return;
      }
      best[idx]={expr,latex,v,delta,acc,cost:obj.cost,countsInfo:ci,searchType:type,hasPow};
      best.sort((a,b)=>(Math.abs(a.delta)-Math.abs(b.delta))||(a.cost-b.cost));
      if(acc==="exact") maybeStopOnExact(delta);
      return;
    }

    best.push({expr,latex,v,delta,acc,cost:obj.cost,countsInfo:ci,searchType:type,hasPow});
    best.sort((a,b)=>(Math.abs(a.delta)-Math.abs(b.delta))||(a.cost-b.cost));
    if(best.length>outN*4)best.length=outN*3;

    bestSeen.clear();
    for(let i=0;i<best.length;i++){
      const vk=best[i].v.toPrecision(BESTP);
      const hasPowBest=!!best[i].hasPow;
      const kkBase=mp.keepMeetDup?(vk+"|"+(best[i].searchType||"fwd")):vk;
      const kk=hasPowBest?(kkBase+"|pow"):kkBase;
      bestSeen.set(kk,i);
    }

    if(acc==="exact") maybeStopOnExact(delta);
  }

  const fwd=Array.from({length:maxC+1},()=>[]);
  const rev=Array.from({length:maxC+1},()=>[]);
  const revIdx=new Map();
  const fwdIdx=new Map();

  function idxInsert(map,key,it,cap){
    let arr=map.get(key);
    if(!arr){arr=[];map.set(key,arr);}
    if(arr.length<cap){arr.push(it);return;}
    let wi=0;
    for(let i=1;i<arr.length;i++){
      const a=arr[i], w=arr[wi];
      if( (a.cost>w.cost) || (a.cost===w.cost && (a.keep??INF)>(w.keep??INF)) ) wi=i;
    }
    const w=arr[wi];
    if( (it.cost<w.cost) || (it.cost===w.cost && (it.keep??INF)<(w.keep??INF)) ){
      arr[wi]=it;
    }
  }

  function addRevIdx(items){
    const cap=Math.max(8,mp.revIdxKeyCap|0||120);
    for(const it of items){
      const k2=it.mkey || (it.mkey = meetPrimaryKey(it.v));
      idxInsert(revIdx,k2,it,cap);
    }
    meetDbg.revIdxKeys=revIdx.size;
    let total=0;for(const v of revIdx.values())total+=v.length;
    meetDbg.revIdxItems=total;
  }

  function addFwdIdx(items){
    const cap=Math.max(8,mp.fwdIdxKeyCap|0||120);
    for(const it of items){
      const k2=it.mkey || (it.mkey = meetPrimaryKey(it.v));
      idxInsert(fwdIdx,k2,it,cap);
    }
    meetDbg.fwdIdxKeys=fwdIdx.size;
    let total=0;for(const v of fwdIdx.values())total+=v.length;
    meetDbg.fwdIdxItems=total;
  }

  function keepScore(goal,bb,revHit,mask){
    let keep=(mp.keepMode==="goal")?goal:Math.min(goal,bb);
    if(revHit)keep*=(1.0-(mp.meetHitBonus||0));
    if(useBitmask && REQ_POP>0) keep *= reqAdj(mask|0);
    return keep;
  }

  const keyOf=(v,mask,ck)=>{
    const vk=vKey(v);
    if(useBitmask) return vk+"|"+(mask|0);
    if(tCount===0) return vk;
    return vk+"|"+(ck||"");
  };

  function meetKeysCached(node){
    if(node.mkeys) return node.mkeys;
    const ks = meetKeys(node.v);
    node.mkeys = ks;
    return ks;
  }

  // init layer c=1
  {
    const{bucket,put}=mkBucket(beamF,mp.spillMul);
    for(let i=0;i<nC;i++){
      const v=consts[i].v;visited++;
      if(!Number.isFinite(v)||Math.abs(v)>CAP)continue;
      const goal=Math.abs(v-T);
      const bb=bbScore(v,mp.bbD,mp.bbMagA);
      const mk = bidir ? meetPrimaryKey(v) : "";
      const revHit=bidir?revIdx.has(mk):false;

      if(useBitmask){
        const bit=idx2bit[i];
        let mask=0;
        if(bit>=0){if(!maxBits[bit])continue;mask=1<<bit;}
        const keep=keepScore(goal,bb,revHit,mask);
        const flags=mkFlags(v,TAG_NONE,true);
        const ast=mkC(consts[i].s,v,ordLeaf(consts[i].s));
        if(LEAF_ORDER && ast.ord && !ast.ord.ok) continue;
        put(keyOf(v,mask,""),{v,goal,bb,keep,ast,mask,flags,mkey:mk});
      }else{
        let cnt=EMPTY;
        const pos=idx2bit[i];
        if(pos>=0){cnt=new Uint16Array(tCount);cnt[pos]=1;if(cnt[pos]>maxT[pos])continue;}
        const ck=tCount?ckFromCnt(cnt):"";
        const keep=(mp.keepMode==="goal")?goal:Math.min(goal,bb);
        const flags=mkFlags(v,TAG_NONE,true);
        const ast=mkC(consts[i].s,v,ordLeaf(consts[i].s));
        if(LEAF_ORDER && ast.ord && !ast.ord.ok) continue;
        put(keyOf(v,0,ck),{v,goal,bb,keep,ast,cnt,ck,flags,mkey:mk});
      }
    }

    const items=Array.from(bucket.values());
    for(const it of items){it.hasPow=!!(it.ast&&it.ast.p);it.hasFunc=!!(it.ast&&it.ast.f);it.depth=astDepth(it.ast);}
    const picked=selectTop(items,beamF,divRatio,mp,(bidir?revIdx:null),Array.isArray(opsBin)&&opsBin.includes("^"),useBitmask);
    for(const it of picked){it.cost=1;}
    fwd[1]=picked;
    addFwdIdx(fwd[1]);

    for(const e of fwd[1]){e.searchType="fwd";pushBest({v:e.v,ast:e.ast,mask:e.mask,cnt:e.cnt,cost:1,searchType:"fwd"});}
    emit(1);
  }

  // seed reverse
  if(bidir){
    const seedMask=0;
    const seedCnt=tCount?new Uint16Array(tCount):EMPTY;
    const seedCk=tCount?ckFromCnt(seedCnt):"";
    const mk = meetPrimaryKey(T);
    rev[0]=[{v:T,wA:(a)=>a,mask:seedMask,cnt:seedCnt,ck:seedCk,flags:mkFlags(T,TAG_NONE,true),cost:0,score:0,srcOp:"seed",mkey:mk}];
    addRevIdx(rev[0]);
  }

  function tryMeetPair(f,r){
    const tc=f.cost+r.cost;
    if(tc>maxC)return;

    if(useBitmask){if((f.mask&r.mask)!==0){meetDbg.rejMaskOverlap++;return;}}
    else{const c=addCnt(f.cnt??EMPTY,r.cnt??EMPTY);if(!c){meetDbg.rejCntLimit++;return;}}

    const scale=Math.max(1,Math.abs(T),Math.abs(f.v),Math.abs(r.v));
    const matchGap=Math.abs(f.v-r.v);

    const isPowRelated = (r.srcOp==="^") || (f.hasPow) || (r.wA && r.srcOp==="pow");
    const binSlack=(MEET_STYLE==="bin")?((mp.binSlackMul??1)*Math.max(1,MEET_R)/Math.max(1,MEET_Q))*scale:0;
    const epsCand=(4e-10*mp.candEpsMul*(isPowRelated?2.8:1.0))*scale+binSlack;
    if(matchGap>epsCand){meetDbg.rejEpsCand++;return;}
    meetCandidates++;

    const probeAST=r.wA?r.wA(mkC("#",f.v,ordLeaf("#"))):mkC("#",f.v,ordLeaf("#"));
    const probeVal=evalA(probeAST);
    if(!Number.isFinite(probeVal)||Math.abs(probeVal)>CAP){meetDbg.rejEvalNaN++;return;}

    const combinedAST=r.wA?r.wA(f.ast):f.ast;

    if(LEAF_ORDER && combinedAST && combinedAST.ord && !combinedAST.ord.ok) return;

    const hasFunc=!!(combinedAST&&combinedAST.f);
    const powStat=astPowStats(combinedAST);
    const powCnt=powStat.cnt;
    const powRisk=powStat.risk;
    const powTighten=Math.min(1.0,(1/(1+0.18*powCnt+0.06*powRisk))*(hasFunc?1.12:1.0));

    const epsProbeBase=(8e-10*mp.confirmEpsMul)*Math.max(1,Math.abs(T),Math.abs(probeVal))*(1+tc*0.03);
    const epsProbeGap=matchGap*(1.7+tc*0.09)*powTighten*(isPowRelated?1.6:1.0);
    const epsProbe=Math.max(epsProbeBase,epsProbeGap,mp.confirmAbsFloor||0);
    const probeErr=Math.abs(probeVal-T);
    if(probeErr>epsProbe){
      meetDbg.rejProbeConfirm++;
      if(probeErr>meetDbg.maxConfirmErr)meetDbg.maxConfirmErr=probeErr;
      return;
    }

    const trueVal=evalA(combinedAST);
    if(!Number.isFinite(trueVal)||Math.abs(trueVal)>CAP){meetDbg.rejEvalNaN++;return;}

    const structuralDrift=Math.abs(trueVal-probeVal);
    const driftCap=matchGap*(3.4+tc*0.18)*(1+powCnt*0.22)/(1+0.10*powRisk)+3e-12*scale;
    if(structuralDrift>driftCap){
      meetDbg.rejProbeConfirm++;
      if(structuralDrift>meetDbg.maxConfirmErr)meetDbg.maxConfirmErr=structuralDrift;
      return;
    }

    const epsConfirmBase=(7e-10*mp.confirmEpsMul)*Math.max(1,Math.abs(T),Math.abs(trueVal))*(1+tc*0.025);
    const epsConfirmGap=matchGap*(2.2+tc*0.11)*powTighten*(isPowRelated?1.5:1.0);
    const epsConfirm=Math.max(epsConfirmBase,epsConfirmGap,mp.confirmAbsFloor||0);
    const err=Math.abs(trueVal-T);
    if(err>epsConfirm){
      meetDbg.rejConfirm++;
      if(err>meetDbg.maxConfirmErr)meetDbg.maxConfirmErr=err;
      return;
    }

    if(powCnt>0){
      const stableVal=evalAStable(combinedAST);
      if(!Number.isFinite(stableVal)||Math.abs(stableVal)>CAP){meetDbg.rejEvalNaN++;return;}
      const stableGap=Math.abs(stableVal-trueVal);
      const stableCap=Math.max(3e-12*scale,matchGap*(0.55+tc*0.03)/(1+0.22*powRisk));
      if(stableGap>stableCap){
        meetDbg.rejConfirm++;
        if(stableGap>meetDbg.maxConfirmErr)meetDbg.maxConfirmErr=stableGap;
        return;
      }
    }

    meetConfirmed++;
    if(useBitmask){
      pushBest({v:trueVal,ast:combinedAST,mask:(f.mask|r.mask),cost:tc,searchType:"meet"});
    }else{
      const cnt=addCnt(f.cnt??EMPTY,r.cnt??EMPTY);
      pushBest({v:trueVal,ast:combinedAST,cnt,cost:tc,searchType:"meet"});
    }
  }

  function tryMeetReverseWithFwdIdx(r){
    if(!bidir)return;
    const keys = meetKeysCached(r);
    meetLookups+=keys.length;
    let seen=null;
    if(keys.length>1)seen=new Set();
    const limKey=Math.max(8,mp.meetKeyProbeCap|0||120);

    for(const k2 of keys){
      if(seen){if(seen.has(k2))continue;seen.add(k2);}
      const fl=fwdIdx.get(k2);
      if(!fl)continue;
      meetDbg.keyHits++;
      const lim2=Math.min(fl.length,limKey);
      for(let i=0;i<lim2;i++){
        meetDbg.rev2fwdPairs++;
        meetDbg.pairsTried++;
        tryMeetPair(fl[i],r);
        if(stopFlag) return;
      }
    }
  }

  function tryMeetFwdWithRevIdx(f){
    if(!bidir)return;
    const keys = meetKeysCached(f);
    meetLookups+=keys.length;
    let seen=null;
    if(keys.length>1)seen=new Set();
    for(const k2 of keys){
      if(seen){if(seen.has(k2))continue;seen.add(k2);}
      const rl=revIdx.get(k2);
      if(!rl)continue;
      meetDbg.keyHits++;
      const lim2=Math.min(rl.length,Math.max(8,mp.meetKeyProbeCap|0||120));
      for(let i=0;i<lim2;i++){
        meetDbg.pairsTried++;
        tryMeetPair(f,rl[i]);
        if(stopFlag) return;
      }
    }
  }
  
// [æ’å…¥ä½ç½®ï¼šåœ¨ tryMeetFwdWithRevIdx å‡½æ•°ç»“æŸåï¼ŒbuildRev å‡½æ•°å¼€å§‹å‰]

  // --- æ ¸å¿ƒå¢å¼ºï¼šç›®æ ‡åˆ†è§£ (Target Decomposition) ---
  // è¿™è®©ç®—æ³•èƒ½åˆ©ç”¨å·²æœ‰çš„æ­£å‘ç»“æœï¼Œè‡ªæˆ‘ç»„åˆå‡º A^B=T, A*B=T, A+B=T
  function tryTargetDecomposition(layerItems, T){
    // å¦‚æœæ­£å‘ç´¢å¼•å¤ªå°‘ï¼Œæˆ–è€…ç›®æ ‡Tæ— æ•ˆï¼Œè·³è¿‡
    if(fwdIdx.size < 10 || !Number.isFinite(T)) return;
    
    const absT = Math.abs(T);
    const logT = (T > 0) ? Math.log(T) : NaN;
    
    // éå†å½“å‰å±‚ç”Ÿæˆçš„æ‰€æœ‰æ–°å…ƒç´ 
    for(const item of layerItems){
      const v = item.v;
      if(!Number.isFinite(v)) continue;
      const absV = Math.abs(v);

      // ç­–ç•¥1ï¼šå¯»æ‰¾ä¹˜æ³•ä¼™ä¼´ (v * X = T  =>  X = T/v)
      // ä¾‹å¦‚ï¼šå¦‚æœç›®æ ‡æ˜¯ 100ï¼Œå½“å‰ç®—å‡ºäº† 25ï¼Œæˆ‘ä»¬å»å†å²åº“é‡Œæ‰¾æœ‰æ²¡æœ‰ 4
      if(HAS_MUL && absV > 1e-9){
        const targetX = T / v;
        // å‰ªæï¼šå¦‚æœ targetX å¤ªå¤§æˆ–å¤ªå°ï¼Œåº“é‡Œè‚¯å®šæ²¡æœ‰ï¼Œè·³è¿‡
        if(Math.abs(targetX) <= CAP) {
          tryMeetDecomp(item, targetX, "*", (a,b)=>mkB("*",a,b));
        }
      }

      // ç­–ç•¥2ï¼šå¯»æ‰¾å¹‚æ¬¡ä¼™ä¼´ (A^B = T)
      if(logT){ // å‰æï¼šTå¿…é¡»æ˜¯æ­£æ•°
        // æƒ…å†µAï¼šå½“å‰ item æ˜¯åº•æ•° (v^X = T => X = ln(T)/ln(v))
        // è¦æ±‚ï¼šv > 0 ä¸” v != 1
        if(v > 1e-9 && Math.abs(v-1) > 1e-9){
          const lnV = Math.log(v);
          const targetX = logT / lnV;
          if(Math.abs(targetX) <= CAP) {
            tryMeetDecomp(item, targetX, "^base", (a,b)=>mkB("^",a,b));
          }
        }

        // æƒ…å†µBï¼šå½“å‰ item æ˜¯æŒ‡æ•° (X^v = T => X = T^(1/v))
        // è¦æ±‚ï¼šv != 0
        if(absV > 1e-9){
          // æ³¨æ„ï¼šMath.pow(T, 1/v) å¯èƒ½ä¼šäº§ç”Ÿå¤æ•°æˆ–NaNï¼Œè¿™é‡Œåªå¤„ç†å®æ•°ç»“æœ
          // JSçš„ pow(æ­£æ•°, ä»»æ„æ•°) æ€»æ˜¯å®‰å…¨çš„å®æ•°
          const targetX = Math.pow(T, 1/v);
          if(Number.isFinite(targetX) && Math.abs(targetX) <= CAP){
            tryMeetDecomp(item, targetX, "^exp", (a,b)=>mkB("^",b,a)); // æ³¨æ„é¡ºåºï¼šbæ˜¯åº•æ•°
          }
        }
      }
      
      if(stopFlag) return;
    }
  }

  // è¾…åŠ©å‡½æ•°ï¼šåœ¨æ­£å‘å†å²åº“ä¸­æ¨¡ç³ŠæŸ¥æ‰¾ targetVal
  function tryMeetDecomp(itemA, targetVal, type, astBuilder){
    // ä½¿ç”¨ meetKeys ç”Ÿæˆæ¨¡ç³Šé”®ï¼ˆå¤„ç†ç²¾åº¦è¯¯å·®ï¼‰
    const keys = meetKeys(targetVal);
    
    for(const k of keys){
      const matches = fwdIdx.get(k);
      if(!matches) continue;
      
      for(const itemB of matches){
        // ä¸¥æ ¼çš„åŒé‡éªŒè¯ï¼šæ•°å€¼å¿…é¡»éå¸¸æ¥è¿‘
        if(Math.abs(itemB.v - targetVal) < 1e-7 * Math.max(1, Math.abs(targetVal))){
           
           // é¿å…è‡ªèº«ç»„åˆ (ä¾‹å¦‚ x^x, x*x)ï¼Œé™¤éé€»è¾‘å…è®¸
           // ä¸€èˆ¬æ¥è¯´ï¼Œä¸åŒå¤æ‚åº¦çš„é¡¹ç»„åˆæ›´æœ‰æ„ä¹‰
           
           // æ„å»º AST
           let ast;
           if(type === "^exp") ast = astBuilder(itemA.ast, itemB.ast); // itemB is Base, itemA is Exp
           else ast = astBuilder(itemA.ast, itemB.ast);
           
           if(LEAF_ORDER && ast.ord && !ast.ord.ok) continue;
           
           // ä¼°ç®—æ–°æˆæœ¬ï¼šä¸¤ä¸ªç»„ä»¶çš„æˆæœ¬ + æ“ä½œç¬¦æˆæœ¬
           const opCost = (type.startsWith("^") ? 3 : (type==="*" ? 2 : 1)); 
           const newCost = itemA.cost + itemB.cost + opCost;
           
           // åªæœ‰å½“æ€»æˆæœ¬ä¸å¤ªç¦»è°±æ—¶æ‰æäº¤
           if(newCost <= maxC + 3){
             // è®¡ç®—ç²¾ç¡®å€¼
             const trueVal = evalA(ast);
             if(!Number.isFinite(trueVal)) continue;
             
             // æäº¤ç»“æœ (ä½¿ç”¨ "meet" ç±»å‹)
             pushBest({
               v: trueVal, 
               ast: ast, 
               cost: newCost, 
               searchType: "meet", 
               mask: (itemA.mask | itemB.mask)
             });
           }
        }
      }
    }
  }

  function buildRev(c){
    if(!bidir)return;
    const{bucket,put}=mkBucket(beamR,mp.spillMul);
    const revScore=(v)=>Math.log1p(Math.abs(v));

    for(const op of opsUn){
      const w=wUn(op),sc=c-w;
      if(sc<0||!rev[sc]||!rev[sc].length)continue;
      const src=rev[sc];
      const lim2=Math.min(src.length,beamR);
      for(let i=0;i<lim2;i++){
        const a=src[i];
        if(pruneEquiv&&pruneUn(op,a.flags,a.v)){pruned++;continue;}
        const invs=invUn(op,a.v);
        for(const inv of invs){
          visited++;
          const v=inv.v;
          if(!Number.isFinite(v)||Math.abs(v)>CAP)continue;
          const out=applyUn(op,v);
          const s=Math.max(1,Math.abs(a.v),Math.abs(out));
          if(!Number.isFinite(out)||Math.abs(out-a.v)>1e-10*s){meetDbg.revInvBad++;continue;}
          const nf=mkFlags(v,opTag(op),false);
          const pW=a.wA;
          const nW=pW?(fa=>pW(mkU(op,fa))):(fa=>mkU(op,fa));
          const score=revScore(v);
          const mk = meetPrimaryKey(v);
          const cand = useBitmask
            ? {v,wA:nW,mask:a.mask,flags:nf,keep:score,goal:score,bb:score,cost:c,srcOp:op,mkey:mk}
            : {v,wA:nW,cnt:a.cnt,ck:(a.ck||""),flags:nf,keep:score,goal:score,bb:score,cost:c,srcOp:op,mkey:mk};

          if(LEAF_ORDER && cand.wA){
            // leafOrder applies when combined; not here
          }

          put(keyOf(v,useBitmask?cand.mask:0,useBitmask?"":cand.ck),cand);
          if(op==="inv"||op==="sqrt") tryMeetReverseWithFwdIdx(cand);
          if(stopFlag) return;
        }
      }
    }

    const sBin=opsBin.slice(); // include custom binary too
    for(const op of sBin){
      const w=wBin(op);
      for(let rc=0;rc<=c-w-1;rc++){
        const fc=c-w-rc;
        const rs=rev[rc],fs=fwd[fc];
        if(!rs||!fs||!rs.length||!fs.length)continue;

        const base=Math.floor(Math.sqrt(beamR));
        const isPow = (op==="^");
        const laneMul=isPow?6.0:3.0;
        const laneMin=isPow?360:140;
        const cR=Math.min(rs.length,Math.max(laneMin,Math.floor(base*laneMul)));
        const cF=Math.min(fs.length,Math.max(laneMin,Math.floor(base*laneMul)));

        for(let ir=0;ir<cR;ir++){
          const r=rs[ir];
          for(let jf=0;jf<cF;jf++){
            const f=fs[jf];visited++;

            const x1=invBinR(op,r.v,f.v);
            if(Number.isFinite(x1)&&Math.abs(x1)<=CAP){
              const out1=applyBin(op,f.v,x1);
              const s1=Math.max(1,Math.abs(r.v),Math.abs(out1));
              if(!Number.isFinite(out1)||Math.abs(out1-r.v)>1e-10*s1){meetDbg.revInvBad++;}
              else if(useBitmask){
                const m=combMask(f.mask,r.mask);
                if(m>=0){
                  const pW=r.wA,fA=f.ast;
                  const nW=pW?(fa=>pW(mkB(op,fA,fa))):(fa=>mkB(op,fA,fa));
                  const score=revScore(x1)*(isPow?0.40:1.0);
                  const mk = meetPrimaryKey(x1);
                  const cand={v:x1,wA:nW,mask:m,flags:mkFlags(x1,TAG_NONE,false,extraBinFlags(r.flags,f.flags)),keep:score,goal:score,bb:score,cost:c,srcOp:op,mkey:mk};
                  put(keyOf(x1,m,""),cand);
                  if(isPow) tryMeetReverseWithFwdIdx(cand);
                  if(stopFlag) return;
                }
              }else{
                const cnt=addCnt(f.cnt??EMPTY,r.cnt??EMPTY);
                if(cnt){
                  const ck=ckFromCnt(cnt);
                  const pW=r.wA,fA=f.ast;
                  const nW=pW?(fa=>pW(mkB(op,fA,fa))):(fa=>mkB(op,fA,fa));
                  const score=revScore(x1)*(isPow?0.40:1.0);
                  const mk = meetPrimaryKey(x1);
                  const cand={v:x1,wA:nW,cnt,ck,flags:mkFlags(x1,TAG_NONE,false,extraBinFlags(r.flags,f.flags)),keep:score,goal:score,bb:score,cost:c,srcOp:op,mkey:mk};
                  put(keyOf(x1,0,ck),cand);
                  if(isPow) tryMeetReverseWithFwdIdx(cand);
                  if(stopFlag) return;
                }
              }
            }

            if(!isComm(op)){
              const x2=invBinL(op,r.v,f.v);
              if(Number.isFinite(x2)&&Math.abs(x2)<=CAP){
                const out2=applyBin(op,x2,f.v);
                const s2=Math.max(1,Math.abs(r.v),Math.abs(out2));
                if(!Number.isFinite(out2)||Math.abs(out2-r.v)>1e-10*s2){meetDbg.revInvBad++;}
                else if(useBitmask){
                  const m=combMask(f.mask,r.mask);
                  if(m>=0){
                    const pW=r.wA,fA=f.ast;
                    const nW=pW?(fa=>pW(mkB(op,fa,fA))):(fa=>mkB(op,fa,fA));
                    const score=revScore(x2)*(isPow?0.40:1.0);
                    const mk = meetPrimaryKey(x2);
                    const cand={v:x2,wA:nW,mask:m,flags:mkFlags(x2,TAG_NONE,false,extraBinFlags(r.flags,f.flags)),keep:score,goal:score,bb:score,cost:c,srcOp:op,mkey:mk};
                    put(keyOf(x2,m,""),cand);
                    if(isPow) tryMeetReverseWithFwdIdx(cand);
                    if(stopFlag) return;
                  }
                }else{
                  const cnt=addCnt(f.cnt??EMPTY,r.cnt??EMPTY);
                  if(cnt){
                    const ck=ckFromCnt(cnt);
                    const pW=r.wA,fA=f.ast;
                    const nW=pW?(fa=>pW(mkB(op,fa,fA))):(fa=>mkB(op,fa,fA));
                    const score=revScore(x2)*(isPow?0.40:1.0);
                    const mk = meetPrimaryKey(x2);
                    const cand={v:x2,wA:nW,cnt,ck,flags:mkFlags(x2,TAG_NONE,false,extraBinFlags(r.flags,f.flags)),keep:score,goal:score,bb:score,cost:c,srcOp:op,mkey:mk};
                    put(keyOf(x2,0,ck),cand);
                    if(isPow) tryMeetReverseWithFwdIdx(cand);
                    if(stopFlag) return;
                  }
                }
              }
            }

            if(stopFlag) return;
          }
        }
      }
    }

    const items=Array.from(bucket.values());
    items.sort((a,b)=>a.keep-b.keep);
    const picked=items.slice(0,beamR);
    for(const it of picked){it.cost=c;}
    rev[c]=picked;
    addRevIdx(rev[c]);
  }

  function meetSweepWithNewReverseLayer(rc){
    if(!bidir)return;
    const rr=rev[rc];
    if(!rr||!rr.length)return;

    let powCnt=0;
    const rProbe=Math.min(rr.length,80);
    for(let i=0;i<rProbe;i++) if(rr[i].srcOp==="^") powCnt++;
    const powFrac = rProbe? (powCnt/rProbe) : 0;

    const sweepMul = (powFrac>0.10) ? (mp.meetSweepPowMul||mp.meetSweepMul) : (mp.meetSweepMul||0.1);
    const perLayerCap=Math.max(32,Math.floor(beamF*sweepMul));

    const rLim=Math.min(rr.length,Math.max(12,mp.meetSweepRevCap|0||160));
    const maxFc=Math.min(maxC-rc,rc);
    if(maxFc<1||rLim<1)return;

    const localIdx=new Map();
    for(let j=0;j<rLim;j++){
      const r=rr[j];
      const k2=r.mkey || (r.mkey = meetPrimaryKey(r.v));
      let arr=localIdx.get(k2);
      if(!arr){arr=[];localIdx.set(k2,arr);}
      arr.push(r);
    }

    for(let fc=1;fc<=maxFc;fc++){
      const ff=fwd[fc];
      if(!ff||!ff.length)continue;
      const lim2=Math.min(ff.length,perLayerCap);
      for(let i=0;i<lim2;i++){
        const f=ff[i];
        const keys = meetKeysCached(f);
        meetLookups+=keys.length;
        let seen=null;
        if(keys.length>1)seen=new Set();
        for(const k2 of keys){
          if(seen){if(seen.has(k2))continue;seen.add(k2);}
          const rl=localIdx.get(k2);
          if(!rl)continue;
          meetDbg.keyHits++;
          for(let j=0;j<rl.length;j++){
            meetDbg.pairsTried++;
            tryMeetPair(f,rl[j]);
            if(stopFlag) return;
          }
        }
      }
    }
  }

  // MT pool (custom ops supported)
  let subWorkers=[];
  async function initSubWorkers(){
    if(!(mt&&threads>1))return;
    if(!subSrc)return;
    const url=URL.createObjectURL(new Blob([subSrc],{type:"text/javascript"}));
    subWorkers=Array.from({length:threads-1},()=>new Worker(url));

    const initMsg={
      type:"init",keyPrec:KEYP,useBitmask,noConstraintFast,tCount,
      maxT:useBitmask?null:(maxT?Array.from(maxT):null),
      opsUn,opsBin,pruneEquiv,needZero:NEED_ZERO,needOne:NEED_ONE,
      hasNeg:HAS_NEG,hasSub:HAS_SUB,hasDiv:HAS_DIV,hasMul:HAS_MUL,
      reqMask:REQ_MASK, reqPop:REQ_POP,
      leafOrder:LEAF_ORDER,
      customUnary, customBinary
    };

    await Promise.all(subWorkers.map(w=>new Promise((resolve)=>{
      const h=(ev)=>{if(ev.data?.type==="inited"){w.removeEventListener("message",h);resolve();}};
      w.addEventListener("message",h);
      w.postMessage(initMsg);
    })));
    sendLayerToSubs(1);
  }
  function termSubWorkers(){for(const w of subWorkers)w.terminate();subWorkers=[];}

  function packLayer(cost){
    const src=fwd[cost];
    const lim2=Math.min(src.length,subLayerCap);
    const v=new Float64Array(lim2);
    const flags=new Int32Array(lim2);
    const ordHas = LEAF_ORDER ? new Uint8Array(lim2) : null;
    const ordOk  = LEAF_ORDER ? new Uint8Array(lim2) : null;
    const ordMin = LEAF_ORDER ? new Int32Array(lim2) : null;
    const ordMax = LEAF_ORDER ? new Int32Array(lim2) : null;

    if(useBitmask){
      const mask=new Int32Array(lim2);
      for(let i=0;i<lim2;i++){
        const it=src[i];
        v[i]=it.v;mask[i]=it.mask|0;flags[i]=it.flags|0;
        if(LEAF_ORDER){
          const o=it.ast?.ord;
          ordHas[i]=o?.has?1:0;
          ordOk[i]=o?.ok?1:0;
          ordMin[i]=o?.mn|0;
          ordMax[i]=o?.mx|0;
        }
      }
      const layer={len:lim2,v,mask,flags};
      if(LEAF_ORDER){ layer.ordHas=ordHas; layer.ordOk=ordOk; layer.ordMin=ordMin; layer.ordMax=ordMax; }
      return layer;
    }else{
      if(noConstraintFast){
        for(let i=0;i<lim2;i++){
          const it=src[i];
          v[i]=it.v;flags[i]=it.flags|0;
          if(LEAF_ORDER){
            const o=it.ast?.ord;
            ordHas[i]=o?.has?1:0; ordOk[i]=o?.ok?1:0; ordMin[i]=o?.mn|0; ordMax[i]=o?.mx|0;
          }
        }
        const layer={len:lim2,v,flags};
        if(LEAF_ORDER){ layer.ordHas=ordHas; layer.ordOk=ordOk; layer.ordMin=ordMin; layer.ordMax=ordMax; }
        return layer;
      }
      const cnt=new Uint16Array(lim2*tCount);
      for(let i=0;i<lim2;i++){
        const it=src[i];
        v[i]=it.v;flags[i]=it.flags|0;
        const base=i*tCount;
        const cvec=it.cnt;
        for(let j=0;j<tCount;j++)cnt[base+j]=cvec[j];
        if(LEAF_ORDER){
          const o=it.ast?.ord;
          ordHas[i]=o?.has?1:0; ordOk[i]=o?.ok?1:0; ordMin[i]=o?.mn|0; ordMax[i]=o?.mx|0;
        }
      }
      const layer={len:lim2,v,cnt,flags};
      if(LEAF_ORDER){ layer.ordHas=ordHas; layer.ordOk=ordOk; layer.ordMin=ordMin; layer.ordMax=ordMax; }
      return layer;
    }
  }
  function sendLayerToSubs(cost){
    if(subWorkers.length===0)return;
    const layer=packLayer(cost);
    for(const w of subWorkers){w.postMessage({type:"setLayer",cost,layer});}
  }

  async function computeLayerMT(c,capUn,capBin){
    const{bucket,put}=mkBucket(beamF,mp.spillMul);
    const W=subWorkers.length+1;
    const allowPow=Array.isArray(opsBin)&&opsBin.includes("^");

    // main-thread stripe 0 (simple)
    for(const op of opsUn){
      const w=wUn(op),sc=c-w;
      if(sc<1)continue;
      const src=fwd[sc];if(!src||!src.length)continue;
      const lim2=Math.min(src.length,capUn);
      for(let i=0;i<lim2;i+=W){
        const a=src[i];
        if(pruneEquiv&&pruneUn(op,a.flags,a.v)){pruned++;continue;}
        const v=applyUn(op,a.v);visited++;
        if(!Number.isFinite(v)||Math.abs(v)>CAP)continue;
        const goal=Math.abs(v-T);
        const bb=bbScore(v,mp.bbD,mp.bbMagA);
        const mk = bidir ? meetPrimaryKey(v) : "";
        const revHit=bidir?revIdx.has(mk):false;
        const ast=mkU(op,a.ast);
        if(LEAF_ORDER && ast.ord && !ast.ord.ok) continue;

        if(useBitmask){
          const keep=keepScore(goal,bb,revHit,a.mask);
          put(keyOf(v,a.mask,""),{v,goal,bb,keep,ast,mask:a.mask,flags:mkFlags(v,opTag(op),false,extraUnFlags(op,a.flags)),mkey:mk});
        }else{
          const keep=(mp.keepMode==="goal")?goal:Math.min(goal,bb);
          put(keyOf(v,0,a.ck),{v,goal,bb,keep,ast,cnt:a.cnt,ck:a.ck,flags:mkFlags(v,opTag(op),false,extraUnFlags(op,a.flags)),mkey:mk});
        }
      }
    }

    for(const op of opsBin){
      const w=wBin(op),rem=c-w;
      if(rem<2)continue;
      const comm=isComm(op);
      const icMax = comm ? Math.floor(rem/2) : (rem-1);
      for(let ic=1;ic<=icMax;ic++){
        const jc=rem-ic;
        const A=fwd[ic],B=fwd[jc];
        if(!A.length||!B.length)continue;
        const cA=Math.min(A.length,capBin),cB=Math.min(B.length,capBin);
        for(let ia=0;ia<cA;ia+=W){
          const a=A[ia];
          const stB=(comm&&ic===jc)?ia:0;
          for(let ib=stB;ib<cB;ib++){
            const b=B[ib];
            if(pruneEquiv&&pruneBin(op,a.flags,b.flags,a.v,b.v)){pruned++;continue;}
            visited++;
            if(useBitmask){
              if((a.mask&b.mask)!==0)continue;
              const mask=a.mask|b.mask;
              const ast=mkB(op,a.ast,b.ast);
              if(LEAF_ORDER && ast.ord && !ast.ord.ok) continue;

              const v=applyBin(op,a.v,b.v);
              if(!Number.isFinite(v)||Math.abs(v)>CAP)continue;
              const goal=Math.abs(v-T);
              const bb=bbScore(v,mp.bbD,mp.bbMagA);
              const mk = bidir ? meetPrimaryKey(v) : "";
              const revHit=bidir?revIdx.has(mk):false;
              const keep=keepScore(goal,bb,revHit,mask);
              put(keyOf(v,mask,""),{v,goal,bb,keep,ast,mask,flags:mkFlags(v,opTag(op),false,extraBinFlags(a.flags,b.flags)),mkey:mk});
            }else{
              const cnt=addCnt(a.cnt??EMPTY,b.cnt??EMPTY);
              if(!cnt)continue;
              const ast=mkB(op,a.ast,b.ast);
              if(LEAF_ORDER && ast.ord && !ast.ord.ok) continue;

              const v=applyBin(op,a.v,b.v);
              if(!Number.isFinite(v)||Math.abs(v)>CAP)continue;
              const goal=Math.abs(v-T);
              const bb=bbScore(v,mp.bbD,mp.bbMagA);
              const mk = bidir ? meetPrimaryKey(v) : "";
              const revHit=bidir?revIdx.has(mk):false;
              const keep=(mp.keepMode==="goal")?goal:Math.min(goal,bb);
              const ck=ckFromCnt(cnt);
              put(keyOf(v,0,ck),{v,goal,bb,keep,ast,cnt,ck,flags:mkFlags(v,opTag(op),false,extraBinFlags(a.flags,b.flags)),mkey:mk});
            }
          }
        }
      }
    }

    const tasks=subWorkers.map((w,idx)=>new Promise((resolve)=>{
      const workerId=idx+1;
      const h=(ev)=>{if(ev.data?.type==="taskDone"){w.removeEventListener("message",h);resolve(ev.data.payload);}};
      w.addEventListener("message",h);
      w.postMessage({
        type:"task",T,c,beam:beamF,
        capUn,capBin,
        workerId,workerCount:W,
        bbD:mp.bbD,bbMagA:mp.bbMagA,
        keepMode: mp.keepMode==="goal" ? "goal" : "min"
      });
    }));
    const results=await Promise.all(tasks);

    for(const res of results){
      visited+=res.visited;
      pruned+=res.pruned;
      for(const it of res.items){
        const v=it.v;
        const mk = bidir ? meetPrimaryKey(v) : "";
        const revHit=bidir?revIdx.has(mk):false;

        if(useBitmask){
          const key=keyOf(v,it.mask,"");
          if(it.kind==="u"){
            const a=fwd[it.ac][it.ai];
            const ast=mkU(it.op,a.ast);
            if(LEAF_ORDER && ast.ord && !ast.ord.ok) continue;
            const keep=keepScore(it.goal,it.bb,revHit,it.mask);
            put(key,{v,goal:it.goal,bb:it.bb,keep,ast,mask:it.mask|0,flags:mkFlags(v,opTag(it.op),false,extraUnFlags(it.op,a.flags)),mkey:mk});
          }else{
            const a=fwd[it.ac][it.ai],b=fwd[it.bc][it.bi];
            const ast=mkB(it.op,a.ast,b.ast);
            if(LEAF_ORDER && ast.ord && !ast.ord.ok) continue;
            const keep=keepScore(it.goal,it.bb,revHit,it.mask);
            put(key,{v,goal:it.goal,bb:it.bb,keep,ast,mask:it.mask|0,flags:mkFlags(v,opTag(it.op),false,extraBinFlags(a.flags,b.flags)),mkey:mk});
          }
        }else{
          const ck=it.ck||"";
          const key=keyOf(v,0,ck);
          const cnt=(tCount?cntFromCk(ck):EMPTY);
          const keep=(mp.keepMode==="goal")?it.goal:Math.min(it.goal,it.bb);
          if(it.kind==="u"){
            const a=fwd[it.ac][it.ai];
            const ast=mkU(it.op,a.ast);
            if(LEAF_ORDER && ast.ord && !ast.ord.ok) continue;
            put(key,{v,goal:it.goal,bb:it.bb,keep,ast,cnt,ck,flags:mkFlags(v,opTag(it.op),false,extraUnFlags(it.op,a.flags)),mkey:mk});
          }else{
            const a=fwd[it.ac][it.ai],b=fwd[it.bc][it.bi];
            const ast=mkB(it.op,a.ast,b.ast);
            if(LEAF_ORDER && ast.ord && !ast.ord.ok) continue;
            put(key,{v,goal:it.goal,bb:it.bb,keep,ast,cnt,ck,flags:mkFlags(v,opTag(it.op),false,extraBinFlags(a.flags,b.flags)),mkey:mk});
          }
        }
      }
    }

    const items=Array.from(bucket.values());
    for(const it of items){it.hasPow=!!(it.ast&&it.ast.p);it.hasFunc=!!(it.ast&&it.ast.f);it.depth=astDepth(it.ast);}
    const picked=selectTop(items,beamF,divRatio,mp,(bidir?revIdx:null),allowPow,useBitmask);
    for(const it of picked){it.cost=c;}
    return picked;
  }

  await initSubWorkers();

  for(let c=2;c<=maxC;c++){
    if(stopFlag)break;
    if(performance.now()-t0>lim)break;

    if(bidir){
      buildRev(c);
      if(stopFlag)break;
      meetSweepWithNewReverseLayer(c);
      if(stopFlag)break;
    }

    let capUn=Math.max(180,Math.floor(beamF*(mp.capUnMul||2.0)/4/constPenalty));
    let capBin=Math.max(120,Math.floor(beamF*(mp.capBinMul||1.8)/6/constPenalty));
    capUn=Math.max(50,Math.floor(capUn*mp.capMul));
    capBin=Math.max(45,Math.floor(capBin*mp.capMul));

    if(subWorkers.length>0){
      fwd[c]=await computeLayerMT(c,capUn,capBin);
    }else{
      const{bucket,put}=mkBucket(beamF,mp.spillMul);
      const allowPow=Array.isArray(opsBin)&&opsBin.includes("^");

      for(const op of opsUn){
        const w=wUn(op),sc=c-w;
        if(sc<1)continue;
        const src=fwd[sc];if(!src||!src.length)continue;
        const lim2=Math.min(src.length,capUn);
        for(let i=0;i<lim2;i++){
          const a=src[i];
          if(pruneEquiv&&pruneUn(op,a.flags,a.v)){pruned++;continue;}
          const v=applyUn(op,a.v);visited++;
          if(!Number.isFinite(v)||Math.abs(v)>CAP)continue;
          const goal=Math.abs(v-T);
          const bb=bbScore(v,mp.bbD,mp.bbMagA);
          const mk = bidir ? meetPrimaryKey(v) : "";
          const revHit=bidir?revIdx.has(mk):false;
          const ast=mkU(op,a.ast);
          if(LEAF_ORDER && ast.ord && !ast.ord.ok) continue;

          if(useBitmask){
            const keep=keepScore(goal,bb,revHit,a.mask);
            put(keyOf(v,a.mask,""),{v,goal,bb,keep,ast,mask:a.mask,flags:mkFlags(v,opTag(op),false,extraUnFlags(op,a.flags)),mkey:mk});
          }else{
            const keep=(mp.keepMode==="goal")?goal:Math.min(goal,bb);
            put(keyOf(v,0,a.ck),{v,goal,bb,keep,ast,cnt:a.cnt,ck:a.ck,flags:mkFlags(v,opTag(op),false,extraUnFlags(op,a.flags)),mkey:mk});
          }

          if((visited&8191)===0)emit(c);
          if(stopFlag||performance.now()-t0>lim)break;
        }
      }

      for(const op of opsBin){
        const w=wBin(op),rem=c-w;
        if(rem<2)continue;
        const comm=isComm(op);
        const icMax = comm ? Math.floor(rem/2) : (rem-1);
        for(let ic=1;ic<=icMax;ic++){
          const jc=rem-ic;
          const A=fwd[ic],B=fwd[jc];
          if(!A.length||!B.length)continue;
          const cA=Math.min(A.length,capBin),cB=Math.min(B.length,capBin);
          for(let ia=0;ia<cA;ia++){
            const a=A[ia];
            const stB=(comm&&ic===jc)?ia:0;
            for(let ib=stB;ib<cB;ib++){
              const b=B[ib];
              if(pruneEquiv&&pruneBin(op,a.flags,b.flags,a.v,b.v)){pruned++;continue;}
              visited++;

              if(useBitmask){
                if((a.mask&b.mask)!==0)continue;
                const mask=a.mask|b.mask;
                const ast=mkB(op,a.ast,b.ast);
                if(LEAF_ORDER && ast.ord && !ast.ord.ok) continue;

                const v=applyBin(op,a.v,b.v);
                if(!Number.isFinite(v)||Math.abs(v)>CAP)continue;
                const goal=Math.abs(v-T);
                const bb=bbScore(v,mp.bbD,mp.bbMagA);
                const mk = bidir ? meetPrimaryKey(v) : "";
                const revHit=bidir?revIdx.has(mk):false;
                const keep=keepScore(goal,bb,revHit,mask);
                put(keyOf(v,mask,""),{v,goal,bb,keep,ast,mask,flags:mkFlags(v,opTag(op),false,extraBinFlags(a.flags,b.flags)),mkey:mk});
              }else{
                const cnt=addCnt(a.cnt??EMPTY,b.cnt??EMPTY);
                if(!cnt)continue;
                const ast=mkB(op,a.ast,b.ast);
                if(LEAF_ORDER && ast.ord && !ast.ord.ok) continue;

                const v=applyBin(op,a.v,b.v);
                if(!Number.isFinite(v)||Math.abs(v)>CAP)continue;
                const goal=Math.abs(v-T);
                const bb=bbScore(v,mp.bbD,mp.bbMagA);
                const mk = bidir ? meetPrimaryKey(v) : "";
                const revHit=bidir?revIdx.has(mk):false;
                const keep=(mp.keepMode==="goal")?goal:Math.min(goal,bb);
                const ck=ckFromCnt(cnt);
                put(keyOf(v,0,ck),{v,goal,bb,keep,ast,cnt,ck,flags:mkFlags(v,opTag(op),false,extraBinFlags(a.flags,b.flags)),mkey:mk});
              }

              if((visited&8191)===0)emit(c);
              if(stopFlag||performance.now()-t0>lim)break;
            }
            if(stopFlag||performance.now()-t0>lim)break;
          }
          if(stopFlag||performance.now()-t0>lim)break;
        }
      }

      const items=Array.from(bucket.values());
      for(const it of items){it.hasPow=!!(it.ast&&it.ast.p);it.hasFunc=!!(it.ast&&it.ast.f);it.depth=astDepth(it.ast);}
      const picked=selectTop(items,beamF,divRatio,mp,(bidir?revIdx:null),allowPow,useBitmask);
      for(const it of picked){it.cost=c;}
      fwd[c]=picked;
    }

    sendLayerToSubs(c);

    addFwdIdx(fwd[c]);
    tryTargetDecomposition(fwd[c], T);


    for(const e of fwd[c]){
      pushBest({v:e.v,ast:e.ast,mask:e.mask,cnt:e.cnt,cost:e.cost,searchType:"fwd"});
      if(stopFlag)break;
      if(bidir) tryMeetFwdWithRevIdx(e);
      if(stopFlag)break;
    }

    emit(c);
    await new Promise(r=>setTimeout(r,0));
  }

  termSubWorkers();

  postMessage({type:"done",payload:{
    elapsed:Math.round(performance.now()-t0),maxC,c:maxC,
    visited,pruned,
    meetLookups,meetCandidates,meetConfirmed,
    meetDbg,
    reEvalFixed,dupesKilled,
    mode:runtimeMode,
    mt:(mt&&threads>1)?("ON("+threads+")"):"OFF",
    profile:mode,
    beamF,beamR,
    best:best.slice(0,outN)
  }});
};
`;
  const url=URL.createObjectURL(new Blob([workerSrc],{type:"text/javascript"}));
  const w=new Worker(url);
  w.__blobUrl=url;
  return w;
}

// ---------- run ----------
let worker=null;
let lastT=24;
let runToken=0;

function killWorkerImmediate(){
  if(worker){
    try{ worker.terminate(); }catch(e){}
    try{ if(worker.__blobUrl) URL.revokeObjectURL(worker.__blobUrl); }catch(e){}
    worker=null;
  }
}

$("btnStart").onclick=()=>{
  const T=parseTarget($("target").value);
  if(!Number.isFinite(T)){alert("ç›®æ ‡å€¼æ— æ•ˆ");return}
  lastT=T;

  const mode=normalizeMode($("mode").value);
  $("mode").value=mode;

  let bidir=$("bidir").checked;
  if(mode==="normal"||mode==="speed")bidir=true;

  const maxC=Math.max(1,Math.min(200,Number($("maxC").value||30)));
  const beam=Math.max(50,Math.min(50000,Number($("beam").value||4000)));
  const divRatio=Math.max(0,Math.min(1,Number($("divRatio").value||.25)));
  const outN=Math.max(1,Math.min(200,Number($("outN").value||30)));
  const infiniteTime=$("infiniteTime").checked;
  const timeLimit=infiniteTime?0:Math.max(0,Number($("timeLimit").value||0));
  const emitInterval=Math.max(50,Math.min(60000,Number($("emitInterval").value||500)));
  const showCounts=$("showCounts").checked;
  const pruneEquiv=$("pruneEquiv").checked;
  const excludeExact=$("excludeExact").checked;
  let mt=$("mt").checked;
  const threads=Math.max(1,Math.min(64,Number($("threads").value||1)));
  const latexMode=$("latexMode").checked;
  const customEnable=$("customEnable").checked;
  const customCode=$("customBox").value||"";

  
  
  // 1. å…ˆåº”ç”¨è‡ªå®šä¹‰æ‰©å±• (åŸä»£ç ä½ç½®ä¸å˜ï¼Œä½†è¦ç¡®ä¿è¿™å—åœ¨ getOps ä¹‹å‰)
  try{
    if(customEnable){
      const scope = safeEvalCustom(customCode);
      const ext = scope.getExtensions ? normalizeExt(scope.getExtensions()) : {constants:[],unaryOps:[],binaryOps:[]};
      const st=collectUIState();
      CONST_LIST = BASE_CONST_LIST.slice();
      OP_LIST = BASE_OP_LIST.slice();
      mergeExtensionsToLists(ext);
      mountConsts(); mountOps();
      applyUIState(st);
    }
  }catch(e){
    alert("è‡ªå®šä¹‰æ‰©å±•åŠ è½½å¤±è´¥: "+(e?.message||String(e)));
    return;
  }

  // 2. ã€å…³é”®ä¿®æ”¹ã€‘åœ¨æ‰©å±•åŠ è½½å®Œæ¯•ã€UIåˆ·æ–°åï¼Œå†è·å– Opsï¼
  // è¿™æ · Worker æ‰èƒ½æ”¶åˆ°ç”¨æˆ·æ–°å¢çš„å‡½æ•°
  tuneOpsByMode(mode);
  const{opsUn,opsBin}=getOps(); 
  if(!opsUn.length&&!opsBin.length){alert("è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªè¿ç®—");return}

  let consts;
  try{consts=getConsts()}catch(e){alert(e.message);return}

  try{localStorage.setItem(LS_KEY,JSON.stringify(collectUIState()));}catch(e){}

  runToken++;
  const token=runToken;

  killWorkerImmediate();
  worker=buildWorker();

  $("btnStart").disabled=true;
  $("btnStop").disabled=false;
  $("pruneStats").style.display="none";
  $("copyMsg").textContent="";
  updateRuntimePanel({c:0,maxC,elapsed:0,visited:0});
  $("status").style.display="none";

  worker.onmessage=async(ev)=>{
    if(token!==runToken) return;
    const{type,payload}=ev.data;
    if(type==="error"){
      alert(payload);
      $("btnStart").disabled=false;
      $("btnStop").disabled=true;
      return;
    }
    if(type==="progress"||type==="done"){
      const rows=payload.best||[];
      const ba=rows.length?Math.abs(rows[0].delta):NaN;
      updateRuntimePanel(payload);
      const debugOn=$("debugMode").checked;
      if(debugOn){
        $("status").style.display="flex";
        statusPills({
          T:fmt(lastT),status:type,profile:payload.profile||mode,mode:payload.mode,
          mt:payload.mt||"OFF",c:(payload.c??0)+"/"+payload.maxC,
          elapsed_ms:payload.elapsed,visited:payload.visited,pruned:payload.pruned||0,
          meetLookups:payload.meetLookups||0,meetCand:payload.meetCandidates||0,
          meetOK:payload.meetConfirmed||0,best_delta:Number.isFinite(ba)?fmt(ba):"n/a"
        });
        const ps=$("pruneStats");
        ps.style.display="block";
        ps.innerHTML=
          "<b>ASTé‡æ±‚å€¼ä¿®æ­£ï¼š</b>"+(payload.reEvalFixed||0).toLocaleString()+
          " &nbsp;|&nbsp; <b>è¾“å‡ºåŒå€¼åˆå¹¶ï¼š</b>"+(payload.dupesKilled||0).toLocaleString();
        if(payload.meetDbg){
          const d=payload.meetDbg;
          ps.innerHTML+=
            "<br><b>MEET Debug</b> "+
            `revIdxKeys=${d.revIdxKeys} revIdxItems=${d.revIdxItems} fwdIdxKeys=${d.fwdIdxKeys} fwdIdxItems=${d.fwdIdxItems}<br>`+
            `keyHits=${d.keyHits} pairsTried=${d.pairsTried} rev2fwdPairs=${d.rev2fwdPairs}<br>`+
            `rej(mask=${d.rejMaskOverlap}, cnt=${d.rejCntLimit}, eps=${d.rejEpsCand}, evalNaN=${d.rejEvalNaN}, probe=${d.rejProbeConfirm}, confirm=${d.rejConfirm}) `+
            `revInvBad=${d.revInvBad} maxConfirmErr=${d.maxConfirmErr}`;
        }
      }else{
        $("status").style.display="none";
        $("status").innerHTML="";
        $("pruneStats").style.display="none";
      }
      await renderResults(rows,showCounts,debugOn,latexMode);
      if(type==="done"){
        $("btnStart").disabled=false;
        $("btnStop").disabled=true;
        killWorkerImmediate();
      }
    }
  };

  worker.postMessage({
    type:"start",
    T,mode,maxC,beam,divRatio,outN,
    timeLimit,infiniteTime,emitInterval,
    opsUn,opsBin,consts,
    showCounts,bidir,
    pruneEquiv,excludeExact,
    mt,threads,
    customEnable,customCode,
    subSrc:SUBWORKER_CODE
  });
};

$("btnStop").onclick=()=>{
  runToken++;
  killWorkerImmediate();
  $("btnStop").disabled=true;
  $("btnStart").disabled=false;

  const debugOn=$("debugMode").checked;
  if(debugOn){
    $("status").style.display="flex";
    statusPills({status:"stopped", T:fmt(lastT)});
  }
};

// init
mountConsts();
mountOps();

// load saved config first
try{
  const st=JSON.parse(localStorage.getItem(LS_KEY)||"null");
  if(st){
    // if saved custom enabled, apply its extensions before mounting state
    if(st.customEnable && st.customBox){
      try{
        const scope=safeEvalCustom(st.customBox);
        const ext=scope.getExtensions?normalizeExt(scope.getExtensions()):{constants:[],unaryOps:[],binaryOps:[]};
        mergeExtensionsToLists(ext);
        mountConsts(); mountOps();
      }catch(e){}
    }
    applyUIState(st);
  }
}catch(e){}

tuneOpsByMode($("mode").value);
$("timeLimit").disabled=$("infiniteTime").checked;
updateMtHint();
hookAutoSave();
updateRuntimePanel({c:0,maxC:Number($("maxC").value||0),elapsed:0,visited:0});
})();
</script>
</body>
</html>
