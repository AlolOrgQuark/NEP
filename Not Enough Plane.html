
<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>NOT ENOUGH PLANE · NEP</title>
  <style>
/* ================= CORE THEME & VARIABLES ================= */
:root{
  --c-cyan:#52E6FF;
  --c-magenta:#B36CFF;
  --c-yellow:#FFB020;
  --c-danger:#FF2F57;
  --c-bg:#0E1738;
  --c-panel:rgba(14,23,56,0.75);
  --c-panel-border:rgba(82,230,255,0.3);
  --font-mono:"Consolas","Monaco","Courier New",monospace;
  --font-sans:system-ui,-apple-system,sans-serif;
}

*{ box-sizing:border-box; }

html,body{
  height:100%;
  margin:0;
  overflow:hidden;
  background:#000;
  color:var(--c-cyan);
  font-family:var(--font-sans);
  user-select:none;
  -webkit-user-select:none;
}

/* scanline overlay */
body::after{
  content:"";
  position:fixed; inset:0;
  pointer-events:none;
  z-index:9999;
  background:linear-gradient(
    to bottom,
    rgba(255,255,255,0) 0%,
    rgba(255,255,255,0) 50%,
    rgba(0,0,0,0.10) 50%,
    rgba(0,0,0,0.10) 100%
  );
  background-size:100% 4px;
  opacity:0.30;
}

/* ================= CANVAS & LAYERS ================= */
#wrap{ position:fixed; inset:0; }
canvas{ width:100%; height:100%; display:block; touch-action:none; }

.ui{
  position:fixed; inset:0;
  pointer-events:none;
  display:flex;
  flex-direction:column;
  justify-content:space-between;
  z-index:10;
}

.ui.compact .top,
.ui.compact .bottom,
.ui.compact #fortressPanel{
  display:none !important;
}

/* ================= TYPOGRAPHY & UTILS ================= */
.mono{ font-family:var(--font-mono); letter-spacing:-0.5px; }
.neon-text{ text-shadow:0 0 8px currentColor; }
.muted{ opacity:0.6; font-size:0.85em; text-transform:uppercase; letter-spacing:1px; }
b{ font-weight:800; }

/* helper colors */
.c-p1{ color:var(--c-cyan); }
.c-p2{ color:var(--c-magenta); }
.c-y { color:var(--c-yellow); }
.c-r { color:var(--c-danger); }

/* ================= PANELS ================= */
.cyber-panel{
  background:var(--c-panel);
  backdrop-filter:blur(8px);
  -webkit-backdrop-filter:blur(8px);
  border:1px solid var(--c-panel-border);
  box-shadow:0 0 15px rgba(0,0,0,0.5), inset 0 0 20px rgba(82,230,255,0.05);
  border-left:2px solid var(--c-cyan);
  border-right:2px solid var(--c-cyan);
  position:relative;
}
.cyber-panel::before{
  content:"";
  position:absolute; top:-1px; left:-1px;
  width:10px; height:10px;
  border-top:2px solid var(--c-cyan);
  border-left:2px solid var(--c-cyan);
}
.cyber-panel::after{
  content:"";
  position:absolute; bottom:-1px; right:-1px;
  width:10px; height:10px;
  border-bottom:2px solid var(--c-cyan);
  border-right:2px solid var(--c-cyan);
}

/* ================= BUTTONS ================= */
button{
  pointer-events:auto;
  appearance:none;
  background:rgba(82,230,255,0.10);
  border:1px solid rgba(82,230,255,0.40);
  color:var(--c-cyan);
  padding:12px 24px;
  font-family:var(--font-mono);
  font-weight:700;
  text-transform:uppercase;
  letter-spacing:2px;
  cursor:pointer;
  position:relative;
  overflow:hidden;
  transition:all 0.2s;
  clip-path:polygon(10px 0,100% 0,100% calc(100% - 10px),calc(100% - 10px) 100%,0 100%,0 10px);
}
button:hover{
  background:var(--c-cyan);
  color:#000;
  box-shadow:0 0 15px var(--c-cyan);
}
button:active{ transform:scale(0.96); }
button:disabled{ opacity:0.5; cursor:not-allowed; filter:grayscale(1); }

.mini-btn{
  padding:6px 12px;
  font-size:12px;
  clip-path:none;
  border-radius:4px;
  background:rgba(0,0,0,0.5);
  border-color:rgba(255,255,255,0.2);
  color:#ccc;
}
.mini-btn:hover{
  background:rgba(255,255,255,0.1);
  color:#fff;
  box-shadow:none;
}

/* ================= HUD ================= */
.top{
  display:flex;
  justify-content:space-between;
  align-items:flex-start;
  padding:max(10px, env(safe-area-inset-top)) 15px 10px;
}
.hud-group{ display:flex; gap:8px; }
.top .hud-group:last-child{ flex-wrap:wrap; justify-content:flex-end; row-gap:6px; max-width:min(62vw, 520px); }

.stat-pill{
  background:rgba(0,0,0,0.6);
  border:1px solid rgba(255,255,255,0.15);
  padding:6px 12px;
  font-family:var(--font-mono);
  font-size:14px;
  border-radius:2px;
  display:flex;
  gap:8px;
  align-items:baseline;
  transform:skewX(-10deg);
}
.stat-pill>*{ transform:skewX(10deg); }

.bottom{
  padding:0 15px max(15px, env(safe-area-inset-bottom));
  display:flex;
  flex-direction:column;
  gap:10px;
}
.hud-panel{
  width:min(500px, 90vw);
  padding:12px;
  align-self:center;
  background:linear-gradient(
    90deg,
    rgba(0,0,0,0.6) 0%,
    rgba(14,23,56,0.85) 20%,
    rgba(14,23,56,0.85) 80%,
    rgba(0,0,0,0.6) 100%
  );
  border-top:1px solid rgba(255,255,255,0.1);
  border-bottom:1px solid rgba(255,255,255,0.1);
  position:relative;
}
.hud-panel::before,
.hud-panel::after{
  content:"";
  position:absolute;
  top:50%;
  width:4px;
  height:60%;
  background:var(--c-cyan);
  transform:translateY(-50%);
}
.hud-panel::before{ left:0; }
.hud-panel::after{ right:0; }

.bar-row{ display:flex; align-items:center; gap:10px; margin-bottom:6px; }
.bar-label{ width:30px; font-size:10px; font-weight:900; color:var(--c-cyan); text-align:right; }

.bar-track{
  flex:1;
  height:12px;
  background:rgba(0,0,0,0.5);
  position:relative;
  transform:skewX(-20deg);
  border:1px solid rgba(255,255,255,0.1);
  overflow:hidden;
}
.bar-fill{
  height:100%;
  width:50%;
  box-shadow:2px 0 10px currentColor;
  transition:width 0.1s linear;
}
.bar-track.hp .bar-fill{ background:var(--c-cyan); color:var(--c-cyan); }
.bar-track.shd{ height:4px; margin-top:2px; border:none; background:none; }
.bar-track.shd .bar-fill{ background:var(--c-magenta); color:var(--c-magenta); }

.bar-track.xp{ height:6px; }
.bar-track.xp .bar-fill{ background:var(--c-yellow); }

.bar-track.od .bar-fill{ background:var(--c-danger); }
.bar-track.mag .bar-fill{ background:var(--c-cyan); }

.data-row{
  display:flex;
  justify-content:space-between;
  font-size:11px;
  color:rgba(255,255,255,0.6);
  margin-top:6px;
  font-family:var(--font-mono);
}
.data-val{ color:#fff; font-weight:bold; margin-left:4px; }

.bomb-display{ display:flex; align-items:center; gap:6px; color:var(--c-yellow); }
.bomb-dot{
  width:10px; height:10px;
  transform:rotate(45deg);
  border:1px solid rgba(255,176,32,0.4);
  background:rgba(0,0,0,0.5);
  transition:all 0.2s;
}
.bomb-dot.on{
  background:var(--c-yellow);
  box-shadow:0 0 8px var(--c-yellow);
  border-color:#fff;
}

.chip-row{
  display:flex;
  gap:6px;
  justify-content:center;
  margin-top:8px;
  height:20px;
}
.chip{
  font-size:10px;
  padding:2px 8px;
  border-radius:2px;
  background:rgba(0,0,0,0.4);
  border:1px solid currentColor;
  color:#fff;
  display:flex;
  align-items:center;
  gap:4px;
  box-shadow:0 0 5px currentColor;
}
.chip b{ font-family:var(--font-mono); }

.hint{
  text-align:center;
  font-size:11px;
  opacity:0.5;
  margin-top:4px;
  letter-spacing:2px;
  text-transform:uppercase;
}

#fortressPanel{
  width:min(500px, 90vw);
  align-self:center;
  padding:8px 10px;
  border-top:1px solid rgba(255,255,255,0.1);
  border-bottom:1px solid rgba(255,255,255,0.1);
  display:none;
  margin-bottom:6px;
}

#fortressPanel,
#fortressPanel *{ pointer-events:auto !important; }
#fortressPanel .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:space-between; }
#fortressPanel .mini-btn{ font-size:11px; padding:5px 8px; white-space:nowrap; flex:0 0 auto; }
#fortressBuildScroller{ display:flex; gap:6px; overflow-x:auto; overflow-y:hidden; padding-bottom:4px; touch-action:pan-x; -webkit-overflow-scrolling:touch; }
#fortressBuildScroller::-webkit-scrollbar{ height:6px; }
#fortressBuildScroller::-webkit-scrollbar-thumb{ background:rgba(82,230,255,0.35); border-radius:6px; }
#fortressBuildScroller .mini-btn.on{ background:rgba(82,230,255,0.22); color:#fff; border-color:var(--c-cyan); }

.ui-fab{
  appearance:none;
  position:fixed;
  right:max(10px, env(safe-area-inset-right));
  bottom:max(14px, env(safe-area-inset-bottom));
  width:48px !important;
  height:48px !important;
  min-width:48px;
  min-height:48px;
  padding:0 !important;
  border-radius:50% !important;
  clip-path:none !important;
  transform:none !important;
  border:1px solid rgba(82,230,255,0.55);
  background:rgba(8,18,42,0.58);
  color:var(--c-cyan);
  z-index:30;
  pointer-events:auto !important;
  touch-action:manipulation;
  display:flex;
  align-items:center;
  justify-content:center;
  font-family:var(--font-mono);
  font-size:11px;
  backdrop-filter:blur(6px);
}

/* ================= OVERLAYS (GAMEOVER/PAUSE) ================= */
.center-overlay{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,0.6);
  backdrop-filter:blur(4px);
  z-index:9000;
  pointer-events:auto;
  animation:overlayIn .28s ease both;
}
.center-overlay *{ pointer-events:auto; }

@keyframes overlayIn{
  from{ opacity:0; transform:translateY(10px); }
  to{ opacity:1; transform:translateY(0); }
}
@keyframes panelIn{
  0%{ opacity:0; transform:scale(0.96) translateY(8px); filter:blur(2px); }
  100%{ opacity:1; transform:scale(1) translateY(0); filter:blur(0); }
}
.center-overlay .cyber-panel{
  animation:panelIn .32s cubic-bezier(.2,.9,.2,1) both;
}

.menu-panel{
  width:min(480px, 90vw);
  padding:30px;
  display:flex;
  flex-direction:column;
  gap:20px;
  text-align:center;
}

.game-title{
  font-size:42px;
  line-height:1;
  font-weight:900;
  color:var(--c-cyan);
  letter-spacing:4px;
  margin-bottom:10px;
  position:relative;
  text-transform:uppercase;
  font-style:italic;
}
.game-title::before{
  content:attr(data-text);
  position:absolute; left:2px; top:0;
  text-shadow:-1px 0 #ff00c1;
  color:white;
  overflow:hidden;
  clip:rect(0,900px,0,0);
  animation:glitch-2 3s infinite linear alternate-reverse;
}
.game-title::after{
  content:attr(data-text);
  position:absolute; left:-2px; top:0;
  text-shadow:-1px 0 #00fff9;
  color:white;
  overflow:hidden;
  clip:rect(0,900px,0,0);
  animation:glitch-1 2s infinite linear alternate-reverse;
}
@keyframes glitch-1{
  0%{ clip:rect(20px,9999px,11px,0); }
  20%{ clip:rect(60px,9999px,5px,0); }
  40%{ clip:rect(10px,9999px,80px,0); }
  60%{ clip:rect(80px,9999px,20px,0); }
  80%{ clip:rect(30px,9999px,40px,0); }
  100%{ clip:rect(50px,9999px,60px,0); }
}
@keyframes glitch-2{
  0%{ clip:rect(60px,9999px,5px,0); }
  20%{ clip:rect(10px,9999px,80px,0); }
  40%{ clip:rect(50px,9999px,60px,0); }
  60%{ clip:rect(20px,9999px,11px,0); }
  80%{ clip:rect(80px,9999px,20px,0); }
  100%{ clip:rect(30px,9999px,40px,0); }
}

.actions{ display:flex; flex-direction:column; gap:12px; width:100%; margin-top:10px; }
.actions-row{ display:flex; gap:10px; }
.actions-row button{ flex:1; }

.input-row{
  display:flex;
  align-items:center;
  justify-content:center;
  gap:10px;
  font-size:14px;
  color:var(--c-cyan);
}
.input-row input{
  background:rgba(0,0,0,0.5);
  border:1px solid var(--c-cyan);
  color:#fff;
  padding:8px;
  width:60px;
  text-align:center;
  font-family:var(--font-mono);
  font-size:16px;
  outline:none;
}
.input-row input:focus{ box-shadow:0 0 10px var(--c-cyan); }

/* overlays: explicit ids */
#gameover{ z-index:9000; }
#pausePanel{ z-index:9200; }

/* ================= MENU (FULLSCREEN) ================= */
#menu.screen{
  position:fixed;
  inset:0;
  display:none;
  z-index:1000;
  pointer-events:auto;
}
#menu.screen.show{ display:flex; }
#menu.screen, #menu.screen *{ pointer-events:auto; }

#menu .menu-bg{
  position:absolute; inset:0; z-index:0;
  background:
    radial-gradient(1200px 600px at 50% 20%, rgba(82,230,255,0.15), transparent 55%),
    radial-gradient(900px 500px at 20% 70%, rgba(179,108,255,0.12), transparent 60%),
    linear-gradient(180deg, #070A12 0%, #060816 40%, #03040A 100%);
  overflow:hidden;
}
#menu .menu-bg::before{
  content:"";
  position:absolute; inset:-40%;
  background:
    repeating-linear-gradient(0deg, rgba(82,230,255,0.06) 0 1px, transparent 1px 42px),
    repeating-linear-gradient(90deg, rgba(82,230,255,0.04) 0 1px, transparent 1px 52px);
  transform:rotate(6deg);
  animation:menuGridDrift 12s linear infinite;
  opacity:0.55;
}
#menu .menu-bg::after{
  content:"";
  position:absolute; inset:0;
  background:linear-gradient(
    to bottom,
    rgba(255,255,255,0) 0%,
    rgba(255,255,255,0) 50%,
    rgba(0,0,0,0.14) 50%,
    rgba(0,0,0,0.14) 100%
  );
  background-size:100% 4px;
  opacity:0.28;
  mix-blend-mode:overlay;
}
@keyframes menuGridDrift{
  from{ transform:rotate(6deg) translateY(0px); }
  to{ transform:rotate(6deg) translateY(120px); }
}
@keyframes screenIn{
  from{ opacity:0; transform:translateY(10px); filter:blur(2px); }
  to{ opacity:1; transform:none; filter:none; }
}
#menu.screen.show .menu-shell{
  animation:screenIn .32s cubic-bezier(.2,.9,.2,1) both;
}

#menu .menu-shell{
  position:relative; z-index:1;
  display:flex; flex-direction:column;
  width:min(1120px, 92vw);
  height:min(720px, 92vh);
  margin:auto;
  border:1px solid rgba(82,230,255,0.28);
  background:rgba(0,0,0,0.45);
  backdrop-filter:blur(10px);
  box-shadow:0 0 30px rgba(0,0,0,0.65), inset 0 0 20px rgba(82,230,255,0.06);
  min-width:0;
  min-height:0;
}

#menu .menu-topbar{
  display:flex; align-items:center; justify-content:space-between;
  padding:14px 16px;
  border-bottom:1px solid rgba(255,255,255,0.10);
}
#menu .brand .title{
  font-weight:900;
  letter-spacing:5px;
  font-size:22px;
  text-transform:uppercase;
  font-style:italic;
  text-shadow:0 0 12px rgba(82,230,255,0.35);
}
#menu .brand .sub{
  font-family:var(--font-mono);
  color:rgba(255,255,255,0.65);
  letter-spacing:3px;
  font-size:11px;
}

#menu .menu-nav{
  display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;
}
#menu .nav-btn{
  padding:8px 12px;
  font-size:12px;
  clip-path:none;
  border-radius:8px;
  background:rgba(0,0,0,0.35);
  border-color:rgba(255,255,255,0.18);
  color:#d8d8d8;
}
#menu .nav-btn.active{
  background:rgba(82,230,255,0.20);
  border-color:rgba(82,230,255,0.70);
  color:#fff;
  box-shadow:0 0 18px rgba(82,230,255,0.18);
}

/* menu main: default SINGLE column (no side) */
#menu .menu-main{
  flex:1;
  display:grid;
  grid-template-columns:1fr;
  gap:14px;
  padding:14px 16px 16px;
  overflow:auto;
  -webkit-overflow-scrolling:touch;
  align-content:start;
  min-width:0;
  min-height:0;
}

/* pages: only main scroll; pages themselves not fixed height to avoid blank space */
#menu .page{ display:none; padding-right:4px; }
#menu .page.active{ display:block; animation:pageIn .18s ease both; }
@keyframes pageIn{ from{ opacity:0; transform:translateY(6px);} to{opacity:1; transform:none;} }

#menu .side{ display:none; border-left:1px solid rgba(255,255,255,0.10); padding-left:14px; }

@media (min-width:901px){
  body[data-menupage="forge"] #menu .menu-main{
    grid-template-columns:minmax(0,1fr) minmax(0,0.88fr);
  }
  body[data-menupage="forge"] #menu .side{
    display:block;
    grid-column:2;
    grid-row:1;
    height:auto;
    overflow:visible;
  }
  body[data-menupage="forge"] #menu .menu-main > div:first-child{
    grid-column:1;
    grid-row:1;
    min-width:0;
  }
}

/* preview visibility */
#forgePreviewTopWrap, #forgePreviewSideWrap{ display:none !important; }
body[data-menupage="forge"] #forgePreviewTopWrap,
body[data-menupage="forge"] #forgePreviewSideWrap{ display:block !important; }
@media (min-width:901px){
  body[data-menupage="forge"] #forgePreviewTopWrap{ display:none !important; }
  body[data-menupage="forge"] #forgePreviewSideWrap{ display:block !important; }
}
@media (max-width:900px){
  body[data-menupage="forge"] #forgePreviewSideWrap{ display:none !important; }
  body[data-menupage="forge"] #forgePreviewTopWrap{ display:block !important; }
}

/* hide intro text (正式版) */
.menu-intro{ display:none !important; }
#ws_previewText{ display:none !important; }

/* menu cards */
.menu-card{
  background:rgba(0,0,0,0.30);
  border:1px solid rgba(255,255,255,0.10);
  padding:12px;
  margin-bottom:12px;
}
.menu-card .card-title{
  font-family:var(--font-mono);
  letter-spacing:2px;
  font-weight:900;
  color:#fff;
  margin-bottom:10px;
}

/* fields */
.field{
  display:flex;
  flex-direction:column;
  gap:6px;
  margin-bottom:10px;
}
.field label{
  font-size:11px;
  letter-spacing:1px;
  color:rgba(255,255,255,0.65);
  text-transform:uppercase;
}
.field input, .field select, .field textarea{
  pointer-events:auto;
  background:rgba(0,0,0,0.55);
  border:1px solid rgba(82,230,255,0.45);
  color:#fff;
  padding:8px;
  outline:none;
  font-family:var(--font-mono);
}
.field input:focus, .field select:focus, .field textarea:focus{
  box-shadow:0 0 12px rgba(82,230,255,0.25);
  border-color:rgba(82,230,255,0.85);
}

/* select arrow */
.field select{
  appearance:none;
  -webkit-appearance:none;
  background-image:
    linear-gradient(45deg, transparent 50%, rgba(82,230,255,0.9) 50%),
    linear-gradient(135deg, rgba(82,230,255,0.9) 50%, transparent 50%),
    linear-gradient(to right, rgba(255,255,255,0.12), rgba(255,255,255,0.12));
  background-position:
    calc(100% - 18px) 55%,
    calc(100% - 12px) 55%,
    calc(100% - 34px) 50%;
  background-size:6px 6px, 6px 6px, 1px 60%;
  background-repeat:no-repeat;
  padding-right:42px;
}


/* forge extra wrapper/emitter select (same cyber style as .field select) */
.forge-extra-select{
  appearance:none;
  -webkit-appearance:none;
  width:100%;
  pointer-events:auto;
  background:rgba(0,0,0,0.55);
  border:1px solid rgba(82,230,255,0.45);
  color:#fff;
  padding:8px 42px 8px 8px;
  outline:none;
  font-family:var(--font-mono);
  background-image:
    linear-gradient(45deg, transparent 50%, rgba(82,230,255,0.9) 50%),
    linear-gradient(135deg, rgba(82,230,255,0.9) 50%, transparent 50%),
    linear-gradient(to right, rgba(255,255,255,0.12), rgba(255,255,255,0.12));
  background-position:
    calc(100% - 18px) 55%,
    calc(100% - 12px) 55%,
    calc(100% - 34px) 50%;
  background-size:6px 6px, 6px 6px, 1px 60%;
  background-repeat:no-repeat;
}
.forge-extra-select:focus{
  box-shadow:0 0 12px rgba(82,230,255,0.25);
  border-color:rgba(82,230,255,0.85);
}

/* slider row */
.slider-row{
  display:grid;
  grid-template-columns:1fr 90px;
  gap:8px;
  align-items:center;
}
.slider-row input[type="range"]{ width:100%; }
.slider-row input[type="number"]{ width:100%; }

@media (max-width:520px){
  .slider-row{ grid-template-columns:1fr 72px; }
  #menu .menu-nav{ justify-content:flex-start; }
  #menu .nav-btn{ flex:1; min-width:46%; }
}

/* accordions */
.acc{
  border:1px solid rgba(255,255,255,0.12);
  background:rgba(0,0,0,0.18);
  margin-bottom:10px;
}
.acc > summary{
  cursor:pointer;
  list-style:none;
  padding:10px 12px;
  font-family:var(--font-mono);
  letter-spacing:1px;
  color:#fff;
  display:flex;
  justify-content:space-between;
  align-items:center;
}
.acc > summary::-webkit-details-marker{ display:none; }
.acc > summary::after{
  content:'▸';
  opacity:.8;
  transition:transform .22s ease;
}
.acc[open] > summary::after{ transform:rotate(90deg); }
.acc .acc-body{
  max-height:0;
  overflow:hidden;
  opacity:0;
  transform:translateY(-4px);
  padding:0 12px;
  border-top:1px solid rgba(255,255,255,0.00);
  transition:max-height .28s ease, opacity .24s ease, transform .24s ease, padding .24s ease, border-color .24s ease;
}
.acc[open] .acc-body{
  max-height:5000px;
  overflow:visible;
  opacity:1;
  transform:translateY(0);
  padding:10px 12px 12px;
  border-top:1px solid rgba(255,255,255,0.10);
}

/* chips */
.chip-pick{
  display:flex;
  flex-wrap:wrap;
  gap:6px;
  max-height:190px;
  overflow:auto;
  padding:6px;
  border:1px solid rgba(255,255,255,0.10);
  background:rgba(0,0,0,0.25);
}
.pick-chip{
  font-family:var(--font-mono);
  font-size:11px;
  letter-spacing:1px;
  padding:6px 8px;
  border-radius:8px;
  border:1px solid rgba(255,255,255,0.18);
  background:rgba(0,0,0,0.25);
  color:rgba(255,255,255,0.82);
  cursor:pointer;
  transition:transform .12s, background .12s, border-color .12s;
}
.pick-chip:hover{ transform:translateY(-1px); }
.pick-chip.on{
  background:rgba(82,230,255,0.22);
  border-color:rgba(82,230,255,0.8);
  color:#fff;
  box-shadow:0 0 16px rgba(82,230,255,0.18);
}

.ub-panel{
  margin-top:10px;
  padding:10px;
  border:1px solid rgba(130,229,255,.35);
  border-radius:10px;
  background:linear-gradient(160deg, rgba(12,26,48,.65), rgba(26,10,42,.6));
  box-shadow:0 0 22px rgba(82,230,255,.14) inset;
}
.ub-panel .ub-title{
  font:700 12px/1.2 var(--font-mono);
  color:var(--c-cyan);
  letter-spacing:1px;
  margin-bottom:6px;
}
.ub-list{ display:flex; flex-wrap:nowrap; gap:8px; overflow-x:auto; overflow-y:hidden; margin-top:8px; padding-bottom:4px; -webkit-overflow-scrolling:touch; }

.ub-list::-webkit-scrollbar{ height:6px; }
.ub-list::-webkit-scrollbar-thumb{ background:rgba(157,238,255,.35); border-radius:8px; }
.ub-chip{
  border:1px solid rgba(157,238,255,.45);
  border-radius:999px;
  padding:4px 8px;
  font:600 10px/1.1 var(--font-mono);
  color:#d9f9ff;
  background:rgba(0,0,0,.26);
}

/* Forge extra emitter mobile overflow fixes */
#forgeExtraEmittersList, #forgeExtraEmittersList *{ box-sizing:border-box; }
#forgeExtraEmittersList{ overflow-x:hidden; }
.forge-extra-card{ width:100%; min-width:0; overflow:hidden; border-radius:8px; }
.forge-extra-title{ display:flex; justify-content:space-between; align-items:flex-start; gap:8px; margin-bottom:6px; }
.forge-extra-title-text{ min-width:0; word-break:break-word; white-space:normal; line-height:1.25; }
.forge-extra-wrap{ border:1px dashed rgba(179,108,255,0.35); padding:6px; margin-bottom:6px; width:100%; min-width:0; overflow:hidden; }
.forge-extra-wrap-row{ border:1px solid rgba(179,108,255,0.25); padding:6px; background:rgba(179,108,255,0.08); width:100%; min-width:0; overflow:hidden; }
.forge-extra-wrap-top{ display:flex; gap:6px; align-items:center; flex-wrap:wrap; }
.forge-extra-wrap-actions{ display:flex; gap:6px; flex-wrap:wrap; }
.forge-extra-wrap-actions .mini-btn{ flex:0 0 auto; }
@media (max-width:700px){
  .forge-extra-wrap-top{ align-items:stretch; }
  .forge-extra-wrap-top .forge-extra-select{ flex:1 1 100% !important; width:100%; }
}

/* Unit battle modal */
#unitBattleModal{ position:fixed; inset:0; z-index:26000; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.65); opacity:0; pointer-events:none; transition:opacity .22s ease; }
#unitBattleModal:not(.show){ display:none !important; }
#unitBattleModal.show{ display:flex; }
#unitBattleModal.visible{ opacity:1; pointer-events:auto; }
#unitBattleModal .ub-modal-card{ width:min(780px,94vw); max-height:min(86vh,860px); overflow:auto; background:linear-gradient(160deg, rgba(8,16,34,.92), rgba(24,8,40,.9)); border:1px solid rgba(130,229,255,.42); box-shadow:0 18px 50px rgba(0,0,0,.55); padding:14px; border-radius:12px; transform:translateY(18px) scale(.96); opacity:0; transition:transform .26s cubic-bezier(.2,.9,.2,1), opacity .26s ease; }
#unitBattleModal.visible .ub-modal-card{ transform:translateY(0) scale(1); opacity:1; }
#unitBattleModal textarea{ min-height:180px; }
.ub-unit-card{ position:relative; flex:0 0 auto; width:86px; border:1px solid rgba(157,238,255,.35); border-radius:10px; padding:4px; background:rgba(0,0,0,.24); display:flex; flex-direction:column; gap:4px; align-items:center; }
.ub-unit-icon{ width:64px; height:64px; border:1px solid rgba(157,238,255,.3); background:radial-gradient(circle at 50% 50%, rgba(157,238,255,.12), rgba(0,0,0,.2)); }
.ub-unit-meta{ font:600 9px/1.15 var(--font-mono); color:#c8f4ff; text-align:center; word-break:break-word; }
.ub-unit-del{ position:absolute; top:-6px; right:-6px; width:18px; height:18px; border-radius:999px; border:1px solid rgba(255,120,120,.7); background:rgba(28,0,0,.85); color:#ffb3b3; font:700 11px/1 var(--font-mono); display:flex; align-items:center; justify-content:center; cursor:pointer; padding:0; }
.ub-unit-del:hover{ background:rgba(90,0,0,.92); color:#fff; }

/* action row */
.menu-actions{
  display:flex;
  flex-wrap:wrap;
  gap:10px;
  justify-content:center;
  margin-top:10px;
}
.menu-actions button{ flex:1; min-width:190px; }

/* hide workshop SAVE */
#btnSaveBuilds{ display:none !important; }

/* ================= DRAWER (IMPORT/EXPORT) ================= */
.drawer{
  position:fixed;
  top:0; right:0;
  width:min(560px, 94vw);
  height:100%;
  z-index:2000;
  transform:translateX(102%);
  transition:transform .26s cubic-bezier(.2,.9,.2,1);
  background:rgba(0,0,0,0.72);
  border-left:1px solid rgba(82,230,255,0.25);
  backdrop-filter:blur(10px);
  box-shadow:-20px 0 40px rgba(0,0,0,0.55);
  padding:14px;
  display:flex;
  flex-direction:column;
  gap:10px;
}
.drawer.open{ transform:translateX(0); }
.drawer .drawer-top{ display:flex; justify-content:space-between; align-items:center; gap:10px; }
.drawer .drawer-top .t{ font-family:var(--font-mono); font-weight:900; letter-spacing:2px; color:#fff; }
.drawer textarea{ flex:1; resize:none; min-height:220px; }
.drawer .drawer-actions{ display:flex; flex-wrap:wrap; gap:8px; }
.drawer .drawer-actions button{ flex:1; min-width:160px; }
.drawer .file-row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
.drawer input[type="file"]{ color:rgba(255,255,255,0.8); font-family:var(--font-mono); }

/* ================= VIEW SWITCH (menu vs game) ================= */
/* 关键：不要隐藏 #wrap（menu 在里面），只压暗 canvas */
body[data-view="menu"] #wrap{
  opacity:1 !important;
  filter:none !important;
  pointer-events:auto !important;
}
body[data-view="menu"] canvas{
  opacity:0.22;
  filter:blur(2px) saturate(0.8);
}
body[data-view="menu"] .top,
body[data-view="menu"] .bottom{
  opacity:0;
  pointer-events:none;
}
body[data-view="menu"] #menu{
  opacity:1 !important;
  pointer-events:auto !important;
}
body[data-view="game"] #wrap{
  opacity:1;
  pointer-events:auto;
  filter:none;
  transition:opacity .25s ease, filter .25s ease;
}

/* ================= RANGE (custom) ================= */
input[type="range"]{
  appearance:none;
  -webkit-appearance:none;
  height:18px;
  background:transparent;
}
input[type="range"]::-webkit-slider-runnable-track{
  height:6px;
  background:rgba(0,0,0,0.55);
  border:1px solid rgba(82,230,255,0.35);
  box-shadow:inset 0 0 12px rgba(82,230,255,0.06);
}
input[type="range"]::-webkit-slider-thumb{
  -webkit-appearance:none;
  width:16px; height:16px;
  margin-top:-6px;
  border-radius:3px;
  background:rgba(82,230,255,0.95);
  border:1px solid rgba(255,255,255,0.75);
  box-shadow:0 0 18px rgba(82,230,255,0.35);
}
input[type="range"]::-moz-range-track{
  height:6px;
  background:rgba(0,0,0,0.55);
  border:1px solid rgba(82,230,255,0.35);
}
input[type="range"]::-moz-range-thumb{
  width:16px; height:16px;
  border-radius:3px;
  background:rgba(82,230,255,0.95);
  border:1px solid rgba(255,255,255,0.75);
  box-shadow:0 0 18px rgba(82,230,255,0.35);
}

/* ===== FORCE OVERLAYS SHOW/HIDE (override inline styles) ===== */
#gameover, #pausePanel{
  display: none;
  position: fixed !important;
  inset: 0 !important;
  z-index: 20000 !important;
  pointer-events: auto !important;
}
#gameover.show, #pausePanel.show{
  display: flex !important; /* override inline display:none */
}
#gameover *, #pausePanel *{
  pointer-events: auto !important;
}

/* ===== GAMEOVER: force on top & controllable by class ===== */
#gameover{
  position: fixed !important;
  inset: 0 !important;
  z-index: 50000 !important;
  display: none !important;       /* ignore accidental inline */
  pointer-events: auto !important;
}
#gameover.show{
  display: flex !important;
}
#gameover, #gameover *{
  pointer-events: auto !important;
}

/* ================= JOYSTICK + INPUT MODE ================= */
.joystick-layer{
  position:fixed; inset:0;
  pointer-events:none;
  z-index:8;
  touch-action:none;
}
.joy-base{
  position:absolute;
  width:120px; height:120px;
  margin-left:-60px; margin-top:-60px;
  border-radius:50%;
  border:2px solid rgba(82,230,255,0.30);
  background:radial-gradient(
    circle,
    rgba(82,230,255,0.05) 0%,
    rgba(82,230,255,0.01) 60%,
    transparent 100%
  );
  opacity:0;
  transition:opacity .10s ease;
  pointer-events:none;
}
.joy-base::before{
  content:"";
  position:absolute; inset:0;
  background:
    linear-gradient(0deg,   transparent 46%, rgba(82,230,255,0.10) 49%,
                    rgba(82,230,255,0.10) 51%, transparent 54%),
    linear-gradient(90deg,  transparent 46%, rgba(82,230,255,0.10) 49%,
                    rgba(82,230,255,0.10) 51%, transparent 54%);
  border-radius:50%;
}
.joy-base.on{ opacity:1; }

.joy-thumb{
  position:absolute;
  width:40px; height:40px;
  margin-left:-20px; margin-top:-20px;
  border-radius:50%;
  border:2px solid rgba(82,230,255,0.65);
  background:radial-gradient(
    circle,
    rgba(82,230,255,0.25) 0%,
    rgba(82,230,255,0.06) 70%,
    transparent 100%
  );
  box-shadow:0 0 10px rgba(82,230,255,0.20);
  opacity:0;
  transition:opacity .06s ease;
  pointer-events:none;
}
.joy-thumb.on{ opacity:1; }

.input-mode-tag{
  position:fixed;
  bottom:max(6px, env(safe-area-inset-bottom));
  right:8px;
  font-family:var(--font-mono);
  font-size:9px;
  letter-spacing:1px;
  color:rgba(82,230,255,0.30);
  pointer-events:none;
  z-index:12;
  text-transform:uppercase;
}
body[data-view="menu"] .input-mode-tag{ display:none; }

.control-pick{
  display:flex;
  gap:8px;
}
.control-pick .pick-chip{
  flex:1;
  text-align:center;
  padding:10px 6px;
  font-size:12px;
}

/* ================= 底部 HUD 半透明化 ================= */

/* 整个底部区域完全穿透点击 */
.bottom,
.bottom *{
  pointer-events:none !important;
}

/* 主面板：大幅降低背景不透明度 */
.hud-panel{
  background:linear-gradient(
    90deg,
    rgba(0,0,0,0.15) 0%,
    rgba(14,23,56,0.25) 20%,
    rgba(14,23,56,0.25) 80%,
    rgba(0,0,0,0.15) 100%
  );
  border-top:1px solid rgba(82,230,255,0.08);
  border-bottom:1px solid rgba(82,230,255,0.08);
  backdrop-filter:none;
  -webkit-backdrop-filter:none;
  padding:8px 12px;
  opacity:0.75;
  transition:opacity .2s ease;
}

/* 左右竖线装饰弱化 */
.hud-panel::before,
.hud-panel::after{
  background:rgba(82,230,255,0.12);
  width:2px;
  height:40%;
}

/* 玩家操作时面板进一步淡出，完全不干扰 */
body[data-view="game"] .bottom:has(~ *) .hud-panel,
.hud-panel{
  /* 触摸激活时通过 JS 可进一步控制，这里给基础淡化 */
}

/* 血条背景更透 */
.bar-track{
  background:rgba(0,0,0,0.25);
  border-color:rgba(255,255,255,0.06);
}
.bar-track.shd{
  background:none;
}

/* 血条填充降低光晕 */
.bar-fill{
  box-shadow:1px 0 5px currentColor;
}

/* 数据行更淡 */
.data-row{
  color:rgba(255,255,255,0.40);
  font-size:10px;
  margin-top:4px;
}
.data-val{
  color:rgba(255,255,255,0.70);
}

/* 状态芯片更轻 */
.chip{
  background:rgba(0,0,0,0.18);
  border-color:rgba(255,255,255,0.12);
  box-shadow:none;
  font-size:9px;
  padding:2px 6px;
}

/* 炸弹指示更淡 */
.bomb-display{
  opacity:0.65;
}
.bomb-dot{
  border-color:rgba(255,176,32,0.20);
  background:rgba(0,0,0,0.20);
  width:8px; height:8px;
}
.bomb-dot.on{
  background:rgba(255,176,32,0.65);
  box-shadow:0 0 4px rgba(255,176,32,0.35);
  border-color:rgba(255,255,255,0.45);
}

/* XP条更细更淡 */
.bar-track.xp{
  height:3px;
  background:rgba(0,0,0,0.15);
  border:none;
}

/* OD/MAG 计时条更淡 */
.bar-track.od,
.bar-track.mag{
  height:2px;
}
.bar-track.od .bar-fill,
.bar-track.mag .bar-fill{
  box-shadow:none;
}

/* 芯片行减高 */
.chip-row{
  height:16px;
  margin-top:4px;
}

/* 底部提示文字更淡更小 */
.hint{
  opacity:0.25;
  font-size:9px;
  margin-top:2px;
  letter-spacing:1px;
}

/* HP 文字更淡 */
.bar-row .mono{
  color:rgba(255,255,255,0.50);
  font-size:11px;
}
.bar-label{
  color:rgba(82,230,255,0.55);
  font-size:9px;
}

/* 底部整体紧凑 */
.bottom{
  padding:0 12px max(8px, env(safe-area-inset-bottom));
  gap:4px;
}

/* ---- 顶部 HUD 也做适度透明化保持风格一致 ---- */
.top .stat-pill{
  background:rgba(0,0,0,0.30);
  border-color:rgba(255,255,255,0.08);
}

/* ---- 游戏中按钮保留可点击 ---- */
.top,
.top *{
  pointer-events:auto;
}
.top .mini-btn{
  pointer-events:auto !important;
  background:rgba(0,0,0,0.30);
  border-color:rgba(255,255,255,0.12);
}

.top .stat-pill:first-child {
  max-width: 90px; /* 强制上限 */
  overflow: hidden;
  white-space: nowrap;
}

#score {
  display: inline-block;
  min-width: 60px;
  text-align: left;
}

input[type="checkbox"] {
  accent-color: var(--c-cyan);
  cursor: pointer;
}

  </style>
</head>
<body>

<div id="wrap">
  <canvas id="c"></canvas>

<div class="joystick-layer" id="joyLayer">
  <div class="joy-base"  id="joyBase"></div>
  <div class="joy-thumb" id="joyThumb"></div>
</div>
<div class="input-mode-tag" id="inputModeTag"></div>
<!-- [新增] Option / TAS 设置面板 -->
<div class="center-overlay" id="optionPanel" style="display:none">
  <div class="menu-panel cyber-panel" style="width:min(400px,90vw)">
    <div class="card-title">SYSTEM CONFIG</div>
    
    <!-- 游戏速率滑条 -->
    <div class="field" id="optSpeedField">
      <label>GAME SPEED: <span id="valSpeed" class="c-p1">1.0</span>x</label>
      <input id="inpSpeed" type="range" min="0.1" max="2.0" step="0.1" value="1.0">
    </div>

    <!-- TAS 模式开关 -->
    <div class="field" id="optTasField" style="margin-top:10px">
      <label style="display:flex;justify-content:space-between;align-items:center">
        <span>TAS MODE (AUTO REWIND)</span>
        <input id="inpTas" type="checkbox" style="width:20px;height:20px;">
      </label>
      <div class="muted" style="font-size:10px;margin-top:4px">
        死亡时自动回溯 3 秒，不重置游戏。
      </div>
    </div>

    <!-- 按钮组 -->
    <div class="actions" style="margin-top:20px">
      <button id="btnOptResume">BACK</button>
      <button id="btnOptMenu" style="border-color:rgba(255,255,255,0.3);color:#aaa">EXIT TO TITLE</button>
    </div>
  </div>
</div>

  <div class="ui">
    <!-- Top HUD -->
    <div class="top">
      <div class="hud-group">
        <div class="stat-pill"><span class="muted">分</span> <b id="score" class="c-cyan">0</b></div>
        <div class="stat-pill" style="border-color:var(--c-yellow)"><span class="muted">WAVE</span> <b id="wave" class="c-y">1</b></div>
      </div>
      <div class="hud-group">
<button id="btnPause" class="mini-btn">PAUSE</button>
<button id="btnOption" class="mini-btn" style="display:none;border-color:var(--c-cyan);">OPTION</button>
<button id="btnMute" class="mini-btn">AUDIO: ON</button>
<button id="btnAutoPilot" class="mini-btn" style="border-color:var(--c-magenta); color:var(--c-magenta)">AI: OFF</button>
<button id="btnPauseRetry" class="mini-btn" style="display:none; border-color:var(--c-yellow); color:var(--c-yellow)">RETRY</button>
      </div>
    </div>
    <!-- Bottom HUD -->
    <div class="bottom">
      <div id="fortressPanel">
        <div class="row" style="margin-bottom:6px">
          <span class="mono" id="fortressPhase" style="font-size:12px;color:var(--c-yellow)">FORTRESS</span>
          <span class="mono" id="fortressMat" style="font-size:12px">MAT 0</span>
          <span class="mono" id="fortressCore" style="font-size:12px;color:var(--c-danger)">FLAG 100%</span>
        </div>
        <div id="fortressBuildScroller">
          <button id="btnFortNone" data-item="none" class="mini-btn">空</button>
          <button id="btnFortBarricade" data-item="barricade" class="mini-btn on">木障 3</button>
          <button id="btnFortWall" data-item="wall" class="mini-btn">钢壁 6</button>
          <button id="btnFortHeavyWall" data-item="heavywall" class="mini-btn">合金墙 11</button>
          <button id="btnFortBunker" data-item="bunker" class="mini-btn">堡垒墙 18</button>
          <button id="btnFortShield" data-item="shield" class="mini-btn" style="border-color:var(--c-magenta);color:var(--c-magenta)">棱镜盾 9</button>
          <button id="btnFortTurret" data-item="turret" class="mini-btn" style="border-color:var(--c-danger);color:var(--c-danger)">炮塔+ 10</button>
          <button id="btnFortGatling" data-item="gatling" class="mini-btn" style="border-color:#ff8f8f;color:#ff8f8f">加特林 12</button>
          <button id="btnFortSniper" data-item="sniper" class="mini-btn">狙击塔 14</button>
          <button id="btnFortMissile" data-item="missile" class="mini-btn" style="border-color:#ffd28a;color:#ffd28a">导弹井 16</button>
          <button id="btnFortTesla" data-item="tesla" class="mini-btn" style="border-color:#9dd7ff;color:#9dd7ff">特斯拉塔 15</button>
          <button id="btnFortFlame" data-item="flame" class="mini-btn" style="border-color:#ffb56b;color:#ffb56b">喷火塔 13</button>
          <button id="btnFortMortar" data-item="mortar" class="mini-btn" style="border-color:#d7d7ff;color:#d7d7ff">迫击炮 17</button>
          <button id="btnFortDrone" data-item="dronepad" class="mini-btn" style="border-color:#8bf7ff;color:#8bf7ff">无人机坪 16</button>
          <button id="btnFortPulse" data-item="pulse" class="mini-btn" style="border-color:var(--c-yellow);color:var(--c-yellow)">脉冲器 12</button>
          <button id="btnFortMine" data-item="mine" class="mini-btn">地雷 8</button>
          <button id="btnFortSlow" data-item="slow" class="mini-btn">减速塔 11</button>
          <button id="btnFortRepair" data-item="repair" class="mini-btn">旗帜维修机 13</button>
          <button id="btnFortRepairPlayer" data-item="repairplayer" class="mini-btn" style="border-color:#9deeff;color:#9deeff">医疗站 12</button>
          <button id="btnFortRepairField" data-item="repairfield" class="mini-btn" style="border-color:#9dffad;color:#9dffad">工程站 14</button>
          <button id="btnFortFactory" data-item="factory" class="mini-btn" style="border-color:#9dffad;color:#9dffad">补给站 12</button>
          <button id="btnFortSpinner" data-item="spinner" class="mini-btn" style="border-color:#92c7ff;color:#92c7ff">旋刃塔 15</button>
          <button id="btnFortRam" data-item="ram" class="mini-btn" style="border-color:#ffcb66;color:#ffcb66">冲锋桩 14</button>
          <button id="btnFortBeacon" data-item="beacon" class="mini-btn" style="border-color:#b8a6ff;color:#b8a6ff">指挥信标 10</button>
          <button id="btnFortTaunt" data-item="taunt" class="mini-btn" style="border-color:#ff9b72;color:#ff9b72">诱敌堡 16</button>
        </div>
        <div class="row" style="margin-top:4px">
          <button id="btnFortStartWave" class="mini-btn" style="border-color:var(--c-danger);color:var(--c-danger)">开始敌袭</button>
          <button id="btnFortRepairFlag" class="mini-btn" style="border-color:#ff7fa1;color:#ff7fa1">修旗 6</button>
          <button id="btnFortSell" class="mini-btn" style="border-color:#ffb347;color:#ffb347">SELL</button>
          <button id="btnFortUndo" class="mini-btn">UNDO</button>
          <button id="btnFortExportLayout" class="mini-btn" style="display:none;border-color:#9deeff;color:#9deeff">导出阵型</button>
          <button id="btnFortImportLayout" class="mini-btn" style="display:none;border-color:#9deeff;color:#9deeff">导入阵型</button>
        </div>
      </div>

      <div class="hud-panel">
        
        <!-- HP Row -->
        <div class="bar-row">
          <div class="bar-label">HP</div>
          <div style="flex:1">
            <div class="bar-track hp"><div class="bar-fill" id="hpFill"></div></div>
            <div class="bar-track shd"><div class="bar-fill" id="shieldFill" style="width:0%"></div></div>
          </div>
          <div class="mono" style="font-size:12px;width:60px;text-align:right" id="hpText">100/100</div>
        </div>

        <!-- Energy/Bomb Row -->
        <div class="data-row">
          <div style="display:flex; gap:15px">
            <span>LVL<span class="data-val c-p1" id="lvText">1</span></span>
            <span>XP <span class="data-val" id="xpText">0/30</span></span>
          </div>
          <div class="bomb-display">
            <span class="muted">BOMB</span>
            <span id="bombIcons" style="display:inline-flex;gap:4px"></span>
            <span id="bombText" class="mono" style="margin-left:4px">1</span>
          </div>
        </div>
        
        <!-- XP Bar (Slim) -->
        <div class="bar-track xp" style="margin-top:4px"><div class="bar-fill" id="xpFill"></div></div>

        <!-- Timers (OD / Mag) -->
        <div style="display:flex; gap:4px; margin-top:4px; height:4px">
          <div class="bar-track od"><div class="bar-fill" id="odFill"></div></div>
          <div class="bar-track mag"><div class="bar-fill" id="magFill"></div></div>
        </div>
        
        <!-- Stats details -->
        <div class="data-row muted" style="margin-top:4px; justify-content:flex-start; gap:15px">
           <span>DRN <b id="droneText">0</b></span>
           <span>MOD <b id="modText">0</b></span>
        </div>

        <!-- Buff Chips -->
        <div class="chip-row" id="chipRow">
          <span class="chip c-r" id="chipSlow" style="display:none; color:var(--c-danger)">⚠ SLOW</span>
          <span class="chip c-y" id="chipOD" style="display:none; color:var(--c-danger)">OD <b id="odText">0.0</b>s</span>
          <span class="chip c-p1" id="chipMag" style="display:none; color:var(--c-cyan)">MAG <b id="magText">0.0</b>s</span>
          <span class="chip c-p2" id="chipShield" style="display:none; color:var(--c-magenta)">SHD <b id="shText">0.0</b>s</span>
        </div>

      </div>
      <div class="hint">DOUBLE TAP TO DETONATE BOMB</div>
    </div>
    <button id="btnCompactUI" class="ui-fab">UI</button>

    <!-- Main Menu -->
    <div id="menu" class="screen">
  <div class="menu-bg"></div>

  <div class="menu-shell cyber-panel">
    <div class="menu-topbar">
      <div class="brand">
        <div class="title">NEON ELECTRIC PLANE</div>
        <div class="sub">NEP · v1.0</div>
      </div>
      <div class="menu-nav">
        <button class="nav-btn mini-btn active" data-page="home">HOME</button>
        <button class="nav-btn mini-btn" data-page="workshop">PLAYER</button>
        <button class="nav-btn mini-btn" data-page="forge">FORGE</button>
        <button class="nav-btn mini-btn" id="btnOpenIO" style="border-color:rgba(255,176,32,0.45);color:var(--c-yellow)">I/O</button>
      </div>
    </div>

    <div class="menu-main">
      <div>
        <!-- HOME -->
        <div class="page active" id="pageHome">

          <div class="menu-card">
            <div class="card-title">START OPTIONS</div>
            <div class="field">
  <label>CONTROL MODE</label>
  <div class="control-pick" id="controlPick"></div>
</div>
<div class="field">
  <label>DIFFICULTY 难度设定</label>
  <select id="inpDiffMode">
    <option value="0">CASUAL (轻松)</option>
    <option value="1" selected>NORMAL (标准)</option>
    <option value="2">HARD (困难)</option>
    <option value="3">HELL (地狱)</option>
  </select>
  <div class="muted" style="font-size:10px; margin-top:4px;">
    影响：怪物密度 / 词条数量 / 弹幕密度 / 掉落率
  </div>
</div>
            <div class="field">
              <label>WARP TO WAVE (SURVIVAL)</label>
              <input id="inpStartWave" type="number" min="1" max="200" value="1">
            </div>
            <div class="field">
  <label>DYNAMIC ZOOM</label>
  <select id="inpDynZoom">
    <option value="1">ON — AUTO ZOOM OUT</option>
    <option value="0">OFF — FIXED VIEW</option>
  </select>
</div>
<details class="acc" style="margin-top:10px;">
  <summary>联机 MULTIPLAYER <span class="muted">WIP(RIP)</span></summary>
  <div class="acc-body" style="padding-top:8px;">
    <div class="field"><label>SERVER</label><input id="inpMpServer" type="text" maxlength="120" placeholder="ws://127.0.0.1:8787"></div>
    <div class="field"><label>ROOM</label><input id="inpMpRoom" type="text" maxlength="20" placeholder="房间号（大写字母/数字）"></div>
    <div class="field"><label>NICK</label><input id="inpMpNick" type="text" maxlength="16" placeholder="昵称（默认 PILOT）"></div>
    <div class="field"><label>NET MODE</label>
      <select id="inpMpMode">
        <option value="survival" selected>SURVIVAL</option>
        <option value="challenge">CHALLENGE</option>
        <option value="lab">LAB</option>
        <option value="workshop">WORKSHOP 1V1 (A vs A)</option>
        <option value="fortress_duel">FORTRESS DUEL 1V1</option>
      </select>
    </div>
    <div class="menu-actions" style="margin-top:8px;gap:8px;flex-wrap:wrap;justify-content:flex-start;">
      <button id="btnMpConnect" class="mini-btn" style="border-color:var(--c-magenta);color:var(--c-magenta)">CONNECT</button>
      <button id="btnMpJoin" class="mini-btn" style="border-color:var(--c-cyan);">JOIN ROOM</button>
      <button id="btnMpLeave" class="mini-btn" style="border-color:rgba(255,255,255,0.3);color:#bbb">LEAVE</button>
      <button id="btnMpStart" class="mini-btn" style="border-color:var(--c-yellow);color:var(--c-yellow)">PREPARE</button>
    </div>
    <div id="mpStatus" class="muted" style="margin-top:6px; font-size:10px; word-break:break-word;">联机未连接</div>
  </div>
</details>
            <div class="menu-actions">
              <button id="btnStartSurvival">START SURVIVAL (BUILD A)</button>
              <button id="btnStartChallenge" style="border-color:var(--c-danger);color:var(--c-danger)">CHAOS CHALLENGE (1v1)</button>
              <button id="btnStartFortress" style="border-color:#7ef9c0;color:#7ef9c0">START FORTRESS (BASTION)</button>
              <button id="btnStartDuel" style="border-color:var(--c-yellow);color:var(--c-yellow)">START DUEL (A vs B)</button>
              <button id="btnStartLab" style="border-color:rgba(179,108,255,0.6);color:var(--c-magenta)">START LAB (FORGE)</button>
              <button id="btnStartUnitBattle" style="border-color:#9deeff;color:#9deeff">START UNIT BATTLE</button>
            </div>
          </div>

        </div>

        <!-- WORKSHOP -->
        <div class="page" id="pageWorkshop">
          <div class="menu-card">
            <div class="card-title">PLAYER WORKSHOP</div>
            <div class="menu-intro">低密度：折叠分组 + 滑条/数字联动 + 词条芯片选择 + 右侧预览。</div>
          </div>

          <div class="menu-card">
            <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between">
              <div style="display:flex; gap:8px; flex-wrap:wrap">
                <button class="mini-btn nav-btn active" id="btnEditA">EDIT BUILD A</button>
                <button class="mini-btn nav-btn" id="btnEditB">EDIT BUILD B</button>
              </div>
              <div class="menu-actions" style="margin:0; width:min(420px,100%)">
                <button id="btnSaveBuilds" style="border-color:var(--c-yellow);color:var(--c-yellow)">SAVE</button>
                <button id="btnResetBuilds" style="border-color:rgba(255,255,255,0.25);color:#aaa">RESET</button>
              </div>
            </div>
          </div>

          <details class="acc">
            <summary>CORE <span class="muted">HP / FIRE / DMG / CRIT</span></summary>
            <div class="acc-body">
              <div class="field"><label>NAME</label><input id="ws_name"></div>

              <div class="field"><label>MAX HP</label>
                <div class="slider-row">
                  <input id="ws_hp_r" type="range" min="30" max="600" step="1">
                  <input id="ws_hp_n" type="number" min="30" max="600" step="1">
                </div>
              </div>

              <div class="field"><label>FIRE RATE MUL</label>
                <div class="slider-row">
                  <input id="ws_fire_r" type="range" min="0.5" max="3.0" step="0.01">
                  <input id="ws_fire_n" type="number" min="0.5" max="3.0" step="0.01">
                </div>
              </div>

              <div class="field"><label>DMG MUL</label>
                <div class="slider-row">
                  <input id="ws_dmg_r" type="range" min="0.5" max="5.0" step="0.01">
                  <input id="ws_dmg_n" type="number" min="0.5" max="5.0" step="0.01">
                </div>
              </div>

              <div class="field"><label>CRIT</label>
                <div class="slider-row">
                  <input id="ws_crit_r" type="range" min="0" max="0.6" step="0.01">
                  <input id="ws_crit_n" type="number" min="0" max="0.6" step="0.01">
                </div>
              </div>
            </div>
          </details>

          <details class="acc">
            <summary>UTILITY <span class="muted">PIERCE / DRONES / HOMING / BOMB</span></summary>
            <div class="acc-body">
              <div class="field"><label>PIERCE BASE</label>
                <div class="slider-row">
                  <input id="ws_pierce_r" type="range" min="0" max="8" step="1">
                  <input id="ws_pierce_n" type="number" min="0" max="8" step="1">
                </div>
              </div>

              <div class="field"><label>DRONES</label>
                <div class="slider-row">
                  <input id="ws_drones_r" type="range" min="0" max="4" step="1">
                  <input id="ws_drones_n" type="number" min="0" max="4" step="1">
                </div>
              </div>

              <div class="field"><label>HOMING AMMO</label>
                <div class="slider-row">
                  <input id="ws_homing_r" type="range" min="0" max="120" step="1">
                  <input id="ws_homing_n" type="number" min="0" max="120" step="1">
                </div>
              </div>

              <div class="field"><label>START BOMB</label>
                <div class="slider-row">
                  <input id="ws_bomb_r" type="range" min="0" max="3" step="1">
                  <input id="ws_bomb_n" type="number" min="0" max="3" step="1">
                </div>
              </div>
            </div>
          </details>

          <details class="acc">
            <summary>AFFIX <span class="muted">CHIPS</span></summary>
            <div class="acc-body">
              <div class="field"><label>SEARCH</label>
                <input id="ws_modSearch" placeholder="filter... (e.g. HOMING, SPLIT)">
              </div>
              <div class="chip-pick" id="ws_modChips"></div>
              <div class="muted" style="margin-top:8px">建议保持 0~4 个词条；分裂/烟花类会显著提高弹幕量。</div>
            </div>
          </details>
          <details class="acc">
  <summary>PLAYER EMITTERS <span class="muted">START LOADOUT · 0~3</span></summary>
  <div class="acc-body">
    <div class="field">
      <label>SEARCH</label>
      <input id="ws_emitSearch" placeholder="filter... (e.g. RING, SHOTGUN)">
    </div>
    <div class="chip-pick" id="ws_emitChips"></div>
    <div class="muted" style="margin-top:8px">
      选择玩家开局携带的额外发射器（最多 3 个）。生存模式中仍可掉落并“顶掉最旧”的 emitter。
    </div>
  </div>
</details>
        </div>

        <!-- FORGE -->
        <div class="page" id="pageForge">
          <div class="menu-card forge-preview-top" id="forgePreviewTopWrap">
  <div class="card-title">FORGE PREVIEW</div>
  <canvas id="forgePreviewTop" width="520" height="300"
          style="width:100%;height:auto;border:1px solid rgba(255,255,255,0.10);background:rgba(0,0,0,0.25)"></canvas>
</div>
          <div class="menu-card">
            <div class="card-title">ENEMY / BOSS FORGE</div>
            <div class="menu-intro">同样低密度：基础参数用 select/input，词条/traits 用芯片选择。</div>
          </div>

          <details class="acc">
            <summary>FORGE CORE</summary>
            <div class="acc-body">
              <div class="field"><label>IS BOSS</label>
                <select id="forgeBoss"><option value="0">NO</option><option value="1">YES</option></select>
              </div>
              <div class="field">
  <label>MOVE PATTERNS (1+)</label>
  <div class="chip-pick" id="forgeMoveChips" style="max-height: 120px; overflow-y: auto;">
    <!-- JS will populate this -->
  </div>
  <div class="muted" style="font-size: 10px; margin-top: 4px;">选择1个或多个移动模式。游戏中敌人会动态切换。</div>
</div>
              <div class="field"><label>COLOR</label><select id="forgeCol"></select></div>
              <div class="field"><label>HP</label><input id="forgeHp" type="number" min="20" max="99999" value="900"></div>
              <div class="field"><label>BODY KIND</label>
  <select id="forgeBodyKind">
    <option value="AUTO">AUTO</option>
    <option value="poly">poly</option>
    <option value="star">star</option>
    <option value="gear">gear</option>
    <option value="ringRect">ringRect</option>
    <option value="diamondRing">diamondRing</option>
    <option value="arcSeg">arcSeg</option>
    <option value="crescent">crescent</option>
    <option value="cross">cross</option>
    <option value="chevron">chevron</option>
    <option value="dodeca">dodeca</option>
    <option value="cone">cone</option>
  </select>
</div>

<div class="field"><label>BODY SEED</label>
  <input id="forgeBodySeed" type="number" value="1337">
</div>

<div class="field"><label>BODY SCALE</label>
  <input id="forgeBodyScale" type="number" step="0.05" min="0.6" max="2.2" value="1.00">
</div>
            </div>
          </details>
          
          <details class="acc">
  <summary>APPEARANCE <span class="muted">BODY PARAMS</span></summary>
  <div class="acc-body">

    <div class="field"><label>BASE N (POLY/STAR)</label>
      <input id="forgeBaseN" type="number" min="3" max="12" step="1" placeholder="AUTO">
    </div>

    <div class="field"><label>INNER N</label>
      <input id="forgeInnerN" type="number" min="3" max="12" step="1" placeholder="AUTO">
    </div>

    <div class="field"><label>RING</label>
      <select id="forgeRing">
        <option value="">AUTO</option>
        <option value="1">ON</option>
        <option value="0">OFF</option>
      </select>
    </div>

    <div class="field"><label>SPOKES</label>
      <input id="forgeSpokes" type="number" min="0" max="10" step="1" placeholder="AUTO">
    </div>

    <div class="field"><label>STAR INNER</label>
      <input id="forgeStarInner" type="number" min="0.20" max="0.85" step="0.01" placeholder="AUTO">
    </div>

    <div class="field"><label>GEAR TEETH</label>
      <input id="forgeTeeth" type="number" min="3" max="26" step="1" placeholder="AUTO">
    </div>

    <div class="field"><label>GEAR TOOTH DEPTH</label>
      <input id="forgeToothDepth" type="number" min="0.05" max="0.45" step="0.01" placeholder="AUTO">
    </div>

    <div class="field"><label>RINGRECT ROUND (rr)</label>
      <input id="forgeRR" type="number" min="0.10" max="0.60" step="0.01" placeholder="AUTO">
    </div>

    <div class="field"><label>DIAMOND SKEW</label>
      <input id="forgeDiaSkew" type="number" min="0.40" max="1.60" step="0.01" placeholder="AUTO">
    </div>

    <div class="field"><label>ARC SEGS</label>
      <input id="forgeArcSegs" type="number" min="2" max="10" step="1" placeholder="AUTO">
    </div>

    <div class="field"><label>ARC SPAN</label>
      <input id="forgeArcSpan" type="number" min="0.20" max="1.60" step="0.01" placeholder="AUTO">
    </div>

    <div class="field"><label>ARC GAP</label>
      <input id="forgeArcGap" type="number" min="0.00" max="1.00" step="0.01" placeholder="AUTO">
    </div>

  </div>
</details>

<details class="acc">
  <summary>WEAPONS</summary>
  <div class="acc-body">
    
    <!-- EMITTER #1 CONFIG -->
    <div style="background:rgba(0,0,0,0.2); padding:8px; border:1px solid rgba(255,255,255,0.05); margin-bottom:10px;">
      <div class="card-title muted" style="font-size:10px; margin-bottom:6px;">SLOT 1 CONFIG</div>
      
      <!-- Base Emitter -->
      <div class="field"><label>BASE EMITTER</label><select id="forgeEm1Type"></select></div>
      <div class="slider-row">
        <div class="field"><label>CD</label><input id="forgeEm1Cd" type="number" step="0.01" value="1.2"></div>
        <div class="field"><label>SPEED</label><input id="forgeEm1Speed" type="number" step="1" value="220"></div>
      </div>
      
      <!-- Base Mods Picker (Changed from Input to Div) -->
      <div class="field">
        <label>BASE MODS</label>
        <div id="forgeEm1ModsContainer" class="chip-pick" style="max-height:100px; overflow-y:auto; background:rgba(0,0,0,0.3);"></div>
      </div>

      <!-- Wrapper Layer 1 (Inner) -->
      <div style="margin-top:8px; border-top:1px dashed rgba(255,255,255,0.15); padding-top:4px;">
        <div class="field"><label>WRAPPER 1 (INNER)</label>
          <select id="forgeEm1Comp1" class="comp-selector" data-layer="1" data-slot="1"></select>
        </div>
        <div id="forgeEm1Comp1Cfg" class="comp-cfg-panel"></div>
      </div>

      <!-- Wrapper Layer 2 (Outer) -->
      <div style="margin-top:8px; border-top:1px dashed rgba(255,255,255,0.15); padding-top:4px;">
        <div class="field"><label>WRAPPER 2 (OUTER)</label>
          <select id="forgeEm1Comp2" class="comp-selector" data-layer="2" data-slot="1"></select>
        </div>
        <div id="forgeEm1Comp2Cfg" class="comp-cfg-panel"></div>
      </div>
    </div>

    <!-- EMITTER #2 CONFIG -->
    <div style="background:rgba(0,0,0,0.2); padding:8px; border:1px solid rgba(255,255,255,0.05);">
      <div class="card-title muted" style="font-size:10px; margin-bottom:6px;">SLOT 2 CONFIG</div>
      
      <!-- Base Emitter -->
      <div class="field"><label>BASE EMITTER</label><select id="forgeEm2Type"></select></div>
      <div class="slider-row">
        <div class="field"><label>CD</label><input id="forgeEm2Cd" type="number" step="0.01" value="2.2"></div>
        <div class="field"><label>SPEED</label><input id="forgeEm2Speed" type="number" step="1" value="180"></div>
      </div>
      
      <!-- Base Mods Picker (Changed from Input to Div) -->
      <div class="field">
        <label>BASE MODS</label>
        <div id="forgeEm2ModsContainer" class="chip-pick" style="max-height:100px; overflow-y:auto; background:rgba(0,0,0,0.3);"></div>
      </div>

      <!-- Wrapper Layer 1 (Inner) -->
      <div style="margin-top:8px; border-top:1px dashed rgba(255,255,255,0.15); padding-top:4px;">
        <div class="field"><label>WRAPPER 1 (INNER)</label>
          <select id="forgeEm2Comp1" class="comp-selector" data-layer="1" data-slot="2"></select>
        </div>
        <div id="forgeEm2Comp1Cfg" class="comp-cfg-panel"></div>
      </div>

      <!-- Wrapper Layer 2 (Outer) -->
      <div style="margin-top:8px; border-top:1px dashed rgba(255,255,255,0.15); padding-top:4px;">
        <div class="field"><label>WRAPPER 2 (OUTER)</label>
          <select id="forgeEm2Comp2" class="comp-selector" data-layer="2" data-slot="2"></select>
        </div>
        <div id="forgeEm2Comp2Cfg" class="comp-cfg-panel"></div>
      </div>
    </div>

  </div>
</details>

          <details class="acc">
            <summary>EXTRA EMITTERS <span class="muted">UNLIMITED</span></summary>
            <div class="acc-body">
              <div class="menu-actions" style="justify-content:flex-start;gap:6px">
                <button id="btnForgeExtraAdd" class="mini-btn">ADD BASE</button>
                <button id="btnForgeExtraAddFrom1" class="mini-btn">COPY SLOT1</button>
                <button id="btnForgeExtraAddFrom2" class="mini-btn">COPY SLOT2</button>
                <button id="btnForgeExtraMode" class="mini-btn">VIEW: UI</button>
              </div>
              <div class="muted" style="margin:6px 0 8px">每个条目支持完整 emitter/wrapper JSON，可无限追加、修改、删除。</div>
              <div id="forgeExtraEmittersList" style="display:flex;flex-direction:column;gap:8px"></div>
            </div>
          </details>

          <details class="acc">
            <summary>FORGE MODS / TRAITS</summary>
            <div class="acc-body">
              <div class="field"><label>BULLET AFFIX (BOTH EMITTERS)</label>
                <div class="chip-pick" id="forgeModChips"></div>
              </div>
              <div class="field"><label>ENEMY TRAITS</label>
                <div class="chip-pick" id="forgeTraitChips"></div>
              </div>
            </div>
          </details>
        </div>
        </div>

       

      <!-- right: preview -->
      <div class="side">
        <div class="menu-card forge-preview-side" id="forgePreviewSideWrap">
  <div class="card-title">FORGE PREVIEW</div>
  <canvas id="forgePreviewSide" width="420" height="260"
          style="width:100%;height:auto;border:1px solid rgba(255,255,255,0.10);background:rgba(0,0,0,0.25)"></canvas>
</div>
      
    </div>
  </div>
</div>

<!-- Import/Export Drawer -->


<div id="unitBattleModal" aria-hidden="true">
  <div class="ub-modal-card cyber-panel">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;margin-bottom:10px">
      <div class="ub-title" style="margin:0">UNIT BATTLE · 兵种批量导入对战</div>
      <button id="btnUbClose" class="mini-btn" style="border-color:rgba(255,255,255,0.3);color:#bbb">CLOSE</button>
    </div>
    <div class="muted" style="font-size:10px">导入多个怪物 Forge JSON（支持 {type:&quot;forge&quot;,forge:{...}} 与 {spec:{...}}），可无限追加。进入后先自由布置堡垒，再拖动半透明预览体调整刷怪点。</div>
    <div class="field" style="margin-top:8px"><label>UNIT JSON</label><textarea id="ubJsonInput" placeholder='粘贴 forge JSON'></textarea></div>
    <div class="menu-actions" style="margin-top:8px;justify-content:flex-start;gap:8px">
      <button id="btnUbImport" class="mini-btn" style="border-color:#9deeff;color:#9deeff">导入兵种</button>
      <button id="btnUbClear" class="mini-btn" style="border-color:#ff9b72;color:#ff9b72">清空兵种</button>
      <button id="btnUbStart" class="mini-btn" style="border-color:#7ef9c0;color:#7ef9c0">开始兵种对战</button>
      <button id="btnUbExportWinner" class="mini-btn" style="border-color:#ffd28a;color:#ffd28a">导出胜者</button>
    </div>
    <div id="ubList" class="ub-list"></div>
  </div>
</div>

<div class="drawer" id="ioDrawer" aria-hidden="true">
  <div class="drawer-top">
    <div class="t">IMPORT / EXPORT</div>
    <button class="mini-btn" id="btnCloseIO">CLOSE</button>
  </div>

  <div class="field">
    <label>DATA</label>
    <textarea id="ioText" spellcheck="false" placeholder="JSON will appear here..."></textarea>
  </div>

  <div class="drawer-actions">
    <button id="btnExportBuilds" style="border-color:var(--c-yellow);color:var(--c-yellow)">EXPORT BUILDS</button>
    <button id="btnImportBuilds">IMPORT BUILDS</button>
    <button id="btnExportForge" style="border-color:rgba(179,108,255,0.55);color:var(--c-magenta)">EXPORT FORGE</button>
    <button id="btnImportForge">IMPORT FORGE</button>
  </div>

  <div class="drawer-actions">
    <button id="btnCopyIO">COPY</button>
    <button id="btnDownloadIO">DOWNLOAD .JSON</button>
  </div>

  <div class="file-row">
  <input id="ioFile" type="file" accept="application/json"
         style="position:fixed;left:-9999px;top:-9999px;width:1px;height:1px;opacity:0">
  <button id="btnChooseFile" class="mini-btn">CHOOSE FILE</button>
  <button id="btnLoadFile" class="mini-btn" style="border-color:var(--c-yellow);color:var(--c-yellow)">IMPORT FILE</button>
  <span class="muted" id="ioFileName">NO FILE</span>
</div>

  <div class="muted">导入后会立即刷新 WORKSHOP / FORGE 的 UI。</div>
</div>

    <!-- Game Over / Pause Menu -->
    
    

  </div>
  <div class="center-overlay" id="gameover" style="display:none">
      <div class="menu-panel cyber-panel">
        <div class="game-title" style="font-size:32px; color:var(--c-danger)" data-text="CRITICAL FAILURE">CRITICAL FAILURE</div>
        
        <div style="display:flex; justify-content:space-around; margin:10px 0; font-size:18px">
          <div>SCORE <div class="c-cyan mono" style="font-size:24px" id="finalScore">0</div></div>
          <div>WAVE <div class="c-y mono" style="font-size:24px" id="finalWave">1</div></div>
        </div>

        <!-- Wave Jump Input -->
        <div class="input-row">
          <span>WARP TO WAVE:</span>
          <input id="inpWave" type="number" min="1" max="100" value="1">
        </div>

        <div class="actions">
          <button id="btnCopyKiller" style="border-color:rgba(179,108,255,0.6);color:var(--c-magenta);display:none">
  EXPORT KILLER
</button>
          <button id="btnRevive" style="border-color:var(--c-yellow); color:var(--c-yellow)">EMERGENCY REBOOT</button>
          <div class="actions-row">
            <button id="btnRestart">RETRY</button>
            <button id="btnBack" style="border-color:rgba(255,255,255,0.3); color:#aaa">ABORT</button>
          </div>
        </div>
      </div>
    </div>
</div>

<script>
  // ================= PERF / BALANCE =================
  const PERF = {
    dprMax: 2.1,
    stars: 80,
    additive: true,
    particlesMax: 1100,
    gridSpacing: 46,
    dynamicFX: true,
    fxFrameMod: 0,
  };

  const BAL = {
    // 难度曲线
    diffTimeEarly: 0.0150,
    diffTimeLate: 0.030,
    diffSwitchT: 75,
    diffScore: 1/4200,

    // 生成频率
    spawnRateEarly: 1.10,
    spawnRateLate: 0.34,

    bossMinTime: 52,
    bossInterval: 92,

    // 升级：无上限；但 XP 变慢 + 需求增长更快
    xpBase: 36,
    xpGrowth: 1.20,

    // 掉落
    dropBase: 0.18,

    // revive
    continueHP: 0.58,
    continueInvuln: 2.0,
  };

  // ================= Utils =================
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const rand = (a,b)=>a+Math.random()*(b-a);
  const randi = (a,b)=>a + (Math.random()*(b-a+1)|0);
  const chance = (p)=>Math.random()<p;
  const dist2 = (ax,ay,bx,by)=>{const dx=ax-bx,dy=ay-by;return dx*dx+dy*dy;};

  function smoothstep(a,b,x){
    const t = clamp((x-a)/(b-a), 0, 1);
    return t*t*(3-2*t);
  }
  function rgbToRgba(rgb, a){
    return rgb.replace('rgb(', 'rgba(').replace(')', `,${a})`);
  }
  function hellFactor(){
    return smoothstep(4, 13, Game.wave);
  }

  // seeded rng (for deterministic shapes)
  function makeRng(seed){
    let s = seed>>>0;
    return ()=> {
      s ^= s<<13; s >>>= 0;
      s ^= s>>17; s >>>= 0;
      s ^= s<<5;  s >>>= 0;
      return (s>>>0) / 4294967296;
    };
  }

  // ================= Canvas =================
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false, desynchronized:true });

  let W=0,H=0,DPR=1;
  function resize(){
    DPR = Math.min(PERF.dprMax, Math.max(1, window.devicePixelRatio||1));
    W = window.innerWidth|0;
    H = window.innerHeight|0;
    canvas.width = (W*DPR)|0;
    canvas.height = (H*DPR)|0;
    canvas.style.width = W+'px';
    canvas.style.height = H+'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // ================= UI =================
  const $ = (id)=>document.getElementById(id);
  const ui = {
    score: $('score'),
    wave: $('wave'),
    hpFill: $('hpFill'),
    shieldFill: $('shieldFill'),
    hpText: $('hpText'),

    lvText: $('lvText'),
    droneText: $('droneText'),
    modText: $('modText'),

    xpFill: $('xpFill'),
    xpText: $('xpText'),
    odFill: $('odFill'),
    magFill: $('magFill'),

    bombText: $('bombText'),
    bombIcons: $('bombIcons'),

    chipSlow: $('chipSlow'),
    chipOD: $('chipOD'),
    chipMag: $('chipMag'),
    chipShield: $('chipShield'),
    odText: $('odText'),
    magText: $('magText'),
    shText: $('shText'),
    inpWave: $('inpWave'),

    menu: $('menu'),
    over: $('gameover'),
    finalScore: $('finalScore'),
    finalWave: $('finalWave'),
    btnStart: $('btnStart'),
    btnRestart: $('btnRestart'),
    btnBack: $('btnBack'),
    btnPause: $('btnPause'),
    btnMute: $('btnMute'),
    btnRevive: $('btnRevive'),
    btnOption: $('btnOption'),
    btnCompactUI: $('btnCompactUI'),
    devBadge: $('devBadge'),

    fortressPanel: $('fortressPanel'),
    fortressPhase: $('fortressPhase'),
    fortressMat: $('fortressMat'),
    fortressCore: $('fortressCore'),
    btnFortRepairFlag: $('btnFortRepairFlag'),
    btnFortWall: $('btnFortWall'),
    btnFortTurret: $('btnFortTurret'),
    btnFortShield: $('btnFortShield'),
    btnFortPulse: $('btnFortPulse'),
    btnFortBarricade: $('btnFortBarricade'),
    btnFortHeavyWall: $('btnFortHeavyWall'),
    btnFortGatling: $('btnFortGatling'),
    btnFortMissile: $('btnFortMissile'),
    btnFortTesla: $('btnFortTesla'),
    btnFortBunker: $('btnFortBunker'),
    btnFortFlame: $('btnFortFlame'),
    btnFortMortar: $('btnFortMortar'),
    btnFortDrone: $('btnFortDrone'),
    btnFortFactory: $('btnFortFactory'),
    btnFortMine: $('btnFortMine'),
    btnFortSlow: $('btnFortSlow'),
    btnFortRepair: $('btnFortRepair'),
    btnFortSniper: $('btnFortSniper'),
    btnFortStartWave: $('btnFortStartWave'),
    btnFortSell: $('btnFortSell'),
    btnFortUndo: $('btnFortUndo'),
    btnFortExportLayout: $('btnFortExportLayout'),
    btnFortImportLayout: $('btnFortImportLayout'),

    inpMpServer: $('inpMpServer'),
    inpMpRoom: $('inpMpRoom'),
    inpMpNick: $('inpMpNick'),
    btnMpConnect: $('btnMpConnect'),
    btnMpJoin: $('btnMpJoin'),
    btnMpLeave: $('btnMpLeave'),
    btnMpStart: $('btnMpStart'),
    inpMpMode: $('inpMpMode'),
    mpStatus: $('mpStatus'),
  };

  // ================= Audio =================
  let audioOn = true;
  let audioCtx = null;

  // master graph
  let masterGain=null, sfxGain=null, bgmGain=null, comp=null;
  let noiseBuf=null;

  function initAudioGraph(){
    if (!audioCtx || masterGain) return;

    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.92;

    sfxGain = audioCtx.createGain();
    sfxGain.gain.value = 0.90;

    bgmGain = audioCtx.createGain();
    bgmGain.gain.value = 0.28;

    // light limiter / glue
    comp = audioCtx.createDynamicsCompressor();
    comp.threshold.value = -18;
    comp.knee.value = 24;
    comp.ratio.value = 6;
    comp.attack.value = 0.003;
    comp.release.value = 0.18;

    sfxGain.connect(comp);
    bgmGain.connect(comp);
    comp.connect(masterGain).connect(audioCtx.destination);

    // noise buffer for hats/snare
    const len = Math.floor(audioCtx.sampleRate * 0.25);
    noiseBuf = audioCtx.createBuffer(1, len, audioCtx.sampleRate);
    const ch = noiseBuf.getChannelData(0);
    for(let i=0;i<len;i++) ch[i] = (Math.random()*2-1) * 0.8;
  }

  function ensureAudio(){
    if (!audioOn) return null;
    if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
    initAudioGraph();
    return audioCtx;
  }

  function setBgmLevel(v, t=0.06){
    if (!bgmGain || !audioCtx) return;
    bgmGain.gain.setTargetAtTime(v, audioCtx.currentTime, t);
  }
  function setSfxLevel(v, t=0.03){
    if (!sfxGain || !audioCtx) return;
    sfxGain.gain.setTargetAtTime(v, audioCtx.currentTime, t);
  }

  function beep({type='sine', f=440, t=0.05, g=0.03, slide=0}){
    const ac = ensureAudio();
    if (!ac) return;
    const o = ac.createOscillator();
    const gn = ac.createGain();
    const now = ac.currentTime;
    o.type = type;
    o.frequency.setValueAtTime(f, now);
    if (slide) o.frequency.exponentialRampToValueAtTime(Math.max(40, f*slide), now+t);
    gn.gain.setValueAtTime(0.0001, now);
    gn.gain.exponentialRampToValueAtTime(g, now+0.01);
    gn.gain.exponentialRampToValueAtTime(0.0001, now+t);
    o.connect(gn).connect(sfxGain);
    o.start(now); o.stop(now+t+0.02);
  }

  // ---- synth helpers for BGM / richer SFX ----
  function midiToFreq(m){ return 440*Math.pow(2,(m-69)/12); }

  function voice({t, freq, dur, gain=0.12, type='sawtooth', lp=1200, hp=0, dest='bgm', slideTo=0, atk=0.008, rel=0.10}){
    const ac = ensureAudio();
    if (!ac) return;
    const o = ac.createOscillator();
    const g = ac.createGain();
    let node = o;

    if (hp>0){
      const f = ac.createBiquadFilter();
      f.type='highpass'; f.frequency.value=hp;
      node.connect(f); node = f;
    }
    if (lp>0){
      const f2 = ac.createBiquadFilter();
      f2.type='lowpass'; f2.frequency.value=lp;
      node.connect(f2); node = f2;
    }

    o.type = type;
    o.frequency.setValueAtTime(freq, t);
    if (slideTo>0) o.frequency.exponentialRampToValueAtTime(slideTo, t+Math.min(dur, 0.08));

    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(gain, t+atk);
    g.gain.exponentialRampToValueAtTime(0.0001, t+dur+rel);

    node.connect(g);
    g.connect(dest==='bgm' ? bgmGain : sfxGain);

    o.start(t);
    o.stop(t+dur+rel+0.02);
  }

  function drumKick(t, v=0.9){
    const f0 = 120, f1 = 50;
    voice({t, freq:f0, slideTo:f1, dur:0.085, gain:0.22*v, type:'sine', lp:900, dest:'bgm', atk:0.002, rel:0.06});
    // click
    voice({t, freq:2200, dur:0.01, gain:0.04*v, type:'triangle', lp:4000, hp:800, dest:'bgm', atk:0.001, rel:0.02});
  }

  function drumHat(t, v=0.55){
    const ac = ensureAudio();
    if (!ac || !noiseBuf) return;
    const src = ac.createBufferSource();
    src.buffer = noiseBuf;
    const hpF = ac.createBiquadFilter();
    hpF.type='highpass'; hpF.frequency.value = 6500;
    const g = ac.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.07*v, t+0.003);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.035);
    src.connect(hpF).connect(g).connect(bgmGain);
    src.start(t);
    src.stop(t+0.05);
  }

  function drumSnare(t, v=0.7){
    const ac = ensureAudio();
    if (!ac || !noiseBuf) return;
    // noise body
    const src = ac.createBufferSource();
    src.buffer = noiseBuf;
    const bp = ac.createBiquadFilter();
    bp.type='bandpass'; bp.frequency.value = 1800; bp.Q.value=0.9;
    const g = ac.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.12*v, t+0.004);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.10);
    src.connect(bp).connect(g).connect(bgmGain);
    src.start(t); src.stop(t+0.12);
    // tone
    voice({t, freq:220, dur:0.06, gain:0.06*v, type:'triangle', lp:900, dest:'bgm', atk:0.002, rel:0.06});
  }

  // ---- SFX (cooldown throttled) ----
  const SFX = {
    hitCd:0, killCd:0, pickCd:0, pHitCd:0,lvCd:0, shootCd:0,
    update(dt){
      this.hitCd = Math.max(0, this.hitCd-dt);
      this.killCd = Math.max(0, this.killCd-dt);
      this.pickCd = Math.max(0, this.pickCd-dt);
      this.pHitCd = Math.max(0, this.pHitCd-dt);
      this.lvCd = Math.max(0, this.lvCd-dt);
      this.shootCd = Math.max(0, this.shootCd-dt);
    },

    enemyKill(){
  if (this.killCd>0) return;
  this.killCd = 0.08;

  const ac = ensureAudio(); if (!ac) return;
  const t = ac.currentTime;

  // low punch
  voice({t, freq:220, slideTo:140, dur:0.07, gain:0.10, type:'square', lp:2600, hp:120, dest:'sfx', atk:0.002, rel:0.12});
  // bright click
  voice({t:t+0.01, freq:1200, slideTo:700, dur:0.03, gain:0.05, type:'triangle', lp:9000, hp:600, dest:'sfx', atk:0.001, rel:0.06});

  // noise tick (adds “crunch”)
  if (noiseBuf){
    const src = ac.createBufferSource(); src.buffer = noiseBuf;
    const bp = ac.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1800; bp.Q.value=0.9;
    const g = ac.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.05, t+0.004);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.07);
    src.connect(bp).connect(g).connect(sfxGain);
    src.start(t); src.stop(t+0.10);
  }
},

bossDown(){
  const ac = ensureAudio(); if (!ac) return;
  const t = ac.currentTime;

  // deep sub drop
  voice({t, freq:55, slideTo:22, dur:0.85, gain:0.34, type:'sine', lp:220, dest:'sfx', atk:0.002, rel:0.30});
  // gritty layer
  voice({t:t+0.03, freq:110, slideTo:40, dur:0.55, gain:0.18, type:'sawtooth', lp:900, hp:0, dest:'sfx', atk:0.003, rel:0.28});

  // long noise tail (not crisp)
  if (noiseBuf){
    const src = ac.createBufferSource(); src.buffer = noiseBuf;
    const lp = ac.createBiquadFilter(); lp.type='lowpass';
    lp.frequency.setValueAtTime(1800, t);
    lp.frequency.exponentialRampToValueAtTime(260, t+1.10);

    const g = ac.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.22, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t+1.25);

    src.connect(lp).connect(g).connect(sfxGain);
    src.start(t); src.stop(t+1.35);
  }

  // metallic “final” stab
  voice({t:t+0.12, freq:220, dur:0.18, gain:0.06, type:'square', lp:4200, hp:180, dest:'sfx', atk:0.002, rel:0.18});
  voice({t:t+0.12, freq:330, dur:0.18, gain:0.05, type:'square', lp:4200, hp:180, dest:'sfx', atk:0.002, rel:0.18});
},
    
    levelUp(){
      if (this.lvCd>0) return;
      this.lvCd = 0.22;
      const ac = ensureAudio(); if (!ac) return;
      const t = ac.currentTime;
      // bright “rank up” chord
      voice({t,        freq:523.25, dur:0.08, gain:0.06, type:'triangle', lp:5200, hp:200, dest:'sfx', atk:0.002, rel:0.10}); // C5
      voice({t:t+0.04, freq:659.25, dur:0.09, gain:0.05, type:'triangle', lp:5600, hp:200, dest:'sfx', atk:0.002, rel:0.12}); // E5
      voice({t:t+0.08, freq:783.99, dur:0.10, gain:0.04, type:'triangle', lp:6200, hp:200, dest:'sfx', atk:0.002, rel:0.14}); // G5
    },

    enemyShoot(col){
  if (this.shootCd>0) return;
  this.shootCd = 0.045;

  const ac = ensureAudio(); if (!ac) return;
  const t = ac.currentTime;

  let f = 520;
  if (col===C.E1) f = 520;
  else if (col===C.E2) f = 440;
  else if (col===C.E3) f = 600;
  else if (col===C.Y)  f = 740;

  // sharp tick + tiny noise
  voice({t, freq:f, dur:0.018, gain:0.028, type:'triangle', lp:6000, hp:400, dest:'sfx', atk:0.001, rel:0.03});
  voice({t:t+0.008, freq:f*1.5, dur:0.012, gain:0.014, type:'square', lp:8000, hp:800, dest:'sfx', atk:0.001, rel:0.02});

  if (noiseBuf){
    const src = ac.createBufferSource(); src.buffer = noiseBuf;
    const hpF = ac.createBiquadFilter(); hpF.type='highpass'; hpF.frequency.value = 7000;
    const g = ac.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.002, t+0.002);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.03);
    src.connect(hpF).connect(g).connect(sfxGain);
    src.start(t); src.stop(t+0.04);
  }
},


bomb(){
  const ac = ensureAudio(); if (!ac) return;
  const t = ac.currentTime;

  // deep impact (sub)
  voice({t, freq:78, slideTo:26, dur:0.60, gain:0.30, type:'sine', lp:180, dest:'sfx', atk:0.002, rel:0.26});
  // mid rumble
  voice({t:t+0.02, freq:140, slideTo:55, dur:0.35, gain:0.14, type:'sawtooth', lp:600, hp:0, dest:'sfx', atk:0.002, rel:0.22});

  // dirty lowpass noise tail (no crisp highs)
  if (noiseBuf){
    const src = ac.createBufferSource(); src.buffer = noiseBuf;

    const lp = ac.createBiquadFilter(); lp.type='lowpass';
    lp.frequency.setValueAtTime(1400, t);
    lp.frequency.exponentialRampToValueAtTime(220, t+0.75);

    const g = ac.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.22, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.90);

    src.connect(lp).connect(g).connect(sfxGain);
    src.start(t); src.stop(t+1.00);
  }
},

enemyHit(){
  if (this.hitCd>0) return;
  this.hitCd = 0.020;

  // Enemy hit = 高、短、脆的“玻璃/金属”点刺
  const ac = ensureAudio(); if (!ac) return;
  const t = ac.currentTime;

  voice({t,        freq:1600, dur:0.012, gain:0.040, type:'triangle', lp:9000, hp:900, dest:'sfx', atk:0.001, rel:0.02});
  voice({t:t+0.01, freq:2400, dur:0.010, gain:0.020, type:'square',   lp:9500, hp:1200,dest:'sfx', atk:0.001, rel:0.02});
},

playerHit(){
  if (this.pHitCd>0) return;
  this.pHitCd = 0.16;

  // Player hit = 低频冲击 + “警报式下滑” + 更脏的噪声（明显区别敌方）
  const ac = ensureAudio();
  if (!ac) return;
  const t = ac.currentTime;

  // low impact
  voice({t, freq:110, slideTo:55, dur:0.14, gain:0.18, type:'sine', lp:700, dest:'sfx', atk:0.002, rel:0.12});

  // alarm-ish descending tone
  voice({t:t+0.01, freq:880, slideTo:420, dur:0.10, gain:0.07, type:'sawtooth', lp:2600, hp:120, dest:'sfx', atk:0.002, rel:0.10});

  // dirty noise snap
  if (noiseBuf){
    const src = ac.createBufferSource(); src.buffer = noiseBuf;
    const bp = ac.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=900; bp.Q.value=0.7;
    const g = ac.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.16, t+0.004);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.10);
    src.connect(bp).connect(g).connect(sfxGain);
    src.start(t); src.stop(t+0.12);
  }
},

    pickup(){
      if (this.pickCd>0) return;
      this.pickCd = 0.08;
      const ac = ensureAudio();
      if (!ac) return;
      const t = ac.currentTime;
      // cyber chime (3-note)
      voice({t:t,        freq:880,  dur:0.05, gain:0.060, type:'triangle', lp:4800, hp:200, dest:'sfx', atk:0.002, rel:0.08});
      voice({t:t+0.035,  freq:1175, dur:0.05, gain:0.052, type:'triangle', lp:5200, hp:200, dest:'sfx', atk:0.002, rel:0.08});
      voice({t:t+0.070,  freq:1760, dur:0.06, gain:0.045, type:'triangle', lp:5600, hp:200, dest:'sfx', atk:0.002, rel:0.10});
    },

    wave(){
      beep({f:560,t:0.08,g:0.02,type:'triangle',slide:1.40});
    },
    revive(){
      const ac = ensureAudio(); if (!ac) return;
      const t = ac.currentTime;
      voice({t, freq:220, dur:0.10, gain:0.06, type:'sawtooth', lp:2200, hp:120, dest:'sfx', atk:0.01, rel:0.18});
      voice({t:t+0.06, freq:440, dur:0.10, gain:0.05, type:'sawtooth', lp:2600, hp:120, dest:'sfx', atk:0.01, rel:0.20});
      voice({t:t+0.12, freq:880, dur:0.10, gain:0.04, type:'sawtooth', lp:3200, hp:120, dest:'sfx', atk:0.01, rel:0.22});
    },
    bossWarn(){
      beep({f:78,t:0.14,g:0.03,type:'sawtooth',slide:1.3});
    }
  };
  
  
  function hash32(x){
  x |= 0;
  x ^= x >>> 16;
  x = Math.imul(x, 0x7feb352d);
  x ^= x >>> 15;
  x = Math.imul(x, 0x846ca68b);
  x ^= x >>> 16;
  return x >>> 0;
}

  // ---- BGM (Keygen / Cracktro style) ----
  const MusicTracks = [
    {
      name:'CYBER_RUN_Dm', bpm:142, root:38, scale:[0,2,3,5,7,8,10], bars:256, vibe:'bright',
      prog: [0,5,2,6], // Dm Bb F C
      arpPat: [0,1,2,1, 0,1,2,3, 2,1,0,1, 2,3,2,1],
      lead: [7,5,4,5, 7,9,7,5, 4,5,7,5, 4,2,4,5]
    },
    {
      name:'NEON_SKY_Em', bpm:128, root:40, scale:[0,2,3,5,7,8,10], bars:256, vibe:'mid',
      prog: [0,6,5,3], // Em D C Am
      arpPat: [0,2,1,2, 0,2,3,2, 1,2,0,2, 3,2,1,2],
      lead: [12,10,9,10, 12,14,12,10, 9,10,12,10, 9,7,9,10]
    },
    {
      name:'VOID_CORE_Cm', bpm:150, root:36, scale:[0,2,3,5,7,8,10], bars:320, vibe:'dark',
      prog: [0,3,5,6], // Cm Fm Ab Bb
      arpPat: [0,1,0,2, 0,1,3,1, 0,2,1,2, 3,1,0,1],
      lead: [7,7,5,4, 7,9,10,9, 7,5,4,2, 4,5,7,5]
    },
    {
      name:'HYPER_Fm', bpm:155, root:41, scale:[0,2,3,5,7,8,10], bars:384, vibe:'dark',
      prog: [0,4,2,5], // Fm Cm Gm Bb (Modal feel)
      arpPat: [0,1,2,3, 4,3,2,1, 0,2,4,2, 0,1,2,3],
      lead: [4,5,7,5, 4,2,0,2, 4,7,9,7, 4,2,4,7]
    },
    {
      name:'SOLAR_Am', bpm:138, root:45, scale:[0,2,3,5,7,8,10], bars:256, vibe:'bright',
      prog: [0,5,3,4], // Am F Dm Em
      arpPat: [0,2,0,2, 1,3,1,3, 0,1,2,3, 3,2,1,0],
      lead: [9,7,9,10, 12,10,9,7, 5,7,9,7, 5,4,5,7]
    },
    {
      name:'GLITCH_Gm', bpm:145, root:43, scale:[0,2,3,5,7,8,10], bars:320, vibe:'dark',
      prog: [0,2,0,6], // Gm Bb Gm F
      arpPat: [0,1,0,1, 2,3,2,3, 0,0,1,1, 2,2,3,3], // repetitive techno feel
      lead: [7,7,10,7, 7,7,5,7, 10,7,12,7, 10,7,5,7]
    },
    {
      name:'CHILL_Bm', bpm:120, root:35, scale:[0,2,3,5,7,8,10], bars:256, vibe:'mid',
      prog: [0,2,5,6], // Bm D G A
      arpPat: [0,1,2,1, 0,1,2,1, 0,2,1,2, 0,2,1,2],
      lead: [4,2,0,2, 4,7,4,2, 0,2,4,2, 0,-2,0,2] // lower melody
    },
    {
      name:'BOSS_Phryg', bpm:160, root:38, scale:[0,1,3,5,7,8,10], bars:512, vibe:'dark', // Phrygian scale
      prog: [0,1,0,6], // D Eb D C (Phrygian tension)
      arpPat: [0,1,2,3, 0,1,2,3, 0,1,2,3, 3,2,1,0],
      lead: [7,8,7,5, 4,5,4,1, 0,1,4,5, 7,8,10,12]
    },
    { name:'SKYLINE_Gm_MAJ', bpm:124, root: 43, scale:[0,2,4,5,7,9,11], prog:[0,4,5,3, 2,5,4,0], arpPat:[0,2,1,2, 0,3,2,3, 1,2,0,2, 3,2,1,2], lead:[7,9,11,9, 7,6,4,6, 7,9,11,12, 11,9,7,6], bars:999, vibe:'bright',
    drums:{kick:[0,7,8,12], snare:[4,12], hatOdd:true} },

  // Phrygian cyber-dark (更“异域”)
  { name:'PHRYGIAN_GRID_Em', bpm:148, root: 40, scale:[0,1,3,5,7,8,10], prog:[0,6,0,5, 3,6,5,0], arpPat:[0,1,0,2, 0,1,3,1, 0,2,1,2, 3,1,0,1], lead:[7,8,10,8, 7,5,3,5, 7,8,10,12, 10,8,7,5], bars:999, vibe:'dark',
    drums:{kick:[0,8,10,12], snare:[4,12], hatOdd:true} },

  // Dorian mid (更“跑动/驾驶”)
  { name:'DRIVE_DORIAN_Dm', bpm:132, root: 38, scale:[0,2,3,5,7,9,10], prog:[0,3,5,3, 0,6,5,3], arpPat:[0,2,1,2, 0,2,3,2, 1,2,0,2, 3,2,1,2], lead:[7,9,7,5, 4,5,7,9, 10,9,7,5, 4,2,4,5], bars:999, vibe:'mid',
    drums:{kick:[0,6,8,14], snare:[4,12], hatOdd:false} },

  // Harmonic minor (更“注册机旋律感”，但不同于之前)
  { name:'HARMONIC_A_m', bpm:140, root: 45, scale:[0,2,3,5,7,8,11], prog:[0,5,3,4, 0,6,5,4], arpPat:[0,1,2,1, 0,1,3,2, 2,1,0,1, 2,3,2,1], lead:[7,5,4,5, 7,9,11,9, 7,11,12,11, 9,7,5,4], bars:999, vibe:'bright',
    drums:{kick:[0,8,12], snare:[4,12], hatOdd:true} },

  // Half-time feel (鼓组完全不同)
  { name:'HALF_TIME_Cm', bpm:150, root: 36, scale:[0,2,3,5,7,8,10], prog:[0,3,5,6, 0,2,5,3], arpPat:[0,1,0,2, 0,1,3,1, 0,2,1,2, 3,1,0,1], lead:[12,10,9,10, 12,14,12,10, 9,10,12,10, 9,7,9,10], bars:999, vibe:'dark',
    drums:{kick:[0,8,11], snare:[8], hatOdd:true} }
  ];
  const Music = {
  playing:false,
  paused:false,

  trackIndex: 0,
  tr: MusicTracks[0],

  step: 0,
  nextT: 0,
  lookAhead: 0.18,
  _bar: -1,
  barCount: 0,
  switching:false,
pendingTrack:-1,
switchAtBar:-1,
bar0:0,
autoMin: 85,          // 最短间隔（秒）
autoMax: 140,         // 最长间隔（秒）
nextSwitchTime: 0,    // AudioContext time

  start(){
  if (this.playing) return;
  const ac = ensureAudio();
  if (!ac) return;

  // already playing: do NOT reset step/nextT (prevents overlapping schedules)
  if (this.playing){
    this.paused = false;
    setBgmLevel(0.30, 0.06);
    return;
  }

  this.playing = true;
  this.paused = false;

  this.step = 0;
  this.nextT = ac.currentTime + 0.07;
  this.nextSwitchTime = audioCtx.currentTime + rand(this.autoMin, this.autoMax);

  this._bar = -1;
  this.barCount = 0;

  this.switching = false;
  this.pendingTrack = -1;
  this.switchAtBar = -1;
  this.bar0 = 0;

  if (!this.tr) this.useTrack(0);
  setBgmLevel(0.30, 0.06);
},

  // gameover/continue 不停音乐：只用 setPaused/duck 控制音量
  stop(){
    this.playing = false;
    this.paused = false;
    if (audioCtx) setBgmLevel(0.0001, 0.08);
  },

  setPaused(p){
    this.paused = p;
    if (!audioCtx) return;
    setBgmLevel(p ? 0.12 : 0.30, 0.07);
  },

  duck(v=0.20, t=0.08){
    if (!audioCtx) return;
    setBgmLevel(v, t);
  },

  useTrack(i){
  const n = MusicTracks.length;
  this.trackIndex = (i%n+n)%n;
  this.tr = MusicTracks[this.trackIndex];

  // restart musical phrase from NEXT bar boundary, without restarting scheduler timeline
  this.bar0 = (this.step/16)|0;

  this._bar = -1;
  this.barCount = 0;

  this.switching = false;
  this.pendingTrack = -1;
  this.switchAtBar = -1;
},

  nextTrack(){
  if (!audioCtx) return;
  if (this.switching) return;

  this.switching = true;
  this.pendingTrack = (this.trackIndex + 1) % MusicTracks.length;

  // schedule switch at next bar boundary
  const barNow = (this.step/16)|0;
  this.switchAtBar = barNow + 1;

  // duck before switching to avoid audible overlap of scheduled notes
  setBgmLevel(0.0001, 0.10);
},

  degToMidi(deg, oct=0){
    // preserve octave (fix "跑调" caused by mod 7)
    const tr = this.tr;
    const q = Math.floor(deg/7);
    const d = ((deg%7)+7)%7;
    return tr.root + tr.scale[d] + (oct+q)*12;
  },

  triad(rootDeg){
    return [rootDeg, rootDeg+2, rootDeg+4, rootDeg+7];
  },

  scheduleStep(t){
    const ac = ensureAudio();
    if (!ac) return;

    const tr = this.tr;
    const spb = 60/tr.bpm;
    const stepDur = spb/4;

    const s = this.step % 16;
    const bar = (this.step/16)|0;
    const localBar = bar - (this.bar0|0);

    if (bar !== this._bar){
  this._bar = bar;
  this.barCount++;

  // perform scheduled switch exactly at switchAtBar
  if (this.switching && this.pendingTrack>=0 && bar >= this.switchAtBar){
    this.useTrack(this.pendingTrack);
    setBgmLevel(0.30, 0.14);
  } else if (this.barCount >= (tr.bars||256)){
    this.nextTrack();
  }
}

    const chordRoot = tr.prog[((localBar%tr.prog.length)+tr.prog.length)%tr.prog.length];
    const tri = this.triad(chordRoot);

    // ----- drums (audible but not too loud) -----
    if (s===0 || s===8 || s===12) drumKick(t, 0.80);
    if (s===4 || s===12) drumSnare(t+0.002, 0.62);
    if (s%2===1) drumHat(t, 0.48);

    // ----- bass -----
    if (s===0 || s===8){
      const m = this.degToMidi(chordRoot, 0);
      voice({t, freq:midiToFreq(m), dur:stepDur*6.6, gain:0.12, type:'sawtooth', lp:420, dest:'bgm', atk:0.004, rel:0.08});
      voice({t, freq:midiToFreq(m-12), dur:stepDur*6.2, gain:0.07, type:'sine', lp:220, dest:'bgm', atk:0.004, rel:0.10});
    }

    // ----- arp -----
    const idx = tr.arpPat[s] ?? 0;
    const deg = tri[Math.min(3, Math.max(0, idx))];
    const mA = this.degToMidi(deg, 3);
    voice({
      t,
      freq:midiToFreq(mA),
      dur:stepDur*0.82,
      gain: (tr.vibe==='dark'?0.045:0.055),
      type:'square',
      lp: (tr.vibe==='bright'?2600:2200),
      hp: 120,
      dest:'bgm',
      atk:0.002,
      rel:0.05
    });

    // ----- lead (syncopated) -----
    if (s===2 || s===6 || s===10 || s===14){
      const k = (localBar*4 + (s===2?0:s===6?1:s===10?2:3)) % tr.lead.length;
      const degL = chordRoot + tr.lead[k];
      const mL = this.degToMidi(degL, 4);
      voice({
        t, freq:midiToFreq(mL),
        dur:stepDur*2.9,
        gain: (tr.vibe==='dark'?0.035:0.045),
        type:'sawtooth',
        lp: (tr.vibe==='bright'?4200:3200),
        hp: 180,
        dest:'bgm',
        atk:0.006,
        rel:0.16
      });
    }
  },

  update(){
    if (!this.playing || !audioOn || !audioCtx || this.paused) return;
    const tr = this.tr;
    const spb = 60/tr.bpm;
    const stepDur = spb/4;
    if (!this.switching && audioCtx.currentTime >= this.nextSwitchTime){
  // request a random different track
  const n = MusicTracks.length;
  let next = (Math.random()*n)|0;
  if (next === this.trackIndex) next = (next+1)%n;

  this.switching = true;
  this.pendingTrack = next;
  this.switchAtBar = ((this.step/16)|0) + 1; // next bar boundary
  setBgmLevel(0.0001, 0.12);

  // schedule next time window now (so even if switch lags, it won't spam)
  this.nextSwitchTime = audioCtx.currentTime + rand(this.autoMin, this.autoMax);
}

    while(this.nextT < audioCtx.currentTime + this.lookAhead){
      this.scheduleStep(this.nextT);
      this.nextT += stepDur;
      this.step = (this.step + 1) % 16384;
    }
  }
};

  // ================= Pools =================
  function makePool(factory, initial){
    const free=[];
    for(let i=0;i<initial;i++) free.push(factory());
    return {
  get(){
    let o = free.pop();
    while ((o == null) && free.length) o = free.pop(); // skip null/undefined
    return o || factory();
  },
  put(o){
    if (o == null) return; // ignore null/undefined
    free.push(o);
  }
};
  }

  // ================= Colors =================
  const C = {
    P1:'rgb(82,230,255)',
    P2:'rgb(179,108,255)',
    E1:'rgb(255,77,109)',
    E2:'rgb(255,47,87)',
    E3:'rgb(255,120,147)',
    E4:'rgb(64,255,210)',   // aqua-teal
E5:'rgb(255,64,214)',   // magenta-pink
E6:'rgb(255,96,32)',    // neon orange
E7:'rgb(160,255,64)',   // neon lime
    Y:'rgb(255,176,32)',
    G:'rgb(77,255,136)',
    W:'rgb(231,238,255)',
  };

  // ================= Glow sprites =================
  function makeGlowSprite(color, radius, blur=2.6){
    const size = Math.ceil((radius*(blur+1))*2);
    const off = document.createElement('canvas');
    off.width = off.height = size;
    const g = off.getContext('2d');
    const cx=size/2, cy=size/2;
    const grd = g.createRadialGradient(cx,cy, 0, cx,cy, size/2);
    grd.addColorStop(0.0, 'rgba(255,255,255,0.96)');
    grd.addColorStop(0.18, rgbToRgba(color, 0.85));
    grd.addColorStop(0.60, rgbToRgba(color, 0.16));
    grd.addColorStop(1.0, 'rgba(0,0,0,0)');
    g.fillStyle = grd;
    g.beginPath(); g.arc(cx,cy,size/2,0,Math.PI*2); g.fill();
    return off;
  }

  const Spr = {
    glowP: makeGlowSprite(C.P1, 6),
    glowP2: makeGlowSprite(C.P2, 7),
    glowE: makeGlowSprite(C.E1, 7),
    glowE2: makeGlowSprite(C.E2, 8),
    glowE3: makeGlowSprite(C.E3, 6),
    glowE4: makeGlowSprite(C.E4, 7),
glowE5: makeGlowSprite(C.E5, 7),
glowE6: makeGlowSprite(C.E6, 7),
glowE7: makeGlowSprite(C.E7, 7),
    glowY: makeGlowSprite(C.Y, 7),
    glowG: makeGlowSprite(C.G, 7),
    glowW: makeGlowSprite(C.W, 6),
  };

  function drawGlow(sprite, x,y, scale=1, alpha=1){
    const tier = PERF.dynamicFX ? FXState.tier : 0;
    const a = alpha * (PERF.dynamicFX ? FXState.glowBudget : 1.0);

    if (tier >= 2 && scale < 0.38){
      ctx.globalAlpha = a * (tier >= 3 ? 0.55 : 0.72);
      ctx.fillStyle = '#ffffff';
      const sz = tier >= 3 ? 1.5 : 2.0;
      ctx.fillRect(x - sz*0.5, y - sz*0.5, sz, sz);
      return;
    }

    if (tier >= 3 && PERF.fxFrameMod % 2 === 0 && scale < 0.65) return;

    const w = sprite.width*scale, h=sprite.height*scale;
    ctx.globalAlpha = a;
    ctx.drawImage(sprite, x-w/2, y-h/2, w, h);
  }

  // ================= Lists =================
  const bulletsP=[], bulletsE=[], enemies=[], particles=[], supplies=[], texts=[], shockwaves=[], beams=[];
  const FXState = { tier:0, glowBudget:1.0, additiveOn:true, maxShockwaves:180 };

  function updateFXState(){
    const bulletN = bulletsP.length + bulletsE.length;
    const particleN = particles.length;
    const waveN = shockwaves.length;
    const stress = bulletN + particleN*0.4 + waveN*3;

    let tier = 0;
    if (stress > 920 || bulletN > 460) tier = 3;
    else if (stress > 700 || bulletN > 340) tier = 2;
    else if (stress > 500 || bulletN > 240) tier = 1;

    FXState.tier = tier;
    FXState.glowBudget = [1.0, 0.82, 0.62, 0.45][tier];
    FXState.additiveOn = PERF.additive && tier < 3;
    FXState.maxShockwaves = [180, 140, 100, 70][tier];
    PERF.fxFrameMod = (PERF.fxFrameMod + 1) & 31;
  }

  let shakeT=0, shakeMag=0;
const addShake = (m, t=0.16) => {
  // 防护1：如果传入非数字(NaN/Infinity)，直接忽略，防止污染 shakeMag
  if (!Number.isFinite(m)) return;
  
  // 防护2：设置硬上限。45像素的震动已经是“天崩地裂”了，再大就是BUG
  shakeMag = Math.min(Math.max(shakeMag, m), 45); 
  
  shakeT = Math.max(shakeT, t);
};

  // ================= Background =================
  const stars = Array.from({length: PERF.stars}, ()=>({
    x: Math.random(), y: Math.random(),
    v: rand(16, 90),
    a: rand(0.18, 0.85),
    s: rand(0.6, 1.6),
  }));

  // ================= Game state =================
  const Game = {
    state:'menu',
    time:0,
    score:0,
    wave:1,
    difficulty:1,
    bossAlive:false,
    lastBossAt:0,
    continues: 999999,
    killerData: null,
    failReason: '',
    failSnapshot: null,
    mode: 'survival',      // 'survival' | 'duel' | 'lab' | 'fortress' | 'fortress_duel'
    lastStart: { mode:'survival', wave:1 },
    mute(){
      audioOn = !audioOn;
      ui.btnMute.textContent='AUDIO: '+(audioOn?'ON':'OFF');

      if (!audioOn){
        // fade out and stop scheduling
        Music.stop();
        if (audioCtx && masterGain){
          masterGain.gain.setTargetAtTime(0.0001, audioCtx.currentTime, 0.03);
        }
      } else {
        ensureAudio();
        if (audioCtx && masterGain){
          masterGain.gain.setTargetAtTime(0.92, audioCtx.currentTime, 0.03);
        }
        // resume bgm if in game
        if (Game.state==='playing') Music.start();
      }
    }
  };

  const Fortress = {
    phase:'idle', // idle | fortify | assault
    timer:0,
    stock:0,
    flagHp:1000,
    flagMaxHp:1000,
    flagInvulnT:0,
    selected:'wall',
    structures:[],
    spawnCd:0,
    spawnLeft:0,
    sid:1,
    undoStack:[],
    sellMode:false,
    bossSpawned:false,
    activeDrag:null,
    preview:null,
    previewPointerId:null,
    squadRoles:new Map(),
    squadIntelCd:0,
    autoAssaultStall:0,
    catalog:{
      barricade:{cost:3,w:46,h:16,hp:220,col:'#b8d28a',type:'barricade'},
      wall:{cost:6,w:78,h:20,hp:520,col:'#7ef9c0',type:'wall'},
      heavywall:{cost:11,w:104,h:24,hp:980,col:'#89f5dd',type:'heavywall'},
      bunker:{cost:18,w:126,h:28,hp:1800,col:'#76ffd7',type:'bunker'},
      shield:{cost:9,w:74,h:18,hp:720,col:'#b36cff',type:'shield'},
      turret:{cost:10,w:44,h:24,hp:460,col:'#ff5577',type:'turret',cd:0.42},
      gatling:{cost:12,w:40,h:22,hp:400,col:'#ff8f8f',type:'gatling',cd:0.16},
      sniper:{cost:14,w:36,h:24,hp:360,col:'#ffa5ff',type:'sniper',cd:0.58},
      missile:{cost:16,w:42,h:26,hp:430,col:'#ffd28a',type:'missile',cd:1.75},
      tesla:{cost:15,w:40,h:28,hp:460,col:'#9dd7ff',type:'tesla',cd:1.05},
      flame:{cost:13,w:38,h:24,hp:430,col:'#ffb56b',type:'flame',cd:0.22},
      mortar:{cost:17,w:44,h:28,hp:520,col:'#d7d7ff',type:'mortar',cd:1.3},
      dronepad:{cost:16,w:42,h:26,hp:480,col:'#8bf7ff',type:'dronepad',cd:1.35},
      pulse:{cost:12,w:36,h:36,hp:380,col:'#ffd56d',type:'pulse',cd:2.2},
      mine:{cost:8,w:24,h:24,hp:8800,col:'#f2ff80',type:'mine'},
      slow:{cost:11,w:34,h:30,hp:380,col:'#8ee7ff',type:'slow'},
      repair:{cost:13,w:40,h:28,hp:390,col:'#9dffad',type:'repair',cd:4.2},
      repairplayer:{cost:12,w:38,h:26,hp:360,col:'#9deeff',type:'repairplayer',cd:2.8},
      repairfield:{cost:14,w:44,h:28,hp:520,col:'#9dffad',type:'repairfield',cd:3.2},
      factory:{cost:12,w:48,h:26,hp:500,col:'#9dffad',type:'factory',cd:6.0},
      spinner:{cost:15,w:42,h:24,hp:440,col:'#92c7ff',type:'spinner',cd:0.14,rot:0},
      ram:{cost:14,w:52,h:22,hp:560,col:'#ffcb66',type:'ram',cd:3.4,rot:0},
      beacon:{cost:10,w:32,h:32,hp:320,col:'#b8a6ff',type:'beacon',cd:2.8,rot:0},
      taunt:{cost:16,w:58,h:38,hp:2200,col:'#ff9b72',type:'taunt',cd:0},
    },
    itemBehaviors:{
      spinner:{
        onCreate(st){ st.rot = st.rot || 0; st.spinBoost = 0; },
        onPointerDown(st, ctx){
          if (ctx.phase!=='assault') return false;
          st.spinBoost = 1.4;
          st.rot += Math.PI * 0.5;
          sparks(st.x, st.y, 'glowP2', 7, 220);
          return true;
        },
        onUpdate(st, dt){
          st.rot += dt * (5.6 + st.spinBoost*9);
          st.spinBoost = Math.max(0, st.spinBoost - dt*1.4);
          st.cd -= dt;
          if (st.cd<=0){
            const t = findNearestEnemy(st.x, st.y, 260);
            if (t){
              const a = Math.atan2(t.y-st.y, t.x-st.x);
              fortressSpawnBullet('P', st.x, st.y, Math.cos(a)*460, Math.sin(a)*460, {r:2.6,dmg:15+Game.wave*0.75,col:'#92c7ff',spr:'glowP2',life:1.0,mods:['PIERCE_LINE'],style:1,pierce:1});
              st.cd = Math.max(0.05, 0.18 - st.spinBoost*0.05);
            }
          }
          return true;
        },
      },
      ram:{
        onCreate(st){ st.rot = st.rot || 0; st.dashT = 0; st.baseX = st.x; st.baseY = st.y; st.dragging=false; },
        onPointerDown(st, ctx){
          if (ctx.phase!=='assault') return false;
          st.dragging = true;
          st.baseX = st.x; st.baseY = st.y;
          return true;
        },
        onPointerMove(st, ctx){
          if (!st.dragging || ctx.phase!=='assault') return false;
          st.rot = Math.atan2(ctx.world.y-st.y, ctx.world.x-st.x);
          return true;
        },
        onPointerUp(st, ctx){
          if (!st.dragging || ctx.phase!=='assault') return false;
          st.dragging = false;
          st.rot = Math.atan2(ctx.world.y-st.y, ctx.world.x-st.x);
          st.dashT = 0.40;
          st.baseX = st.x; st.baseY = st.y;
          spawnShockwave(st.x, st.y, '#ffcb66', 90, 0.18);
          return true;
        },
        onUpdate(st, dt){
          if (st.dashT>0){
            st.dashT -= dt;
            const sp = 240;
            st.x += Math.cos(st.rot)*sp*dt;
            st.y += Math.sin(st.rot)*sp*dt;
            for (const e of enemies){
              if (!e.alive) continue;
              if (dist2(st.x,st.y,e.x,e.y) < 42*42) e.onHit?.(22 + Game.wave*0.85);
            }
            if (st.dashT<=0){
              st.x = clamp((st.baseX + st.x)*0.5, 28, W-28);
              st.y = clamp((st.baseY + st.y)*0.5, H*0.38, H-60);
            }
          }
          return true;
        },
      },
      taunt:{
        onCreate(st){ st.pulseT = 0; },
        onUpdate(st, dt){
          st.pulseT = (st.pulseT || 0) + dt;
          if (st.pulseT > 1.2){
            st.pulseT = 0;
            spawnShockwave(st.x, st.y, '#ff9b72', 88, 0.16);
          }
          return true;
        },
      },
      beacon:{
        onCreate(st){ st.rot = st.rot || 0; st.mode = st.mode || 0; },
        onPointerDown(st, ctx){
          if (ctx.phase!=='assault') return false;
          st.mode = (st.mode + 1) % 3;
          st.x = clamp(ctx.world.x, 24, W-24);
          st.y = clamp(ctx.world.y, H*0.36, H-54);
          st.rot += Math.PI*0.3;
          textPop(st.x, st.y-24, ['火力','冻结','材料'][st.mode], '#b8a6ff');
          return true;
        },
        onUpdate(st, dt){
          st.cd -= dt;
          if (st.cd>0) return true;
          if (st.mode===0){
            for (const fs of Fortress.structures){
              if (fs.id===st.id) continue;
              if (dist2(st.x,st.y,fs.x,fs.y) < 170*170) fs.cd = Math.max(0, (fs.cd||0) - 0.2);
            }
          } else if (st.mode===1){
            for (const e of enemies){
              if (!e.alive) continue;
              if (dist2(st.x,st.y,e.x,e.y) < 180*180) e._freezeT = Math.max(e._freezeT||0, 0.45);
            }
          } else {
            Fortress.stock += 1.2;
          }
          spawnShockwave(st.x, st.y, '#b8a6ff', 75, 0.18);
          st.cd = 2.6;
          return true;
        },
      },
    },
    getBehavior(type){ return this.itemBehaviors[type] || null; },
    reset(){
      this.phase='idle'; this.timer=0; this.stock=0; this.structures.length=0;
      this.flagMaxHp = 1200;
      this.flagHp = this.flagMaxHp;
      this.flagInvulnT = 0;
      this.selected='barricade';
      this.spawnCd=0; this.spawnLeft=0; this.sid=1;
      this.undoStack.length=0;
      this.sellMode=false;
      this.bossSpawned=false;
      this.activeDrag=null;
      this.preview=null;
      this.previewPointerId=null;
      this.squadRoles.clear();
      this.squadIntelCd=0;
      this.autoAssaultStall=0;
      this.placeRot = 0;
    },
    start(){
      this.reset();
      this.stock = 28;
      this.phase='fortify';
      this.labForgeSpec = null;
      this.labForgeSpawned = false;
      this.labLockedAssault = false;
      this.duelRound = 1;
      this.duelTimer = 0;
      this.clearPreview();
      this.updatePanel();
      this.syncSelectionUI();
    },
    canBuild(){ return (Game.mode==='fortress' || Game.mode==='lab' || Game.mode==='fortress_duel') && this.phase==='fortify' && Game.state==='playing'; },
    updatePanel(){
      if (!ui.fortressPanel) return;
      const on = (Game.mode==='fortress' || Game.mode==='lab' || Game.mode==='fortress_duel') && Game.state==='playing';
      ui.fortressPanel.style.display = (on && this.phase==='fortify') ? 'block' : 'none';
      if (!on) return;
      const phaseText = (Game.mode==='fortress_duel')
        ? (this.phase==='fortify' ? `对战准备 ${Math.ceil(this.duelTimer||0)}s` : `对战敌袭 ${Math.ceil(this.duelTimer||0)}s`)
        : (this.phase==='fortify' ? '准备阶段：选择物品后点画布放置' : `守城阶段 余敌:${this.spawnLeft}`);
      ui.fortressPhase.textContent = phaseText;
      ui.fortressMat.textContent = `材料 ${Math.floor(this.stock)}`;
      if (ui.fortressCore){
        if (Game.mode==='lab'){
          ui.fortressCore.textContent = '';
          ui.fortressCore.style.display = 'none';
        } else {
          ui.fortressCore.style.display = 'inline-block';
          ui.fortressCore.textContent = (Game.mode==='fortress_duel')
            ? `我方旗帜 ${(this.flagHp/this.flagMaxHp*100).toFixed(0)}%`
            : `旗帜 ${(this.flagHp/this.flagMaxHp*100).toFixed(0)}%`;
        }
      }
      if (ui.btnFortStartWave) ui.btnFortStartWave.style.display = (Game.mode==='fortress_duel') ? 'none' : (this.phase==='fortify' ? 'inline-block' : 'none');
      if (ui.btnFortRepairFlag){
        ui.btnFortRepairFlag.style.display = (Game.mode!=='lab' && this.phase==='fortify') ? 'inline-block' : 'none';
        ui.btnFortRepairFlag.disabled = this.stock < 6 || this.flagHp >= this.flagMaxHp;
      }
      const canLayoutIO = ((Game.mode==='lab' || Game.mode==='fortress' || Game.mode==='fortress_duel') && this.phase==='fortify');
      if (ui.btnFortExportLayout) ui.btnFortExportLayout.style.display = canLayoutIO ? 'inline-block' : 'none';
      if (ui.btnFortImportLayout) ui.btnFortImportLayout.style.display = canLayoutIO ? 'inline-block' : 'none';
    },
    syncSelectionUI(){
      const map = Object.keys(this.catalog);
      for (const k of map){
        const el = document.querySelector(`#fortressBuildScroller [data-item="${k}"]`);
        if (el) el.classList.toggle('on', !this.sellMode && this.selected===k);
      }
      if (ui.btnFortSell) ui.btnFortSell.classList.toggle('on', this.sellMode);
    },
    select(item){
      this.sellMode = (item==='sell');
      if (!this.sellMode){
        if (this.selected===item) this.placeRot = (((this.placeRot||0) + Math.PI/4) % (Math.PI*2));
        this.selected = item;
        if (this.canBuild()){
          const nextRot = (this.placeRot||0);
          if (this.preview){
            this.preview.item = this.selected;
            this.preview.rot = nextRot;
          } else {
            const sx = Number.isFinite(Input?.tx) ? Input.tx : (W*0.5);
            const sy = Number.isFinite(Input?.ty) ? Input.ty : (H*0.6);
            const p = this.resolvePlacementPoint(sx, sy);
            this.preview = {x:p.x, y:p.y, item:this.selected, rot:nextRot};
            this.previewPointerId = null;
          }
        }
      } else {
        this.clearPreview();
      }
      this.syncSelectionUI();
    },
    snapshotLabLayout(){
      if (Game.mode!=='lab') return;
      this._labSavedLayout = this.structures.filter(st=>st && st.hp>0).map(st=>({type:st.type,x:st.x,y:st.y,rot:(st.rot||0)}));
    },
    currentLayout(){
      return this.structures.filter(st=>st && st.hp>0).map(st=>({type:st.type,x:st.x,y:st.y,rot:(st.rot||0)}));
    },
    estimateLayoutCost(layout){
      if (!Array.isArray(layout)) return 0;
      return layout.reduce((sum,it)=>{
        const cfg = this.catalog[it?.type];
        return sum + (cfg?.cost || 0);
      },0);
    },
    trimLayoutToBudget(layout, budget){
      if (!Array.isArray(layout)) return [];
      let used = 0;
      const out = [];
      for (const it of layout){
        const cfg = this.catalog[it?.type];
        if (!cfg) continue;
        if (used + cfg.cost > budget) continue;
        out.push({type:it.type, x:it.x, y:it.y, rot:(it.rot||0)});
        used += cfg.cost;
      }
      return out;
    },
    applyLabLayout(layout, opts={}){
      if (!Array.isArray(layout)) return false;
      const mode = Game.mode;
      const isLab = mode==='lab';
      const isFort = (mode==='fortress' || mode==='fortress_duel');
      if (!isLab && !isFort) return false;

      let finalLayout = layout.slice();
      let spent = 0;
      const prevLayout = this.currentLayout();
      const prevStock = this.stock;

      if (isFort){
        const total = this.estimateLayoutCost(finalLayout);
        if (total > this.stock){
          const autoTrim = !!opts.autoTrim;
          let chooseTrim = autoTrim;
          if (!autoTrim){
            chooseTrim = confirm(`导入阵型需要 ${total} 材料，当前仅有 ${Math.floor(this.stock)}。
确定自动裁剪到预算内吗？
选择“取消”将放弃导入。`);
          }
          if (!chooseTrim) return false;
          finalLayout = this.trimLayoutToBudget(finalLayout, this.stock);
        }
        spent = this.estimateLayoutCost(finalLayout);
      }

      this.structures.length = 0;
      this.sid = 1;
      for (const it of finalLayout){
        const cfg = this.catalog[it?.type];
        if (!cfg) continue;
        const minY = (isLab ? 30 : H*0.4);
        const maxY = (isLab ? (H-30) : (H-70));
        this.structures.push({
          id:this.sid++, x:clamp(+it.x||W*0.5, 30, W-30), y:clamp(+it.y||H*0.6, minY, maxY),
          w:cfg.w,h:cfg.h,hp:cfg.hp,maxHp:cfg.hp,col:cfg.col,type:cfg.type,rot:(+it.rot||0),cd:cfg.cd||0,cost:cfg.cost
        });
      }
      if (isFort){
        this.stock = Math.max(0, this.stock - spent);
        this.undoStack.push({type:'import_layout', prevLayout, prevStock});
      }
      this.snapshotLabLayout();
      this.updatePanel();
      return true;
    },
    async exportLabLayout(){
      const mode = Game.mode;
      if (mode!=='lab' && mode!=='fortress' && mode!=='fortress_duel') return false;
      if (mode==='lab') this.snapshotLabLayout();
      const payload = JSON.stringify({type:'layout', mode, layout:(mode==='lab' ? (this._labSavedLayout||[]) : this.currentLayout())});
      let ok=false;
      try { await navigator.clipboard.writeText(payload); ok=true; } catch(_){ }
      if (!ok){
        const ta=document.createElement('textarea'); ta.value=payload; ta.style.position='fixed'; ta.style.left='-9999px';
        document.body.appendChild(ta); ta.select();
        try{ ok=document.execCommand('copy'); }catch(_){ ok=false; }
        ta.remove();
      }
      if (ok) textPop(W*0.5,H*0.2,'阵型已复制',C.P2); else alert(payload);
      return ok;
    },
    async importLabLayout(){
      const mode = Game.mode;
      if (mode!=='lab' && mode!=='fortress' && mode!=='fortress_duel') return false;
      let txt='';
      try{ txt=await navigator.clipboard.readText(); }catch(_){ }
      if (!txt){ txt = prompt('粘贴阵型 JSON'); if (!txt) return false; }
      try{
        const obj = JSON.parse(txt);
        const layout = Array.isArray(obj) ? obj : obj.layout;
        if (!this.applyLabLayout(layout)) throw new Error('invalid layout');
        textPop(W*0.5,H*0.2,'阵型已导入',C.P2);
        return true;
      }catch(err){ alert('导入失败: '+(err?.message||err)); return false; }
    },
    beginAssault(){
      if (this.phase!=='fortify') return;
      this.phase='assault';
      this.clearPreview();

      if (Game.mode==='fortress_duel'){
        this.phase='assault';
        Game.wave = (Game.wave|0) + 1;
        if (Game.wave>0 && Game.wave%5===0){
          Player.bomb = Math.min(3, (Player.bomb||0) + 1);
          textPop(W*0.5, H*0.12, `BOMB +1 (W${Game.wave})`, C.Y);
        }
        this.duelTimer = 60;
        this.spawnLeft = 0;
        this.bossSpawned = false;
        textPop(W*0.5, H*0.16, `DUEL 敌袭 ${Math.ceil(this.duelTimer)}s`, C.E1);
        spawnShockwave(W*0.5, H*0.16, C.E1, 220, 0.42);
        this.updatePanel();
        return;
      }

      if (Game.mode==='lab'){
        this._labAssaultStart = {
          layout: deepClone(this.currentLayout()),
          selected: this.selected,
          placeRot: this.placeRot||0,
          sellMode: !!this.sellMode
        };
        if (UnitBattle.active){
          UnitBattle.assaultSnapshot = {
            ghosts: deepClone(UnitBattle.ghosts||[]),
            units: deepClone(UnitBattle.units||[])
          };
        }
        this.labLockedAssault = true;
        this.spawnLeft = 0;
        this.bossSpawned = false;
        if (UnitBattle.active){
          UnitBattle.spawnBattle();
          textPop(W*0.5, H*0.16, 'UNIT BATTLE START', C.P2);
        } else if (!this.labForgeSpawned && this.labForgeSpec){
          spawnForgeEnemy(this.labForgeSpec);
          this.labForgeSpawned = true;
          textPop(W*0.5, H*0.16, 'LAB 敌袭开始', C.E1);
        }
        spawnShockwave(W*0.5, H*0.16, C.E1, 240, 0.45);
        this.updatePanel();
        return;
      }

      this.spawnLeft = 8 + Math.floor(Game.wave*3.1);
      this.bossSpawned = false;
      WaveDirector.onWave(Game.wave);
      this.spawnCd = 0.25;
      textPop(W*0.5, H*0.16, `敌袭 WAVE ${Game.wave}`, C.E1);
      spawnShockwave(W*0.5, H*0.16, C.E1, 240, 0.45);
      this.updatePanel();
    },
    onEnterFortifyEffects(){
      // assault -> fortify 时立即清弹并给玩家无敌，避免残留伤害
      for (const b of bulletsP) b.alive = false;
      for (const b of bulletsE) b.alive = false;
      beams.length = 0;
      Player.invuln = Math.max(Player.invuln||0, 2.5);
      if (Multiplayer?.peers?.size){
        for (const peer of Multiplayer.peers.values()){
          if (Array.isArray(peer.smoothBullets)) peer.smoothBullets.length = 0;
        }
      }
    },
    beginFortify(){
      if (Game.mode==='lab') return;
      if (Game.mode==='fortress_duel'){
        this.phase='fortify';
        this.onEnterFortifyEffects();
        this.duelRound = (this.duelRound||1) + 1;
        this.duelTimer = 35;
        this.stock += 28;
        textPop(W*0.5, H*0.16, `DUEL 准备 ${Math.ceil(this.duelTimer)}s`, C.P1);
        this.updatePanel();
        return;
      }
      this.phase='fortify';
      this.onEnterFortifyEffects();
      const gain = 10 + Math.floor(Game.wave*2.6);
      this.stock += gain;
      Game.wave += 1;
      textPop(W*0.5, H*0.16, `加固 +${gain}`, C.P1);
      spawnShockwave(W*0.5, H*0.16, C.P1, 220, 0.4);
      this.updatePanel();
    },
    repairFlag(cost=6, heal=180){
      if ((Game.mode!=='fortress' && Game.mode!=='lab') || Game.state!=='playing' || this.phase!=='fortify') return false;
      if (Game.mode==='lab') return false;
      if (this.stock < cost || this.flagHp >= this.flagMaxHp) return false;
      this.stock -= cost;
      this.flagHp = Math.min(this.flagMaxHp, this.flagHp + heal);
      sparks(W*0.5, H-58, 'glowP2', 9, 260);
      textPop(W*0.5, H-76, `旗帜 +${Math.floor(heal)}`, '#ff7fa1');
      this.clearPreview();
      this.updatePanel();
      return true;
    },
    toWorld(screenX, screenY){
      const z = (Camera && Camera.zoom) ? Camera.zoom : 1.0;
      const cx = W*0.5, cy = H*0.5;
      return {x:(screenX-cx)/z + cx, y:(screenY-cy)/z + cy};
    },
    resolvePlacementPoint(screenX, screenY){
      const pt = this.toWorld(screenX, screenY);
      const minY = (Game.mode==='fortress_duel') ? (H*0.50) : 30;
      const maxY = (Game.mode==='fortress_duel') ? (H-70) : (H-30);
      return {x:clamp(pt.x, 30, W-30), y:clamp(pt.y, minY, maxY)};
    },
    clearPreview(){
      this.preview = null;
      this.previewPointerId = null;
    },
    setPreview(screenX, screenY, pointerId=null){
      if (!this.canBuild() || this.sellMode) return false;
      if (this.selected==='mine' && Game.mode==='fortress_duel' && Game.lastStart?.net) return false;
      const cfg = this.catalog[this.selected];
      if (!cfg || this.stock < cfg.cost) return false;
      const p = this.resolvePlacementPoint(screenX, screenY);
      this.preview = {x:p.x, y:p.y, item:this.selected, rot:(this.placeRot||0)};
      this.previewPointerId = pointerId;
      return true;
    },
    placeAt(screenX, screenY){
      if (!this.canBuild()) return false;
      if (this.sellMode) return this.sellAt(screenX, screenY);
      if (this.selected==='mine' && Game.mode==='fortress_duel' && Game.lastStart?.net) return false;
      const cfg = this.catalog[this.selected];
      if (!cfg || this.stock < cfg.cost) return false;
      const p = this.resolvePlacementPoint(screenX, screenY);
      const x = p.x;
      const y = p.y;
      const id = this.sid++;
      const st = {id,x,y,w:cfg.w,h:cfg.h,hp:cfg.hp,maxHp:cfg.hp,col:cfg.col,type:cfg.type,rot:(this.placeRot||0),cd:cfg.cd||0,cost:cfg.cost,_builtAt:Game.time||0,_builtWave:Game.wave||1};
      this.getBehavior(st.type)?.onCreate?.(st, {fortress:this});
      this.structures.push(st);
      if (Game.mode!=='lab') this.stock -= cfg.cost;
      this.undoStack.push({type:'place', id, refund:cfg.cost});
      sparks(x,y,'glowP', 8, 180);
      this.clearPreview();
      this.updatePanel();
      this.snapshotLabLayout();
      return true;
    },
    pickShieldInterceptor(x,y,r=2){
      let best = null;
      let bestD2 = Infinity;
      for (const st of this.structures){
        if (!st || st.hp<=0 || st.type!=='shield') continue;
        const rr = Math.max(st.w*0.68, st.h*1.95, 28) + r;
        const d2 = dist2(x,y,st.x,st.y);
        if (d2 <= rr*rr && d2 < bestD2){
          best = st;
          bestD2 = d2;
        }
      }
      return best;
    },
    pickStructure(screenX, screenY){
      const pt = this.toWorld(screenX, screenY);
      for (let i=this.structures.length-1;i>=0;i--){
        const s = this.structures[i];
        const hw=s.w*0.5, hh=s.h*0.5;
        if (pt.x>=s.x-hw && pt.x<=s.x+hw && pt.y>=s.y-hh && pt.y<=s.y+hh) return i;
      }
      return -1;
    },
    findTauntTarget(x,y,maxD=99999){
      let best=null, bestD=maxD*maxD;
      for (const s of this.structures){
        if (s.hp<=0 || s.type!=='taunt') continue;
        const d2 = dist2(x,y,s.x,s.y);
        if (d2<bestD){ bestD=d2; best=s; }
      }
      return best;
    },
    pickStrategicTarget(x,y,maxD=99999){
      const alive = this.structures.filter(s=>s.hp>0);
      if (!alive.length){
        if (Game.mode==='lab') return Player?.alive ? {x:Player.x,y:Player.y,type:'player'} : {x:W*0.5,y:H*0.72,type:'labcore'};
        return {x:W*0.5,y:H-62,type:'flag'};
      }

      const pressure = clamp((enemies.length / Math.max(3, 2 + Game.difficulty*1.3)), 0, 1);
      const siegePower = clamp((Game.difficulty*0.45 + enemies.length*0.07 + Game.wave*0.025), 0, 3.2);
      const corridor = alive.filter(s => Math.abs(s.x - W*0.5) < 170 && s.y > H*0.44);
      const corridorHp = corridor.reduce((a,s)=>a + (s.hp||0), 0);
      const corridorOpen = corridor.length <= 1 || corridorHp < (380 + Game.wave*35 + siegePower*180);

      let best = null;
      let bestScore = -1e18;
      for (const fs of alive){
        const d2 = dist2(x,y,fs.x,fs.y);
        if (d2 > maxD*maxD) continue;

        const hpPct = clamp(fs.hp / Math.max(1, fs.maxHp||1), 0, 1);
        const distW = 1 / (1 + Math.sqrt(d2) * 0.010);
        const laneW = (Math.abs(fs.x - W*0.5) < 185 && fs.y > H*0.44) ? 1.8 : 0.9;
        const softenW = (1 - hpPct) * 1.5;

        const offenseMap = {
          turret:2.2,gatling:2.4,sniper:2.0,missile:2.5,tesla:2.3,flame:2.1,mortar:2.4,
          dronepad:2.0,pulse:1.9,spinner:1.6,ram:1.6,beacon:1.8,repair:1.7,repairfield:2.0,
          wall:1.5,heavywall:1.9,bunker:2.1,shield:1.8,taunt:1.4,factory:1.5
        };
        const value = offenseMap[fs.type] || 1.2;

        const longPlan = (pressure < 0.52)
          ? (value * 1.05 + laneW * 0.55)
          : (laneW * 1.35 + value * 0.75);

        const score = longPlan * distW + softenW;
        if (score > bestScore){ bestScore = score; best = fs; }
      }

      const flagBase = (Game.mode==='lab') ? (Player?.alive ? {x:Player.x,y:Player.y,type:'player'} : {x:W*0.5,y:H*0.72,type:'labcore'}) : {x:W*0.5,y:H-62,type:'flag'};
      if (!best) return flagBase;

      // 只有在防线已经打开且敌方总体能力占优时，才集中冲旗
      const forceFlag = corridorOpen && (pressure > 0.62 || siegePower > 1.85);
      return forceFlag ? flagBase : best;
    },
    _updateSquadIntel(dt){
      if (Game.mode!=='fortress' || this.phase!=='assault') return;
      this.squadIntelCd = Math.max(0, (this.squadIntelCd||0) - dt);
      if (this.squadIntelCd > 0) return;
      this.squadIntelCd = 0.24;

      const aliveEnemies = enemies.filter(e=>e.alive && e.type!=='BOSS');
      if (!aliveEnemies.length){
        this.squadRoles.clear();
        return;
      }
      aliveEnemies.sort((a,b)=>a.x-b.x);
      const n = aliveEnemies.length;
      for (let i=0;i<n;i++){
        const e = aliveEnemies[i];
        const key = e.spawnId ?? `E-${i}`;
        let role = 'breaker';
        if (i===0 || i===n-1) role = 'flank';
        else if (i >= Math.floor(n*0.3) && i <= Math.ceil(n*0.7)) role = 'core';
        if (n >= 6 && i%3===0) role = 'support';
        this.squadRoles.set(key, role);
      }
    },
    _pickRoleTarget(role, x,y,maxD=99999){
      const alive = this.structures.filter(s=>s.hp>0);
      const flagBase = (Game.mode==='lab') ? (Player?.alive ? {x:Player.x,y:Player.y,type:'player'} : {x:W*0.5,y:H*0.72,type:'labcore'}) : {x:W*0.5,y:H-62,type:'flag'};
      if (!alive.length) return flagBase;

      const byValue = {
        breaker: new Set(['wall','heavywall','bunker','shield','barricade']),
        flank: new Set(['sniper','missile','mortar','factory','beacon','repairfield']),
        support: new Set(['repair','repairplayer','dronepad','pulse','tesla']),
        core: new Set(['turret','gatling','flame','spinner','ram','taunt'])
      };
      const pref = byValue[role] || byValue.core;
      let best = null;
      let bestScore = -1e18;
      for (const fs of alive){
        const d2 = dist2(x,y,fs.x,fs.y);
        if (d2 > maxD*maxD) continue;
        const distW = 1 / (1 + Math.sqrt(d2) * 0.010);
        const hpW = 1 + (1 - clamp(fs.hp / Math.max(1, fs.maxHp||1),0,1))*1.3;
        const prefW = pref.has(fs.type) ? 1.7 : 0.95;
        const laneW = (Math.abs(fs.x-W*0.5) < 170) ? 1.25 : 1.0;
        const score = distW * hpW * prefW * laneW;
        if (score > bestScore){ bestScore = score; best = fs; }
      }
      if (best) return best;
      return this.pickStrategicTarget(x,y,maxD);
    },

    getDuelOffenseTarget(st, x,y,maxD=99999){
      if (Game.mode!=='fortress_duel' || !Multiplayer?.peers?.size) return null;
      const peer = [...Multiplayer.peers.values()].find(p=>p && p.alive!==false) || [...Multiplayer.peers.values()][0];
      if (!peer) return null;
      const pf = Multiplayer.projectedPeerFortress?.(peer);
      const pp = Multiplayer.projectedPeer?.(peer);
      if (!pf && !pp) return null;

      const canHitFlag = !!pf && dist2(x,y,pf.flagX,pf.flagY) <= maxD*maxD;
      if (canHitFlag) return {x:pf.flagX, y:pf.flagY, type:'flag'};

      const laneIdx = Math.abs((st?.id || 0) % 3);
      const laneX = [W*0.24, W*0.50, W*0.76][laneIdx];
      let best = null, bestScore = -1e18;
      for (const fs of (pf?.structures || [])){
        if (!fs || (fs.hp||0)<=0) continue;
        const d2 = dist2(x,y,fs.x,fs.y);
        if (d2 > maxD*maxD) continue;
        const laneW = 1 / (1 + Math.abs(fs.x - laneX)*0.02);
        const hpW = 1 + (1 - clamp((fs.hp||1)/Math.max(1,fs.maxHp||1),0,1))*1.25;
        const score = laneW*1.4 + hpW + (1/(1+Math.sqrt(d2)*0.01));
        if (score > bestScore){ bestScore = score; best = fs; }
      }
      if (best) return {...best, type:'structure'};
      if (pp && dist2(x,y,pp.x,pp.y) <= maxD*maxD) return {x:pp.x, y:pp.y, type:'player'};
      if (pf) return {x:pf.flagX, y:pf.flagY, type:'flag'};
      return pp ? {x:pp.x, y:pp.y, type:'player'} : null;
    },
    getEnemyTarget(x,y,maxD=99999){
      if (Game.mode==='fortress' || Game.mode==='lab'){
        const taunt = this.findTauntTarget(x,y,maxD);
        if (taunt) return taunt;
        const near = enemies.find(e=>e.alive && e.type!=='BOSS' && dist2(e.x,e.y,x,y)<42*42);
        const role = near ? this.squadRoles.get(near.spawnId ?? '') : null;
        if (role) return this._pickRoleTarget(role, x, y, maxD);
        return this.pickStrategicTarget(x,y,maxD);
      }
      return Player.alive ? Player : null;
    },
    handlePointerDown(screenX, screenY, pointerId=null){
      if ((Game.mode!=='fortress' && Game.mode!=='lab' && Game.mode!=='fortress_duel') || Game.state!=='playing') return false;
      if (UnitBattle.handlePointerDown(screenX, screenY, pointerId)) return true;
      const pt = this.toWorld(screenX, screenY);
      if (this.preview){
        const pv = this.preview;
        const cfg = this.catalog[pv.item];
        if (cfg){
          const hw = cfg.w*0.5, hh = cfg.h*0.5;
          if (pt.x>=pv.x-hw && pt.x<=pv.x+hw && pt.y>=pv.y-hh && pt.y<=pv.y+hh){
            this.selected = pv.item;
            return this.placeAt(screenX, screenY);
          }
        }
        this.clearPreview();
      }
      const idx = this.pickStructure(screenX, screenY);
      if (idx>=0 && this.phase==='assault'){
        const st = this.structures[idx];
        const acted = this.getBehavior(st.type)?.onPointerDown?.(st, {fortress:this, phase:this.phase, world:pt}) || false;
        if (acted){
          const canDrag = !!this.getBehavior(st.type)?.onPointerMove;
          if (canDrag) this.activeDrag = {pointerId, sid:st.id};
          this.updatePanel();
          return true;
        }
      }
      if (this.canBuild() && IS_TOUCH && !this.sellMode){
        return this.setPreview(screenX, screenY, pointerId);
      }
      if (this.canBuild()) return this.placeAt(screenX, screenY);
      return false;
    },
    handlePointerMove(screenX, screenY, pointerId=null){
      if (UnitBattle.handlePointerMove(screenX, screenY, pointerId)) return true;
      if (this.canBuild() && !IS_TOUCH && !this.sellMode){
        this.setPreview(screenX, screenY, pointerId);
      } else if (this.preview && (!this.canBuild() || this.sellMode)){
        this.clearPreview();
      }
      if (UnitBattle.handlePointerUp(screenX, screenY, pointerId)) return true;
      if (!this.activeDrag || (pointerId!=null && this.activeDrag.pointerId!=null && pointerId!==this.activeDrag.pointerId)) return false;
      const st = this.structures.find(v=>v.id===this.activeDrag.sid);
      if (!st) return false;
      const pt = this.toWorld(screenX, screenY);
      const acted = this.getBehavior(st.type)?.onPointerMove?.(st, {fortress:this, phase:this.phase, world:pt}) || false;
      if (acted) return true;
      return false;
    },
    handlePointerUp(screenX, screenY, pointerId=null){
      if (!this.activeDrag || (pointerId!=null && this.activeDrag.pointerId!=null && pointerId!==this.activeDrag.pointerId)) return false;
      const st = this.structures.find(v=>v.id===this.activeDrag.sid);
      this.activeDrag = null;
      if (!st) return false;
      const pt = this.toWorld(screenX, screenY);
      const acted = this.getBehavior(st.type)?.onPointerUp?.(st, {fortress:this, phase:this.phase, world:pt}) || false;
      return acted;
    },
    sellAt(screenX, screenY){
      if (!this.canBuild()) return false;
      const idx = this.pickStructure(screenX, screenY);
      if (idx<0) return false;
      const [st] = this.structures.splice(idx,1);
      const refund = Math.max(1, Math.floor((st.cost||6)*0.6));
      this.stock += refund;
      this.undoStack.push({type:'sell', structure:st, index:idx, refund});
      sparks(st.x,st.y,'glowY', 6, 140);
      this.updatePanel();
      this.snapshotLabLayout();
      return true;
    },
    undo(){
      const a = this.undoStack.pop();
      if (!a) return;
      if (a.type==='place'){
        const idx = this.structures.findIndex(s=>s.id===a.id);
        if (idx>=0) this.structures.splice(idx,1);
        this.stock += a.refund || 0;
      } else if (a.type==='sell'){
        this.stock = Math.max(0, this.stock - (a.refund||0));
        const idx = Math.max(0, Math.min(this.structures.length, a.index|0));
        this.structures.splice(idx,0,a.structure);
      } else if (a.type==='import_layout'){
        this.stock = (a.prevStock ?? this.stock);
        this.structures.length = 0;
        this.sid = 1;
        for (const it of (a.prevLayout||[])){
          const cfg = this.catalog[it?.type];
          if (!cfg) continue;
          this.structures.push({id:this.sid++, x:clamp(+it.x||W*0.5, 30, W-30), y:clamp(+it.y||H*0.6, H*0.4, H-70), w:cfg.w,h:cfg.h,hp:cfg.hp,maxHp:cfg.hp,col:cfg.col,type:cfg.type,cd:cfg.cd||0,cost:cfg.cost});
        }
      }
      this.updatePanel();
      this.snapshotLabLayout();
    },
    hitFlag(dmg){
      if (Game.mode==='lab') return;
      if ((this.flagInvulnT||0) > 0) return;
      this.flagHp = Math.max(0, this.flagHp - dmg);
      if (this.flagHp<=0 && Player.alive){
        spawnShockwave(W*0.5, H-52, C.E1, 260, 0.85);
        sparks(W*0.5, H-52, 'glowE2', 62, 760);
        beep({f:130,t:0.32,g:0.06,type:'sawtooth',slide:0.55});
        if (Game.mode==='fortress_duel' && Game.lastStart?.net && Multiplayer?.isActive?.()) Multiplayer.sendServer({type:'peer_hit', kind:'flag_destroyed_fx', dmg:1, x:W*0.5, y:H-52, r:260});
        if (TimeMachine.enabled && TimeMachine.rewind('flag')) return;
        Game.failReason = 'flag';
        Game.failSnapshot = { hp: Player.hp, shield: Player.shield, invuln: Player.invuln, x: Player.x, y: Player.y };
        Player.hp = 0;
      }
      this.updatePanel();
    },
    update(dt){
      if (Game.mode!=='fortress' && Game.mode!=='lab' && Game.mode!=='fortress_duel') return;
      if ((this.flagInvulnT||0) > 0) this.flagInvulnT = Math.max(0, this.flagInvulnT - dt);
      if (Game.mode==='fortress_duel'){
        const netFollower = !!(Game.lastStart?.net && Multiplayer.isActive?.() && Multiplayer.leaderId?.() !== Multiplayer.localId);
        if (!netFollower){
          this.duelTimer = Math.max(0, (this.duelTimer||0) - dt);
          if (this.duelTimer<=0){
            if (this.phase==='fortify') this.beginAssault();
            else if (this.phase==='assault') this.beginFortify();
          }
        }
      }

      if (this.phase==='assault'){
        this._updateSquadIntel(dt);
        const needBoss = (Game.wave>0 && Game.wave%5===0 && !this.bossSpawned);
        if (this.spawnLeft<=0 && !Game.bossAlive && !needBoss){
          let aliveCount = 0;
          for (const e of enemies) if (e.alive) aliveCount++;
          if (aliveCount===0 && Game.mode!=='lab' && Game.mode!=='fortress_duel') this.beginFortify();
        }
      }

      let w = 0;
      for (const st of this.structures){
        if (st.hp<=0) continue;
        // 准备阶段暂停所有定时型建筑效果，防止无限等待刷收益/冷却
        if (this.phase!=='assault'){
          this.structures[w++] = st;
          continue;
        }
        if (this.getBehavior(st.type)?.onUpdate?.(st, dt, {fortress:this, phase:this.phase})){
          this.structures[w++] = st;
          continue;
        }
        if (st.type==='turret'){
          st.cd -= dt;
          if (st.cd<=0){
            const t = (Game.mode==='fortress_duel') ? this.getDuelOffenseTarget(st, st.x, st.y, 500) : findNearestEnemy(st.x, st.y, 500);
            if (t){
              const lead = predictEnemyPos(st.x, st.y, t, 520) || t;
              const a = Math.atan2(lead.y-st.y, lead.x-st.x);
              fortressSpawnBullet('P', st.x, st.y-6, Math.cos(a)*520, Math.sin(a)*520, {r:2.8,dmg:26+Game.wave*1.2,col:C.P2,spr:'glowP2',life:1.9,mods:['PIERCE_LINE'],style:1,pierce:1});
              st.cd = 0.36;
            }
          }
        } else if (st.type==='gatling'){
          st.cd -= dt;
          if (st.cd<=0){
            const t = (Game.mode==='fortress_duel') ? this.getDuelOffenseTarget(st, st.x, st.y, 520) : findNearestEnemy(st.x, st.y, 520);
            if (t){
              const lead = predictEnemyPos(st.x, st.y, t, 560) || t;
              const base = Math.atan2(lead.y-st.y, lead.x-st.x);
              for (let k=-1;k<=1;k++){
                const a = base + k*0.05;
                fortressSpawnBullet('P', st.x, st.y-4, Math.cos(a)*560, Math.sin(a)*560, {r:2.2,dmg:9+Game.wave*0.55,col:'#ff8f8f',spr:'glowP',life:1.4,mods:[],style:1});
              }
              st.cd = 0.15;
            }
          }
        } else if (st.type==='missile'){
          st.cd -= dt;
          if (st.cd<=0){
            const t = (Game.mode==='fortress_duel') ? this.getDuelOffenseTarget(st, st.x, st.y, 760) : findNearestEnemy(st.x, st.y, 760);
            if (t){
              const lead = predictEnemyPos(st.x, st.y, t, 320) || t;
              const a = Math.atan2(lead.y-st.y, lead.x-st.x);
              const mb = fortressSpawnBullet('P', st.x, st.y-10, Math.cos(a)*320, Math.sin(a)*320, {r:3.4,dmg:40+Game.wave*1.9,col:'#ffd28a',spr:'glowY',life:1.8,mods:['MINE'],style:1,mineT:0.45});
              if (mb) mb.noHitT = 0.04;
              st.cd = 1.65;
            }
          }
        } else if (st.type==='tesla'){
          st.cd -= dt;
          if (st.cd<=0){
            const t = (Game.mode==='fortress_duel') ? this.getDuelOffenseTarget(st, st.x, st.y, 340) : findNearestEnemy(st.x, st.y, 340);
            if (t){
              const lead = predictEnemyPos(st.x, st.y, t, 760) || t;
              spawnBeam(st.x, st.y-6, lead.x, lead.y, 5, 0.12, 20 + Game.wave*1.1, '#9dd7ff');
              t.onHit?.(20 + Game.wave*1.1);
              st.cd = 0.95;
            }
          }
        } else if (st.type==='flame'){
          st.cd -= dt;
          if (st.cd<=0){
            for (const e of enemies){
              if (!e.alive) continue;
              const d2 = dist2(st.x,st.y,e.x,e.y);
              if (d2 < 170*170) e.onHit?.(10 + Game.wave*0.65);
            }
            spawnShockwave(st.x, st.y, '#ffb56b', 95, 0.18);
            st.cd = 0.22;
          }
        } else if (st.type==='mortar'){
          st.cd -= dt;
          if (st.cd<=0){
            const t = (Game.mode==='fortress_duel') ? this.getDuelOffenseTarget(st, st.x, st.y, 800) : findNearestEnemy(st.x, st.y, 800);
            if (t){
              const lead = predictEnemyPos(st.x, st.y, t, 340) || t;
              const a = Math.atan2(lead.y-st.y, lead.x-st.x);
              const b = fortressSpawnBullet('P', st.x, st.y-8, Math.cos(a)*340, Math.sin(a)*340, {r:3.8,dmg:30+Game.wave*1.35,col:'#d7d7ff',spr:'glowP2',life:2.1,mods:['MINE'],mineT:0.32,style:1});
              if (b) b.noHitT = 0.06;
              st.cd = 1.24;
            }
          }
        } else if (st.type==='dronepad'){
          st.cd -= dt;
          if (st.cd<=0){
            const t = (Game.mode==='fortress_duel') ? this.getDuelOffenseTarget(st, st.x, st.y, 680) : findNearestEnemy(st.x, st.y, 680);
            if (t){
              for (let i=0;i<2;i++){
                const lead = predictEnemyPos(st.x, st.y, t, 340) || t;
                const a = Math.atan2(lead.y-st.y, lead.x-st.x) + (i?0.12:-0.12);
                const b = fortressSpawnBullet('P', st.x, st.y-8, Math.cos(a)*340, Math.sin(a)*340, {r:2.8,dmg:18+Game.wave*0.9,col:'#8bf7ff',spr:'glowP',life:1.8,mods:['HOMING'],homing:1,style:1});
                if (b) b.turnAfter = 0.08;
              }
              st.cd = 1.25;
            }
          }
        } else if (st.type==='sniper'){
          st.cd -= dt;
          if (st.cd<=0){
            const t = (Game.mode==='fortress_duel') ? this.getDuelOffenseTarget(st, st.x, st.y, 760) : findNearestEnemy(st.x, st.y, 760);
            if (t){
              const lead = predictEnemyPos(st.x, st.y, t, 900) || t;
              const a = Math.atan2(lead.y-st.y, lead.x-st.x);
              fortressSpawnBullet('P', st.x, st.y-8, Math.cos(a)*900, Math.sin(a)*900, {r:3.2,dmg:88+Game.wave*3.1,col:'#ffa5ff',spr:'glowP2',life:1.3,mods:['PHASE_SHIFT'],style:1,pierce:5});
              st.cd = 0.52;
            }
          }
        } else if (st.type==='pulse'){
          st.cd -= dt;
          if (st.cd<=0){
            spawnShockwave(st.x,st.y,C.Y,150,0.35);
            for (const e of enemies){
              if (!e.alive) continue;
              if (dist2(st.x,st.y,e.x,e.y) < 165*165){
                e._freezeT = Math.max(e._freezeT||0, 0.75);
                e.onHit?.(20 + Game.wave*1.05);
              }
            }
            st.cd = 2.15;
          }
        } else if (st.type==='repair'){
          st.cd -= dt;
          if (st.cd<=0){
            this.flagHp = Math.min(this.flagMaxHp, this.flagHp + 35);
            spawnShockwave(st.x,st.y,'#9dffad',90,0.25);
            st.cd = 5.0;
          }
        } else if (st.type==='repairplayer'){
          st.cd -= dt;
          if (st.cd<=0){
            if (Player.alive) Player.hp = Math.min(Player.maxHp, Player.hp + 14);
            spawnShockwave(st.x,st.y,'#9deeff',80,0.18);
            st.cd = 2.6;
          }
        } else if (st.type==='repairfield'){
          st.cd -= dt;
          if (st.cd<=0){
            for (const fs of this.structures){
              if (fs.id===st.id || fs.hp<=0) continue;
              if (dist2(st.x,st.y,fs.x,fs.y) < 190*190){
                fs.hp = Math.min(fs.maxHp, fs.hp + 42);
              }
            }
            spawnShockwave(st.x,st.y,'#9dffad',105,0.22);
            st.cd = 3.1;
          }
        } else if (st.type==='factory'){
          st.cd -= dt;
          if (st.cd<=0){
            this.stock += 2;
            sparks(st.x,st.y,'glowG', 5, 120);
            st.cd = 6.0;
          }
        } else if (st.type==='slow'){
          for (const e of enemies){
            if (!e.alive) continue;
            if (dist2(st.x,st.y,e.x,e.y) < 140*140){
              e._freezeT = Math.max(e._freezeT||0, 0.16);
            }
          }
        } else if (st.type==='mine'){
          let trig=false;
          for (const e of enemies){
            if (!e.alive) continue;
            if (dist2(st.x,st.y,e.x,e.y) < 45*45){ trig=true; break; }
          }
          if (trig){
            spawnShockwave(st.x,st.y,C.Y,160,0.36);
            SFX.bomb?.();
            for (const e of enemies){
              if (!e.alive) continue;
              if (dist2(st.x,st.y,e.x,e.y) < 150*150) e.onHit?.(320 + Game.wave*2.2);
            }
            st.hp = 0;
            continue;
          }
        }
        this.structures[w++] = st;
      }
      this.structures.length = w;

      this.updatePanel();
    }
  };

  // ================= Input =================
const Input = {
    active:false,
    px:W*0.5, py:H*0.78,
    tx:W*0.5, ty:H*0.78
  };
  const hoverOffset = 64;

  // 桌面鼠标输入缓冲：避免高回报率鼠标在 pointermove 中频繁计算导致卡顿
  const MouseAim = {
    dirty: false,
    x: 0,
    y: 0,
    push(x, y){ this.x = x; this.y = y; this.dirty = true; },
    consume(){
      if (!this.dirty) return false;
      this.dirty = false;
      updateDragInput(this.x, this.y);
      return true;
    }
  };

  // ================================================================
  //  输入系统：移动端 DRAG/JOYSTICK  |  桌面端 MOUSE/KEYBOARD
  // ================================================================

  const IS_TOUCH = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
  const LS_CTRL  = 'NAW_CTRL_MODE';

  // 移动端两种 / 桌面端两种
  const MODE_A = IS_TOUCH ? 'drag'     : 'mouse';     // 吸附类
  const MODE_B = IS_TOUCH ? 'joystick' : 'keyboard';   // 方向类
  const LABEL_A = IS_TOUCH ? 'DRAG'     : 'MOUSE';
  const LABEL_B = IS_TOUCH ? 'JOYSTICK' : 'KEYBOARD';

  let inputMode = localStorage.getItem(LS_CTRL) || MODE_A;
  // 修正：如果存储了移动端值但当前是桌面（或反之）
  if (inputMode !== MODE_A && inputMode !== MODE_B) inputMode = MODE_A;

  // ---- 摇杆状态 ----
  const Joy = {
    active: false,
    pid: null,
    ox: 0, oy: 0,       // 底座中心
    cx: 0, cy: 0,       // 当前手指
    dx: 0, dy: 0,       // 归一化方向 [-1,1]
    baseR: 60,
    deadzone: 0.15,
  };

  // ---- 键盘状态 ----
  const Keys = { w:false, a:false, s:false, d:false,
                 up:false, left:false, down:false, right:false };

  // ---- DOM 引用 ----
  const joyBase     = document.getElementById('joyBase');
  const joyThumb    = document.getElementById('joyThumb');
  const joyLayer    = document.getElementById('joyLayer');
  const inputModeTag = document.getElementById('inputModeTag');

  // ---- 摇杆视觉 ----
  function joyUpdateVisual(){
    if (!Joy.active || inputMode !== 'joystick'){
      joyBase.classList.remove('on');
      joyThumb.classList.remove('on');
      return;
    }
    joyBase.classList.add('on');
    joyBase.style.left = Joy.ox + 'px';
    joyBase.style.top  = Joy.oy + 'px';

    const thumbX = Joy.ox + Joy.dx * Joy.baseR;
    const thumbY = Joy.oy + Joy.dy * Joy.baseR;
    joyThumb.classList.add('on');
    joyThumb.style.left = thumbX + 'px';
    joyThumb.style.top  = thumbY + 'px';
  }

  // ---- 摇杆计算 ----
  function joyCalc(clientX, clientY){
    const rawDx = clientX - Joy.ox;
    const rawDy = clientY - Joy.oy;
    const dist  = Math.hypot(rawDx, rawDy);

    if (dist < 1e-3){ Joy.dx = 0; Joy.dy = 0; return; }

    const clampDist = Math.min(dist, Joy.baseR);
    const ux = rawDx / dist;
    const uy = rawDy / dist;
    const norm = clampDist / Joy.baseR;

    if (norm < Joy.deadzone){
      Joy.dx = 0; Joy.dy = 0;
    } else {
      // 超过死区后方向归一（匀速），不做比例映射
      Joy.dx = ux;
      Joy.dy = uy;
    }
    Joy.cx = Joy.ox + ux * clampDist;
    Joy.cy = Joy.oy + uy * clampDist;
  }

  // ---- 摇杆释放 ----
  function joyRelease(){
    Joy.active = false;
    Joy.pid    = null;
    Joy.dx = 0; Joy.dy = 0;
    joyUpdateVisual();
  }

  // ---- 键盘方向向量 ----
  function keyDir(){
    let kx = 0, ky = 0;
    if (Keys.a || Keys.left)  kx -= 1;
    if (Keys.d || Keys.right) kx += 1;
    if (Keys.w || Keys.up)    ky -= 1;
    if (Keys.s || Keys.down)  ky += 1;
    // 归一化对角线
    const len = Math.hypot(kx, ky);
    if (len > 1){ kx /= len; ky /= len; }
    return {kx, ky, moving: len > 0.01};
  }

  // ---- 双击检测 ----
  let lastTapT = 0;
  function checkDoubleTap(){
    if (Game.state !== 'playing') return;
    if ((Game.mode==='fortress' || Game.mode==='lab' || Game.mode==='fortress_duel') && Fortress?.phase==='fortify'){
      lastTapT = performance.now();
      return;
    }
    const now = performance.now();
    if (now - lastTapT < 260) useBomb();
    lastTapT = now;
  }

  // ---- 模式切换 ----
  function setInputMode(mode){
    if (mode !== MODE_A && mode !== MODE_B) mode = MODE_A;
    inputMode = mode;
    localStorage.setItem(LS_CTRL, mode);

    const label = (mode === MODE_A) ? LABEL_A : LABEL_B;
    const btn = document.getElementById('btnInputMode');
    if (btn) btn.textContent = 'CTRL: ' + label;
    if (inputModeTag) inputModeTag.textContent = label;

    document.querySelectorAll('#controlPick .pick-chip').forEach(el => {
      el.classList.toggle('on', el.dataset.mode === mode);
    });

    joyRelease();
  }

  // ---- Pointer 事件（移动端 + 桌面鼠标吸附） ----
  Input.pid = null;

function updateDragInput(cx, cy) {
  // 1. 获取当前缩放比例 (防错: 默认为1)
  const z = (Camera && Camera.zoom) ? Camera.zoom : 1.0;
  
  // 2. 屏幕中心点
  const ctrX = W / 2;
  const ctrY = H / 2;

  // 3. 计算手指期望的屏幕位置 (应用手指遮挡偏移 hoverOffset)
  // 我们希望飞机的"视觉位置"在手指上方 hoverOffset 像素处
  const targetScreenX = cx;
  const targetScreenY = cy - hoverOffset;

  // 4. 逆向投影：屏幕坐标 -> 世界坐标
  // 公式：World = (Screen - Center) / Zoom + Center
  // 解释：先减去中心点变成相对坐标，除以缩放比例还原大小，再加回中心点
  Input.tx = (targetScreenX - ctrX) / z + ctrX;
  Input.ty = (targetScreenY - ctrY) / z + ctrY;

  // 5. 如果是刚开始点击 (Input.active刚激活)，瞬间同步位置防止跳跃
  // 注意：这个逻辑通常在 pointerdown 里处理，但为了保险，
  // 如果发现距离过大（说明是刚切换模式或刚生成），可以强制同步
  if (!Input.active) {
    Input.px = Input.tx;
    Input.py = Input.ty;
  }
}

// 联机场景下如果出现 pointer capture 丢失，允许一键恢复本地输入
function recoverLocalControl(){
  const px = Number.isFinite(Player?.x) ? Player.x : (W*0.5);
  const py = Number.isFinite(Player?.y) ? Player.y : (H*0.75);
  Input.active = (!IS_TOUCH && inputMode === 'mouse');
  Input.pid = null;
  Joy.active = false;
  Joy.pid = null;
  Joy.dx = 0;
  Joy.dy = 0;
  Input.tx = px;
  Input.ty = py;
  Input.px = px;
  Input.py = py;
  joyUpdateVisual();
}

  canvas.addEventListener('pointerdown', (e) => {
    DevEditor.onCanvasPointerDown(e);
    if (Game.state !== 'playing') return;
    ensureAudio();
    checkDoubleTap();

    if ((Game.mode==='fortress' || Game.mode==='lab' || Game.mode==='fortress_duel') && Fortress.handlePointerDown(e.clientX, e.clientY, e.pointerId)){
      e.preventDefault?.();
      return;
    }

    if (Input.pid != null && e.pointerId !== Input.pid) return;

    try { canvas.setPointerCapture(e.pointerId); } catch(_){}
    Input.pid = e.pointerId;

    if (inputMode === 'joystick'){
      // 摇杆逻辑保持不变
      Joy.active = true;
      Joy.pid    = e.pointerId;
      Joy.ox     = e.clientX;
      Joy.oy     = e.clientY;
      Joy.dx     = 0;
      Joy.dy     = 0;
      Joy.cx     = e.clientX;
      Joy.cy     = e.clientY;
      joyUpdateVisual();
      Input.active = true;
    } else {
      // 拖拽模式：使用新坐标逻辑
      Input.active = true;
      updateDragInput(e.clientX, e.clientY);
      // 瞬间同步位置，避免点击瞬间飞机“跳”过来
      Input.px = Input.tx;
      Input.py = Input.ty;
    }
  }, {passive: false});

  canvas.addEventListener('pointermove', (e) => {
    DevEditor.onCanvasPointerMove(e);
    if ((Game.mode==='fortress' || Game.mode==='lab' || Game.mode==='fortress_duel') && Fortress.handlePointerMove(e.clientX, e.clientY, e.pointerId)){
      e.preventDefault?.();
      return;
    }
    // 桌面 mouse 模式：仅缓存坐标，主循环每帧消费一次，避免高频同步卡顿
    if (!IS_TOUCH && inputMode === 'mouse'){
      Input.active = true;
      MouseAim.push(e.clientX, e.clientY);
      return;
    }

    if (e.pointerId !== Input.pid) return;

    if (inputMode === 'joystick'){
      if (!Joy.active) return;
      joyCalc(e.clientX, e.clientY);
      joyUpdateVisual();
    } else {
      if (!Input.active) return;
      updateDragInput(e.clientX, e.clientY);
    }
  }, {passive: false});

  function endPointer(e){
    if (e) DevEditor.onCanvasPointerUp(e);
    const pid = e ? e.pointerId : Input.pid;
    if (e && (Game.mode==='fortress' || Game.mode==='lab' || Game.mode==='fortress_duel') && Fortress.handlePointerUp(e.clientX, e.clientY, e.pointerId)){
      e.preventDefault?.();
    }
    if (pid != null && pid !== Input.pid) return;
    if (inputMode === 'joystick') joyRelease();
    Input.active = false;
    if (Input.pid != null){
      try { canvas.releasePointerCapture(Input.pid); } catch(_){}
      Input.pid = null;
    }
  }

  canvas.addEventListener('pointerup',     (e) => endPointer(e), {passive: false});
  canvas.addEventListener('pointercancel', (e) => endPointer(e), {passive: false});
  canvas.addEventListener('dblclick', (e)=>{ DevEditor.handleCanvasDoubleClick(e); }, {passive:false});

  document.addEventListener('touchmove', (e) => {
    if (e.target === canvas) e.preventDefault();
  }, {passive: false});

  // ---- 键盘事件（桌面 WASD + 方向键） ----
  function keyMap(code){
    switch(code){
      case 'KeyW': case 'ArrowUp':    return 'w';
      case 'KeyA': case 'ArrowLeft':  return 'a';
      case 'KeyS': case 'ArrowDown':  return 's';
      case 'KeyD': case 'ArrowRight': return 'd';
    }
    return null;
  }

  document.addEventListener('keydown', (e) => {
    // 空格炸弹
    if (e.code === 'Space' && Game.state === 'playing'){
      e.preventDefault();
      useBomb();
      return;
    }
    // ESC 暂停
    if (e.code === 'Escape' && (Game.state === 'playing' || Game.state === 'paused')){
      togglePause();
      return;
    }
    const k = keyMap(e.code);
    if (k){
      if (e.code.startsWith('Arrow')) Keys[{w:'up',a:'left',s:'down',d:'right'}[k]] = true;
      Keys[k] = true;
    }
  });

  document.addEventListener('keyup', (e) => {
    const k = keyMap(e.code);
    if (k){
      if (e.code.startsWith('Arrow')) Keys[{w:'up',a:'left',s:'down',d:'right'}[k]] = false;
      Keys[k] = false;
    }
  });

  // ---- UI 按钮事件 ----
  document.getElementById('btnInputMode')?.addEventListener('click', () => {
    setInputMode(inputMode === MODE_A ? MODE_B : MODE_A);
  });

  document.getElementById('controlPick')?.addEventListener('click', (e) => {
    const chip = e.target.closest('[data-mode]');
    if (chip) setInputMode(chip.dataset.mode);
  });

  // ---- 初始化菜单选项 ----
  (function initControlPick(){
    const wrap = document.getElementById('controlPick');
    if (!wrap) return;
    wrap.innerHTML =
      `<div class="pick-chip" data-mode="${MODE_A}">${LABEL_A}</div>` +
      `<div class="pick-chip" data-mode="${MODE_B}">${LABEL_B}</div>`;
    setInputMode(inputMode);
  })();

  // ================= Player =================
  const Player = {
    x:W*0.5, y:H*0.78, r:12,
    hp:100, maxHp:100,
    invuln:0,
    shield:0,
    slowT:0,
    bomb:1,

    lv:1,
    xp:0,
    xpNeed:0,

    fireRate:1.0,
    dmgMul:1.0,
    crit:0.05,

    // bullet affixes for player's projectiles
    gunMods: [],     // array of mod keys
    gunModsMax: 6,   // hard cap to avoid explosion
    emitters: [],
    emittersMax: 3,

    pierceBase: 0,
    homingAmmo:0,

    magnetT:0,
    overdriveT:0,
    drones:0,
    mods:0,

    fireCd:0,
    alive:true,
    deathT:0,
  };

  function xpNeedFor(lv){
    // 1~35 指数；35+ 次线性（保持可玩但更慢）
    if (lv<=35) return Math.floor(BAL.xpBase * Math.pow(BAL.xpGrowth, lv-1));
    const base35 = Math.floor(BAL.xpBase * Math.pow(BAL.xpGrowth, 34));
    const t = lv-35;
    return Math.floor(base35 + 26*Math.pow(t, 1.35) + t*22);
  }
  
    function _doSplit2(b){
  const sp   = Math.hypot(b.vx, b.vy) || 200;
  const base = Math.atan2(b.vy, b.vx);
  const dna  = inheritBulletDNA(b, 0.75);
  const mods = propagateMods(b.mods);
  for (const sgn of [-1, 1]){
    const a = base + sgn * (0.28 + rand(-0.05, 0.05));
    spawnBullet((b.fortressSafe?'P':b.team), b.x, b.y,
      Math.cos(a)*sp*0.92, Math.sin(a)*sp*0.92,
      Object.assign({
        r: Math.max(2.2, b.r*0.85),
        dmg: b.dmg*0.60,
        col: b.col, spr: b.spr, style: 1, life: 2.2,
        depth: b.depth+1,
        mods,
      }, dna)
    );
  }
  sparks(b.x, b.y, b.spr, 8, 320);
}

function _doSplit3(b){
  const sp   = Math.hypot(b.vx, b.vy) || 200;
  const base = Math.atan2(b.vy, b.vx);
  const dna  = inheritBulletDNA(b, 0.70);
  const mods = propagateMods(b.mods);
  for (let i = -1; i <= 1; i++){
    const a = base + i * (0.26 + rand(-0.05, 0.05));
    spawnBullet((b.fortressSafe?'P':b.team), b.x, b.y,
      Math.cos(a)*sp*0.90, Math.sin(a)*sp*0.90,
      Object.assign({
        r: Math.max(2.2, b.r*0.80),
        dmg: b.dmg*0.55,
        col: b.col, spr: b.spr, style: 1, life: 2.0,
        depth: b.depth+1,
        mods,
      }, dna)
    );
  }
  sparks(b.x, b.y, b.spr, 10, 360);
}

function _doCrossSplit(b){
  const sp   = Math.hypot(b.vx, b.vy) || 200;
  const base = Math.atan2(b.vy, b.vx);
  const dna  = inheritBulletDNA(b, 0.70);
  const mods = propagateMods(b.mods);
  for (const off of [Math.PI/2, -Math.PI/2]){
    const a = base + off;
    spawnBullet((b.fortressSafe?'P':b.team), b.x, b.y,
      Math.cos(a)*sp*0.85, Math.sin(a)*sp*0.85,
      Object.assign({
        r: Math.max(2.2, b.r*0.80),
        dmg: b.dmg*0.50,
        col: b.col, spr: b.spr, style: 1, life: 1.8,
        depth: b.depth+1,
        mods,
      }, dna)
    );
  }
  sparks(b.x, b.y, b.spr, 6, 280);
}

  // ================= Bullet Affix System (模块化词条，可叠加) =================
  // 词条可用于：敌人发射器、敌人整体（wave deck）、玩家升级/模块
  // 扩展方式：在 BulletAffixCatalog 里加一个对象即可（weight/minWave/tags/hooks）
  const BulletAffixCatalog = {
    // steering/motion
    SPIN: {
      tags:['steer'], minWave:5, weight:1.0,
      onSpawn(b, ctx){
        const hf = hellFactor();
        const sgn = chance(0.5)?1:-1;
        b.angVel = sgn * (1.0 + 2.2*hf);
      }
    },
    WAVE: {
      tags:['steer'], minWave:5, weight:1.0,
      onSpawn(b, ctx){
        const hf = hellFactor();
        b.waveA = 24 + 78*hf;
        b.waveF = 6.8 + 3.0*hf;
        b.waveP = rand(0,Math.PI*2);
      }
    },
    ACCEL: {
      tags:['speed'], minWave:6, weight:0.7,
      onSpawn(b, ctx){
        const hf = hellFactor();
        b.accel = 120 + 220*hf;
      }
    },
    DECEL: {
      tags:['speed'], minWave:7, weight:0.6,
      onSpawn(b, ctx){
        const hf = hellFactor();
        b.accel = -(100 + 200*hf);
      }
    },
    BOOMERANG: {
      tags:['steer'], minWave:8, weight:0.55,
      onSpawn(b, ctx){
        const hf = hellFactor();
        b.reverseT = 0.55 + 0.35*hf;
      }
    },
    DELAY_HOMING: {
      tags:['steer','rare'], minWave:9, weight:0.45,
      onSpawn(b, ctx){
        const hf = hellFactor();
        b.turnAfter = 0.32 + 0.38*hf;
        // homing will be enabled when turnAfter elapses
      }
    },
    HOMING: {
      tags:['steer','rare'], minWave:10, weight:0.35,
      onSpawn(b, ctx){
        b.homing = 1;
      }
    },

    // physics-like
    BOUNCE: {
      tags:['special'], minWave:6, weight:0.55,
      onSpawn(b, ctx){
        b.bounce = Math.max(b.bounce, 1 + (chance(0.35)?1:0));
      }
    },
    PIERCE: {
      tags:['special'], minWave:4, weight:0.75,
      onSpawn(b, ctx){
        b.pierce = Math.max(b.pierce, 1);
      }
    },
    BIG: {
      tags:['stat'], minWave:3, weight:0.85,
      onSpawn(b, ctx){
        b.r *= 1.35;
        b.dmg *= 1.15;
        b.vx *= 0.92; b.vy *= 0.92;
      }
    },
    TINY_FAST: {
      tags:['stat'], minWave:3, weight:0.85,
      onSpawn(b, ctx){
        b.r *= 0.78;
        b.dmg *= 0.92;
        b.vx *= 1.22; b.vy *= 1.22;
      }
    },

    // status/effects
    SLOW_HIT: {
      tags:['status'], minWave:7, weight:0.55,
      onSpawn(b, ctx){
        // enemy bullets slow player; player bullets ignore
        if (b.team==='E') b.slow = Math.max(b.slow, 0.85);
      }
    },
    TRAIL: {
      tags:['fx'], minWave:2, weight:1.0,
      onUpdate(b, dt, ctx){
        // 优化：改为低频、半透明、小尺寸的静态残留，避免视觉干扰
        if (chance(0.15)){
          const p = particlePool.get();
          p.alive=true; p.x=b.x; p.y=b.y;
          p.vx=0; p.vy=0;    // 速度为0，原地残留
          p.t=0; p.life=0.25; // 寿命缩短
          p.a=0.4;           // 透明度大幅降低 (原为1.0)
          p.spr=b.spr;
          p.scale=0.45;      // 尺寸减小
          pushParticle(p);
        }
      }
    },

    // death FX (层次：死亡/命中再分裂/烟花)
        SPLIT_2: {
      tags:['deathfx'], minWave:6, weight:0.65,
      onSpawn(b, ctx){
        b._splitTimer = b.life * (0.40 + Math.random() * 0.20);
        b._splitDone = false;
      },
      onUpdate(b, dt, ctx){
        if (b.depth >= maxSpawnDepth(b) || b._splitDone) return;
        b._splitTimer -= dt;
        if (b._splitTimer > 0) return;
        b._splitDone = true;
        _doSplit2(b);
      },
      onDeath(b, reason, ctx){
        if (b.depth >= maxSpawnDepth(b) || b._splitDone) return;
        if (b._diedAtEdge) return;
        _doSplit2(b);
      }
    },
        SPLIT_3: {
      tags:['deathfx','rare'], minWave:9, weight:0.40,
      onSpawn(b, ctx){
        b._splitTimer = b.life * (0.40 + Math.random() * 0.20);
        b._splitDone = false;
      },
      onUpdate(b, dt, ctx){
        if (b.depth >= maxSpawnDepth(b) || b._splitDone) return;
        b._splitTimer -= dt;
        if (b._splitTimer > 0) return;
        b._splitDone = true;
        _doSplit3(b);
      },
      onDeath(b, reason, ctx){
        if (b.depth >= maxSpawnDepth(b) || b._splitDone) return;
        if (b._diedAtEdge) return;
        _doSplit3(b);
      }
    },
    FIREWORK: {
      tags:['deathfx','rare'], minWave:10, weight:0.38,
      onDeath(b, reason, ctx){
        if (b.depth >= maxSpawnDepth(b)) return;
        const hf  = hellFactor();
        const n   = (b.team==='P') ? (8+Math.round(6*hf)) : (10+Math.round(10*hf));
        const sp  = 170 + 60*hf;
        const dna  = inheritBulletDNA(b, 0.55);
        const mods = propagateMods(b.mods);
        for (let i=0; i<n; i++){
          const a = rand(0, Math.PI*2);
          spawnBullet((b.fortressSafe?'P':b.team), b.x, b.y,
            Math.cos(a)*sp, Math.sin(a)*sp,
            Object.assign({
              r: 2.4,
              dmg: b.dmg * (b.team==='P' ? 0.40 : 0.48),
              col: b.col, spr: b.spr, style:0, life:1.25,
              depth: b.depth+1,
              mods,
            }, dna)
          );
        }
        sparks(b.x, b.y, b.spr, 14+Math.round(18*hf), 680);
        spawnShockwave(b.x, b.y, b.col, 180+120*hf, 0.55);
      }
    },
    CLUSTER_ON_HIT: {
      tags:['hitfx'], minWave:11, weight:0.28,
      onHit(b, target, ctx){
        if (b.depth >= maxSpawnDepth(b)) return;
        const hf   = hellFactor();
        const n    = 6 + Math.round(6*hf);
        const sp   = 160 + 50*hf;
        const dna  = inheritBulletDNA(b, 0.60);
        const mods = propagateMods(b.mods);
        for (let i=0; i<n; i++){
          const a = rand(0, Math.PI*2);
          spawnBullet((b.fortressSafe?'P':b.team), b.x, b.y,
            Math.cos(a)*sp, Math.sin(a)*sp,
            Object.assign({
              r: 2.4, dmg: b.dmg*0.35,
              col: b.col, spr: b.spr, style:0, life:1.05,
              depth: b.depth+1,
              mods,
            }, dna)
          );
        }
        sparks(b.x, b.y, b.spr, 12+Math.round(10*hf), 620);
        b.pierce = Math.min(b.pierce, 0);
      }
    },

    // "mine" is implemented via existing mineT mechanic (explodes after timer)
    MINE: {
      tags:['timerfx','rare'], minWave:9, weight:0.32,
      onSpawn(b, ctx){
        const hf = hellFactor();
        b.mineT = 0.95 + 0.45*rand(0,1) - 0.25*hf;
        b.life = Math.max(b.life, b.mineT + 1.35);
        b.r = Math.max(b.r, 5.8);
        b.style = 0;
        // for mines, direct contact damage is low (or 0 for enemy mines)
        if (b.team==='E') b.dmg = 0;
      }
    },

    // onSpawn fork (creates 2 extra projectiles). Use sparingly due to bullet count
    FORK_2: {
      tags:['spawnfx','rare'], minWave:8, weight:0.30,
      onSpawn(b, ctx){
        if (b.depth>=1) return;
        if (chance(0.55)) return; // prevent always forking
        const sp = Math.hypot(b.vx,b.vy) || 200;
        const base = Math.atan2(b.vy,b.vx);
        for (const sgn of [-1,1]){
          const a = base + sgn*(0.20 + rand(-0.04,0.04));
          spawnBullet((b.fortressSafe?'P':b.team), b.x, b.y, Math.cos(a)*sp*0.96, Math.sin(a)*sp*0.96, Object.assign({
            r: b.r*0.92,
            dmg: b.dmg*0.70,
            col: b.col, spr: b.spr, style:b.style, life: b.life*0.90,
            depth: b.depth+1
          }, inheritBulletMotion(b)));
        }
      }
    },
    
    // 子弹留下减速区域
    SLOW_ZONE: {
      tags:['status'], minWave:4, weight:0.55,
      onDeath(b, reason, ctx){
        if (b.depth>=2) return;
        // 留下一个短暂减速区域（用粒子模拟视觉）
        const dur = 1.8;
        const r = 60;
        const zone = {x:b.x, y:b.y, r, t:0, life:dur};
        if (!Game._slowZones) Game._slowZones = [];
        Game._slowZones.push(zone);
        sparks(b.x, b.y, b.spr, 8, 180);
      }
    },

    // 子弹死亡时向垂直方向分裂
        CROSS_SPLIT: {
      tags:['deathfx'], minWave:5, weight:0.50,
      onSpawn(b, ctx){
        b._splitTimer = b.life * (0.40 + Math.random() * 0.20);
        b._splitDone = false;
      },
      onUpdate(b, dt, ctx){
        if (b.depth >= maxSpawnDepth(b) || b._splitDone) return;
        b._splitTimer -= dt;
        if (b._splitTimer > 0) return;
        b._splitDone = true;
        _doCrossSplit(b);
      },
      onDeath(b, reason, ctx){
        if (b.depth >= maxSpawnDepth(b) || b._splitDone) return;
        if (b._diedAtEdge) return;
        _doCrossSplit(b);
      }
    },

    // 子弹周期性脉冲变大变小
    PULSE: {
      tags:['fx'], minWave:2, weight:0.80,
      onSpawn(b, ctx){
        b._pulseP = rand(0, Math.PI*2);
        b._pulseBaseR = b.r;
      },
      onUpdate(b, dt, ctx){
        if (!b._pulseBaseR) return;
        b._pulseP += dt * 8;
        b.r = b._pulseBaseR * (1 + 0.35 * Math.sin(b._pulseP));
      }
    },

    // 子弹在飞行中留下子弹（拖尾射击）
    TRAIL_SHOOT: {
      tags:['spawnfx'], minWave:7, weight:0.35,
      onUpdate(b, dt, ctx){
        if (b.depth >= 1) return;
        if (!b._tsT) b._tsT = 0;
        b._tsT += dt;
        if (b._tsT < 0.28) return;
        b._tsT = 0;
        if (chance(0.45)){
          const a    = Math.atan2(b.vy, b.vx) + Math.PI + rand(-0.4, 0.4);
          const sp   = 120;
          const dna  = inheritBulletDNA(b, 0.50);
          const mods = propagateMods(b.mods).filter(k => k !== 'TRAIL_SHOOT');
          spawnBullet((b.fortressSafe?'P':b.team), b.x, b.y,
            Math.cos(a)*sp, Math.sin(a)*sp,
            Object.assign({
              r:2.0, dmg: b.dmg*0.30,
              col: b.col, spr: b.spr, style:0, life:0.85,
              depth: b.depth+1,
              mods,
            }, dna)
          );
        }
      }
    },

    // 命中时冻结目标（敌人短暂不动）
    FREEZE_HIT: {
      tags:['status','rare'], minWave:8, weight:0.35,
      onHit(b, target, ctx){
        if (target && target.emCdMul != null){
          target._freezeT = Math.max(target._freezeT||0, 0.45);
        }
      }
    },

    // 子弹到达最大射程时爆炸成环
    EXPIRE_RING: {
      tags:['deathfx'], minWave:6, weight:0.48,
      onDeath(b, reason, ctx){
        if (reason !== 'expire' || b.depth >= maxSpawnDepth(b)) return;
        const n    = 8;
        const sp   = 160;
        const dna  = inheritBulletDNA(b, 0.65);
        const mods = propagateMods(b.mods);
        for (let i=0; i<n; i++){
          const a = i * (Math.PI*2/n);
          spawnBullet((b.fortressSafe?'P':b.team), b.x, b.y,
            Math.cos(a)*sp, Math.sin(a)*sp,
            Object.assign({
              r:2.2, dmg: b.dmg*0.35,
              col: b.col, spr: b.spr, style:0, life:1.15,
              depth: b.depth+1,
              mods,
            }, dna)
          );
        }
        sparks(b.x, b.y, b.spr, 10, 420);
        spawnShockwave(b.x, b.y, b.col, 140, 0.40);
      }
    },

    // 子弹飞行中逐渐变大并增伤
    GROWTH: {
      tags:['stat'], minWave:3, weight:0.70,
      onSpawn(b, ctx){
        b._growBaseR = b.r;
        b._growBaseDmg = b.dmg;
      },
      onUpdate(b, dt, ctx){
        if (!b._growBaseR) return;
        const k = clamp(b.t / 1.2, 0, 1);
        b.r = b._growBaseR * (1 + k * 0.8);
        b.dmg = b._growBaseDmg * (1 + k * 0.5);
      }
    },

    // 子弹在玩家附近时加速追踪（近距触发追踪）
    PROX_HOMING: {
      tags:['steer'], minWave:6, weight:0.45,
      onUpdate(b, dt, ctx){
        if (b.homing > 0) return;
        let tx, ty;
        if (b.team === 'E'){ const t = findEnemyFocus(b.x,b.y); if (t){ tx = t.x; ty = t.y; } }
        else if (b.team === 'P'){
          const t = findNearestEnemy(b.x, b.y, 200);
          if (t){ tx = t.x; ty = t.y; }
        }
        if (tx != null){
          const d2 = dist2(b.x, b.y, tx, ty);
          if (d2 < 160*160) b.homing = 1;
        }
      }
    },

    // 子弹在飞行一段时间后分裂成扇形
    DELAYED_FAN: {
      tags:['deathfx','timerfx'], minWave:7, weight:0.40,
      onSpawn(b, ctx){
        b._dfT = 0.55 + rand(0, 0.3);
      },
      onUpdate(b, dt, ctx){
        if (b.depth >= maxSpawnDepth(b) || !b._dfT) return;
        b._dfT -= dt;
        if (b._dfT > 0) return;
        b._dfT = null;
        const sp     = Math.hypot(b.vx, b.vy) || 200;
        const base   = Math.atan2(b.vy, b.vx);
        const n      = 5;
        const spread = 0.65;
        const dna    = inheritBulletDNA(b, 0.70);
        const mods   = propagateMods(b.mods);
        for (let i=0; i<n; i++){
          const t = (i/(n-1))-0.5;
          const a = base + t*spread;
          spawnBullet((b.fortressSafe?'P':b.team), b.x, b.y,
            Math.cos(a)*sp*0.90, Math.sin(a)*sp*0.90,
            Object.assign({
              r: Math.max(2.0, b.r*0.75), dmg: b.dmg*0.40,
              col: b.col, spr: b.spr, style:1, life:1.25,
              depth: b.depth+1,
              mods,
            }, dna)
          );
        }
        killBullet(b, 'split', {});
      }
    },

    // 子弹之间互相吸引形成弹幕流
    GRAVITY: {
      tags:['steer'], minWave:5, weight:0.40,
      onUpdate(b, dt, ctx){
        const arr = (b.team==='P') ? bulletsP : bulletsE;
        let fx=0, fy=0, count=0;
        for(const o of arr){
          if (!o.alive || o===b) continue;
          const dx=o.x-b.x, dy=o.y-b.y;
          const d2 = dx*dx+dy*dy;
          if (d2 > 80*80 || d2 < 1) continue;
          const d = Math.sqrt(d2);
          fx += (dx/d) * 35; fy += (dy/d) * 35;
          if (++count >= 4) break;
        }
        if (count > 0){
          b.vx += (fx/count) * dt;
          b.vy += (fy/count) * dt;
        }
      }
    },

    // 命中时产生闪电链（跳到附近目标）
    CHAIN_LIGHTNING: {
      tags:['hitfx','rare'], minWave:9, weight:0.30,
      onHit(b, target, ctx){
        if (b.depth >= maxSpawnDepth(b) || !target) return;
        const range  = 140;
        let src      = target;
        const hit    = new Set([target]);
        // DNA 中的 accel 增强链伤
        const chainDmg = b.dmg * 0.25 * (1 + Math.abs(b._dna?.accel||0)*0.001);
        for (let jumps=0; jumps<3; jumps++){
          let best=null, bestD=range*range;
          for (const e of enemies){
            if (!e.alive || hit.has(e)) continue;
            const d2 = dist2(src.x, src.y, e.x, e.y);
            if (d2<bestD){ bestD=d2; best=e; }
          }
          if (!best) break;
          hit.add(best);
          spawnBeam(src.x, src.y, best.x, best.y, 4, 0.12, chainDmg, b.col);
          sparks(best.x, best.y, b.spr, 6, 280);
          best.onHit?.(chainDmg);
          src = best;
        }
      }
    },

    // 子弹螺旋扩散（半径逐渐增大的螺旋轨迹）
    SPIRAL_EXPAND: {
      tags:['steer'], minWave:4, weight:0.50,
      onSpawn(b, ctx){
        b._seR = 0;
        b._seA = rand(0, Math.PI*2);
        b._seSpd = (chance(0.5)?1:-1) * (3.5 + rand(0,2));
      },
      onUpdate(b, dt, ctx){
        b._seR += dt * 55;
        b._seA += dt * b._seSpd;
        b.x += Math.cos(b._seA) * b._seR * dt * 0.3;
        b.y += Math.sin(b._seA) * b._seR * dt * 0.3;
      }
    },
    
    // [新] 弹跳分裂：结合 BOUNCE 和 CHILD_BURST 的逻辑
    BOUNCE_SPLIT: {
      tags:['special'], minWave:7, weight:0.45,
      onBounce(b, ctx){
        if (b.depth >= 2) return;
        // 反弹时生成 2 个小分裂弹，向反方向飞
        const sp = Math.hypot(b.vx, b.vy) * 0.8;
        const baseA = Math.atan2(b.vy, b.vx);
        for(const off of [-0.4, 0.4]){
          const a = baseA + off + Math.PI; // 反向散射
          spawnBullet((b.fortressSafe?'P':b.team), b.x, b.y, Math.cos(a)*sp, Math.sin(a)*sp, Object.assign({
            r: b.r*0.7, dmg: b.dmg*0.5, col:b.col, spr:b.spr, style:0, life:1.5,
            depth: b.depth+1, bounce:0 // 子弹不再反弹
          }, inheritBulletMotion(b)));
        }
      }
    },

    // [新] 动态变速：让 SALVO 或 MULTI_DIR 产生的子弹速度不一
    // 这需要 Wrapper 注入 b.st.index (序列索引)
    INDEXED_SPEED: {
      tags:['stat'], minWave:5, weight:0.60,
      onSpawn(b, ctx){
        // 如果是 Wrapper 生成的，通常会有 st.index 或类似标记
        // 如果没有，就随机变速
        const idx = b.st?.index ?? (Math.random()*5|0); 
        const factor = 0.8 + (idx % 3) * 0.2; // 0.8, 1.0, 1.2
        b.vx *= factor;
        b.vy *= factor;
      }
    },

    // [新] 临界质量：配合 GROWTH，变大到一定程度自动爆炸
    CRITICAL_MASS: {
      tags:['deathfx'], minWave:8, weight:0.35,
      onUpdate(b, dt, ctx){
        // 如果成长到原始大小的 1.8 倍，触发死亡（爆炸）
        if (b._growBaseR && b.r > b._growBaseR * 1.8) {
           killBullet(b, 'expire', {}); // 触发 onDeath (如 FIREWORK)
        }
      },
      // 必须配合 GROWTH 使用，所以在 onSpawn 里强制注入 GROWTH
      onSpawn(b, ctx){
        if (!b.mods.includes('GROWTH')) {
           b.mods.push('GROWTH');
           BulletAffixCatalog['GROWTH'].onSpawn(b, ctx);
        }
      }
    },

    // [新] 悬停炮台：配合 DELAYED_WAVE，在悬停期间发射子弹
    TURRET_HOVER: {
      tags:['spawnfx'], minWave:9, weight:0.30,
      onUpdate(b, dt, ctx){
        // 只有在暂停期间(pauseT > 0)才开火
        if (b.pauseT > 0 && b.depth < 1) {
           const perf = bulletPerfTier();
           const fireCd = [0.14, 0.19, 0.24, 0.30][perf] || 0.30;
           b._turretCd = (b._turretCd || 0) - dt;
           if (b._turretCd <= 0) {
             b._turretCd = fireCd;
             // 向玩家/敌机发射（带简单预判）
             let t = null;
             if (b.team === 'P') t = findNearestEnemy(b.x,b.y, 900);
             else t = findEnemyFocus(b.x,b.y);
             if (!t) return;

             const sp = 200;
             const pred = predictInterceptAim(b.x, b.y, t, {
               speed: sp,
               shooterVx: b.vx || 0,
               shooterVy: b.vy || 0,
               launchDelay: 0,
               maxTime: 1.5,
               iterN: perf>=2 ? 1 : 2,
               simDt: perf>=2 ? 1/30 : 1/48
             });
             const a = pred?.angle ?? Math.atan2(t.y-b.y, t.x-b.x);

             spawnBullet((b.fortressSafe?'P':b.team), b.x, b.y, Math.cos(a)*sp, Math.sin(a)*sp, {
               r:2.0, dmg:b.dmg*0.3, col:b.col, spr:b.spr, style:0, life:0.8,
               depth: b.depth+1
             });
           }
        }
      }
    },
    
    // [新] 钻头：PIERCE 耗尽时触发爆炸，而不是消失
    DRILL_BURST: {
      tags:['deathfx'], minWave:6, weight:0.50,
      onHit(b, target, ctx){
        // 当穿透次数归零（即将死亡）时
        if (b.pierce <= 0) {
           // 强制触发 CHILD_BURST 逻辑（如果存在）
           // 这里我们手动模拟一个小型爆炸
           const n = 6;
           for(let i=0;i<n;i++){
             const a = (i/n)*Math.PI*2;
             spawnBullet((b.fortressSafe?'P':b.team), b.x, b.y, Math.cos(a)*150, Math.sin(a)*150, {
               r:2.2, dmg:b.dmg*0.4, col:b.col, style:0, life:0.6, depth:b.depth+1
             });
           }
        }
      }
    },
    
    
     // ECHO — 子弹死亡时"回响"：反方向扇形射出子弹
    // 协同：MULTI_DIR → 多方向回响  BOOMERANG → 回旋死亡也回响
    ECHO: {
      tags:['deathfx','rare'], minWave:8, weight:0.32,
      onDeath(b, reason, ctx){
        if (b.depth >= maxSpawnDepth(b)) return;
        if (b._diedAtEdge) return;
        const sp   = Math.hypot(b.vx, b.vy) || 200;
        const base = Math.atan2(b.vy, b.vx);
        const dna  = inheritBulletDNA(b, 0.55);
        const mods = propagateMods(b.mods).filter(k => k !== 'ECHO');
        for (let i = -1; i <= 1; i++){
          const a = base + Math.PI + i*0.35;
          spawnBullet((b.fortressSafe?'P':b.team), b.x, b.y,
            Math.cos(a)*sp*0.70, Math.sin(a)*sp*0.70,
            Object.assign({
              r: Math.max(2.0, b.r*0.75), dmg: b.dmg*0.35,
              col: b.col, spr: b.spr, style:1, life:1.4,
              depth: b.depth+1, mods,
            }, dna)
          );
        }
        sparks(b.x, b.y, b.spr, 10, 380);
        spawnShockwave(b.x, b.y, b.col, 100, 0.30);
      }
    },

    // RESONANCE — 飞行中周期释放小环
    // 协同：ACCEL_WAVE → 环弹继承加速DNA越飞越快
    //       BOOMERANG  → 去程+回程都释放环 = 双向弹幕走廊
    RESONANCE: {
      tags:['spawnfx'], minWave:6, weight:0.42,
      onSpawn(b, ctx){
        b._resT = 0;
        b._resInterval = 0.45 + rand(0, 0.15);
        b._resCount = 0;
      },
      onUpdate(b, dt, ctx){
        if (b.depth >= 1) return;
        b._resT += dt;
        if (b._resT < b._resInterval) return;
        b._resT = 0;
        if (++b._resCount > 5) return;
        const n    = 6;
        const sp   = 110 + Math.abs(b._dna?.accel||0)*0.15;
        const dna  = inheritBulletDNA(b, 0.40);
        const mods = propagateMods(b.mods).filter(k => k !== 'RESONANCE');
        const phase = rand(0, Math.PI*2);
        for (let i=0; i<n; i++){
          const a = phase + i*(Math.PI*2/n);
          spawnBullet((b.fortressSafe?'P':b.team), b.x, b.y,
            Math.cos(a)*sp, Math.sin(a)*sp,
            Object.assign({
              r:2.0, dmg: b.dmg*0.22,
              col: b.col, spr: b.spr, style:0, life:0.85,
              depth: b.depth+1, mods,
            }, dna)
          );
        }
        sparks(b.x, b.y, b.spr, 4, 180);
      }
    },

    // REFRACT — 命中时根据 DNA 角速度折射出弧线弹
    // 协同：DOUBLE_HELIX/SPIRAL_ARMS → 命中后螺旋碎片
    //       ROTATE_SWEEP → 折射角度随扫描变化
    REFRACT: {
      tags:['hitfx'], minWave:7, weight:0.38,
      onHit(b, target, ctx){
        if (b.depth >= maxSpawnDepth(b)) return;
        const dna  = inheritBulletDNA(b, 0.60);
        const mods = propagateMods(b.mods).filter(k => k !== 'REFRACT');
        const sp   = Math.hypot(b.vx, b.vy)*0.80 || 180;
        const base = Math.atan2(b.vy, b.vx);
        const curvature = (dna.angVel||0)*1.5 || (chance(0.5) ? 2.2 : -2.2);
        const n = 2 + (Math.abs(dna.angVel||0) > 1.5 ? 1 : 0);
        for (let i=0; i<n; i++){
          const sgn = (i%2===0) ? 1 : -1;
          const a = base + sgn*(0.35 + i*0.15);
          const child = spawnBullet((b.fortressSafe?'P':b.team), b.x, b.y,
            Math.cos(a)*sp, Math.sin(a)*sp,
            Object.assign({
              r: Math.max(2.0, b.r*0.80), dmg: b.dmg*0.30,
              col: b.col, spr: b.spr, style:1, life:1.35,
              depth: b.depth+1, mods,
            }, dna)
          );
          if (child) child.angVel = curvature * sgn;
        }
        sparks(b.x, b.y, b.spr, 8, 320);
      }
    },

    // CASCADE — "放大器"：允许子代在 depth 2 仍可触发分裂/烟花
    // 协同：SPLIT_2 + BOOMERANG → 回旋分裂→子弹也回旋→再分裂→级联
    CASCADE: {
      tags:['stat'], minWave:9, weight:0.30,
      onSpawn(b, ctx){
        b._cascadeActive = true;
      }
    },

    // SYMPATHETIC — 死亡时附近同队友弹获得增伤
    // 协同：SPIRAL_ARMS/MULTI_DIR 等密集弹幕 → 一颗爆炸周围全增伤
    SYMPATHETIC: {
      tags:['deathfx'], minWave:7, weight:0.40,
      onDeath(b, reason, ctx){
        if (b.depth >= 2) return;
        const range2 = 100*100;
        const arr    = (b.team==='P') ? bulletsP : bulletsE;
        let boosted  = 0;
        for (const o of arr){
          if (!o.alive || o===b) continue;
          if (dist2(b.x,b.y, o.x,o.y) > range2) continue;
          o.dmg *= 1.30;
          o.r   *= 1.12;
          if (++boosted >= 8) break;
        }
        if (boosted > 0){
          sparks(b.x, b.y, b.spr, 6+boosted*2, 320);
          spawnShockwave(b.x, b.y, b.col, 100, 0.25);
        }
      }
    },

    // MORPH_BULLET — 飞行一段时间后随机突变一种运动属性
    // 协同：任何 Wrapper → 初始运动 + 突变 = 不可预测轨迹
    MORPH_BULLET: {
      tags:['steer'], minWave:5, weight:0.45,
      onSpawn(b, ctx){
        b._morphT  = 0.4 + rand(0, 0.5);
        b._morphed = false;
      },
      onUpdate(b, dt, ctx){
        if (b._morphed) return;
        b._morphT -= dt;
        if (b._morphT > 0) return;
        b._morphed = true;
        const roll = randi(0, 4);
        if (roll===0) b.angVel += (chance(0.5)?1:-1) * (1.5+rand(0,1.5));
        if (roll===1) b.waveA = (b.waveA||0) + 30 + rand(0,40);
        if (roll===2) b.accel = (b.accel||0) + (chance(0.5)?150:-120);
        if (roll===3) b.homing = Math.max(b.homing, 1);
        if (roll===4){
          b.reverseT = Math.max(b.reverseT||0, 0.4+rand(0,0.3));
          b.life     = Math.max(b.life, (b.reverseT||0)+1.2);
        }
        stampBulletDNA(b);
        sparks(b.x, b.y, b.spr, 4, 180);
      }
    },

    // PHASE_SHIFT — 周期性隐形闪烁（隐形时不参与碰撞）
    // 协同：BOOMERANG → 去程隐形回程可见   DELAYED_WAVE → 暂停时隐形突然出现
    PHASE_SHIFT :{
  tags: ['special'], minWave: 6, weight: 0.45,
  onSpawn(b, ctx) {
    const cc = b._compCtx || {};
    const chain = b._compChain || [];

    let phaseOffset = 0;
    if (chain.includes('MULTI_DIR') && cc.dirIndex != null) {
      phaseOffset = cc.dirIndex * (Math.PI * 2 / cc.dirTotal);
    } else if (chain.includes('SPIRAL_ARMS') && cc.armIndex != null) {
      phaseOffset = cc.armIndex * (Math.PI * 2 / cc.armTotal);
    } else if (chain.includes('DOUBLE_HELIX')) {
      phaseOffset = cc.helixArm === 'A' ? 0 : Math.PI;
    } else if (chain.includes('STACKED_RING') && cc.layerIndex != null) {
      phaseOffset = cc.layerIndex * 0.8;
    } else {
      phaseOffset = rand(0, Math.PI * 2);
    }

    b._psPhase = phaseOffset;
    b._psFreq  = 4.5;
    b._phaseGhost = false;     // 当前是否处于虚体态
    b._phaseAlpha = 1.0;       // 渲染透明度乘数
  },
  onUpdate(b, dt, ctx) {
    const wave = Math.sin(b.t * (b._psFreq || 4.5) + (b._psPhase || 0));
    if (wave > 0.3) {
      // 实体态：正常碰撞
      b._phaseGhost = false;
      b._phaseAlpha = 1.0;
    } else {
      // 虚体态：碰撞穿透
      b._phaseGhost = true;
      b._phaseAlpha = 0.18 + 0.12 * Math.sin(b.t * 18);
    }
  }
},

// [新] WIGGLE: 子弹飞行路径高频抖动（类似蜜蜂）
    WIGGLE: {
      tags: ['steer'], minWave: 4, weight: 0.6,
      onSpawn(b, ctx){
        b._wiggleF = 15 + rand(0, 10); // 频率
        b._wiggleA = 80 + rand(0, 40); // 幅度
        b._baseVx = b.vx;
        b._baseVy = b.vy;
      },
      onUpdate(b, dt, ctx){
        // 在垂直于速度的方向上叠加正弦波速度
        const sp = Math.hypot(b._baseVx, b._baseVy) || 1;
        const nx = -b._baseVy / sp; // 法线 X
        const ny = b._baseVx / sp;  // 法线 Y
        const wave = Math.cos(b.t * b._wiggleF) * b._wiggleA;
        
        b.vx = b._baseVx + nx * wave;
        b.vy = b._baseVy + ny * wave;
      }
    },

    // [新] GHOST: 子弹周期性变得半透明且不可被击中（相位转移）
    GHOST: {
      tags: ['special'], minWave: 7, weight: 0.45,
      onSpawn(b, ctx){
        b._ghostT = 0;
        b._ghostDur = 0.4;
      },
      onUpdate(b, dt, ctx){
        b._ghostT += dt;
        const phase = (b._ghostT % (b._ghostDur*2));
        if (phase > b._ghostDur) {
          // 隐形阶段
          b._phaseGhost = true; // 复用 PHASE_SHIFT 的逻辑
          b._phaseAlpha = 0.2;  // 视觉变淡
        } else {
          // 实体阶段
          b._phaseGhost = false;
          b._phaseAlpha = 1.0;
        }
      }
    },

ORBIT_SELF: {
      tags: ['steer', 'rare'], minWave: 6, weight: 0.4,
      onSpawn(b, ctx){
        if (!ctx || !ctx.owner || !ctx.owner.alive) return;
        b._orbOwner = ctx.owner;
        b._orbReleased = false;
        // 初始角度
        b._orbA = Math.atan2(b.y - ctx.owner.y, b.x - ctx.owner.x);
        b._orbR = 40;
        b._orbSpin = 5.0; 
        b._orbTurn = 0;   
        b._orbNeedTurn = Math.PI * 2; 
        b._orbSp = Math.hypot(b.vx, b.vy) || 300;

        // 停止物理运动，托管给 update
        b.vx = 0; b.vy = 0;
        b.life = 99; 
      },
      onUpdate(b, dt, ctx){
        // 1. 如果子弹已经射出（兼容 WIGGLE/ACCEL 等会改写速度的词条），不再执行环绕逻辑
        if (b._orbReleased || Math.abs(b.vx) > 0.1 || Math.abs(b.vy) > 0.1) {
            b._orbReleased = true;
            // 恢复生命倒计时，防止射出后无限飞行
            if (b.life > 3.0) b.life = 2.0; 
            return;
        }

        // 2. 环绕计算
        const rot = dt * b._orbSpin;
        b._orbA += rot;
        b._orbTurn += Math.abs(rot);
        b._orbR = Math.min(64, b._orbR + dt * 10);

        if (b._orbOwner && b._orbOwner.alive) {
          b.x = b._orbOwner.x + Math.cos(b._orbA) * b._orbR;
          b.y = b._orbOwner.y + Math.sin(b._orbA) * b._orbR;
        } else {
          killBullet(b, 'expire');
          return;
        }

        // 3. 只有转满一圈后才开始做判定
        if (b._orbTurn >= b._orbNeedTurn) {
          
          // 索敌：半径设为 2000 以覆盖全屏
          let target = null;
          if (b.team === 'E') {
            target = findEnemyFocus(b.x, b.y);
          } else {
            target = findNearestEnemy(b.x, b.y, 2000);
          }

          // [逻辑核心]：如果场上无敌机，直接消失
          if (!target || !target.alive) {
            killBullet(b, 'expire');
            sparks(b.x, b.y, b.spr, 4, 100);
            return;
          }

          // [逻辑分支]：场上有敌机，执行射击逻辑
          const tangentA = b._orbA + Math.PI * 0.5;
          const predicted = predictInterceptAim(b.x, b.y, target, {
            speed: b._orbSp,
            launchDelay: 0,
            angVel: b.angVel || 0,
            maxTime: 2.0
          });
          const launchA = predicted?.angle ?? tangentA;
          const dirX = Math.cos(launchA), dirY = Math.sin(launchA);
          const toX = target.x - b.x, toY = target.y - b.y;

          // 允许一定切线偏好，但优先采用可命中的预判发射
          const tangentDot = Math.cos(launchA - tangentA);
          const ahead = toX*dirX + toY*dirY;
          if (ahead > -24 && tangentDot > -0.65) {
            b.vx = dirX * b._orbSp;
            b.vy = dirY * b._orbSp;
            b._orbReleased = true;
            if (b.mods?.includes('WIGGLE')){
              b._baseVx = b.vx;
              b._baseVy = b.vy;
            }
            sparks(b.x, b.y, b.spr, 5, 150);
            // 子弹射出，逻辑结束，下一帧交由物理引擎接管
          }
        }
      }
    },
    
// [修正版] 卫星球核心逻辑
    _BLADE_CORE: {
      tags: ['_internal'], minWave: 99, weight: 0,
      onSpawn(b, ctx) {
        // ❗关键修正：ctx 就是包含 owner 的 modCtx 对象
        b._parent = ctx?.owner; 
        
        if (!b._parent) {
          b.life = 0;
          return;
        }

        b._ang = Math.random() * Math.PI * 2; 
        b._dist = 70;      // 旋转半径
        b._shotCd = 0.25;  // 射击频率
        b._shotT = 0;
        
        // 强制静止，位置完全由 update 托管
        b.vx = 0; b.vy = 0; 
      },
      onUpdate(b, dt) {
        // 检查主人是否还在（支持白板敌人的 reset 测试）
        if (!b._parent || !b._parent.alive) {
          b.life = 0;
          return;
        }

        // 1. 同步位置：绕主转圈
        b._ang += dt * 4.0;
        b.x = b._parent.x + Math.cos(b._ang) * b._dist;
        b.y = b._parent.y + Math.sin(b._ang) * b._dist;

        // 2. 发射子弹
        b._shotT -= dt;
        if (b._shotT <= 0) {
          b._shotT = b._shotCd;
          // 卫星射出的子弹方向：向外径向
          const sp = 280;
          spawnBullet((b.fortressSafe?'P':b.team), b.x, b.y, Math.cos(b._ang)*sp, Math.sin(b._ang)*sp, {
            r: 2.2, 
            dmg: (5 + Game.wave * 0.4), 
            col: b.col, // 继承卫星球颜色
            life: 1.0
          });
        }
      }
    },

// [炫酷重写] _FRACTAL_SEED: 实现真正的递归分形爆炸
    _FRACTAL_SEED: {
      tags: ['_internal'], minWave: 99, weight: 0,
      onSpawn(b, ctx) {
        // 初始代数为 0
        b._fGen = b._fGen || 0;
        // 每一代缩放：第一代最大，之后越来越小
        const scale = Math.pow(0.7, b._fGen);
        b.r *= (b._fGen === 0 ? 1 : 0.8); 
      },
      onDeath(b, reason, ctx) {
        // 设定最大递归深度
        const maxGen = 2; 
        if (b._fGen >= maxGen) return;

        // 每一代产生的碎片数量（第一代少，后面多，形成爆发感）
        const count = b._fGen === 0 ? 5 : 7;
        const nextGen = b._fGen + 1;
        
        // 碎片速度随代数变化（越来越快，向外迸发）
        const sp = 180 + nextGen * 100;
        const dmg = (12 + Game.wave * 2) / (nextGen * 1.5);

        // 爆炸视觉反馈：每一层都有冲击波
        spawnShockwave(b.x, b.y, b.col, 40 + nextGen * 40, 0.3);
        sparks(b.x, b.y, b.spr, 8, sp * 1.2);
        
        // 每一层爆炸都带一点清脆的高音
        if (audioOn) beep({f: 800 + nextGen * 400, t: 0.05, g: 0.01});

        for (let i = 0; i < count; i++) {
          const ang = (i / count) * Math.PI * 2 + rand(-0.2, 0.2);
          
          // 产生下一代子弹
          const child = spawnBullet((b.fortressSafe?'P':b.team), b.x, b.y, Math.cos(ang)*sp, Math.sin(ang)*sp, {
            r: Math.max(1.8, b.r * 0.7),
            dmg: dmg,
            col: b.col,
            spr: b.spr,
            style: 0,
            life: 0.4 + rand(0, 0.3), // 碎片寿命短
            // 关键：将代数传给下一代并重新注入词条
            mods: ['_FRACTAL_SEED']
          });
          
          if (child) {
            child._fGen = nextGen; // 记录代数
          }
        }
      }
    },
    
    // ===== 子母弹伪词条（由 Composite 系统自动挂载，不参与随机） =====
    _CHILD_BURST: {
      tags:['deathfx','_internal'], minWave:0, weight:0,
      onDeath(b, reason, ctx){
        if (b.depth >= 2) return;
        const childType = b._childBurstType;
        const childCfg  = b._childBurstCfg || {};
        if (!childType || !EmitterCatalog[childType]) return;

        const dna = inheritBulletDNA(b, 0.50);

        const tempOwner = {
          x:b.x, y:b.y, tint:b.col, baseCol:b.col,
          waveBulletMods:[], emCdMul:1, _emitAngleOffset:0,
        };
        const mergeCfg = Object.assign({}, childCfg, {col:b.col, mods:[]});
        const em = EmitterCatalog[childType](mergeCfg);

        const beforeE = bulletsE.length;
        const beforeP = bulletsP.length;
        em.fire(tempOwner);

        for (const arr of [bulletsP, bulletsE]){
          const before = (arr===bulletsP) ? beforeP : beforeE;
          for (let i=before; i<arr.length; i++){
            const c = arr[i];
            if (!c || !c.alive) continue;
            c.depth = Math.max(c.depth, b.depth+1);
            c.dmg  *= 0.55;
            c.life  = Math.min(c.life, 1.6);
            c.mods  = c.mods.filter(m => m !== '_CHILD_BURST');
            // 注入 DNA
            c.reverseT = Math.max(c.reverseT||0, dna.reverseT||0);
            c.accel    = (c.accel||0)  + (dna.accel||0);
            c.angVel   = (c.angVel||0) + (dna.angVel||0) * 0.5;
            c.waveA    = Math.max(c.waveA||0, (dna.waveA||0)*0.6);
            c.waveF    = c.waveF || dna.waveF || 0;
            c.bounce   = Math.max(c.bounce||0, dna.bounce||0);
            stampBulletDNA(c);
          }
        }
        sparks(b.x, b.y, b.spr, 12, 480);
        spawnShockwave(b.x, b.y, b.col, 160, 0.45);
      }
    },

    /* ===================== 壮美新词条 - 精心设计 ===================== */

    // QUANTUM_SPLIT - 量子分裂：子弹在飞行中随机分裂成多个量子态
    QUANTUM_SPLIT: {
      tags:['spawnfx','rare'], minWave:10, weight:0.35,
      onSpawn(b, ctx){
        b._qsTimer = 0.3 + rand(0, 0.4);
        b._qsSplit = false;
      },
      onUpdate(b, dt, ctx){
        if(b._qsSplit || b.depth >= maxSpawnDepth(b)) return;
        b._qsTimer -= dt;
        if(b._qsTimer > 0) return;
        
        b._qsSplit = true;
        const hf = hellFactor();
        const splitCount = 3 + Math.round(2*hf);
        const sp = Math.hypot(b.vx, b.vy) || 200;
        const baseA = Math.atan2(b.vy, b.vx);
        
        // 量子分裂：每个分身都是真实的
        for(let i=0; i<splitCount; i++){
          const spreadAngle = (i/(splitCount-1) - 0.5) * 0.9;
          const a = baseA + spreadAngle;
          
          const quantum = spawnBullet((b.fortressSafe?'P':b.team), b.x, b.y,
            Math.cos(a)*sp*0.95, Math.sin(a)*sp*0.95, {
              r: b.r * 0.85,
              dmg: b.dmg * 0.45,
              col: b.col,
              spr: b.spr,
              style: b.style,
              life: b.life * 0.75,
              depth: b.depth + 1,
              mods: propagateMods(b.mods).filter(m => m !== 'QUANTUM_SPLIT'),
              modCtx: ctx
            });
          
          // 每个量子态带有微弱波动
          if(quantum){
            quantum.angVel = (i%2===0?1:-1) * (0.5 + hf*0.5);
            Object.assign(quantum, inheritBulletDNA(b, 0.65));
          }
        }
        
        // 原子弹消失，产生量子波动视觉
        b.life = 0;
        sparks(b.x, b.y, b.spr, 12+Math.round(8*hf), 420);
        spawnShockwave(b.x, b.y, b.col, 100, 0.35);
        if(audioOn) beep({f:1200, t:0.06, g:0.015, slide:0.85});
      }
    },

    // GRAVITY_WELL - 引力井：吸引并减速周围的敌人/子弹
    GRAVITY_WELL: {
      tags:['status','rare'], minWave:9, weight:0.38,
      onSpawn(b, ctx){
        b._gwRadius = 100 + hellFactor()*50;
        b._gwStrength = 180 + hellFactor()*80;
      },
      onUpdate(b, dt, ctx){
        const r2 = b._gwRadius * b._gwRadius;
        
        // 对敌方：吸引敌人
        if(b.team === 'P'){
          for(const e of enemies){
            if(!e.alive) continue;
            const dx = b.x - e.x;
            const dy = b.y - e.y;
            const d2 = dx*dx + dy*dy;
            if(d2 > r2 || d2 < 1) continue;
            
            const d = Math.sqrt(d2);
            const force = b._gwStrength / d;
            e.x += (dx/d) * force * dt;
            e.y += (dy/d) * force * dt;
            
            // 减速敌人
            if(e.vx || e.vy){
              e.vx *= (1 - dt*0.5);
              e.vy *= (1 - dt*0.5);
            }
          }
          
          // 吸引敌方子弹
          for(const eb of bulletsE){
            if(!eb.alive || eb._phaseGhost) continue;
            const dx = b.x - eb.x;
            const dy = b.y - eb.y;
            const d2 = dx*dx + dy*dy;
            if(d2 > r2 || d2 < 1) continue;
            
            const d = Math.sqrt(d2);
            const force = b._gwStrength * 0.7 / d;
            eb.vx += (dx/d) * force * dt;
            eb.vy += (dy/d) * force * dt;
          }
        } else {
          // 敌方引力井：吸引玩家子弹并减速
          for(const pb of bulletsP){
            if(!pb.alive || pb._phaseGhost) continue;
            const dx = b.x - pb.x;
            const dy = b.y - pb.y;
            const d2 = dx*dx + dy*dy;
            if(d2 > r2 || d2 < 1) continue;
            
            const d = Math.sqrt(d2);
            const force = b._gwStrength * 0.6 / d;
            pb.vx += (dx/d) * force * dt;
            pb.vy += (dy/d) * force * dt;
          }
        }
        
        // 视觉效果：引力场涟漪
        if(chance(0.08)){
          const a = rand(0, Math.PI*2);
          const r = rand(20, b._gwRadius);
          sparks(b.x + Math.cos(a)*r, b.y + Math.sin(a)*r, b.spr, 2, 120);
        }
      }
    },

    // TIME_DISTORTION - 时间扭曲：减慢周围区域的时间流速
    TIME_DISTORTION: {
      tags:['status','rare'], minWave:11, weight:0.30,
      onSpawn(b, ctx){
        b._tdRadius = 90 + hellFactor()*60;
        b._tdSlowFactor = 0.25 + hellFactor()*0.15;
      },
      onUpdate(b, dt, ctx){
        const r2 = b._tdRadius * b._tdRadius;
        
        if(b.team === 'P'){
          // 玩家词条：减慢敌人和敌方子弹
          for(const e of enemies){
            if(!e.alive) continue;
            const d2 = dist2(b.x, b.y, e.x, e.y);
            if(d2 > r2) continue;
            
            // 时间扭曲效果
            e._tdSlow = Math.max(e._tdSlow || 0, b._tdSlowFactor);
          }
          
          for(const eb of bulletsE){
            if(!eb.alive) continue;
            const d2 = dist2(b.x, b.y, eb.x, eb.y);
            if(d2 > r2) continue;
            
            eb.vx *= (1 - dt*2.5*b._tdSlowFactor);
            eb.vy *= (1 - dt*2.5*b._tdSlowFactor);
          }
        } else {
          // 敌方词条：减慢玩家和玩家子弹
          if(Player.alive){
            const d2 = dist2(b.x, b.y, Player.x, Player.y);
            if(d2 <= r2){
              Player._timeSlow = Math.max(Player._timeSlow || 0, b._tdSlowFactor);
            }
          }
          
          for(const pb of bulletsP){
            if(!pb.alive) continue;
            const d2 = dist2(b.x, b.y, pb.x, pb.y);
            if(d2 > r2) continue;
            
            pb.vx *= (1 - dt*2.0*b._tdSlowFactor);
            pb.vy *= (1 - dt*2.0*b._tdSlowFactor);
          }
        }
        
        // 视觉：时间扭曲波纹
        if(chance(0.1)){
          const phase = Game.time * 5;
          for(let i=0; i<3; i++){
            const r = (i/3) * b._tdRadius;
            const count = 8;
            for(let j=0; j<count; j++){
              const a = (j/count)*Math.PI*2 + phase;
              sparks(b.x + Math.cos(a)*r, b.y + Math.sin(a)*r, b.spr, 1, 80);
            }
          }
        }
      }
    },

    // PLASMA_CHAIN - 等离子链：击中后电弧连锁到附近多个目标
    PLASMA_CHAIN: {
      tags:['hitfx','rare'], minWave:10, weight:0.32,
      onHit(b, target, ctx){
        if(b.depth >= maxSpawnDepth(b)) return;
        
        const hf = hellFactor();
        const chainRange = 140 + hf*60;
        const maxJumps = 4 + Math.round(2*hf);
        const chainDmg = b.dmg * (0.35 + hf*0.15);
        
        const hitSet = new Set([target]);
        let current = target;
        
        // 等离子链跳跃
        for(let jump=0; jump<maxJumps; jump++){
          let nextTarget = null;
          let minDist = chainRange * chainRange;
          
          // 寻找最近的未击中目标
          const targets = (b.team === 'P') ? enemies : [Player];
          for(const t of targets){
            if(!t || !t.alive || hitSet.has(t)) continue;
            const d2 = dist2(current.x, current.y, t.x, t.y);
            if(d2 < minDist){
              minDist = d2;
              nextTarget = t;
            }
          }
          
          if(!nextTarget) break;
          
          // 造成伤害
          hitSet.add(nextTarget);
          if(nextTarget.onHit) nextTarget.onHit(chainDmg);
          
          // 等离子弧视觉
          const arcCol = jump%2===0 ? C.P2 : C.Y;
          spawnBeam(current.x, current.y, nextTarget.x, nextTarget.y, 
            3.5, 0.15, 0, arcCol);
          
          // 击中特效
          sparks(nextTarget.x, nextTarget.y, b.spr, 8, 380);
          
          // 音效
          if(audioOn) beep({f:1400+jump*200, t:0.04, g:0.01});
          
          current = nextTarget;
        }
        
        // 主弹击中特效增强
        spawnShockwave(b.x, b.y, C.P2, 80, 0.3);
      }
    },

    // VOID_EROSION - 虚空侵蚀：持续降低敌人最大生命值和护盾
    VOID_EROSION: {
      tags:['status','rare'], minWave:12, weight:0.28,
      onHit(b, target, ctx){
        if(!target || b.team !== 'P') return;
        
        const hf = hellFactor();
        const erosion = 0.08 + hf*0.04; // 侵蚀比例
        
        // 降低最大生命值
        if(target.maxHp){
          const reduction = target.maxHp * erosion;
          target.maxHp = Math.max(1, target.maxHp - reduction);
          target.hp = Math.min(target.hp, target.maxHp);
          
          // 视觉：虚空粒子
          sparks(target.x, target.y, 'glowP2', 6, 280);
        }
        
        // 降低护盾
        if(target.shieldHP > 0){
          const shieldReduction = target.shieldHP * (erosion * 1.5);
          target.shieldHP = Math.max(0, target.shieldHP - shieldReduction);
        }
        
        // 虚空侵蚀标记（视觉效果）
        target._voidMark = (target._voidMark || 0) + 0.5;
      },
      onUpdate(b, dt, ctx){
        // 子弹周围的虚空能量场
        if(chance(0.12)){
          const a = rand(0, Math.PI*2);
          const r = rand(5, 15);
          sparks(b.x + Math.cos(a)*r, b.y + Math.sin(a)*r, 'glowP2', 2, 100);
        }
      }
    },

    // AURORA_TRAIL - 极光轨迹：留下美丽且有伤害的彩色轨迹
    AURORA_TRAIL: {
      tags:['fx','status'], minWave:8, weight:0.45,
      onSpawn(b, ctx){
        b._aurColors = [C.P1, C.P2, C.Y, C.E6];
        b._aurIdx = 0;
        b._aurTimer = 0;
      },
      onUpdate(b, dt, ctx){
        b._aurTimer += dt;
        if(b._aurTimer < 0.06) return;
        b._aurTimer = 0;
        
        // 彩色轨迹粒子
        const hf = hellFactor();
        const trailCol = b._aurColors[b._aurIdx];
        b._aurIdx = (b._aurIdx + 1) % b._aurColors.length;
        
        // 创建轨迹伤害区域
        const trail = {
          x: b.x, 
          y: b.y, 
          r: 12 + hf*8,
          dmg: b.dmg * (0.08 + hf*0.04),
          col: trailCol,
          team: b.team,
          life: 0.5 + hf*0.3,
          t: 0
        };
        
        if(!Game._auroraTrails) Game._auroraTrails = [];
        Game._auroraTrails.push(trail);
        
        // 美丽的粒子效果
        for(let i=0; i<3; i++){
          const p = particlePool.get();
          p.alive = true;
          p.x = b.x + rand(-8, 8);
          p.y = b.y + rand(-8, 8);
          p.vx = rand(-30, 30);
          p.vy = rand(-30, 30);
          p.t = 0;
          p.life = 0.4 + rand(0, 0.3);
          p.a = 0.7;
          p.spr = 'glow' + (trailCol === C.P1 ? 'P' : trailCol === C.P2 ? 'P2' : 'Y');
          p.scale = 0.6 + rand(0, 0.3);
          pushParticle(p);
        }
      }
    },

    // MAGNETIC_PULSE - 磁脉冲：周期性推开或吸引周围子弹
    MAGNETIC_PULSE: {
      tags:['special','rare'], minWave:9, weight:0.35,
      onSpawn(b, ctx){
        b._mpTimer = 0;
        b._mpInterval = 0.8 + rand(0, 0.4);
        b._mpRadius = 110 + hellFactor()*50;
        b._mpForce = 450 + hellFactor()*200;
        b._mpMode = chance(0.5) ? 'repel' : 'attract'; // 排斥或吸引
      },
      onUpdate(b, dt, ctx){
        b._mpTimer += dt;
        if(b._mpTimer < b._mpInterval) return;
        
        b._mpTimer = 0;
        b._mpMode = b._mpMode === 'repel' ? 'attract' : 'repel'; // 交替模式
        
        const r2 = b._mpRadius * b._mpRadius;
        const sign = b._mpMode === 'repel' ? -1 : 1;
        
        // 影响周围子弹
        const targetBullets = (b.team === 'P') ? bulletsE : bulletsP;
        let affected = 0;
        
        for(const tb of targetBullets){
          if(!tb.alive || tb._phaseGhost) continue;
          const dx = tb.x - b.x;
          const dy = tb.y - b.y;
          const d2 = dx*dx + dy*dy;
          if(d2 > r2 || d2 < 1) continue;
          
          const d = Math.sqrt(d2);
          const force = b._mpForce / d;
          
          // 施加脉冲
          tb.vx += (dx/d) * force * sign;
          tb.vy += (dy/d) * force * sign;
          
          affected++;
        }
        
        // 脉冲视觉效果
        if(affected > 0){
          const pulseCol = b._mpMode === 'repel' ? C.R : C.P2;
          spawnShockwave(b.x, b.y, pulseCol, b._mpRadius, 0.4);
          sparks(b.x, b.y, b.spr, 15, 500);
          if(audioOn) beep({
            f: b._mpMode === 'repel' ? 600 : 1000, 
            t: 0.08, 
            g: 0.02
          });
        }
      }
    },

    // DIMENSIONAL_TEAR - 维度裂缝：死亡时在两个位置同时爆发
    DIMENSIONAL_TEAR: {
      tags:['deathfx','rare'], minWave:11, weight:0.30,
      onDeath(b, reason, ctx){
        if(b.depth >= maxSpawnDepth(b) || b._diedAtEdge) return;
        
        const hf = hellFactor();
        
        // 主爆发点（原位置）
        const burst1 = {x: b.x, y: b.y};
        
        // 镜像爆发点（随机传送到附近）
        const teleportDist = 100 + hf*80;
        const teleportAngle = rand(0, Math.PI*2);
        const burst2 = {
          x: clamp(b.x + Math.cos(teleportAngle)*teleportDist, 20, W-20),
          y: clamp(b.y + Math.sin(teleportAngle)*teleportDist, 20, H-20)
        };
        
        // 在两个位置产生爆发
        for(const pos of [burst1, burst2]){
          const burstCount = 8 + Math.round(6*hf);
          const sp = 220 + hf*80;
          const dna = inheritBulletDNA(b, 0.50);
          const mods = propagateMods(b.mods).filter(m => m !== 'DIMENSIONAL_TEAR');
          
          for(let i=0; i<burstCount; i++){
            const a = (i/burstCount)*Math.PI*2 + rand(-0.1, 0.1);
            
            spawnBullet((b.fortressSafe?'P':b.team), pos.x, pos.y,
              Math.cos(a)*sp, Math.sin(a)*sp,
              Object.assign({
                r: Math.max(2.2, b.r*0.80),
                dmg: b.dmg * 0.40,
                col: pos === burst1 ? b.col : C.P2,
                spr: pos === burst1 ? b.spr : 'glowP2',
                style: 1,
                life: 1.4,
                depth: b.depth + 1,
                mods
              }, dna)
            );
          }
          
          // 维度裂缝视觉
          sparks(pos.x, pos.y, pos === burst1 ? b.spr : 'glowP2', 18, 600);
          spawnShockwave(pos.x, pos.y, pos === burst1 ? b.col : C.P2, 140, 0.5);
        }
        
        // 连接两个爆发点的维度裂缝
        spawnBeam(burst1.x, burst1.y, burst2.x, burst2.y, 6, 0.25, 0, C.P2);
        
        // 音效
        if(audioOn){
          beep({f:800, t:0.05, g:0.02, slide:0.6});
          setTimeout(() => beep({f:1200, t:0.05, g:0.02, slide:1.4}), 80);
        }
      }
    },
    
  };

  function listKeys(obj){ return Object.keys(obj); }

  function rollAffixes({wave, maxCount, allowTags=null, forbidTags=null}){
    const keys = listKeys(BulletAffixCatalog).filter(k=>{
      const a = BulletAffixCatalog[k];
      if ((a.minWave||1) > wave) return false;
      if (allowTags){
        const tags = a.tags||[];
        let ok=false;
        for (const t of tags) if (allowTags.has(t)) { ok=true; break; }
        if (!ok) return false;
      }
      if (forbidTags){
        const tags = a.tags||[];
        for (const t of tags) if (forbidTags.has(t)) return false;
      }
      return true;
    });
    const picked=[];
    const usedTags = new Set();

    function canPick(k){
      if (picked.includes(k)) return false;
      const tags = BulletAffixCatalog[k].tags||[];
      // simple caps: at most 1 deathfx, 1 steer, 1 spawnfx, 1 hitfx, 1 timerfx
      const tagCaps = new Set(['deathfx','steer','spawnfx','hitfx','timerfx']);
      for (const t of tags){
        if (tagCaps.has(t) && usedTags.has(t)) return false;
      }
      return true;
    }
    function pickOne(){
      const cand = keys.filter(canPick);
      if (!cand.length) return null;
      let sum=0;
      for (const k of cand) sum += (BulletAffixCatalog[k].weight||1);
      let r = Math.random()*sum;
      for (const k of cand){
        r -= (BulletAffixCatalog[k].weight||1);
        if (r<=0) return k;
      }
      return cand[0];
    }

    for (let i=0;i<maxCount;i++){
      if (keys.length===0) break;
      const k = pickOne();
      if (!k) break;
      picked.push(k);
      const tags = BulletAffixCatalog[k].tags||[];
      for (const t of tags) {
        if (['deathfx','steer','spawnfx','hitfx','timerfx'].includes(t)) usedTags.add(t);
      }
    }
    return picked;
  }

  function clearObj(o){
    for (const k in o) delete o[k];
    return o;
  }

  // ================= Bullets =================
  const bulletPool = makePool(()=>({
    alive:false, team:'P',
    x:0,y:0,vx:0,vy:0,
    r:3, dmg:10,
    life:2.2, t:0,
    col:C.P1,
    spr:'glowP',
    style:1,
    bounce:0,
    pierce:0,
    homing:0,
    slow:0,
    splitT:0, // legacy
    mineT:0,
    noHitT:0,

    // motion fields
    angVel:0,
    waveA:0,
    waveF:0,
    waveP:0,
    accel:0,
    reverseT:0,
    turnAfter:0,
    pauseT:0,

    // modular affixes
    mods: [],
    st: Object.create(null),
    depth: 0,
  }), 1300);

  function applyBulletMods(b, mods, ctx){
    if (!mods || !mods.length) return;
    b.mods.length = 0;
    for (const k of mods) b.mods.push(k);
    clearObj(b.st);
    for (const k of b.mods){
      const m = BulletAffixCatalog[k];
      m?.onSpawn?.(b, ctx);
    }
  }
  
  function sprFromColor(col, team){
    if (col===C.P1) return 'glowP';
    if (col===C.P2) return 'glowP2';
    if (col===C.E2) return 'glowE2';
    if (col===C.E3) return 'glowE3';
    if (col===C.E4) return 'glowE4';
if (col===C.E5) return 'glowE5';
if (col===C.E6) return 'glowE6';
if (col===C.E7) return 'glowE7';
    if (col===C.Y)  return 'glowY';
    return team==='P' ? 'glowP' : 'glowE';
  }

  function spawnBullet(team,x,y,vx,vy,opts={}){
    if ((bulletsP.length + bulletsE.length) >= 500) return null;
    if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(vx) || !Number.isFinite(vy)) return null;
    const b = bulletPool.get();
    // 清除 affix 残留字段（防止池回收污染）
    b._phaseGhost  = false;
    b._phaseAlpha  = 1.0;
    b._psPhase     = 0;
    b._psFreq      = 0;
    b._psBaseR     = 0;     // 旧版残留，彻底归零
    b._splitTimer  = 0;
    b._splitDone   = false;
    b._cascT       = 0;
    b._cascN       = 0;
    b._cascMax     = 0;
    b._harmT       = 0;
    b._harmBaseR   = 0;
    b._harmBaseDmg = 0;
    b._growBaseR   = 0;
    b._growBaseDmg = 0;
    b._pulseP      = 0;
    b._pulseBaseR  = 0;
    b._tsT         = 0;
    b._dfT         = 0;
    b._seR         = 0;
    b._seA         = 0;
    b._seSpd       = 0;
    b._compCtx     = null;
    b._compChain   = null;
    b._childBurstType = null;
    b._childBurstCfg  = null;
    b._diedAtEdge  = false;
    b._freezeT     = 0;
    b.alive=true; b.team=team;
    b.x=x; b.y=y; b.vx=vx; b.vy=vy;
    b.r=opts.r ?? (team==='P'?3.0:3.1);
    b.dmg=opts.dmg ?? 10;
    b.life=opts.life ?? 2.3;
    b.t=0;
    b.col = opts.col ?? (team==='P'?C.P1:C.E1);

    // safety: enemy bullets must not use player bullet colors
    if (team==='E' && (b.col===C.P1 || b.col===C.P2)) b.col = C.E2;

    // enforce: enemy bullet sprite always follows its color
    if (team==='E') b.spr = sprFromColor(b.col, 'E');
    else b.spr = opts.spr ?? sprFromColor(b.col, 'P');
    b.style=opts.style ?? (team==='P'?1:0);

    b.bounce=opts.bounce ?? 0;
    b.pierce=opts.pierce ?? 0;
    b.homing=opts.homing ?? 0;
    b.slow=opts.slow ?? 0;
    b.splitT=opts.splitT ?? 0;
    b.mineT=opts.mineT ?? 0;
    b.noHitT=0;

    b.angVel = opts.angVel ?? 0;
    b.waveA  = opts.waveA  ?? 0;
    b.waveF  = opts.waveF  ?? 0;
    b.waveP  = opts.waveP  ?? 0;
    b.accel  = opts.accel  ?? 0;
    b.reverseT = opts.reverseT ?? 0;
    b.turnAfter = opts.turnAfter ?? 0;
    b.pauseT = opts.pauseT ?? 0;

    b.depth = opts.depth ?? 0;
    b.fortressSafe = !!opts.fortressSafe || ((Game.mode==='fortress' || Game.mode==='lab' || Game.mode==='fortress_duel') && team==='P');

    const srcOwner = opts?.modCtx?.owner || UnitBattle._bulletSource?.owner || UnitBattle._source || null;
    b.owner = srcOwner || null;

    // assign mods (affixes)
    if (opts.mods && opts.mods.length){
      applyBulletMods(b, opts.mods, opts.modCtx || null);
    } else {
      b.mods.length = 0;
      clearObj(b.st);
    }

    if (team==='E'){
      if (opts?.ubTeam!=null) b.ubTeam = opts.ubTeam;
      else if (opts?.modCtx?.owner?.ubTeam!=null) b.ubTeam = opts.modCtx.owner.ubTeam;
      else if (UnitBattle._bulletSource?.ubTeam!=null) b.ubTeam = UnitBattle._bulletSource.ubTeam;
      else if (srcOwner?.ubTeam!=null) b.ubTeam = srcOwner.ubTeam;
      else b.ubTeam = null;
    }
    (team==='P'?bulletsP:bulletsE).push(b);
    stampBulletDNA(b);
    return b;
  }
  
    // 从母弹提取可继承的运动/包装器属性
      function inheritBulletMotion(parent){
    return {
      angVel:   0,
      waveA:    0,
      waveF:    0,
      waveP:    0,
      accel:    0,
      // 关键：继承 reverseT（如果母弹还没反转，子弹也应该在同样时间反转）
      reverseT: Math.max(0, parent.reverseT || 0),
      homing:   parent.homing || 0,
      bounce:   parent.bounce || 0,
      slow:     parent.slow   || 0,
    };
  }
  
  
  /**
 * propagateMods — 子弹死亡/分裂时决定哪些 mods 传递给子代
 *
 * 规则：
 *   _internal / timerfx  → 永不传播
 *   deathfx / hitfx / spawnfx → 50% 概率传播（逐层衰减）
 *   其余（steer / speed / fx / stat / status）→ 无条件传播
 */
function propagateMods(parentMods){
  if (!parentMods || !parentMods.length) return [];
  const result = [];
  for (const k of parentMods){
    const def = BulletAffixCatalog[k];
    if (!def) continue;
    const tags = def.tags || [];
    if (tags.includes('_internal')) continue;
    if (tags.includes('timerfx'))   continue;
    if (tags.includes('deathfx') || tags.includes('hitfx') || tags.includes('spawnfx')){
      if (chance(0.50)) result.push(k);
      continue;
    }
    result.push(k);
  }
  return result;
}

/**
 * stampBulletDNA — 快照子弹当前的 Composite 运动状态
 * 每颗子弹生成后调用一次，后续 Wrapper 修改属性后再调用一次
 */
function stampBulletDNA(b){
  if (!b) return;
  b._dna = {
    reverseT: b.reverseT || 0,
    accel:    b.accel    || 0,
    pauseT:   b.pauseT   || 0,
    angVel:   b.angVel   || 0,
    waveA:    b.waveA    || 0,
    waveF:    b.waveF    || 0,
    bounce:   b.bounce   || 0,
    homing:   b.homing   || 0,
    slow:     b.slow     || 0,
  };
}

/**
 * inheritBulletDNA — 子代从父弹继承 Composite 运动印记
 * @param {Object} parent   父弹
 * @param {number} atten    衰减系数 0~1（默认 0.70）
 * @returns {Object} 可展开到 spawnBullet opts 的属性集
 */
function inheritBulletDNA(parent, atten){
  if (atten == null) atten = 0.70;
  const d = parent._dna;
  if (!d) return {
    reverseT: Math.max(0, (parent.reverseT||0) * atten),
    accel:    (parent.accel||0)  * atten,
    angVel:   (parent.angVel||0) * atten,
    waveA:    (parent.waveA||0)  * atten,
    waveF:    parent.waveF || 0,
    bounce:   parent.bounce || 0,
    homing:   parent.homing || 0,
    slow:     parent.slow   || 0,
  };
  return {
    reverseT: Math.max(0, d.reverseT * atten),
    accel:    d.accel  * atten,
    angVel:   d.angVel * atten,
    waveA:    d.waveA  * atten,
    waveF:    d.waveF,
    waveP:    rand(0, Math.PI*2),   // 子代随机相位 → 扩散感
    bounce:   d.bounce,
    homing:   d.homing,
    slow:     d.slow,
  };
}

/**
 * maxSpawnDepth — CASCADE 词条允许子代在更深层级仍可触发分裂
 */
function maxSpawnDepth(b){
  return b._cascadeActive ? 2 : 1;
}

/**
 * refreshDNAAfterFire — Composite Wrapper fire() 结束后刷新所有新增子弹的 DNA
 */
function refreshDNAAfterFire(beforeP, beforeE){
  for (const arr of [bulletsP, bulletsE]){
    const before = (arr === bulletsP) ? beforeP : beforeE;
    for (let i = before; i < arr.length; i++){
      const b = arr[i];
      if (b?.alive) stampBulletDNA(b);
    }
  }
}

  
  function killBullet(b, reason, ctx){
    if (!b.alive) return;
    if(reason==='oob') b._diedAtEdge=true
    
    // 1. 触发 Affix 的 onDeath 钩子 (逻辑层)
    const prevBulletSource = UnitBattle._bulletSource;
    UnitBattle._bulletSource = b;
    if (b.mods.length){
      for (const k of b.mods){
        const m = BulletAffixCatalog[k];
        m?.onDeath?.(b, reason, ctx);
      }
    }
    if (typeof b.onDeath === 'function') {
      b.onDeath(b);
      // 执行后立即移除，防止无限递归
      b.onDeath = null; 
    }
    UnitBattle._bulletSource = prevBulletSource;

    // 2. 视觉特效：自然消散 (expire)
    // 修改点：放宽深度限制，允许 depth <= 4 (分裂弹) 产生特效
    if (reason === 'expire' && b.depth <= 4) {
      // 屏幕边界检查 (-50 ~ W+50)
      if (b.x > -50 && b.x < W+50 && b.y > -50 && b.y < H+50) {
        
        // 动态调整粒子数量和大小
        // 母弹(depth 0): 3个粒子, 正常大小
        // 子弹(depth > 0): 1-2个粒子, 尺寸减半
        const isChild = b.depth > 0;
        const n = isChild ? (1 + (Math.random()>0.7?1:0)) : (2 + (Math.random()>0.5?1:0));
        const scaleMult = isChild ? 0.6 : 1.0;

        for(let i=0; i<n; i++){
          const p = particlePool.get();
          p.alive=true; p.x=b.x; p.y=b.y;
          
          // 速度继承：稍微带一点子弹原本的惯性
          p.vx = b.vx * 0.15 + rand(-15, 15); 
          p.vy = b.vy * 0.15 + rand(-15, 15);
          
          p.t=0; 
          p.life=0.25 * scaleMult; // 子弹粒子寿命更短
          p.a=0.5;     // 半透明
          p.spr=b.spr; // 继承子弹颜色
          p.scale=0.35 * scaleMult; // 根据深度缩小
          
          // 优化：如果是极小的分裂弹，不用 drawImage，改用简单的fillRect粒子 (在 drawParticles 中处理)
          if (p.scale < 0.2) p.scale = 0.14; 

          pushParticle(p);
        }
      }
    }

    b.alive=false;
  }

  // ================= Particles & shockwaves =================
  const particlePool = makePool(()=>({alive:false,x:0,y:0,vx:0,vy:0,t:0,life:0.35,a:1,spr:'glowE',scale:0.6}), 1700);

  function pushParticle(p){
    particles.push(p);
    if (particles.length>PERF.particlesMax){
      particles.splice(0, particles.length-PERF.particlesMax);
    }
  }

  function sparks(x,y, spr='glowE', n=10, sp=360){
    const tier = PERF.dynamicFX ? FXState.tier : 0;
    const keep = [1.0, 0.82, 0.62, 0.42][tier];
    const count = Math.max(1, Math.round(n * keep));

    for(let i=0;i<count;i++){
      const p = particlePool.get();
      const a = rand(0, Math.PI*2);
      const v = sp * rand(0.25, 1);
      p.alive=true; p.x=x; p.y=y;
      p.vx=Math.cos(a)*v; p.vy=Math.sin(a)*v;
      p.t=0; p.life=rand(0.18, 0.55) * (tier>=2 ? 0.88 : 1.0);
      p.a=tier>=3 ? 0.85 : 1;
      p.spr=spr;
      p.scale=rand(0.30, 0.95) * (tier>=2 ? 0.85 : 1.0);
      pushParticle(p);
    }
  }

  function spawnShockwave(x,y, col=C.P1, maxR=260, life=0.55){
    const tier = PERF.dynamicFX ? FXState.tier : 0;
    const keep = [1.0, 0.9, 0.72, 0.55][tier];
    const r = maxR * keep;
    const l = life * (tier>=2 ? 0.82 : 1.0);
    if (tier>=3 && r < 70) return;
    shockwaves.push({x,y,col,t:0,life:l,maxR:r});
    const cap = PERF.dynamicFX ? FXState.maxShockwaves : 180;
    if (shockwaves.length > cap) shockwaves.splice(0, shockwaves.length - cap);
  }

  function textPop(x,y,s,color=C.W){
    texts.push({x,y,s,color,t:0,life:0.9});
  }

  // ================= Beam (laser) =================
  function spawnBeam(x1,y1,x2,y2, width, life, dmg, col){
    beams.push({x1,y1,x2,y2,width,life,t:0,dmg,col});
  }

  function distPointSeg2(px,py,x1,y1,x2,y2){
    const vx=x2-x1, vy=y2-y1;
    const wx=px-x1, wy=py-y1;
    const c1 = vx*wx + vy*wy;
    if (c1<=0) return dist2(px,py,x1,y1);
    const c2 = vx*vx + vy*vy;
    if (c2<=c1) return dist2(px,py,x2,y2);
    const t = c1/c2;
    const bx = x1 + t*vx, by = y1 + t*vy;
    return dist2(px,py,bx,by);
  }

  // ================= Collision =================
  const hitCircle=(ax,ay,ar,bx,by,br)=>{
    const rr=ar+br;
    return dist2(ax,ay,bx,by)<=rr*rr;
  };


  function tryHitUnitBattleOpponentByBullet(b){
    if (!UnitBattle.active || !b?.alive || b.team!=='E' || b.ubTeam==null || b.noHitT>0 || b._phaseGhost) return false;
    let target = null;
    let bestD2 = Infinity;
    for (const e of enemies){
      if (!e?.alive || e.ubTeam==null || e.ubTeam===b.ubTeam) continue;
      if (b.owner && e===b.owner) continue;
      if (!hitCircle(b.x,b.y,b.r||2,e.x,e.y,e.r||10)) continue;
      const d2 = dist2(b.x,b.y,e.x,e.y);
      if (d2 < bestD2){ bestD2=d2; target=e; }
    }
    if (!target) return false;
    if (b.mods.length){
      for (const k of b.mods) BulletAffixCatalog[k]?.onHit?.(b, target, null);
    }
    target.onHit?.(b.dmg||0);
    sparks(b.x,b.y,'glowE', 8, 260);
    if (b.pierce>0){ b.pierce--; b.noHitT = 0.03; }
    else killBullet(b, 'hit', {childMods: propagateMods(b.mods)});
    if ((target.hp||0)<=0){ target.alive=false; target.onDeath?.(); }
    return true;
  }

  function circleRectOverlap(cx, cy, cr, rect){
    const rot = rect.rot||0;
    const c = Math.cos(rot), sn = Math.sin(rot);
    const dx = cx - rect.x, dy = cy - rect.y;
    const lx = dx*c + dy*sn;
    const ly = -dx*sn + dy*c;
    const hw = rect.w*0.5, hh = rect.h*0.5;
    const nx = clamp(lx, -hw, hw);
    const ny = clamp(ly, -hh, hh);
    return dist2(lx, ly, nx, ny) <= cr*cr;
  }

  function pushCircleOutRect(obj, rect){
    const rot = rect.rot||0;
    const c = Math.cos(rot), sn = Math.sin(rot);
    const dx0 = obj.x - rect.x, dy0 = obj.y - rect.y;
    let lx = dx0*c + dy0*sn;
    let ly = -dx0*sn + dy0*c;
    const hw = rect.w*0.5, hh = rect.h*0.5;
    const nx = clamp(lx, -hw, hw);
    const ny = clamp(ly, -hh, hh);
    const dx = lx - nx, dy = ly - ny;
    const rr = (obj.r||10) + 1;
    const d2 = dx*dx + dy*dy;
    if (d2 >= rr*rr) return false;
    if (d2 > 1e-6){
      const d = Math.sqrt(d2);
      const k = (rr - d) / d;
      lx += dx * k;
      ly += dy * k;
    } else {
      const padL = Math.abs(lx + hw);
      const padR = Math.abs(hw - lx);
      const padT = Math.abs(ly + hh);
      const padB = Math.abs(hh - ly);
      const m = Math.min(padL, padR, padT, padB);
      if (m===padL) lx = -hw - rr;
      else if (m===padR) lx = hw + rr;
      else if (m===padT) ly = -hh - rr;
      else ly = hh + rr;
    }
    obj.x = rect.x + (lx*c - ly*sn);
    obj.y = rect.y + (lx*sn + ly*c);
    return true;
  }

  function resolveEnemyFortressCollision(obj, structures, prevX, prevY){
    if (!obj || !Array.isArray(structures) || !structures.length) return;
    let pushed = false;
    for (let iter=0; iter<4; iter++){
      let hit = false;
      for (const fs of structures){
        if (!fs || fs.hp<=0 || fs.type==='mine') continue;
        if (pushCircleOutRect(obj, fs)){
          hit = true;
          pushed = true;
        }
      }
      if (!hit) break;
    }
    if (!pushed) return;

    // 兜底：若仍有重叠，回退到上一帧位置后再推一次，避免穿墙
    let overlapped = false;
    for (const fs of structures){
      if (!fs || fs.hp<=0 || fs.type==='mine') continue;
      if (circleRectOverlap(obj.x, obj.y, obj.r||10, fs)){ overlapped = true; break; }
    }
    if (!overlapped) return;

    obj.x = prevX;
    obj.y = prevY;
    for (const fs of structures){
      if (!fs || fs.hp<=0 || fs.type==='mine') continue;
      pushCircleOutRect(obj, fs);
    }
    if (Number.isFinite(obj.vx)) obj.vx *= 0.6;
    if (Number.isFinite(obj.vy)) obj.vy *= 0.6;
  }

  // ================= Supplies =================
  const Supply = {
    WXP:{ spr:'glowP', col:C.P1, name:'XP', apply(){ addXP(10 + randi(0,8)); textPop(Player.x,Player.y-16,'XP+',C.P1); beep({f:760,t:0.04,g:0.02,slide:1.12}); } },
    HEAL:{ spr:'glowG', col:C.G, name:'HP', apply(){ Player.hp=Math.min(Player.maxHp, Player.hp+26); textPop(Player.x,Player.y-16,'+HP',C.G); } },
    SHIELD:{ spr:'glowP2', col:C.P2, name:'SHD', apply(){ Player.shield=Math.min(12, Player.shield+5.5); textPop(Player.x,Player.y-16,'SHIELD',C.P2); } },
    BOMB:{ spr:'glowY', col:C.Y, name:'BOMB', apply(){ Player.bomb=Math.min(3, Player.bomb+1); textPop(Player.x,Player.y-16,'BOMB+1',C.Y); } },
    DRONE:{ spr:'glowP', col:C.P1, name:'DRN', apply(){ Player.drones=Math.min(4, Player.drones+1); textPop(Player.x,Player.y-16,'DRONE+',C.P1); } },
    MAGNET:{ spr:'glowP', col:C.P1, name:'MAG', apply(){ Player.magnetT=Math.min(12, Player.magnetT+7.0); textPop(Player.x,Player.y-16,'MAGNET',C.P1); } },
    OVERDRIVE:{ spr:'glowE3', col:C.E3, name:'OD', apply(){ Player.overdriveT=Math.min(10, Player.overdriveT+6.0); textPop(Player.x,Player.y-16,'OVERDRIVE',C.E3); } },
    EMIT:{
  spr:'glowY', col:C.Y, name:'EMIT',
  apply(){
    if (Game.mode==='fortress_duel') return;
    if (!grantPlayerEmitter()){
      addXP(10);
    }
  }
},

COMPOSITE:{ spr:'glowY', col:C.Y, name:'COMP', apply(){
      if (Game.mode==='fortress_duel') return;
      grantPlayerComposite();
      SFX.pickup();
    } },

    MOD:{ spr:'glowP2', col:C.P2, name:'MOD', apply(){
      if (Game.mode==='fortress_duel') return;
      Player.mods++;

      // 约 45% 给玩家子弹词条（gunMods）；否则给数值成长
      if (chance(0.45)){
        grantPlayerGunMod();
      } else {
        const roll=randi(0,5);
        if (roll===0) Player.fireRate = Math.min(1.85, Player.fireRate+0.045);
        if (roll===1) Player.dmgMul = Math.min(2.60, Player.dmgMul+0.055);
        if (roll===2) Player.crit = Math.min(0.45, Player.crit+0.018);
        if (roll===3) Player.pierceBase = Math.min(5, Player.pierceBase+1);
        if (roll===4) Player.homingAmmo = Math.min(60, Player.homingAmmo+4);
        if (roll===5) Player.maxHp = Math.min(300, Player.maxHp+8);
        textPop(Player.x,Player.y-16,'MOD+',C.P2);
      }
      beep({f:520,t:0.06,g:0.03,type:'triangle',slide:0.85});
    } }
  };

  function spawnSupply(x,y,key){
    supplies.push({x,y,vx:rand(-18,18),vy:rand(45, 95),r:12,key,t:0,dead:false});
  }

  function dropSupply(x,y){
    const d = Game.difficulty;
    const base = BAL.dropBase + (d<2.2 ? 0.05 : 0) + clamp((d-1)*0.008, 0, 0.07);
    if (!chance(base)) return;

    const hpRate = Player.hp/Player.maxHp;
    const wantHeal = clamp(1-hpRate, 0, 1);
    const wantShield = Player.shield>0 ? 0.20 : 0.80;
    const wantBomb = Player.bomb<1 ? 0.9 : 0.35;
    const wantDrone = Player.drones<2 ? 0.6 : 0.2;

    const entries = [
      ['WXP',  1.20],
      ['MOD',  0.62],
      ['HEAL', 0.25 + wantHeal*0.95],
      ['SHIELD',0.18 + wantShield*0.55],
      ['BOMB', 0.15 + wantBomb*0.40],
      ['DRONE',0.15 + wantDrone*0.50],
      ['MAGNET',0.12],
      ['OVERDRIVE',0.12],
      ...(Game.wave>=4 ? [['EMIT', 0.18]] : []),
      ...(Game.wave>=2 ? [['COMPOSITE', 0.12 + clamp((Game.wave-2)*0.008, 0, 0.10)]] : []),
    ];
    let sum=0; for(const [,w] of entries) sum+=w;
    let r = Math.random()*sum;
    for(const [k,w] of entries){ r-=w; if (r<=0){ spawnSupply(x,y,k); return; } }
    spawnSupply(x,y,'WXP');
  }

  // ================= Leveling (no cap) =================
  function grantPlayerGunMod(){
    if (Game.mode==='fortress_duel') return;
    // 玩家词条黑名单：禁止波浪和螺旋，保证玩家弹道是直线的（或追踪的），避免“乱飘”
    const banned = ['WAVE', 'SPIN', 'PHASE_SHIFT'];
    
    const wave = Game.wave;
    const maxMods = Player.gunModsMax;

    // 尝试抽取一个合法的词条
    let pick = null;
    // 尝试最多 8 次，防止运气不好一直抽到 banned 词条
    for(let i=0; i<8; i++){
      const rolled = rollAffixes({wave, maxCount:1});
      if (rolled.length > 0){
        const candidate = rolled[0];
        if (!banned.includes(candidate)){
          pick = candidate;
          break;
        }
      }
    }
    if (!pick) return; // 极端情况没抽到

    // 逻辑：如果已拥有则升级数值
    if (Player.gunMods.includes(pick)){
      Player.dmgMul = Math.min(2.60, Player.dmgMul+0.025); // 升级补偿略微增加
      textPop(Player.x,Player.y-16,'UPGRADE',C.Y);
      return;
    }

    // 逻辑：未满则添加
    if (Player.gunMods.length < maxMods){
      Player.gunMods.push(pick);
      textPop(Player.x,Player.y-16,'MOD: '+pick, C.Y);
      spawnShockwave(Player.x, Player.y, C.Y, 220, 0.45);
      return;
    }

    // 逻辑：已满则随机替换（保持 Build 流动性）
    const idx = randi(0, Player.gunMods.length-1);
    const old = Player.gunMods[idx];
    Player.gunMods[idx] = pick;
    textPop(Player.x,Player.y-16, old+' > '+pick, C.Y);
  }

  function addXP(v){
    if (Game.mode==='fortress_duel') return;
    Player.xp += v;
    while(Player.xp >= Player.xpNeed){
      Player.xp -= Player.xpNeed;
      Player.lv++;
      Player.xpNeed = xpNeedFor(Player.lv);

      // 成长更克制
      const lv = Player.lv;
      const k = 1 / (1 + lv/40);
      Player.maxHp = Math.min(320, Player.maxHp + (lv<40?2:1));
      Player.hp = Math.min(Player.maxHp, Player.hp + 6);
      Player.dmgMul = Math.min(2.60, Player.dmgMul + 0.014*k);
      Player.fireRate = Math.min(1.85, Player.fireRate + 0.010*k);
      Player.crit = Math.min(0.45, Player.crit + 0.0025*k);

      // 每 5 级给一次“词条/武器变化”（比之前更慢）
      if (lv % 5 === 0){
        grantPlayerGunMod();
        Player.homingAmmo = Math.min(80, Player.homingAmmo + 2);
        // 每 5 级有 35% 概率获得包装器
        if (chance(0.35) && Player.emitters.length > 0){
          grantPlayerComposite();
        }
        textPop(Player.x, Player.y-22, 'POWER+', C.Y);
        spawnShockwave(Player.x, Player.y, C.P1, 220, 0.48);
      } else {
        textPop(Player.x, Player.y-22, 'LEVEL UP', C.P1);
      }
      SFX.levelUp();
      addShake(3,0.10);
      beep({f:880,t:0.05,g:0.02,slide:1.25});
    }
  }

  // ================= Enemy Traits (non-weapon) =================
  function baseEnemy(type, r, hp, score){
    return {
      type, alive:true,
      x:0,y:0,r,
      hp, maxHp:hp,
      score,
      hit:0,
      armor:0,
      regen:0,
      phase:0,
      tint:null,
      shieldHP:0,
      
      // 补丁：生存时间计时器
      age: 0, 

      // body & emitters (modular)
      body:null,
      baseCol:C.E1,
      emitters:[],
      move(dt){},
      update(dt){
        // 补丁：强制离场逻辑
        // 记录存活时间，如果超过 14 秒，强制向下加速漂移
        this.age = (this.age || 0) + dt;
        if (!UnitBattle.active && this.age > 14) {
          // 随时间越来越快的向下推力，无视原本的移动逻辑强制推走
          this.y += (this.age - 14) * 60 * dt;
        }

        this.move(dt);
        updateEmitters(this, dt);
      },
      draw(){ drawEnemyGeneric(this); },

      onDeath:null,
      onHit(dmg){
        SFX.enemyHit();
        const take = Math.max(1, dmg - (this.armor||0));
        if (this.shieldHP>0){
          this.shieldHP -= take;
          this.hit = 0.06;
          if (this.shieldHP<=0){
            sparks(this.x,this.y,'glowP2', 16, 520);
            spawnShockwave(this.x,this.y,C.P2, 180, 0.42);
          }
          return;
        }
        this.hp -= take;
        this.hit = 0.06;
      }
    };
  }

  function wrapMethod(obj, key, wrapper){
    const old = obj[key].bind(obj);
    obj[key] = (dt)=>wrapper(old, dt);
  }

function spawnMinionDrone(owner, d){
  const m = baseEnemy('MINION', rand(7.0, 9.0), Math.round(18 + d*2.0), 0);
  m.isMinion = true;
  m.noDrop = true;
  m.score = 0;

  // inherit owner color (no mismatch)
  m.baseCol = owner.tint || owner.baseCol || C.E1;
  m.tint = owner.tint || null;

  // spawn near owner
  m.x = clamp(owner.x + rand(-36,36), 18, W-18);
  m.y = owner.y + rand(10, 26);

  // small body
  m.bodySeed = ((owner.bodySeed||0) ^ 0x9e3779b9) + randi(0, 1e9);
  m.body = genEnemyBody(m.bodySeed);

  // light movement
  m.vx = rand(-70, 70);
  m.vy = 120 + d*4.0;
  m.move = (dt)=>{
    m.x += m.vx*dt;
    m.y += m.vy*dt;
    if (m.x<18 || m.x>W-18) m.vx *= -1;
  };

  // short lifetime
  m.lifeT = rand(7.0, 10.0);
  const oldUpdate = m.update.bind(m);
  m.update = (dt)=>{
    oldUpdate(dt);
    m.lifeT -= dt;
    if (m.lifeT<=0) m.alive=false;
  };

  // simple single emitter only (keeps them lightweight)
  m.emitters = [
    EmitterCatalog.AIM({
      baseCd: 1.45,
      speed: 210 + d*6,
      dmg: 7 + d*0.45,
      r: 2.4,
      life: 2.0
    })
  ];

  // throttle their shooting a bit
  m.emCdMul = 1.15;

  return m;
}

function addDrawOverlay(e, fn){
  const old = e.draw ? e.draw.bind(e) : ()=>{};
  e.draw = ()=>fn(old);
}

  const EnemyTraitCatalog = {
    // ===== Style traits (cosmetic, stackable) =====

STYLE_DOUBLE_OUTLINE:{
  minWave:1, weight:0.85, group:'style',
  apply(e,d){
    addDrawOverlay(e,(draw)=>{
      draw();
      const col = enemyColor(e);
      ctx.save(); if (FXState.additiveOn) ctx.globalCompositeOperation='lighter';
      ctx.globalAlpha = 0.35;
      tronStroke(col, 1, 0.55);
      ctx.beginPath(); ctx.arc(e.x,e.y,e.r+22,0,Math.PI*2); ctx.stroke();
      ctx.globalAlpha = 0.18;
      tronStroke(col, 1, 0.45);
      ctx.beginPath(); ctx.arc(e.x,e.y,e.r+28,0,Math.PI*2); ctx.stroke();
      ctx.restore();
    });
  }
},

STYLE_SPIN_RING:{
  minWave:1, weight:0.70, group:'style',
  apply(e,d){
    e._srP = rand(0,Math.PI*2);
    addDrawOverlay(e,(draw)=>{
      draw();
      const col = enemyColor(e);
      const r = e.r+18;
      ctx.save(); if (FXState.additiveOn) ctx.globalCompositeOperation='lighter';
      ctx.globalAlpha = 0.18 + 0.10*Math.sin(Game.time*8 + e._srP);
      tronStroke(col, 2, 0.85);
      const a0 = Game.time*0.9 + e._srP;
      for(let i=0;i<3;i++){
        ctx.beginPath();
        ctx.arc(e.x,e.y,r, a0+i*2.1, a0+i*2.1+1.05);
        ctx.stroke();
      }
      ctx.restore();
    });
  }
},

STYLE_SCANLINE:{
  minWave:1, weight:0.55, group:'style',
  apply(e,d){
    e._slP = rand(0,1);
    addDrawOverlay(e,(draw)=>{
      draw();
      const col = enemyColor(e);
      const y = e.y - e.r - 18 + ((Game.time*0.65 + e._slP)%1) * (e.r*2+36);
      ctx.save(); if (PERF.additive) ctx.globalCompositeOperation='lighter';
      ctx.globalAlpha = 0.10;
      ctx.fillStyle = rgbToRgba(col, 0.8);
      ctx.fillRect(e.x-(e.r+26), y, (e.r+26)*2, 2);
      ctx.restore();
    });
  }
},

STYLE_HOLOGRAM:{
  minWave:1, weight:0.50, group:'style',
  apply(e,d){
    addDrawOverlay(e,(draw)=>{
      // flicker alpha (hologram)
      const a = 0.75 + 0.25*Math.sin(Game.time*18 + e.x*0.02);
      ctx.save();
      ctx.globalAlpha = a;
      draw();
      ctx.restore();
    });
  }
},

STYLE_AFTERIMAGE:{
  minWave:1, weight:0.42, group:'style',
  apply(e,d){
    e._hist = [];
    // record history
    wrapMethod(e,'update',(old,dt)=>{
      old(dt);
      e._hist.push({x:e.x,y:e.y});
      if (e._hist.length>8) e._hist.shift();
    });

    addDrawOverlay(e,(draw)=>{
      draw();
      const col = enemyColor(e);
      if (!e._hist) return;
      ctx.save(); if (PERF.additive) ctx.globalCompositeOperation='lighter';
      for(let i=0;i<e._hist.length;i++){
        const p = e._hist[i];
        const k = i/(e._hist.length-1+1e-6);
        ctx.globalAlpha = 0.02 + 0.10*k;
        tronStroke(col, 1, 0.55);
        ctx.beginPath(); ctx.arc(p.x,p.y,e.r+10*(1-k),0,Math.PI*2); ctx.stroke();
      }
      ctx.restore();
    });
  }
},

STYLE_CROWN_SPIKES:{
  minWave:1, weight:0.45, group:'style',
  apply(e,d){
    e._crN = 8 + randi(0,8);
    addDrawOverlay(e,(draw)=>{
      draw();
      const col = enemyColor(e);
      ctx.save(); if (PERF.additive) ctx.globalCompositeOperation='lighter';
      ctx.globalAlpha = 0.18;
      tronStroke(col, 1, 0.65);
      const r0 = e.r+16, r1 = e.r+26;
      const rot = Game.time*0.35;
      for(let i=0;i<e._crN;i++){
        const a = rot + i*(Math.PI*2/e._crN);
        ctx.beginPath();
        ctx.moveTo(e.x+Math.cos(a)*r0, e.y+Math.sin(a)*r0);
        ctx.lineTo(e.x+Math.cos(a+0.10)*r1, e.y+Math.sin(a+0.10)*r1);
        ctx.lineTo(e.x+Math.cos(a+0.20)*r0, e.y+Math.sin(a+0.20)*r0);
        ctx.stroke();
      }
      ctx.restore();
    });
  }
},

STYLE_CORE_TRIAD:{
  minWave:1, weight:0.40, group:'style',
  apply(e,d){
    addDrawOverlay(e,(draw)=>{
      draw();
      const col = enemyColor(e);
      ctx.save(); if (PERF.additive) ctx.globalCompositeOperation='lighter';
      ctx.globalAlpha = 0.20;
      tronStroke(col, 1, 0.55);
      const r = e.r*0.9;
      const rot = -Math.PI/2 + Game.time*0.7;
      ctx.beginPath();
      for(let i=0;i<3;i++){
        const a = rot + i*(Math.PI*2/3);
        const x = e.x + Math.cos(a)*r;
        const y = e.y + Math.sin(a)*r;
        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath(); ctx.stroke();
      ctx.restore();
    });
  }
},

STYLE_LINKS:{
  minWave:1, weight:0.35, group:'style',
  apply(e,d){
    addDrawOverlay(e,(draw)=>{
      draw();
      // link to nearest 1 ally
      let best=null, bestD=1e9;
      for(const o of enemies){
        if (!o.alive || o===e || o.type==='BOSS') continue;
        const d2 = dist2(e.x,e.y,o.x,o.y);
        if (d2<bestD){ bestD=d2; best=o; }
      }
      if (!best || bestD>(260*260)) return;
      const col = enemyColor(e);
      ctx.save(); if (PERF.additive) ctx.globalCompositeOperation='lighter';
      ctx.globalAlpha = 0.10;
      tronStroke(col, 2, 0.65);
      ctx.beginPath(); ctx.moveTo(e.x,e.y); ctx.lineTo(best.x,best.y); ctx.stroke();
      ctx.restore();
    });
  }
},

STYLE_HOLLOW:{
  minWave:1, weight:0.35, group:'style',
  apply(e,d){
    addDrawOverlay(e,(draw)=>{
      draw();
      // inner hollow ring
      const col = enemyColor(e);
      ctx.save(); if (PERF.additive) ctx.globalCompositeOperation='lighter';
      ctx.globalAlpha = 0.14;
      ctx.beginPath();
      ctx.arc(e.x,e.y,e.r+14,0,Math.PI*2);
      ctx.arc(e.x,e.y,e.r+6,0,Math.PI*2,true);
      ctx.fillStyle = rgbToRgba(col, 0.8);
      ctx.fill('evenodd');
      ctx.restore();
    });
  }
},

STYLE_GLITCH_JITTER:{
  minWave:1, weight:0.25, group:'style',
  apply(e,d){
    wrapMethod(e,'update',(old,dt)=>{
      old(dt);
      if (chance(0.06)){
        e.x = clamp(e.x + rand(-10,10), 16, W-16);
        e.y = e.y + rand(-6,6);
      }
    });
  }
},

STYLE_THRUST_TRAIL:{
  minWave:1, weight:0.55, group:'style',
  apply(e,d){
    wrapMethod(e,'update',(old,dt)=>{
      old(dt);
      if (chance(0.25)) sparks(e.x, e.y+e.r+6, sprFromColor(enemyColor(e),'E'), 1, 40);
    });
  }
},

STYLE_WARNING_STRIPES:{
  minWave:1, weight:0.40, group:'style',
  apply(e,d){
    addDrawOverlay(e,(draw)=>{
      draw();
      const col = enemyColor(e);
      ctx.save(); if (PERF.additive) ctx.globalCompositeOperation='lighter';
      ctx.globalAlpha = 0.12;
      tronStroke(col, 1, 0.55);
      const w = e.r+24;
      for(let i=-2;i<=2;i++){
        ctx.beginPath();
        ctx.moveTo(e.x-w, e.y+i*6);
        ctx.lineTo(e.x+w, e.y+i*6 + 10);
        ctx.stroke();
      }
      ctx.restore();
    });
  }
},
    FAST:{ minWave:1, weight:1.0, group:'mobility',
      apply(e,d){
        if (e.vx!=null) e.vx *= 1.22;
        if (e.vy!=null) e.vy *= 1.18;
        e.score = Math.round(e.score*1.10);
      }
    },
    ARMORED:{ minWave:2, weight:0.9, group:'defense',
      apply(e,d){
        e.armor = Math.round(2 + d*0.40);
        e.maxHp = Math.round(e.maxHp*1.35);
        e.hp = e.maxHp;
        e.score = Math.round(e.score*1.20);
      }
    },
    MAGNETIC_ARMOR: {
      minWave: 5,        // 第5波及以后出现
      weight: 0.45,      // 出现权重（中等）
      group: 'defense',  // 属于防御类词条
      
      apply(e, d) {
        // 1. 基础属性强化
        e.maxHp = Math.round(e.maxHp * 1.5); // 血量 x1.5
        e.hp = e.maxHp;
        e.score = Math.round(e.score * 1.4); // 分数更高
        
        // 定义引力场参数
        e._magRadius = 240 + (d * 10); // 引力半径随难度微增
        e._magForce = 900;             // 引力强度

        // 2. 修改受伤逻辑：获得高额减伤 (65% 减伤)
        const oldOnHit = e.onHit.bind(e);
        e.onHit = (dmg) => {
          // 受到伤害减少，且必定只受 35% 伤害
          // 伴随一个沉闷的护盾受击音效
          oldOnHit(Math.max(1, dmg * 0.35)); 
          
          // 视觉反馈：受击时引力场闪烁
          e._magFlashT = 0.2;
        };

        // 3. 物理逻辑：每帧吸引玩家子弹
        wrapMethod(e, 'update', (old, dt) => {
          old(dt);
          
          if (e._magFlashT > 0) e._magFlashT -= dt;

          const r2 = e._magRadius * e._magRadius;
          
          // 遍历所有玩家子弹
          for (const b of bulletsP) {
            if (!b.alive || b._phaseGhost) continue; // 忽略隐形/死亡子弹

            const dx = e.x - b.x;
            const dy = e.y - b.y;
            const distSq = dx*dx + dy*dy;

            // 如果子弹进入引力范围
            if (distSq < r2) {
              const dist = Math.sqrt(distSq);
              // 计算引力向量 (指向敌人中心)
              // 距离越近，引力越强 (非线性增强)
              const force = e._magForce * (1 + (1 - dist/e._magRadius)); 
              
              // 修改子弹速度向量
              b.vx += (dx / dist) * force * dt;
              b.vy += (dy / dist) * force * dt;
              
              // [可选] 稍微偏转子弹角度使其指向敌人（让追踪看起来更自然）
              // b.vx *= 0.98; b.vy *= 0.98; // 增加一点阻力防止弹射过快
            }
          }
        });

        // 4. 视觉表现：绘制引力场扭曲圈
        addDrawOverlay(e, (draw) => {
          draw(); // 先画敌人本体
          
          const col = C.P2; // 使用紫色/品红代表引力/磁力
          
          ctx.save();
          if (PERF.additive) ctx.globalCompositeOperation = 'lighter';
          
          // 绘制引力波纹 (呼吸效果)
          const pulse = Math.sin(Game.time * 4) * 0.1 + 0.9;
          const flash = (e._magFlashT > 0) ? 0.4 : 0.0; // 受击时变亮
          
          // 外圈场域
          ctx.globalAlpha = 0.08 + flash;
          ctx.fillStyle = col;
          ctx.beginPath();
          ctx.arc(e.x, e.y, e._magRadius, 0, Math.PI * 2);
          ctx.fill();
          
          // 内圈强力场线条
          ctx.globalAlpha = 0.3 + flash;
          ctx.strokeStyle = col;
          ctx.lineWidth = 2;
          ctx.setLineDash([10, 15]); // 虚线圈
          // 虚线旋转效果
          ctx.beginPath();
          ctx.arc(e.x, e.y, e._magRadius * 0.8 * pulse, Game.time, Game.time + Math.PI * 2);
          ctx.stroke();
          
          // 核心连接线 (表示正在吸收能量)
          ctx.setLineDash([]);
          ctx.globalAlpha = 0.15;
          ctx.beginPath();
          for(let i=0; i<4; i++) {
             const a = Game.time * -2 + (i * Math.PI / 2);
             ctx.moveTo(e.x + Math.cos(a)*e.r, e.y + Math.sin(a)*e.r);
             ctx.lineTo(e.x + Math.cos(a)*e._magRadius*0.6, e.y + Math.sin(a)*e._magRadius*0.6);
          }
          ctx.stroke();

          ctx.restore();
        });
      }
    },
    SHIELD_LAYER:{ minWave:5, weight:0.7, group:'defense',
      apply(e,d){
        e.shieldHP = Math.round(26 + d*7.0);
        e.score = Math.round(e.score*1.18);
      }
    },
    REGEN:{ minWave:4, weight:0.65, group:'defense',
      apply(e,d){
        e.regen = 0.55 + d*0.06;
        wrapMethod(e,'update',(old,dt)=>{
          old(dt);
          if (e.hp>0 && e.hp<e.maxHp) e.hp = Math.min(e.maxHp, e.hp + e.regen*dt);
        });
        e.score = Math.round(e.score*1.15);
      }
    },
    PHASED:{ minWave:7, weight:0.45, group:'defense',
      apply(e,d){
        const oldOnHit = e.onHit.bind(e);
        e.onHit = (dmg)=>{
          if (chance(0.12 + clamp((Game.difficulty-1)*0.01,0,0.12))){
            oldOnHit(Math.max(1, dmg*0.25));
            sparks(e.x,e.y,'glowP2', 10, 360);
          } else oldOnHit(dmg);
        };
        e.score = Math.round(e.score*1.20);
      }
    },
    CHAMPION:{ minWave:7, weight:0.42, group:'defense',
      apply(e,d){
        const palette = [C.E1, C.E2, C.E3, C.E4, C.E5, C.E6, C.E7, C.Y];
        e.tint = palette[randi(0, palette.length-1)];
        e.maxHp = Math.round(e.maxHp*1.22);
        e.hp = e.maxHp;
        e.score = Math.round(e.score*1.30);
      }
    },
    DASHER:{ minWave:7, weight:0.50, group:'mobility',
      apply(e,d){
        e._dashCd = rand(1.3, 2.4);
        wrapMethod(e,'move',(old,dt)=>{
          old(dt);
          e._dashCd -= dt;
          if (e._dashCd<=0){
            e._dashCd = rand(1.6, 2.8)/Math.sqrt(d);
            e.vx = (e.vx||0) + (chance(0.5)?-1:1) * (140 + 120*hellFactor());
            sparks(e.x,e.y,'glowP2', 10, 420);
          }
        });
        e.score = Math.round(e.score*1.15);
      }
    },
    ZIGZAG:{ minWave:4, weight:0.65, group:'mobility',
      apply(e,d){
        e._zzP = rand(0,Math.PI*2);
        e._zzF = rand(1.2, 2.0);
        e._zzA = rand(35, 90);
        wrapMethod(e,'move',(old,dt)=>{
          old(dt);
          e._zzP += dt*e._zzF;
          e.x += Math.sin(e._zzP) * e._zzA * dt;
          e.x = clamp(e.x, 18, W-18);
        });
        e.score = Math.round(e.score*1.10);
      }
    },
    AURA_SLOW:{ minWave:8, weight:0.38, group:'utility',
      apply(e,d){
        e._auraR = 120 + randi(0,70);
        wrapMethod(e,'update',(old,dt)=>{
          old(dt);
          const dx = Player.x-e.x, dy = Player.y-e.y;
          const d2 = dx*dx+dy*dy;
          if (d2 < e._auraR*e._auraR){
            const k = 1 - Math.sqrt(d2)/e._auraR;
            Player.slowT = Math.min(2.2, Player.slowT + dt*(0.55 + 0.9*k));
          }
        });
        e.score = Math.round(e.score*1.20);
      }
    },
    SUMMONER:{ minWave:10, weight:0.25, group:'utility',
      apply(e,d){
        e._sumCd = rand(3.2, 5.0);
        wrapMethod(e,'update',(old,dt)=>{
          old(dt);
          e._sumCd -= dt;
          if (e._sumCd<=0){
            const hf = hellFactor();
            e._sumCd = lerp(5.4, 3.6, hf) / Math.sqrt(d);
            const n = 1 + (hf>0.65?1:0);
            for(let i=0;i<n;i++){
              const s = EnemyFactory.spawnFromProto(WaveDirector.pickLiteProto(), d);
              s.x = clamp(e.x + rand(-80,80), 22, W-22);
              s.y = e.y + rand(10, 30);
              enemies.push(s);
            }
            sparks(e.x,e.y,'glowE3', 14, 520);
            spawnShockwave(e.x,e.y,C.E3, 160, 0.45);
          }
        });
        e.score = Math.round(e.score*1.30);
      }
    },
    ON_DEATH_NOVA:{ minWave:8, weight:0.45, group:'death',
      apply(e,d){
        const prev = e.onDeath;
        e.onDeath = ()=>{
          prev?.();
          const hf = hellFactor();
          const n = 10 + Math.round(10*hf);
          for (let i=0;i<n;i++){
            const a = rand(0,Math.PI*2);
            spawnBullet('E', e.x, e.y, Math.cos(a)*(210+d*7), Math.sin(a)*(210+d*7), {
              r:2.8, dmg:10+d*0.65, col:C.E2, spr:'glowE2', style:0, life:1.65,
              mods: []
            });
          }
          sparks(e.x,e.y,'glowE2', 20+Math.round(14*hf), 720);
          spawnShockwave(e.x,e.y,C.E2, 220, 0.55);
        };
        e.score = Math.round(e.score*1.22);
      }
    },
    // ===== Functional traits (components) =====

// 1) 召唤小无人机群
DRONE_SWARM:{
  minWave:5, weight:0.80, group:'utility',
  apply(e,d){
    e._swarmCd = rand(3.2, 5.0);
    wrapMethod(e,'update',(old,dt)=>{
      old(dt);
      e._swarmCd -= dt;
      if (e._swarmCd>0) return;
      e._swarmCd = rand(3.8, 6.0) / Math.sqrt(d);

      const n = 3 + (chance(0.35)?1:0); // 3~4
      for(let i=0;i<n;i++){
        const m = spawnMinionDrone(e, Game.difficulty);
        enemies.push(m);
      }
      sparks(e.x,e.y, sprFromColor(e.tint||e.baseCol||C.E3,'E'), 12, 520);
      spawnShockwave(e.x,e.y, e.tint||e.baseCol||C.E3, 160, 0.45);
    });
  }
},

// 2) 修理者：为附近队友回血
REPAIR_AURA:{
  minWave:6, weight:0.65, group:'utility',
  apply(e,d){
    e._repCd = rand(0.8, 1.2);
    e._repR = 150 + randi(0,70);
    wrapMethod(e,'update',(old,dt)=>{
      old(dt);
      e._repCd -= dt;
      if (e._repCd>0) return;
      e._repCd = 0.7;

      const heal = 2.0 + d*0.20;
      for(const o of enemies){
        if (!o.alive || o===e || o.type==='BOSS' || o.isMinion) continue;
        const dx=o.x-e.x, dy=o.y-e.y;
        if (dx*dx+dy*dy > e._repR*e._repR) continue;
        if (o.hp < o.maxHp) o.hp = Math.min(o.maxHp, o.hp + heal);
      }
      if (chance(0.35)) sparks(e.x,e.y,'glowG', 4, 240);
    });
  }
},

// 3) 护盾投射：给队友加 shieldHP
SHIELD_PROJECTOR:{
  minWave:7, weight:0.55, group:'utility',
  apply(e,d){
    e._shpCd = rand(1.8, 2.6);
    e._shpR = 170 + randi(0,80);
    wrapMethod(e,'update',(old,dt)=>{
      old(dt);
      e._shpCd -= dt;
      if (e._shpCd>0) return;
      e._shpCd = rand(2.2, 3.0);

      const add = Math.round(12 + d*2.0);
      for(const o of enemies){
        if (!o.alive || o===e || o.type==='BOSS' || o.isMinion) continue;
        const dx=o.x-e.x, dy=o.y-e.y;
        if (dx*dx+dy*dy > e._shpR*e._shpR) continue;
        o.shieldHP = Math.min((o.shieldHP||0) + add, 90 + d*10);
      }
      sparks(e.x,e.y,'glowP2', 10, 420);
      spawnShockwave(e.x,e.y,C.P2, 190, 0.40);
    });
  }
},

// 4) 冲锋：短暂高速朝玩家冲刺（无瞬移）
CHARGER:{
  minWave:6, weight:0.75, group:'mobility',
  apply(e,d){
    e._chgCd = rand(2.0, 3.2);
    e._chgT = 0;
    e._chgVx = 0; e._chgVy = 0;

    wrapMethod(e,'move',(old,dt)=>{
      if (e._chgT>0){
        e._chgT -= dt;
        e.x = clamp(e.x + e._chgVx*dt, 18, W-18);
        e.y = e.y + e._chgVy*dt;
        e._chgVx *= Math.exp(-4.0*dt);
        e._chgVy *= Math.exp(-4.0*dt);
        if (chance(0.25)) sparks(e.x,e.y,'glowY', 1, 70);
        return;
      }

      old(dt);

      e._chgCd -= dt;
      if (e._chgCd>0) return;
      e._chgCd = rand(2.4, 3.8) / Math.sqrt(d);
      e._chgT = 0.22 + rand(0,0.10);

      const t = findEnemyFocus(e.x,e.y);
      if (!t) return;
      const dx = t.x - e.x;
      const dy = t.y - e.y;
      const len = Math.max(1, Math.hypot(dx,dy));
      const sp = 420 + d*18;
      e._chgVx = (dx/len)*sp;
      e._chgVy = (dy/len)*sp;
      sparks(e.x,e.y,'glowY', 10, 420);
    });
  }
},

// 5) 指挥官：附近队友射速提升（通过 emCdMul）
COMMANDER:{
  minWave:8, weight:0.40, group:'utility',
  apply(e,d){
    e._cmdCd = 0.25;
    e._cmdR = 220 + randi(0,90);
    wrapMethod(e,'update',(old,dt)=>{
      old(dt);
      e._cmdCd -= dt;
      if (e._cmdCd>0) return;
      e._cmdCd = 0.25;

      for(const o of enemies){
        if (!o.alive || o===e || o.type==='BOSS' || o.isMinion) continue;
        const dx=o.x-e.x, dy=o.y-e.y;
        if (dx*dx+dy*dy > e._cmdR*e._cmdR) continue;
        o._cmdBuffT = Math.max(o._cmdBuffT||0, 0.55);
      }
    });
  }
},

// 6) 狂暴：低血量射速提升（对自身）
BERSERK:{
  minWave:7, weight:0.55, group:'utility',
  apply(e,d){
    wrapMethod(e,'update',(old,dt)=>{
      // commander buff timer decay
      if (e._cmdBuffT>0) e._cmdBuffT = Math.max(0, e._cmdBuffT - dt);

      const hpRate = e.hp / e.maxHp;
      const cmdMul = (e._cmdBuffT>0) ? 0.82 : 1.0;
      const rageMul = (hpRate < 0.40) ? lerp(1.0, 0.70, smoothstep(0.40, 0.12, hpRate)) : 1.0;
      e.emCdMul = cmdMul * rageMul;

      old(dt);
    });
  }
},

// 7) EMP 脉冲：范围减速 + 清掉少量玩家子弹
EMP_PULSE:{
  minWave:9, weight:0.35, group:'utility',
  apply(e,d){
    e._empCd = rand(3.5, 5.2);
    e._empR = 190 + randi(0,90);
    wrapMethod(e,'update',(old,dt)=>{
      old(dt);
      e._empCd -= dt;
      if (e._empCd>0) return;
      e._empCd = rand(4.0, 6.0) / Math.sqrt(d);

      const t = findEnemyFocus(e.x,e.y);
      if (t){
        const dx = t.x-e.x, dy=t.y-e.y;
        if (dx*dx+dy*dy < e._empR*e._empR && t===Player){
          Player.slowT = Math.min(2.2, Player.slowT + 1.0);
        }
      }

      let removed = 0;
      for (const b of bulletsP){
        if (!b.alive) continue;
        const bx=b.x-e.x, by=b.y-e.y;
        if (bx*bx+by*by < (e._empR*0.78)*(e._empR*0.78)){
          b.alive=false;
          if (++removed>=6) break;
        }
      }

      spawnShockwave(e.x,e.y, C.P2, e._empR*1.15, 0.55);
      sparks(e.x,e.y,'glowP2', 18, 620);
    });
  }
},

// 8) 腐蚀光环：近距离持续扣血（小额）
CORROSIVE_AURA:{
  minWave:10, weight:0.28, group:'utility',
  apply(e,d){
    e._corR = 130 + randi(0,70);
    wrapMethod(e,'update',(old,dt)=>{
      old(dt);
      const t = findEnemyFocus(e.x,e.y);
      if (!t) return;
      const dx=t.x-e.x, dy=t.y-e.y;
      if (dx*dx+dy*dy < e._corR*e._corR && t===Player && Player.invuln<=0){
        onPlayerHit(2.0 + d*0.22);
      }
    });
  }
},

// 9) 诱饵：生成肉盾假体（不射击，不掉落）
DECOY_SPAWN:{
  minWave:8, weight:0.32, group:'utility',
  apply(e,d){
    e._decCd = rand(5.0, 7.0);
    wrapMethod(e,'update',(old,dt)=>{
      old(dt);
      e._decCd -= dt;
      if (e._decCd>0) return;
      e._decCd = rand(6.0, 9.0);

      const dec = baseEnemy('DECOY', e.r*0.88, Math.round(90 + d*14), 0);
      dec.noDrop = true;
      dec.isMinion = true; // treat as minion for xp skip
      dec.baseCol = e.tint || e.baseCol || C.E2;
      dec.tint = e.tint || null;
      dec.bodySeed = ((e.bodySeed||0) ^ 0xdec0de) + randi(0,1e9);
      dec.body = genEnemyBody(dec.bodySeed);

      dec.x = clamp(e.x + rand(-90,90), 22, W-22);
      dec.y = e.y + rand(10, 30);
      dec.vy = 55 + d*2.0;
      dec.move = (dt2)=>{ dec.y += dec.vy*dt2; };
      dec.update = function(dt2){ this.move(dt2); };

      enemies.push(dec);
      sparks(dec.x,dec.y,'glowW', 10, 420);
    });
  }
},

// 10) 复仇：死亡放出一圈子弹
REVENGE_NOVA:{
  minWave:7, weight:0.55, group:'death',
  apply(e,d){
    const prev = e.onDeath;
    e.onDeath = ()=>{
      prev?.();
      const hf = hellFactor();
      const n = 10 + Math.round(10*hf);
      const sp = 190 + d*7;
      const col = e.tint || e.baseCol || C.E2;

      for(let i=0;i<n;i++){
        const a = (i/n)*Math.PI*2 + rand(-0.05,0.05);
        spawnBullet('E', e.x,e.y, Math.cos(a)*sp, Math.sin(a)*sp, {
          r:2.7, dmg: 9 + d*0.55,
          col, style:0, life:1.6
        });
      }
      spawnShockwave(e.x,e.y,col, 240, 0.55);
      sparks(e.x,e.y, sprFromColor(col,'E'), 22, 720);
    };
  }
},

// 11) 标记追踪：发射延迟追踪弹
MARK_AND_SEEK:{
  minWave:10, weight:0.25, group:'utility',
  apply(e,d){
    e._msCd = rand(3.0, 4.4);
    wrapMethod(e,'update',(old,dt)=>{
      old(dt);
      e._msCd -= dt;
      if (e._msCd>0) return;
      e._msCd = rand(3.2, 5.0)/Math.sqrt(d);

      const col = e.tint || e.baseCol || C.E1;
      const a = Math.atan2(Player.y-e.y, Player.x-e.x);
      const sp = 180 + d*5;
      const b = spawnBullet('E', e.x,e.y+6, Math.cos(a)*sp, Math.sin(a)*sp, {
        r:2.8, dmg: 10 + d*0.65,
        col, style:1, life:2.0
      });
      if (!b) return;
      b.turnAfter = 0.45;
      sparks(e.x,e.y, sprFromColor(col,'E'), 8, 420);
    });
  }
},

// 12) 群体加固：附近队友获得短暂护甲（用 _fortT 计时）
FORTIFY:{
  minWave:9, weight:0.30, group:'utility',
  apply(e,d){
    e._ftCd = 0.35;
    e._ftR = 200 + randi(0,70);
    wrapMethod(e,'update',(old,dt)=>{
      old(dt);
      e._ftCd -= dt;
      if (e._ftCd>0) return;
      e._ftCd = 0.35;

      for(const o of enemies){
        if (!o.alive || o===e || o.type==='BOSS' || o.isMinion) continue;
        const dx=o.x-e.x, dy=o.y-e.y;
        if (dx*dx+dy*dy > e._ftR*e._ftR) continue;
        o._fortT = Math.max(o._fortT||0, 0.60);
      }
    });
  }
},
// ===== Functional traits (components) =====

// REFLECT - 反弹子弹护盾（周期性开启一段时间）
REFLECT:{
  minWave:7, weight:0.38, group:'defense',
  apply(e,d){
    e.reflectCd = rand(2.8, 4.2);
    e.reflectT = 0;
    wrapMethod(e,'update',(old,dt)=>{
      old(dt);
      if (e.reflectT>0) e.reflectT = Math.max(0, e.reflectT - dt);
      e.reflectCd -= dt;
      if (e.reflectCd>0) return;
      e.reflectCd = rand(3.2, 5.0) / Math.sqrt(d);
      e.reflectT = 0.85 + 0.10*hellFactor();
      sparks(e.x,e.y,'glowW', 10, 420);
    });
    wrapDraw(e,(draw)=>{
      draw();
      if (e.reflectT>0){
        ctx.save();
        if (PERF.additive) ctx.globalCompositeOperation='lighter';
        ctx.globalAlpha = 0.18 + 0.12*Math.sin(Game.time*14);
        tronStroke(enemyColor(e), 2, 0.85);
        ctx.beginPath(); ctx.arc(e.x,e.y,e.r+18,0,Math.PI*2); ctx.stroke();
        ctx.restore();
      }
    });
  }
},

// KAMIKAZE - 低血自爆冲刺（触发后停火，冲到玩家附近爆）
KAMIKAZE:{
  minWave:8, weight:0.32, group:'mobility',
  apply(e,d){
    e.kami = 0;
    e.kamiT = 0;
    wrapMethod(e,'update',(old,dt)=>{
      old(dt);
      if (!e.alive) return;

      if (!e.kami && e.hp/e.maxHp < 0.28){
        e.kami = 1;
        e.kamiT = 2.8;            // max chase time
        // stop shooting (still can keep existing bullets)
        e.emitters && (e.emitters.length = 0);
        sparks(e.x,e.y,'glowY', 14, 520);
      }

      if (!e.kami) return;

      e.kamiT -= dt;
      // accelerate toward player (smooth)
      const dx = Player.x - e.x;
      const dy = Player.y - e.y;
      const len = Math.max(1, Math.hypot(dx,dy));
      const sp = 260 + d*14 + 120*hellFactor();
      e.x = clamp(e.x + (dx/len)*sp*dt, 16, W-16);
      e.y = e.y + (dy/len)*sp*dt;

      // detonate
      const rr = (Player.r + e.r + 10);
      if (Player.alive && Player.invuln<=0 && dx*dx+dy*dy < rr*rr){
        onPlayerHit(26 + d*2.0);
        e.hp = 0;
      }
      if (e.kamiT<=0) e.hp = 0;
    });

    const prev = e.onDeath;
    e.onDeath = ()=>{
      prev?.();
      const col = enemyColor(e);
      spawnShockwave(e.x,e.y,col, 320, 0.65);
      sparks(e.x,e.y, sprFromColor(col,'E'), 34, 760);
      // small bullet ring on death
      const n = 10 + Math.round(8*hellFactor());
      const sp = 200 + d*7;
      for(let i=0;i<n;i++){
        const a = (i/n)*Math.PI*2;
        spawnBullet('E', e.x,e.y, Math.cos(a)*sp, Math.sin(a)*sp, {r:2.7, dmg:9+d*0.55, col, life:1.4});
      }
    };
  }
},

// TELEPORTER - 瞬移（带消失/出现，不突兀）
TELEPORTER:{
  minWave:9, weight:0.26, group:'mobility',
  apply(e,d){
    e.tpCd = rand(2.8, 4.8);
    e.tpT = 0;
    e.tpToX = e.x;
    e.tpDid = 0;

    wrapMethod(e,'update',(old,dt)=>{
      old(dt);

      if (e.tpT>0){
        e.tpT -= dt;
        // at mid point do the actual move once
        if (!e.tpDid && e.tpT < 0.07){
          e.tpDid = 1;
          const fromX = e.x;
          e.x = e.tpToX;
          // keep orbit/sweep centers coherent if present
          if (e.cx!=null) e.cx += (e.x - fromX);
          if (e.mmx && e.mmx.ocx!=null) e.mmx.ocx += (e.x - fromX);
          sparks(e.x,e.y,'glowP2', 10, 420);
        }
        return;
      }

      e.tpCd -= dt;
      if (e.tpCd>0) return;
      e.tpCd = rand(3.4, 6.0) / Math.sqrt(d);
      e.tpT = 0.14;   // vanish+appear window
      e.tpDid = 0;
      e.tpToX = clamp(e.x + rand(-240,240), 24, W-24);
      sparks(e.x,e.y,'glowP2', 10, 420);
    });

    wrapDraw(e,(draw)=>{
      if (e.tpT>0){
        const k = clamp(e.tpT/0.14, 0, 1);
        const a = (k>0.5) ? (k-0.5)*2 : (1-k*2); // fade out then in
        ctx.save(); ctx.globalAlpha = 0.20 + 0.60*a;
        draw();
        ctx.restore();
      } else draw();
    });
  }
},

// CLONER - 复制自己（生成弱化克隆，不掉落不加经验）
CLONER:{
  minWave:10, weight:0.22, group:'utility',
  apply(e,d){
    e.cloneCd = rand(5.5, 8.0);
    wrapMethod(e,'update',(old,dt)=>{
      old(dt);
      if (e.isMinion) return;
      e.cloneCd -= dt;
      if (e.cloneCd>0) return;
      e.cloneCd = rand(6.0, 9.0) / Math.sqrt(d);

      const spec = {
        moveKey: e._protoMoveKey || 'DRIFT',
        baseCol: enemyColor(e),
        tint: e.tint || null,
        bodySeed: (e._protoBodySeed||0) ^ 0xc10ee,
        emitters: e._protoEmitters || [],
        waveBulletMods: e._protoWaveBulletMods || []
      };
      const c = spawnEnemyCoreFromSpecs(spec, d);

      c.isMinion = true;
      c.noDrop = true;
      c.score = 0;

      c.maxHp = Math.max(16, Math.round(e.maxHp*0.35));
      c.hp = c.maxHp;
      c.r = Math.max(7, e.r*0.80);

      c.x = clamp(e.x + rand(-80,80), 22, W-22);
      c.y = e.y + rand(10, 30);

      enemies.push(c);
      sparks(c.x,c.y,'glowW', 10, 420);
      spawnShockwave(c.x,c.y, enemyColor(e), 160, 0.45);
    });
  }
},

// MORPH - 动态变大小（不改 hp，只改 r + 轻微影响射速）
MORPH:{
  minWave:7, weight:0.35, group:'utility',
  apply(e,d){
    e.baseR = e.r;
    e.morphP = rand(0, Math.PI*2);
    wrapMethod(e,'update',(old,dt)=>{
      e.morphP += dt*(1.6 + 0.3*hellFactor());
      const s = 0.82 + 0.30*(0.5+0.5*Math.sin(e.morphP));
      e.r = e.baseR * s;
      // slightly slower shooting when large (balance)
      e.emCdMul = (e.emCdMul||1) * lerp(1.0, 1.10, clamp((s-1)*2, 0, 1));
      old(dt);
    });
  }
},

// ORBITER - 环绕护盾球（能挡子弹）
ORBITER:{
  minWave:8, weight:0.30, group:'defense',
  apply(e,d){
    const n = 2 + (chance(0.55)?1:0);
    e.orbiters = [];
    for(let i=0;i<n;i++){
      e.orbiters.push({
        a: rand(0,Math.PI*2),
        r: 8.0,
        rr: 20 + i*12,
        hp: 35 + d*6
      });
    }

    wrapMethod(e,'update',(old,dt)=>{
      old(dt);
      const col = enemyColor(e);
      for(const o of e.orbiters){
        if (o.hp<=0) continue;
        o.a += dt*(1.6 + d*0.01);
        o.x = e.x + Math.cos(o.a)*o.rr;
        o.y = e.y + Math.sin(o.a)*o.rr*0.55;
      }
    });

    wrapDraw(e,(draw)=>{
      draw();
      const col = enemyColor(e);
      if (!e.orbiters) return;
      ctx.save();
      if (PERF.additive) ctx.globalCompositeOperation='lighter';
      for(const o of e.orbiters){
        if (o.hp<=0) continue;
        drawGlow(Spr[sprFromColor(col,'E')], o.x, o.y, 0.55, 0.95);
        ctx.globalAlpha = 0.25;
        tronStroke(col, 1, 0.7);
        ctx.beginPath(); ctx.arc(o.x,o.y,o.r+6,0,Math.PI*2); ctx.stroke();
        ctx.globalAlpha = 1;
      }
      ctx.restore();
    });
  }
},

// PULSAR - 脉冲推开子弹（防守型）
PULSAR:{
  minWave:9, weight:0.28, group:'utility',
  apply(e,d){
    e.pulseCd = rand(2.8, 4.0);
    e.pulseR = 170 + randi(0,90);
    wrapMethod(e,'update',(old,dt)=>{
      old(dt);
      e.pulseCd -= dt;
      if (e.pulseCd>0) return;
      e.pulseCd = rand(3.2, 4.8) / Math.sqrt(d);

      const R = e.pulseR;
      const R2 = R*R;
      const col = enemyColor(e);

      let pushed = 0;
      for(const b of bulletsP){
        if (!b.alive) continue;
        const dx=b.x-e.x, dy=b.y-e.y;
        const d2 = dx*dx+dy*dy;
        if (d2>R2 || d2<1) continue;
        const dist = Math.sqrt(d2);
        const ux=dx/dist, uy=dy/dist;
        const force = (260 + d*16) * (1 - dist/R);
        b.vx += ux*force;
        b.vy += uy*force;
        pushed++;
        if (pushed>14) break;
      }

      spawnShockwave(e.x,e.y,col, R*1.1, 0.55);
      sparks(e.x,e.y, sprFromColor(col,'E'), 16, 620);
    });
  }
},

// SNIPER - 狙击激光（预警线）
SNIPER:{
  minWave:9, weight:0.26, group:'utility',
  apply(e,d){
    e.snCd = rand(2.6, 3.8);
    e.snCharge = 0;
    e.snAimX = 0; e.snAimY = 0;

    wrapMethod(e,'update',(old,dt)=>{
      old(dt);

      if (e.snCharge>0){
        e.snCharge += dt;
        // track aim slightly
        e.snAimX = lerp(e.snAimX, Player.x, 1 - Math.exp(-8*dt));
        e.snAimY = lerp(e.snAimY, Player.y, 1 - Math.exp(-8*dt));

        if (e.snCharge >= 0.75){
          // fire
          const col = C.Y;
          spawnBeam(e.x, e.y+10, e.snAimX, e.snAimY, 10, 0.22, 16 + d*1.5, col);
          sparks(e.x,e.y+10,'glowY', 18, 620);
          spawnShockwave(e.x,e.y+10,col, 240, 0.55);
          e.snCharge = 0;
        }
        return;
      }

      e.snCd -= dt;
      if (e.snCd>0) return;
      e.snCd = rand(2.8, 4.2)/Math.sqrt(d);
      e.snCharge = 0.001;
      e.snAimX = Player.x; e.snAimY = Player.y;
    });

    wrapDraw(e,(draw)=>{
      draw();
      if (e.snCharge>0){
        const k = clamp(e.snCharge/0.75, 0, 1);
        ctx.save();
        if (PERF.additive) ctx.globalCompositeOperation='lighter';
        ctx.globalAlpha = 0.12 + 0.38*k;
        tronStroke(C.Y, 2 + 2*k, 0.85);
        ctx.beginPath();
        ctx.moveTo(e.x, e.y+10);
        ctx.lineTo(e.snAimX, e.snAimY);
        ctx.stroke();
        ctx.restore();
      }
    });
  }
},

// TANK - 超厚血 + 缓慢移动 + 略慢射速
TANK:{
  minWave:6, weight:0.40, group:'defense',
  apply(e,d){
    e.maxHp = Math.round(e.maxHp * 1.85);
    e.hp = e.maxHp;
    e.emCdMul = (e.emCdMul||1) * 1.15;

    wrapMethod(e,'move',(old,dt)=>{
      old(dt * 0.62);
    });
  }
},

// STEALTH - 隐身闪烁（期间大量闪避子弹）
STEALTH:{
  minWave:10, weight:0.22, group:'defense',
  apply(e,d){
    e.stealthCd = rand(3.5, 5.5);
    e.stealthT = 0;

    wrapMethod(e,'update',(old,dt)=>{
      old(dt);
      if (e.stealthT>0) e.stealthT = Math.max(0, e.stealthT-dt);

      e.stealthCd -= dt;
      if (e.stealthCd>0) return;

      e.stealthCd = rand(4.0, 6.0)/Math.sqrt(d);
      e.stealthT = 0.85 + 0.25*hellFactor();
      sparks(e.x,e.y,'glowW', 10, 420);
    });

    wrapDraw(e,(draw)=>{
      if (e.stealthT>0){
        const a = 0.20 + 0.20*Math.sin(Game.time*18 + e.x*0.01);
        ctx.save();
        ctx.globalAlpha = a;
        draw();
        ctx.restore();
      } else draw();
    });
  }
},
  };

  const EnemyTraitFilters = [
    (ctx)=>{
      const w = Game.wave;
      const maxT = (w<4 ? 1 : (w<9 ? 2 : (w<16 ? 3 : 4)));
      const baseChance = (w<3 ? 0.05 : (w<6 ? 0.14 : (w<10 ? 0.26 : (w<15 ? 0.34 : 0.42))));
      let count=0;
      while(count<maxT && chance(baseChance)) count++;
      return {traitCount: count};
    },
    (ctx)=>{
      const w=Game.wave;
      const allowChampion = w>=7 && chance(0.10 + clamp((w-7)*0.02,0,0.20));
      return {forceChampion: allowChampion};
    },
    (ctx)=>{
      const w=Game.wave;
      return {groupCaps:{
        defense: w<6 ? 1 : 2,
        mobility: w<8 ? 1 : 2,
        utility: w<6 ? 1 : (w<10 ? 2 : 3),
        death: w<8 ? 0 : 1,
      }};
    }
  ];

  function pickEnemyTraits(forceChampion, count, forcedTraits=[], groupCaps=null){
    const keys = Object.keys(EnemyTraitCatalog);
    const picked = [];
    const groupCount = {defense:0, mobility:0, utility:0, death:0};

    function canPick(k){
      const tr = EnemyTraitCatalog[k];
      if (!tr) return false;
      if ((tr.minWave||1) > Game.wave) return false;
      if (picked.includes(k)) return false;
      const g = tr.group;
      if (groupCaps && g && groupCaps[g]!=null && groupCount[g] >= groupCaps[g]) return false;
      return true;
    }
    function addPick(k){
      const tr = EnemyTraitCatalog[k];
      picked.push(k);
      if (tr?.group) groupCount[tr.group] = (groupCount[tr.group]||0) + 1;
    }

    for(const k of forcedTraits) if (canPick(k)) addPick(k);

    if (forceChampion && canPick('CHAMPION') && !picked.includes('CHAMPION')){
      addPick('CHAMPION');
      count = Math.max(0, count-1);
    }

    for(let i=0;i<count;i++){
      const cand = keys.filter(canPick);
      if (!cand.length) break;
      let sum=0;
      for(const k of cand) sum += (EnemyTraitCatalog[k].weight||1);
      let r = Math.random()*sum;
      let pick = cand[0];
      for(const k of cand){
        r -= (EnemyTraitCatalog[k].weight||1);
        if (r<=0){ pick=k; break; }
      }
      addPick(pick);
    }
    return picked;
  }

function applyEnemyTraits(e, traitKeys, d){
  // 1. 初始化记录数组（如果不存在）
  if (!e._appliedTraitKeys) e._appliedTraitKeys = [];

  for(const k of traitKeys){
    const tr = EnemyTraitCatalog[k];
    if (!tr) continue;

    // 2. 记录 Trait 的 ID
    // 检查是否已经记录过，避免重复（比如从原型继承后又随机抽到）
    if (!e._appliedTraitKeys.includes(k)) {
      e._appliedTraitKeys.push(k);
    }

    // 3. 执行原始的应用逻辑
    tr.apply?.(e, d);
  }
}

  // ================= Enemy Geometry (dynamic random组合) =================

function genEnemyBody(seed) {
  const R = makeRng(seed);

  const kind = BODY_KINDS[Math.floor(R() * BODY_KINDS.length)];

  // 1. 基础通用参数
  const baseN = 3 + (R() * 8 | 0);
  const innerN = 3 + (R() * 8 | 0);
  // 对于螺旋(spiral)，spokes 代表臂数(2-5)
  const spokes = (kind === 'spiral') ? (2 + (R()*4|0)) : ((R() < 0.80) ? (2 + (R() * 6 | 0)) : 0);
  const ring = R() < 0.78;

  const rot1 = (R() * 1.8 + 0.3) * (R() < 0.5 ? 1 : -1);
  const rot2 = (R() * 2.0 + 0.4) * (R() < 0.5 ? 1 : -1);

  const scale1 = 0.95 + R() * 0.35;
  const scale2 = 0.55 + R() * 0.28;

  // 2. 特殊形状参数
  const starInner = 0.42 + R() * 0.22;
  const teeth = 8 + (R() * 12 | 0);
  const toothDepth = 0.18 + R() * 0.20;
  const rr = 0.20 + R() * 0.35;
  const crossT = 0.18 + R() * 0.18;
  const chevT  = 0.14 + R() * 0.18;
  const diaSkew = 0.70 + R() * 0.45;
  const arcSegs = 3 + (R() * 5 | 0);
  const arcSpan = 0.55 + R() * 0.55;
  const arcGap  = 0.18 + R() * 0.22;

  // 3. 针对几何化重构的参数修正
if (kind === 'lotus') {
    // 莲花重构：多层机械曼陀罗
    // baseN: 主花瓣数 (8~14)，越多越像复杂的齿轮
    // rot1: 基础旋转速度，后续层级基于此倍率计算
    return {
      kind, 
      baseN: 8 + (R()*7|0),    // 增加边数，使其看起来不那么像普通多边形
      innerN: 4 + (R()*3|0),   // 核心层边数
      ring: false, spokes: 0,
      rot1: (0.3 + R()*0.3) * (R()<0.5?1:-1), // 基础慢旋，营造巨大感
      scale1, scale2, 
      pts: null
    };
  }
  if (kind === 'phoenix') {
    // 凤凰：baseN 决定尾羽数量
    return {
      kind, baseN: 3 + (R()*3|0), innerN: 3, ring: false, spokes:0,
      rot1: rot1 * 0.5, // 飞翔不需要转太快
      scale1, scale2,
      pts: null
    };
  }

  return {
    kind,
    baseN, innerN, ring, spokes,
    rot1, rot2, scale1, scale2,
    starInner, teeth, toothDepth,
    rr, pts:null,
    crossT, chevT, diaSkew,
    arcSegs, arcSpan, arcGap,
  };
}

  function starPath(x,y,r,n,rot=0, inner=0.55){
  ctx.beginPath();
  const m = n*2;
  for(let i=0;i<m;i++){
    const a = rot + i*(Math.PI*2/m);
    const rr = (i%2===0) ? r : r*inner;
    const px = x + Math.cos(a)*rr;
    const py = y + Math.sin(a)*rr;
    if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
  }
  ctx.closePath();
}

function gearPath(x,y,r,teeth,rot=0, depth=0.22){
  ctx.beginPath();
  const m = teeth*2;
  for(let i=0;i<m;i++){
    const a = rot + i*(Math.PI*2/m);
    const rr = (i%2===0) ? r : r*(1-depth);
    const px = x + Math.cos(a)*rr;
    const py = y + Math.sin(a)*rr;
    if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
  }
  ctx.closePath();
}

function roundedRectPath(x,y,w,h,r){
  const rr = Math.min(r, w*0.5, h*0.5);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y,   x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x,   y+h, rr);
  ctx.arcTo(x,   y+h, x,   y,   rr);
  ctx.arcTo(x,   y,   x+w, y,   rr);
  ctx.closePath();
}

function shardPath(x,y,r,pts,rot=0){
  ctx.beginPath();
  for(let i=0;i<pts.length;i++){
    const a = rot + pts[i].a;
    const rr = r * pts[i].r;
    const px = x + Math.cos(a)*rr;
    const py = y + Math.sin(a)*rr;
    if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
  }
  ctx.closePath();
}

function diamondPath(x,y,r,rot=0, skew=1){
  ctx.beginPath();
  const a = rot;
  ctx.moveTo(x + Math.cos(a)*r,           y + Math.sin(a)*r);
  ctx.lineTo(x + Math.cos(a+Math.PI/2)*r*skew, y + Math.sin(a+Math.PI/2)*r*skew);
  ctx.lineTo(x + Math.cos(a+Math.PI)*r,       y + Math.sin(a+Math.PI)*r);
  ctx.lineTo(x + Math.cos(a+Math.PI*1.5)*r*skew, y + Math.sin(a+Math.PI*1.5)*r*skew);
  ctx.closePath();
}

function getPoly3DDef(kind){
  let verts = [], edges = [];
  if (kind==='cube'){
    for(let x=-1; x<=1; x+=2) for(let y=-1; y<=1; y+=2) for(let z=-1; z<=1; z+=2) verts.push({x,y,z});
    edges = [[0,1],[1,3],[3,2],[2,0], [4,5],[5,7],[7,6],[6,4], [0,4],[1,5],[2,6],[3,7]];
  } else if (kind==='pyramid'){
    const h = 1.0;
    verts = [{x:0,y:-h,z:0},{x:-1,y:h,z:-0.8},{x:1,y:h,z:-0.8},{x:0,y:h,z:1.0}];
    edges = [[0,1],[0,2],[0,3],[1,2],[2,3],[3,1]];
  } else if (kind==='octa'){
    verts = [{x:0,y:-1.4,z:0},{x:0,y:1.4,z:0},{x:-1,y:0,z:0},{x:1,y:0,z:0},{x:0,y:0,z:-1},{x:0,y:0,z:1}];
    edges = [[0,2],[0,3],[0,4],[0,5],[1,2],[1,3],[1,4],[1,5],[2,4],[4,3],[3,5],[5,2]];
  } else if (kind==='prism'){
    verts = [
      {x:-1,y:-0.9,z:-0.8},{x:1,y:-0.9,z:-0.8},{x:0,y:0.9,z:-0.8},
      {x:-1,y:-0.9,z:0.8},{x:1,y:-0.9,z:0.8},{x:0,y:0.9,z:0.8}
    ];
    edges = [[0,1],[1,2],[2,0],[3,4],[4,5],[5,3],[0,3],[1,4],[2,5]];
  } else if (kind==='dodeca'){
    const phi = (1 + Math.sqrt(5)) / 2;
    const inv = 1 / phi;
    verts = [];
    for (const sx of [-1,1]) for (const sy of [-1,1]) for (const sz of [-1,1]) verts.push({x:sx,y:sy,z:sz});
    for (const sy of [-1,1]) for (const sz of [-1,1]) verts.push({x:0,y:sy*inv,z:sz*phi});
    for (const sx of [-1,1]) for (const sy of [-1,1]) verts.push({x:sx*inv,y:sy*phi,z:0});
    for (const sx of [-1,1]) for (const sz of [-1,1]) verts.push({x:sx*phi,y:0,z:sz*inv});
    const th = 2.35;
    const n = verts.length;
    for(let i=0;i<n;i++) for(let j=i+1;j<n;j++){
      const dx=verts[i].x-verts[j].x, dy=verts[i].y-verts[j].y, dz=verts[i].z-verts[j].z;
      const d=Math.hypot(dx,dy,dz);
      if (d < th) edges.push([i,j]);
    }
  }
  return {verts, edges};
}

function drawPoly3DWire(kind, cx, cy, size, time, col, drawNodes=false, drawCtx=ctx){
  const {verts, edges} = getPoly3DDef(kind);
  if (!verts.length) return;
  const rot3D = (x, y, z, angX, angY) => {
    let y1 = y * Math.cos(angX) - z * Math.sin(angX);
    let z1 = y * Math.sin(angX) + z * Math.cos(angX);
    let x2 = x * Math.cos(angY) - z1 * Math.sin(angY);
    let z2 = x * Math.sin(angY) + z1 * Math.cos(angY);
    return {x:x2, y:y1, z:z2};
  };
  const p2d = [];
  for (const v of verts){
    const r = rot3D(v.x*size, v.y*size, v.z*size, time*0.7, time);
    p2d.push({x:cx+r.x, y:cy+r.y, z:r.z});
  }
  const g = drawCtx;
  g.save();
  g.fillStyle = rgbToRgba(col, 0.14);
  g.beginPath();
  for (const p of p2d) g.lineTo(p.x,p.y);
  g.closePath();
  g.fill();
  for (const [i,j] of edges){
    const p1 = p2d[i], p2 = p2d[j];
    const avgZ = (p1.z + p2.z) / 2;
    const zNorm = clamp((avgZ + size) / (size*2), 0, 1);
    g.strokeStyle = rgbToRgba(col, 0.30 + 0.70*zNorm);
    g.lineWidth = 1.0 + 1.8*zNorm;
    g.beginPath();
    g.moveTo(p1.x,p1.y); g.lineTo(p2.x,p2.y); g.stroke();
    if (drawNodes){
      g.fillStyle = rgbToRgba(col, 0.45 + 0.45*zNorm);
      g.fillRect(p1.x-1.1,p1.y-1.1,2.2,2.2);
    }
  }
  g.restore();
}

function crossPath(x,y,r,rot=0, t=0.25){
  // plus sign polygon (12 points)
  const w = r, th = r*t;
  const c = Math.cos(rot), s = Math.sin(rot);
  const P = [
    [-th,-w],[ th,-w],[ th,-th],[ w,-th],[ w, th],[ th, th],[ th, w],[-th, w],[-th, th],[-w, th],[-w,-th],[-th,-th]
  ];
  ctx.beginPath();
  for(let i=0;i<P.length;i++){
    const px = P[i][0], py = P[i][1];
    const xx = x + px*c - py*s;
    const yy = y + px*s + py*c;
    if (i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
  }
  ctx.closePath();
}

function chevronPath(x,y,r,rot=0, t=0.18){
  // V shaped chevron (8 points)
  const w=r, th=r*t;
  const c=Math.cos(rot), s=Math.sin(rot);
  const P=[
    [-w,-th],[-th,-th],[0,th],[th,-th],[w,-th],[th,th],[0, w*0.55],[-th,th]
  ];
  ctx.beginPath();
  for(let i=0;i<P.length;i++){
    const px=P[i][0], py=P[i][1];
    const xx=x + px*c - py*s;
    const yy=y + px*s + py*c;
    if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
  }
  ctx.closePath();
}
  

  function polyPath(x,y,r,n,rot=0, sx=1, sy=1){
    ctx.beginPath();
    for(let i=0;i<n;i++){
      const a = rot + i*(Math.PI*2/n);
      const px = x + Math.cos(a)*r*sx;
      const py = y + Math.sin(a)*r*sy;
      if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.closePath();
  }
  function tronStroke(col, w=2, a=0.9){
    ctx.strokeStyle = rgbToRgba(col, a);
    ctx.lineWidth = w;
  }
  function tronFill(col, a=0.10){
    ctx.fillStyle = rgbToRgba(col, a);
  }


  function drawEnemyGenericBody(g, e, b, col, R0, rot, time){
    const tronStrokeG = (cc, w=2, a=0.9)=>{ g.strokeStyle = rgbToRgba(cc, a); g.lineWidth = w; };
    const tronFillG = (cc, a=0.10)=>{ g.fillStyle = rgbToRgba(cc, a); };
    const polyPathG = (x,y,r,n,rt=0,sx=1,sy=1)=>{ g.beginPath(); for(let i=0;i<n;i++){ const a=rt+i*(Math.PI*2/n); const px=x+Math.cos(a)*r*sx; const py=y+Math.sin(a)*r*sy; if(i===0) g.moveTo(px,py); else g.lineTo(px,py);} g.closePath(); };
    const starPathG = (x,y,r,n,rt=0,inner=0.5)=>{ const m=n*2; g.beginPath(); for(let i=0;i<m;i++){ const a=rt+i*(Math.PI*2/m); const rr=(i%2===0)?r:r*inner; const px=x+Math.cos(a)*rr; const py=y+Math.sin(a)*rr; if(i===0) g.moveTo(px,py); else g.lineTo(px,py);} g.closePath(); };
    const gearPathG = (x,y,r,teeth=8,rt=0,depth=0.28)=>{ const m=Math.max(6,teeth*2); g.beginPath(); for(let i=0;i<m;i++){ const a=rt+i*(Math.PI*2/m); const rr=(i%2===0)?r:r*(1-depth); const px=x+Math.cos(a)*rr; const py=y+Math.sin(a)*rr; if(i===0) g.moveTo(px,py); else g.lineTo(px,py);} g.closePath(); };
    const roundedRectPathG = (x,y,w,h,rr=8)=>{ rr=Math.max(0,Math.min(rr,Math.min(w,h)*0.5)); g.beginPath(); g.moveTo(x+rr,y); g.arcTo(x+w,y,x+w,y+h,rr); g.arcTo(x+w,y+h,x,y+h,rr); g.arcTo(x,y+h,x,y,rr); g.arcTo(x,y,x+w,y,rr); g.closePath(); };
    const shardPathG = (x,y,r,pts,rt=0)=>{ g.beginPath(); for(let i=0;i<pts.length;i++){ const a=rt+pts[i].a; const rr=r*pts[i].r; const px=x+Math.cos(a)*rr; const py=y+Math.sin(a)*rr; if(i===0) g.moveTo(px,py); else g.lineTo(px,py);} g.closePath(); };
    const diamondPathG = (x,y,r,rt=0,skew=1)=>{ const a=rt; g.beginPath(); g.moveTo(x+Math.cos(a)*r,y+Math.sin(a)*r); g.lineTo(x+Math.cos(a+Math.PI/2)*r*skew,y+Math.sin(a+Math.PI/2)*r*skew); g.lineTo(x+Math.cos(a+Math.PI)*r,y+Math.sin(a+Math.PI)*r); g.lineTo(x+Math.cos(a+Math.PI*1.5)*r*skew,y+Math.sin(a+Math.PI*1.5)*r*skew); g.closePath(); };
    const crossPathG = (x,y,r,rt=0,t=0.25)=>{ const w=r,th=r*t,c=Math.cos(rt),s=Math.sin(rt); const P=[[-th,-w],[th,-w],[th,-th],[w,-th],[w,th],[th,th],[th,w],[-th,w],[-th,th],[-w,th],[-w,-th],[-th,-th]]; g.beginPath(); for(let i=0;i<P.length;i++){ const px=P[i][0],py=P[i][1]; const xx=x+px*c-py*s,yy=y+px*s+py*c; if(i===0) g.moveTo(xx,yy); else g.lineTo(xx,yy);} g.closePath(); };
    const chevronPathG = (x,y,r,rt=0,t=0.18)=>{ const w=r,th=r*t,c=Math.cos(rt),s=Math.sin(rt); const P=[[-w,-th],[-th,-th],[0,th],[th,-th],[w,-th],[th,th],[0,w*0.55],[-th,th]]; g.beginPath(); for(let i=0;i<P.length;i++){ const px=P[i][0],py=P[i][1]; const xx=x+px*c-py*s,yy=y+px*s+py*c; if(i===0) g.moveTo(xx,yy); else g.lineTo(xx,yy);} g.closePath(); };

if (b.kind === 'crescent'){
  const cx1 = e.x, cy1 = e.y, r1 = R0;
  const ox = R0*0.48, oy = -R0*0.08;
  const cx2 = e.x + ox, cy2 = e.y + oy, r2 = R0*0.74;

  const dx = cx2 - cx1, dy = cy2 - cy1;
  const d = Math.hypot(dx, dy);

  if (d < r1 + r2 && d > Math.abs(r1 - r2)){
    const baseA = Math.atan2(dy, dx);
    const cosA1 = clamp((r1*r1 + d*d - r2*r2) / (2*r1*d), -1, 1);
    const halfA1 = Math.acos(cosA1);
    const cosA2 = clamp((r2*r2 + d*d - r1*r1) / (2*r2*d), -1, 1);
    const halfA2 = Math.acos(cosA2);
    const baseA2 = baseA + Math.PI;

    // 月牙路径：外圆大弧（远离内圆侧）+ 内圆短弧（连接回来）
    // 交点角度：外圆上 baseA±halfA1，内圆上 baseA2±halfA2
    // 外圆画从 (baseA-halfA1) 逆时针到 (baseA+halfA1) 的大弧 → 这是远离内圆的弧
    // 但我们要的是外圆上"不被内圆遮挡"的弧，即绕过内圆对面那一侧

    // 填充
    tronFillG(col, 0.08);
    g.beginPath();
    // 外圆：从上交点逆时针绕到下交点（经过远离内圆的一侧 = 大弧）
    g.arc(cx1, cy1, r1, baseA + halfA1, baseA - halfA1, false);
    // 内圆：从下交点顺时针绕到上交点（短弧，连接月牙闭合）
    g.arc(cx2, cy2, r2, baseA2 + halfA2, baseA2 - halfA2, true);
    g.closePath();
    g.fill();

    // 描边
    tronStrokeG(col, 2.5, 0.90);
    g.beginPath();
    g.arc(cx1, cy1, r1, baseA + halfA1, baseA - halfA1, false);
    g.arc(cx2, cy2, r2, baseA2 + halfA2, baseA2 - halfA2, true);
    g.closePath();
    g.stroke();
  } else {
    tronFillG(col, 0.08);
    g.beginPath(); g.arc(e.x, e.y, R0, 0, Math.PI*2); g.fill();
    tronStrokeG(col, 2, 0.85);
    g.beginPath(); g.arc(e.x, e.y, R0, 0, Math.PI*2); g.stroke();
  }

}else if (b.kind === 'star'){
  tronFillG(col, 0.10);
  starPathG(e.x, e.y, R0, Math.max(4, b.baseN), rot, b.starInner);
  g.fill();
  tronStrokeG(col, 2, 0.85);
  g.stroke();

} else if (b.kind === 'gear'){
  tronFillG(col, 0.10);
  gearPathG(e.x, e.y, R0, b.teeth, rot, b.toothDepth);
  g.fill();
  tronStrokeG(col, 2, 0.85);
  g.stroke();

} else if (b.kind === 'ringRect'){
  const ww = (e.r+22)*b.scale1;
  const hh = (e.r+14)*b.scale1;
  tronFillG(col, 0.10);
  roundedRectPathG(e.x-ww/2, e.y-hh/2, ww, hh, Math.min(16, Math.max(5, b.rr*22)));
  g.fill();
  tronStrokeG(col, 2, 0.85);
  g.stroke();

} else if (b.kind === 'cross'){
  tronFillG(col, 0.10);
  crossPathG(e.x, e.y, R0, rot, b.crossT);
  g.fill();
  tronStrokeG(col, 2, 0.85);
  g.stroke();

} else if (b.kind === 'chevron'){
  tronFillG(col, 0.10);
  chevronPathG(e.x, e.y, R0, rot, b.chevT);
  g.fill();
  tronStrokeG(col, 2, 0.85);
  g.stroke();

} else if (b.kind === 'diamondRing'){
  tronFillG(col, 0.10);
  diamondPathG(e.x, e.y, R0, rot, b.diaSkew);
  g.fill();
  tronStrokeG(col, 2, 0.85);
  g.stroke();
  // inner diamond ring
  tronStrokeG(col, 1, 0.55);
  diamondPathG(e.x, e.y, (e.r+4)*b.scale2, -rot*0.9, 1/b.diaSkew);
  g.stroke();

} else if (b.kind === 'arcSeg'){
  // cyber arc segments: draw a faint disc + segmented ring strokes
  tronFillG(col, 0.08);
  g.beginPath();
  g.arc(e.x,e.y,R0*0.72,0,Math.PI*2);
  g.fill();

  tronStrokeG(col, 2, 0.85);
  for(let i=0;i<b.arcSegs;i++){
    const a0 = rot + i*(Math.PI*2/b.arcSegs) + b.arcGap;
    const a1 = a0 + b.arcSpan;
    g.beginPath();
    g.arc(e.x,e.y,R0, a0, a1);
    g.stroke();
  }

} else if (b.kind === 'insect') {
      // 甲虫型：中间长条，两边大颚
      const w = R0*0.5, h = R0*1.2;
      tronFillG(col, 0.12);
      g.beginPath();
      g.ellipse(e.x, e.y, w, h, rot, 0, Math.PI*2);
      g.fill();
      tronStrokeG(col, 2, 0.9);
      g.stroke();
      // 大颚
      g.beginPath();
      g.moveTo(e.x + Math.cos(rot-0.5)*w, e.y + Math.sin(rot-0.5)*h);
      g.lineTo(e.x + Math.cos(rot-0.8)*w*2.5, e.y + Math.sin(rot-0.8)*h*1.5);
      g.moveTo(e.x + Math.cos(rot+Math.PI+0.5)*w, e.y + Math.sin(rot+Math.PI+0.5)*h);
      g.lineTo(e.x + Math.cos(rot+Math.PI+0.8)*w*2.5, e.y + Math.sin(rot+Math.PI+0.8)*h*1.5);
      g.stroke();
    }
    else if (b.kind === 'wing') {
      // 掠翼型：类似隐形战机
      tronFillG(col, 0.1);
      g.beginPath();
      const front = rot - Math.PI/2; 
      // 鼻锥
      g.moveTo(e.x + Math.cos(front)*R0*1.2, e.y + Math.sin(front)*R0*1.2);
      // 左翼
      g.lineTo(e.x + Math.cos(front + 2.4)*R0*1.5, e.y + Math.sin(front + 2.4)*R0*1.5);
      // 尾部凹陷
      g.lineTo(e.x + Math.cos(front + 3.14)*R0*0.5, e.y + Math.sin(front + 3.14)*R0*0.5);
      // 右翼
      g.lineTo(e.x + Math.cos(front - 2.4)*R0*1.5, e.y + Math.sin(front - 2.4)*R0*1.5);
      g.closePath();
      g.fill();
      tronStrokeG(col, 2, 0.85);
      g.stroke();
    }
    else if (b.kind === 'crystal') {
      // 晶体型：不规则的多边形碎片
      const seedLocal = (e.bodySeed || 0); // 确保有一致的随机性
      const rng = makeRng(seedLocal);
      tronFillG(col, 0.15);
      g.beginPath();
      const points = 5 + (rng()*3|0);
      for(let i=0; i<points; i++){
        const a = (i/points)*Math.PI*2 + rng()*0.5;
        const r = R0 * (0.6 + rng()*0.8);
        const px = e.x + Math.cos(rot + a)*r;
        const py = e.y + Math.sin(rot + a)*r;
        if(i===0) g.moveTo(px,py); else g.lineTo(px,py);
      }
      g.closePath();
      g.fill();
      tronStrokeG(col, 1.5, 0.9);
      g.stroke();
      // 内部核心
      g.beginPath(); g.arc(e.x, e.y, R0*0.3, 0, Math.PI*2); g.stroke();
    }
    else if (['cube', 'pyramid', 'octa', 'prism', 'dodeca'].includes(b.kind)) {
      const t = time * (b.rot1 || 1);
      const size = R0 * (b.kind==='dodeca' ? 0.62 : 0.7);
      drawPoly3DWire(b.kind, e.x, e.y, size, t, col, (b.kind==='octa' || b.kind==='cube' || b.kind==='dodeca'), g);

} else if (b.kind === 'spiral') {
  // 游戏内渲染：几何螺旋
  const arms = Math.max(2, b.spokes);
  const r1 = R0*0.4, r2 = R0*1.0;
  for(let i=0; i<arms; i++){
    const a = rot + i*(Math.PI*2/arms);
    g.beginPath();
    const pts = [{r:R0*0.2, da:0}, {r:r1, da:0.4}, {r:r2, da:0.8}, {r:r1, da:0.6}];
    pts.forEach((p, idx) => {
      const px = e.x + Math.cos(a + p.da)*p.r;
      const py = e.y + Math.sin(a + p.da)*p.r;
      if(idx===0) g.moveTo(px, py); else g.lineTo(px, py);
    });
    g.closePath();
    tronFillG(col, 0.2); tronStrokeG(col, 2, 0.9);
    g.fill(); g.stroke();
  }
  // 核心
  g.beginPath(); g.arc(e.x, e.y, R0*0.25, 0, Math.PI*2); g.stroke();

} else if (b.kind === 'lotus') {
  // 游戏内渲染：4层动态曼陀罗
  const n = Math.max(5, b.baseN || 8);
  const layers = 4;
  
  // 呼吸效果：整体轻微缩放
  const pulse = 1.0 + 0.05 * Math.sin(time * 3);

  for(let i=0; i<layers; i++){
    const t = i / (layers - 1);
    const rLayer = R0 * (1.0 - t * 0.72) * pulse;
    
    // 旋转逻辑：交替加速
    const speedMult = 1.0 + i * 0.8;
    const dir = (i % 2 === 0) ? 1 : -1;
    const rotLayer = rot * speedMult * dir + (i * 0.5);

    // 每一层的样式配置
    if (i === 0) {
      // 外层
      tronStrokeG(col, 2, 0.95);
      polyPathG(e.x, e.y, rLayer, n, rotLayer);
      g.stroke();
    } else if (i === layers - 1) {
      // 核心
      tronFillG(col, 0.5); // 核心亮
      tronStrokeG(col, 2, 1.0);
      polyPathG(e.x, e.y, rLayer, b.innerN || 4, rotLayer);
      g.fill(); g.stroke();
    } else {
      // 中间层
      tronFillG(col, 0.1); 
      tronStrokeG(col, 1.5, 0.6);
      polyPathG(e.x, e.y, rLayer, n, rotLayer);
      g.fill(); g.stroke();
    }
  }
  }else if (b.kind === 'phoenix') {
  // 游戏内渲染：矢量战机
  const wingSpan = R0 * 1.4;
  tronFillG(col, 0.2); tronStrokeG(col, 2, 0.9);
  
  // 机身
  g.beginPath();
  g.moveTo(e.x, e.y - R0*0.8);
  g.lineTo(e.x - R0*0.3, e.y + R0*0.5);
  g.lineTo(e.x, e.y + R0*0.3);
  g.lineTo(e.x + R0*0.3, e.y + R0*0.5);
  g.closePath();
  g.fill(); g.stroke();
  
  // 机翼
  g.beginPath();
  g.moveTo(e.x - R0*0.2, e.y - R0*0.2);
  g.lineTo(e.x - wingSpan, e.y + R0*0.2);
  g.lineTo(e.x - R0*0.4, e.y + R0*0.4);
  
  g.moveTo(e.x + R0*0.2, e.y - R0*0.2);
  g.lineTo(e.x + wingSpan, e.y + R0*0.2);
  g.lineTo(e.x + R0*0.4, e.y + R0*0.4);
  g.stroke();
} else if (b.kind === 'cone') {
  const yaw = Math.sin(time*1.8 + (e.bodySeed||0)*0.00002) * 0.95; // 伪3D自旋
  const dir = rot - Math.PI*0.5;
  const ux = Math.cos(dir), uy = Math.sin(dir);
  const tipX = e.x + ux * R0 * (1.10 + 0.22*Math.cos(yaw));
  const tipY = e.y + uy * R0 * (1.10 + 0.22*Math.cos(yaw));
  const baseCx = e.x - ux * R0 * 0.42;
  const baseCy = e.y - uy * R0 * 0.42;
  const bw = R0 * (0.48 + 0.36*(0.5+0.5*Math.cos(yaw)));
  const bh = R0 * (0.22 + 0.36*(0.5+0.5*Math.sin(yaw*0.8)));

  g.save();
  g.translate(baseCx, baseCy);
  g.rotate(dir + Math.PI*0.5);

  const grd = g.createLinearGradient(0, -bh, 0, -bh - R0*1.8);
  grd.addColorStop(0.0, rgbToRgba(col, 0.22 + 0.18*(0.5+0.5*Math.cos(yaw))));
  grd.addColorStop(0.65, rgbToRgba(col, 0.14));
  grd.addColorStop(1.0, 'rgba(255,255,255,0.02)');

  g.beginPath();
  g.moveTo(0, -R0*(1.45 + 0.25*Math.cos(yaw)));
  g.lineTo(-bw, 0);
  g.lineTo(bw, 0);
  g.closePath();
  g.fillStyle = grd;
  g.fill();

  g.strokeStyle = rgbToRgba(col, 0.88);
  g.lineWidth = 2;
  g.stroke();

  g.beginPath();
  g.moveTo(0, -R0*(1.45 + 0.25*Math.cos(yaw)));
  g.lineTo(0, 0);
  g.moveTo(-bw*0.56, 0);
  g.lineTo(0, -R0*1.0);
  g.moveTo(bw*0.56, 0);
  g.lineTo(0, -R0*1.0);
  g.lineWidth = 1.2;
  g.strokeStyle = rgbToRgba(col, 0.52);
  g.stroke();

  g.beginPath();
  g.ellipse(0, 0, bw, bh, 0, 0, Math.PI*2);
  g.fillStyle = rgbToRgba(col, 0.18 + 0.08*(0.5+0.5*Math.sin(yaw)));
  g.fill();
  g.strokeStyle = rgbToRgba(col, 0.82);
  g.lineWidth = 1.4;
  g.stroke();

  // 前后缘高亮，增强3D翻转感
  g.beginPath();
  g.ellipse(0, 0, bw, bh, 0, yaw>0?Math.PI:0, yaw>0?Math.PI*2:Math.PI);
  g.strokeStyle = rgbToRgba('#ffffff', 0.25);
  g.lineWidth = 1.0;
  g.stroke();

  g.restore();

  g.beginPath();
  g.moveTo(tipX, tipY);
  g.lineTo(baseCx - bw*Math.cos(rot), baseCy - bw*Math.sin(rot));
  g.lineTo(baseCx + bw*Math.cos(rot), baseCy + bw*Math.sin(rot));
  g.closePath();
  tronStrokeG(col, 1.1, 0.28);
  g.stroke();
} else if (b.kind === 'dragon') {
      // 龙形：蛇形身体+翼
      const segments = 4;
      const snakeTime = time * b.rot1;
      
      // 身体
      tronFillG(col, 0.15);
      g.beginPath();
      
      for(let i=0; i<segments; i++){
        const t = i / segments;
        const wave = Math.sin(snakeTime*2 + t*Math.PI*2) * R0*0.3;
        const y = e.y + (t-0.5)*R0*2;
        const x = e.x + wave;
        const r = R0 * (0.8 - t*0.4);
        
        if(i===0) g.moveTo(x-r, y);
        g.lineTo(x-r, y);
        if(i===segments-1) g.lineTo(x+r, y);
      }
      
      for(let i=segments-1; i>=0; i--){
        const t = i / segments;
        const wave = Math.sin(snakeTime*2 + t*Math.PI*2) * R0*0.3;
        const y = e.y + (t-0.5)*R0*2;
        const x = e.x + wave;
        const r = R0 * (0.8 - t*0.4);
        g.lineTo(x+r, y);
      }
      
      g.closePath();
      g.fill();
      tronStrokeG(col, 2, 0.85);
      g.stroke();
      
      // 龙翼
      for(const side of [-1, 1]){
        tronFillG(col, 0.10);
        g.beginPath();
        const wingBase = e.y - R0*0.3;
        g.moveTo(e.x, wingBase);
        g.lineTo(e.x + side*R0*1.2, wingBase - R0*0.5);
        g.lineTo(e.x + side*R0*0.8, wingBase + R0*0.8);
        g.closePath();
        g.fill();
        tronStrokeG(col, 1.5, 0.75);
        g.stroke();
      }

    
    } else if (b.kind === 'nebula') {
      // 星云形：多层半透明云状结构
      const layers = 4;
      const nebulaTime = time * b.rot1 * 0.5;
      
      for(let layer=0; layer<layers; layer++){
        const phase = nebulaTime + layer*0.8;
        const cloudCount = 6 + layer*2;
        const layerRadius = R0 * (0.7 + layer*0.15);
        
        for(let i=0; i<cloudCount; i++){
          const a = phase + (i/cloudCount)*Math.PI*2;
          const r = layerRadius * (0.85 + Math.sin(time*4 + i)*0.15);
          const cloudSize = R0 * (0.3 - layer*0.05);
          
          // 星云气泡
          const cloudAlpha = 0.05 + (layers-layer)*0.03;
          tronFillG(col, cloudAlpha);
          g.beginPath();
          g.arc(
            e.x + Math.cos(a)*r,
            e.y + Math.sin(a)*r,
            cloudSize,
            0, Math.PI*2
          );
          g.fill();
        }
      }
      
      // 星云中心明亮核心
      tronFillG(col, 0.25);
      g.beginPath();
      g.arc(e.x, e.y, R0*0.4, 0, Math.PI*2);
      g.fill();
      
      tronStrokeG(col, 2, 0.9);
      g.beginPath();
      g.arc(e.x, e.y, R0*0.4, 0, Math.PI*2);
      g.stroke();
      
      // 星云粒子点缀
      for(let i=0; i<8; i++){
        const a = time*2 + i;
        const r = R0 * (0.5 + Math.sin(time*3 + i)*0.3);
        g.fillStyle = rgbToRgba(col, 0.6);
        g.fillRect(
          e.x + Math.cos(a)*r - 1,
          e.y + Math.sin(a)*r - 1,
          2, 2
        );
      }

    } else {
  // default convex poly
  tronFillG(col, 0.10);
  polyPathG(e.x,e.y,R0, b.baseN, rot);
  g.fill();
  tronStrokeG(col, 2, 0.85);
  g.stroke();
}
  }

  function drawEnemyGeneric(e){
    const col = e.tint || e.baseCol;
    const b = e.body || genEnemyBody(e.bodySeed || hash32(((e.x*997)|0) ^ ((e.y*313)|0) ^ ((e.r*31)|0) ^ 0x51a23));
    if (!e.body) e.body = b;
    ctx.save();
    if (PERF.additive) ctx.globalCompositeOperation='lighter';

    // outer shape
    // outer shape (cyber body variants incl. concave crescent via even-odd)
const R0 = (e.r+10)*b.scale1;
const rot = Game.time*b.rot1;

drawEnemyGenericBody(ctx, e, b, col, R0, rot, Game.time);

    // inner
    tronStroke(col, 1, 0.55);
    polyPath(e.x,e.y,(e.r+4)*b.scale2, b.innerN, -Game.time*b.rot2);
    ctx.stroke();

    // ring arc
    if (b.ring){
      ctx.globalAlpha = 0.20 + 0.10*Math.sin(Game.time*9 + e.x*0.01);
      tronStroke(col, 2, 0.85);
      ctx.beginPath();
      const a0 = Game.time*0.7;
      const a1 = a0 + Math.PI*(1.1 + 0.6*Math.sin(Game.time*1.5));
      ctx.arc(e.x,e.y,e.r+16, a0, a1);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // spokes
    if (b.spokes>0){
      ctx.globalAlpha = 0.35;
      tronStroke(col, 1, 0.55);
      for(let i=0;i<b.spokes;i++){
        const a = Game.time*0.5 + i*(Math.PI*2/b.spokes);
        ctx.beginPath();
        ctx.moveTo(e.x, e.y);
        ctx.lineTo(e.x + Math.cos(a)*(e.r+14), e.y + Math.sin(a)*(e.r+14));
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    }

    // spikes
    if (b.spikes>0){
      ctx.globalAlpha = 0.30;
      tronStroke(col, 1, 0.65);
      for(let i=0;i<b.spikes;i++){
        const a = Game.time*0.25 + i*(Math.PI*2/b.spikes);
        const r0 = e.r+10;
        const r1 = e.r+18;
        ctx.beginPath();
        ctx.moveTo(e.x + Math.cos(a)*r0, e.y + Math.sin(a)*r0);
        ctx.lineTo(e.x + Math.cos(a+0.10)*r1, e.y + Math.sin(a+0.10)*r1);
        ctx.lineTo(e.x + Math.cos(a+0.20)*r0, e.y + Math.sin(a+0.20)*r0);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    }

    // notch cut (visual)
    if (b.notch){
      ctx.globalAlpha = 0.10;
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.beginPath();
      ctx.moveTo(e.x, e.y);
      ctx.arc(e.x,e.y,e.r+18, Game.time*0.4, Game.time*0.4 + b.cut + 0.6);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // core glow
    drawGlow(Spr.glowE, e.x, e.y, 0.55, 0.95);
    if (e.hit>0) drawGlow(Spr.glowW, e.x, e.y, 0.75, 0.22);

    // shield ring if any
    if (e.shieldHP>0){
      ctx.globalAlpha = 0.18 + 0.10*Math.sin(Game.time*10);
      tronStroke(C.P2, 2, 0.85);
      ctx.beginPath(); ctx.arc(e.x,e.y,e.r+14,0,Math.PI*2); ctx.stroke();
      ctx.globalAlpha = 1;
    }

    ctx.restore();

    // tiny hp bar
    const p = clamp(e.hp/e.maxHp, 0,1);
    const w = e.r*2.2, h=4;
    const x = e.x - w/2, y = e.y + e.r + 12;
    ctx.globalAlpha = 0.40;
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(x,y,w,h);
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = rgbToRgba(col, 0.92);
    ctx.fillRect(x,y,w*p,h);
    ctx.globalAlpha = 1;
  }

  // ================= Emitter System (弹幕组模块化) =================
  // 一个敌人可以带多个 emitters；每个 emitter 内部可以随机叠加 bullet affixes
  function updateEmitters(owner, dt){
    if (!owner.emitters?.length) return;
    for (const em of owner.emitters){
      em.cd -= dt;
      if (em.cd>0) continue;
      em.cd = em.nextCd(owner, dt) * (owner.emCdMul || 1);

      // if boss alive and too many bullets, could throttle (optional)
      em.fire(owner);
    }
  }

    function aimedVel(fromX,fromY,toX,toY, speed, angleOffset){
    const a = Math.atan2(toY-fromY, toX-fromX) + (angleOffset || 0);
    return {vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, a};
  }

  const GenericEnemyCtx = {
  team: 'E',
  _cur: null,   // 当前敌人
  _curEm: null, // [新增] 当前发射器实例
  
  getTarget: () => findEnemyFocus((GenericEnemyCtx._cur?.x)||W*0.5, (GenericEnemyCtx._cur?.y)||0),
  getFireRate: () => 1.0,
  getDmgMul: () => 1.0,
  getLv: () => Game.wave || 1,
  
  // 修改：优先合并“发射器局部词条”和“敌人全局词条”
  getMods() { 
    const local = this._curEm?.mods || []; // 全自动获取当前 Slot 的 mods
    const global = this._cur?.waveBulletMods || []; 
    return mergeMods(local, global); 
  },
  getColor() { return this._cur?.tint || this._cur?.baseCol || C.E1; },
  getAltColor() { return this.getColor() === C.Y ? C.P2 : C.Y; }
};

// 2. 创建新的、全功能的全局 EmitterCatalog
const EmitterCatalog = makeEmitterCatalog(GenericEnemyCtx);

  // ================= Wave Deck (每一波随机敌人原型) =================
  const MoveCatalog = {
    DRIFT: (d)=> {
      const e = baseEnemy('ENEMY', rand(12,18), Math.round(42 + d*7.0), 45);
      e.x=rand(24,W-24); e.y=-40;
      e.vy=rand(70, 105)+d*3.6;
      e.vx=rand(-80,80);
      e.move=(dt)=>{
        e.y += e.vy*dt;
        e.x += e.vx*dt;
        if (e.x<20||e.x>W-20) e.vx*=-1;
      };
      return e;
    },
    HOLD: (d)=> {
      const e = baseEnemy('ENEMY', rand(14,20), Math.round(56 + d*9.0), 70);
      e.x=rand(40,W-40); e.y=-70;
      e.vy=rand(55, 75)+d*2.5;
      e.holdY=rand(H*0.14, H*0.24);
      e.state='in';
      e.move=(dt)=>{
        if (e.state==='in'){
          e.y += e.vy*dt;
          if (e.y>=e.holdY){ e.y=e.holdY; e.state='hold'; }
        }
      };
      return e;
    },
    SWEEP: (d)=> {
      const e = baseEnemy('ENEMY', rand(14,18), Math.round(48 + d*8.0), 68);
      e.y=-45; e.vy=rand(70, 95)+d*2.2;
      e.phase=rand(0,Math.PI*2);
      e.move=(dt)=>{
        e.y += e.vy*dt;
        e.phase += dt*(1.05 + d*0.02);
        e.x = W*0.5 + Math.sin(e.phase)*W*0.30;
      };
      e.x = W*0.5 + Math.sin(e.phase)*W*0.30;
      return e;
    },
    ORBIT: (d)=> {
      const e = baseEnemy('ENEMY', rand(14,18), Math.round(62 + d*10.0), 82);
      e.cx = rand(W*0.25, W*0.75); e.cy = rand(H*0.12, H*0.24);
      e.a = rand(0,Math.PI*2);
      e.radT = rand(40, 95); e.rad = 0;
      e.spd = rand(1.0, 1.8) + d*0.03;
      e.state='enter'; e.y=-40; e.enterV=rand(120, 170); e.enterK = 0;
      e.x = e.cx + Math.cos(e.a) * e.rad;
      e.move = (dt)=>{
        e.a += dt*e.spd;
        e.enterK = clamp(e.enterK + dt*1.6, 0, 1);
        const rr = e.radT * smoothstep(0,1,e.enterK);
        const orbX = e.cx + Math.cos(e.a)*rr;
        const orbY = e.cy + Math.sin(e.a)*rr*0.45;
        if (e.state === 'enter'){
          e.y += e.enterV*dt;
          e.x = lerp(e.x, orbX, 1 - Math.exp(-10*dt));
          const yBlend = smoothstep(0.65, 1.0, e.enterK);
          e.y = lerp(e.y, orbY, yBlend);
          if (e.enterK >= 1 && Math.abs(e.y - orbY) < 1.2){
            e.state = 'orbit'; e.x = e.cx + Math.cos(e.a)*e.radT; e.y = e.cy + Math.sin(e.a)*e.radT*0.45;
          }
          return;
        }
        e.x = e.cx + Math.cos(e.a)*e.radT;
        e.y = e.cy + Math.sin(e.a)*e.radT*0.45;
      };
      return e;
    },
    PHASER: (d)=> {
      const e = baseEnemy('ENEMY', rand(14,18), Math.round(58 + d*9.5), 90);
      e.x=rand(24,W-24); e.y=-40;
      e.vy=rand(85, 125)+d*2.8;
      e.blinkCd=rand(1.2, 2.0);
      e.move=(dt)=>{
        e.y += e.vy*dt;
        e.blinkCd -= dt;
        if (e.blinkCd<=0){
          e.blinkCd = rand(1.35, 2.25)/Math.sqrt(d);
          sparks(e.x,e.y,'glowP2', 12, 420);
          e.x = clamp(e.x + rand(-240, 240), 24, W-24);
          sparks(e.x,e.y,'glowP2', 12, 420);
        }
      };
      return e;
    },
    // --- 新增 ---
    BOUNCE: (d)=>{
      const e = baseEnemy('ENEMY', rand(13,17), Math.round(55 + d*8.5), 65);
      e.x=rand(24,W-24); e.y=-40;
      e.vx=rand(80,140)*(chance(0.5)?1:-1);
      e.vy=rand(60,100)+d*2;
      e.move=(dt)=>{
        e.x+=e.vx*dt; e.y+=e.vy*dt;
        if(e.x<15 || e.x>W-15) e.vx*=-1;
        if(e.y>H*0.4 && e.vy>0) e.vy*=-1; // bounce up once
        if(e.y<H*0.1 && e.vy<0) e.vy*=-1; // bounce down
      };
      return e;
    },
    CHASE: (d)=>{
      const e = baseEnemy('ENEMY', rand(14,18), Math.round(50 + d*8.0), 75);
      e.x=rand(20,W-20); e.y=-50;
      e.move=(dt)=>{
        e.y += (30+d*2)*dt;
        const t = findEnemyFocus(e.x,e.y);
        if (!t) return;
        const dx = t.x - e.x;
        e.x += Math.sign(dx) * Math.min(Math.abs(dx), (45+d*4)*dt);
      };
      return e;
    },
    GRID_SNAP: (d)=>{
      const e = baseEnemy('ENEMY', rand(15,20), Math.round(65 + d*9.5), 85);
      e.x=rand(40,W-40); e.y=-50;
      e.tx=e.x; e.ty=e.y; e.timer=0;
      e.move=(dt)=>{
        e.timer-=dt;
        if(e.timer<=0){
          e.timer=1.2;
          e.tx = clamp(e.x + rand(-80,80), 30, W-30);
          e.ty = clamp(e.y + 60, 0, H*0.6);
        }
        e.x = lerp(e.x, e.tx, dt*4);
        e.y = lerp(e.y, e.ty, dt*4);
      };
      return e;
    },


  // 3) 左右摆动前进（正弦摆动 + 前进）
  SWAY_SINE: (d)=>{
    const e = baseEnemy('ENEMY', rand(14,18), Math.round(52 + d*8.0), 75);
    e._protoMoveKey = 'SWAY_SINE';
    e.y=-50;
    e.vy = rand(70, 105)+d*2.2;
    e._p = rand(0, Math.PI*2);
    e._f = rand(1.2, 2.0) + d*0.02;
    e._a = rand(W*0.16, W*0.28);
    e._cx = rand(W*0.25, W*0.75);
    e.x = e._cx;
    e.move=(dt)=>{
      e.y += e.vy*dt;
      e._p += e._f*dt;
      e.x = clamp(e._cx + Math.sin(e._p)*e._a, 18, W-18);
    };
    return e;
  },

  // 4) 左右摆动前进（“三角波/之字”摆动 + 前进，更硬朗）
  SWAY_ZIG: (d)=>{
    const e = baseEnemy('ENEMY', rand(14,18), Math.round(55 + d*8.5), 80);
    e._protoMoveKey = 'SWAY_ZIG';
    e.x = rand(30,W-30); e.y=-55;
    e.vy = rand(70, 98)+d*2.1;
    e._t=0;
    e._amp = rand(W*0.18, W*0.30);
    e._spd = rand(0.6, 1.0) + d*0.015;
    e._cx = e.x;
    e.move=(dt)=>{
      e.y += e.vy*dt;
      e._t += dt*e._spd;
      // triangle wave in [-1,1]
      const f = e._t - Math.floor(e._t);
      const tri = f<0.5 ? (f*4-1) : (3-4*f);
      e.x = clamp(e._cx + tri*e._amp, 18, W-18);
    };
    return e;
  },

  FIGURE8: (d) => {
    const e = baseEnemy('ENEMY', rand(14, 18), Math.round(62 + d * 9.5), 92);
    e._protoMoveKey = 'FIGURE8';
    e.y = -80;
    e._cy = e.y;               // 虚拟中心 Y 坐标
    e._cx = rand(W * 0.3, W * 0.7); // 虚拟中心 X 坐标
    e.vy = rand(45, 65) + d * 1.5;  // 整体下落速度（降低，让8字更明显）
    e._p = rand(0, Math.PI * 2);
    e._f = rand(1.1, 1.6) + d * 0.02; // 频率
    e._ax = rand(W * 0.2, W * 0.3);   // X 轴振幅
    e._ay = e._ax * 0.5;              // Y 轴振幅（通常为X的一半，比例最美）
    
    e.move = (dt) => {
      e._cy += e.vy * dt; // 只有虚拟中心在下坠
      e._p += e._f * dt;
      // 经典的 8 字公式：x = sin(t), y = sin(2t)
      e.x = e._cx + Math.sin(e._p) * e._ax;
      e.y = e._cy + Math.sin(e._p * 2) * e._ay;
      e.x = clamp(e.x, 18, W - 18);
    };
    return e;
  },

  // 2.  SPIRAL_DOWN：螺旋下落
  SPIRAL_DOWN: (d) => {
    const e = baseEnemy('ENEMY', rand(14, 18), Math.round(58 + d * 9.0), 86);
    e._protoMoveKey = 'SPIRAL_DOWN';
    e.y = -80;
    e._cy = e.y;
    e._p = rand(0, Math.PI * 2);
    e._rad = 0; // 从 0 半径开始扩大的气旋
    e._targetRad = rand(W * 0.15, W * 0.3);
    e._rotSpd = (1.8 + d * 0.05) * (chance(0.5) ? 1 : -1);
    e.vy = rand(60, 90) + d * 2.0;
    
    e.move = (dt) => {
      e._cy += e.vy * dt;
      e._p += e._rotSpd * dt;
      // 半径平滑扩大
      e._rad = lerp(e._rad, e._targetRad, 1 - Math.exp(-0.8 * dt));
      e.x = clamp(W * 0.5 + Math.cos(e._p) * e._rad, 18, W - 18);
      e.y = e._cy + Math.sin(e._p) * (e._rad * 0.3); // Y 轴也有微弱起伏
    };
    return e;
  },

  // 3. DODGE：急闪移动
  DODGE: (d) => {
    const e = baseEnemy('ENEMY', rand(13, 17), Math.round(54 + d * 8.5), 78);
    e._protoMoveKey = 'DODGE';
    e.x = rand(40, W - 40); e.y = -50;
    e.vy = rand(70, 100) + d * 2.5;
    e._vx = 0;
    e._ddCd = rand(0.6, 1.1); // 缩短 CD，闪避更频繁
    
    e.move = (dt) => {
      e.y += e.vy * dt;
      e._ddCd -= dt;
      if (e._ddCd <= 0) {
        e._ddCd = rand(0.8, 1.4) / Math.sqrt(d);
        // 瞬间获得一个巨大的横向冲力
        const t = findEnemyFocus(e.x,e.y);
        const tx = t ? t.x : W*0.5;
        const dir = tx > e.x ? -1 : 1; // 聪明点：倾向于往远离目标的方向闪
        e._vx = dir * (350 + 150 * hellFactor());
      }
      // 物理模拟：强力摩擦力使速度衰减
      e.x += e._vx * dt;
      e._vx *= Math.exp(-4.5 * dt); 
      e.x = clamp(e.x, 18, W - 18);
    };
    return e;
  },

  // 4. 优化 HOVER_DIVE：悬停俯冲（状态切换更平滑）
  HOVER_DIVE: (d) => {
    const e = baseEnemy('ENEMY', rand(15, 19), Math.round(70 + d * 10.0), 105);
    e._protoMoveKey = 'HOVER_DIVE';
    e.x = rand(40, W - 40); e.y = -80;
    e.state = 'enter';
    e._targetY = rand(H * 0.15, H * 0.25);
    e._timer = rand(2.5, 4.0); // 悬停时间
    
    e.move = (dt) => {
      if (e.state === 'enter') {
        // 平滑刹车进入悬停区
        const dy = e._targetY - e.y;
        e.y += dy * 2.5 * dt;
        if (Math.abs(dy) < 5) e.state = 'hover';
      } else if (e.state === 'hover') {
        e._timer -= dt;
        // 悬停时小幅度 8 字漂浮
        e.x += Math.sin(Game.time * 2) * 40 * dt;
        e.y += Math.cos(Game.time * 1.5) * 20 * dt;
        if (e._timer <= 0) e.state = 'dive';
      } else if (e.state === 'dive') {
        // 加速俯冲
        e.vy = lerp(e.vy || 0, 450 + d * 20, 1 - Math.exp(-2 * dt));
        e.y += e.vy * dt;
      }
    };
    return e;
  },

  // 6) 轨道下压（围绕一个下移中心小轨道，同时整体下行）
  ORBIT_DESCENT: (d)=>{
    const e = baseEnemy('ENEMY', rand(14,18), Math.round(60 + d*9.0), 88);
    e._protoMoveKey = 'ORBIT_DESCENT';
    e._cx = rand(W*0.25, W*0.75);
    e._cy = -40;
    e._p = rand(0,Math.PI*2);
    e._rad = rand(50, 110);
    e._rot = (1.0 + d*0.02)*(chance(0.5)?1:-1);
    e.vy = rand(55, 82)+d*2.0;
    e.move=(dt)=>{
      e._cy += e.vy*dt;
      e._p += e._rot*dt;
      e.x = clamp(e._cx + Math.cos(e._p)*e._rad, 18, W-18);
      e.y = e._cy + Math.sin(e._p)*e._rad*0.45;
    };
    e.x=e._cx; e.y=-60;
    return e;
  },

  // 7) 向玩家横向冲刺（短 dash + 前进）
  DASH_LANE: (d)=>{
    const e = baseEnemy('ENEMY', rand(14,18), Math.round(58 + d*9.0), 90);
    e._protoMoveKey = 'DASH_LANE';
    e.x=rand(24,W-24); e.y=-60;
    e.vy = rand(70, 95)+d*2.2;
    e._cd = rand(1.0, 1.6);
    e._dashT = 0;
    e._dvx = 0;
    e.move=(dt)=>{
      e.y += e.vy*dt;

      if (e._dashT>0){
        e._dashT -= dt;
        e.x = clamp(e.x + e._dvx*dt, 18, W-18);
        e._dvx *= Math.exp(-5.0*dt);
        return;
      }

      e._cd -= dt;
      if (e._cd<=0){
        e._cd = rand(1.2, 2.0)/Math.sqrt(d);
        e._dashT = 0.22 + rand(0,0.08);
        const dir = Math.sign((Player.x||W*0.5) - e.x) || (chance(0.5)?1:-1);
        e._dvx = dir*(420 + 140*hellFactor());
      }
    };
    return e;
  },

  // 8) 分车道“跳格”前进（几条固定 lane，定时 snap）
  LANE_SNAP: (d)=>{
    const e = baseEnemy('ENEMY', rand(14,18), Math.round(55 + d*8.5), 82);
    e._protoMoveKey = 'LANE_SNAP';
    e.y=-60;
    e.vy = rand(65, 90)+d*2.0;

    const lanes = 5;
    const xs = Array.from({length:lanes}, (_,i)=> (W*(0.15 + 0.70*(i/(lanes-1)))));
    e.x = xs[randi(0, lanes-1)];

    e._snapCd = rand(0.7, 1.2);
    e._tx = e.x;

    e.move=(dt)=>{
      e.y += e.vy*dt;
      e._snapCd -= dt;
      if (e._snapCd<=0){
        e._snapCd = rand(0.75, 1.35)/Math.sqrt(d);
        // prefer near player lane
        const px = Player.x || W*0.5;
        let best=0, bestD=1e9;
        for(let i=0;i<lanes;i++){
          const dd = Math.abs(xs[i]-px);
          if (dd<bestD){ bestD=dd; best=i; }
        }
        // sometimes pick adjacent
        const pick = clamp(best + randi(-1,1), 0, lanes-1);
        e._tx = xs[pick];
      }
      e.x = lerp(e.x, e._tx, 1 - Math.exp(-8*dt));
      e.x = clamp(e.x, 18, W-18);
    };
    return e;
  },

  // 9) 轻量瞬移闪避前进（小幅 x shift，继续下行）
  SHIFT_TELE: (d)=>{
    const e = baseEnemy('ENEMY', rand(14,18), Math.round(58 + d*9.0), 92);
    e._protoMoveKey = 'SHIFT_TELE';
    e.x=rand(24,W-24); e.y=-60;
    e.vy = rand(70, 95)+d*2.3;
    e._cd = rand(1.1, 1.8);
    e.move=(dt)=>{
      e.y += e.vy*dt;
      e._cd -= dt;
      if (e._cd<=0){
        e._cd = rand(1.25, 2.0)/Math.sqrt(d);
        const nx = clamp(e.x + rand(-220,220), 24, W-24);
        e.x = nx;
      }
      e.x = clamp(e.x, 18, W-18);
    };
    return e;
  },


    // 特性：滞留在屏幕上方，利用势场法自动躲避子弹，不修改外观，可被随机生成
    SMART_EVADER: (d)=>{
      // 1. 初始化基础数值 (血量略高，因为需要长期存活)
      const e = baseEnemy('ENEMY', rand(14,18), Math.round(65 + d*9.0), 125);
      e._protoMoveKey = 'SMART_EVADER';
      
      // 2. 初始位置 (屏幕上方外)
      e.x = rand(40, W-40); 
      e.y = -60;
      
      // 3. 滞留目标参数
      // 随机选择一个悬停高度区间 (屏幕上 1/5 到 1/3 处)
      e._hoverY = rand(H*0.15, H*0.35); 
      e._hoverPhase = rand(0, Math.PI*2); // 悬停时的上下浮动相位
      
      // 4. 物理状态
      e.vx = 0;
      e._targetVx = 0;
      
      // 5. AI 核心参数
      const SENSOR_RANGE = 260;      // 感知半径
      const REACTION_TIME = 0.55;    // 反应时间窗
      const MAX_SPEED = 360 + d*10;  // 最大横移速度 (随难度微增)
      const WALL_PAD = 40;           // 墙壁斥力阈值
      const CENTER_BIAS = 80;        // 安全时的回中力 (防止一直贴墙)

      e.move = (dt)=>{
        // --- A. 垂直运动 (滞留逻辑) ---
        // 使用阻尼逼近目标高度，并在目标高度附近做正弦浮动
        const bobbing = Math.sin(Game.time * 2.5 + e._hoverPhase) * 25;
        const targetY = e._hoverY + bobbing;
        
        // 简单的 P 控制器：向目标高度移动
        const dy = targetY - e.y;
        e.y += dy * 3.0 * dt; // 3.0 是垂直跟随速度系数

        // --- B. 水平运动 (势场规避逻辑) ---
        let forceX = 0;
        let dangerDetected = false;

        // B1. 墙壁斥力 (Wall Repulsion)
        const distL = e.x;
        const distR = W - e.x;
        
        // 靠近墙壁时产生强烈的反向推力
        if (distL < WALL_PAD * 2) forceX += (1.0 / (distL*distL + 1)) * 120000;
        if (distR < WALL_PAD * 2) forceX -= (1.0 / (distR*distR + 1)) * 120000;

        // B2. 子弹轨迹势场 (Bullet Repulsion)
        // 适配 SpatialGrid (补丁 Q) 或回退到全遍历
        let potentials = bulletsP;
        if (typeof SpatialGrid !== 'undefined') {
           // 简单起见，仍遍历全表进行距离剔除（子弹数少，且不用创建新数组）
           potentials = bulletsP; 
        }

        for (const b of potentials) {
          if (!b.alive) continue;
          
          // 粗略距离剔除
          const dx = e.x - b.x;
          const dy = e.y - b.y;
          // 只关心正在接近的子弹 (y轴方向接近)
          // 敌人上方是负，下方是正。子弹通常向上飞 (vy < 0)。
          // 如果子弹在敌人下方(dy > 0)且向上飞，则有威胁。
          if (Math.abs(dx) > SENSOR_RANGE || Math.abs(dy) > SENSOR_RANGE) continue;

          // 相对速度预测
          const relVx = b.vx - e.vx; 
          const relVy = b.vy; // 假设敌人垂直不动来简化计算
          
          // 只有当子弹在垂直方向上正在接近时才计算
          // (relVy * dy) > 0 意味着都在同向，即正在远离。我们需要 < 0
          if (relVy * dy > 0) continue;

          const timeToImpact = Math.abs(dy / relVy);
          if (timeToImpact > REACTION_TIME) continue;

          // 预测横向撞击点
          const impactX = b.x + b.vx * timeToImpact;
          const myFutureX = e.x + e.vx * timeToImpact;
          const missDist = impactX - myFutureX;
          
          // 判定碰撞威胁 (排斥场半径)
          const safeZone = e.r + b.r + 25; 
          
          if (Math.abs(missDist) < safeZone) {
            dangerDetected = true;
            
            // 势场力计算
            // 越近(timeToImpact小)力越大，预测越准(missDist小)力越大
            const urgency = 1.0 / (timeToImpact + 0.05);
            const proximity = 1.0 / (Math.abs(missDist) + 1.0);
            
            // 方向：推向相反方向
            const dir = missDist < 0 ? 1 : -1; 
            
            forceX += dir * urgency * proximity * 8000;
          }
        }

        // B3. 安全时的回中偏置 (Center Bias)
        // 如果没有危险，给一个微弱的力让它慢慢回到屏幕中间区域
        // 这样避免它躲完子弹后一直傻傻地贴在墙边
        if (!dangerDetected) {
           const centerDist = (W/2) - e.x;
           forceX += centerDist * CENTER_BIAS;
           
           // 随机微动 (Perlin noise like)，让它看起来更有生物感
           forceX += Math.sin(Game.time * 3 + e.bodySeed) * 500; 
        }

        // --- C. 物理执行 ---
        let targetVx = clamp(forceX, -MAX_SPEED, MAX_SPEED);
        
        // 惯性平滑：危险时反应极快(10)，平时反应从容(3)
        const inertia = dangerDetected ? 10.0 : 3.0;
        e.vx = lerp(e.vx, targetVx, inertia * dt);
        
        // 应用位移
        e.x = clamp(e.x + e.vx * dt, 18, W-18);
      };
      
      // 注意：这里移除了 applyEnemyTraits 和 drawWrapper
      // 保持纯粹的逻辑，让 Spawner 决定它的外观和额外属性
      
      return e;
    },
  };

function attachMoveMixer(e, d, initialKey){
  e.mmx = {
    mode: initialKey,
    nextT: rand(1.8, 3.2),
    vx: 0, vy: 80 + d*3.0, // 速度积分器
    ghost: null,      // 虚拟实体
    ghostMode: null,  // 当前幽灵运行的模式
    driftVx: rand(-90,90),
    driftVy: rand(70,110)+d*2.6,
    sweepPhase: rand(0,Math.PI*2),
    sweepAmp: W*(0.22 + rand(0,0.12)),
    sweepVy: rand(70,95)+d*2.2,
    chaseVy: 28 + d*2.2,
    snapT: 0, tx: e.x, ty: e.y,
    holdY: rand(H*0.14, H*0.24), holdVx: rand(-70,70),
    ocx: e.x, ocy: clamp(e.y, H*0.12, H*0.26),
    oa: 0, orad: 0, oradT: rand(40,95),
    ospd: (chance(0.5)?-1:1) * (1.0 + rand(0,0.9)),
    dashCd: rand(0.8, 1.6), dashT: 0, dashFromX: e.x, dashToX: e.x,
    forceExit: false, exitK: 0,
  };

  mmxInitOrbitFromHere(e);

  e.move = (dt)=>{
    const m = e.mmx;

    // 自动切换逻辑
    m.nextT -= dt;
    if (m.nextT<=0){
      m.nextT = rand(1.9, 3.4) * (Game.wave<6 ? 1.25 : 1.0);
      mmxMaybeSwitch(e, d);
    }

    // 计算目标速度
    const des = mmxDesiredVel(e, dt, d);

    // 平滑插值 (避免切换模式时瞬移或鬼畜)
    const k = 1 - Math.exp(-9*dt);
    m.vx = lerp(m.vx, des.vx, k);
    m.vy = lerp(m.vy, des.vy, k);

    e.x = clamp(e.x + m.vx*dt, 16, W-16);
    e.y = e.y + m.vy*dt;
  };
}
function mmxInitOrbitFromHere(e){
  const m = e.mmx;
  // pick orbit center near current position to avoid large shifts
  m.ocx = clamp(e.x + rand(-90,90), W*0.20, W*0.80);
  m.ocy = clamp(e.y + rand(-40,40), H*0.12, H*0.26);

  // derive angle/radius from current position so first orbit target matches current
  const dx = e.x - m.ocx;
  const dy = (e.y - m.ocy) / 0.45;
  m.oa = Math.atan2(dy, dx);
  m.orad = Math.max(0, Math.hypot(dx, dy));
  m.exitK = 0;
  m.forceExit = false;
}

function mmxDesiredVel(e, dt, d){
  const m = e.mmx;
  
  // 辅助函数：以一定力度追踪目标点
  const seek = (tx,ty, gain=6.0, maxV=260)=>{
    const vx = clamp((tx - e.x)*gain, -maxV, maxV);
    const vy = clamp((ty - e.y)*gain, -maxV, maxV);
    return {vx,vy};
  };

  // --- 处理退出状态 (Orbit/Hold) ---
  if ((m.mode==='ORBIT' || m.mode==='HOLD') && m.forceExit){
    m.exitK = clamp(m.exitK + dt*1.2, 0, 1);
  } else {
    m.exitK = clamp(m.exitK - dt*1.4, 0, 1);
  }

  // --- 优先处理 MoveMixer 内置的特化逻辑 (性能稍好) ---
  if (m.mode==='DRIFT'){
    if (e.x<18) m.driftVx = Math.abs(m.driftVx);
    if (e.x>W-18) m.driftVx = -Math.abs(m.driftVx);
    return {vx:m.driftVx, vy:m.driftVy};
  }
  if (m.mode==='SWEEP'){
    m.sweepPhase += dt*(1.05 + d*0.02);
    const tx = W*0.5 + Math.sin(m.sweepPhase)*m.sweepAmp;
    const sv = seek(tx, e.y, 5.5, 260);
    return {vx:sv.vx, vy:m.sweepVy};
  }
  if (m.mode==='CHASE'){
    const dx = (Player.x||W*0.5) - e.x;
    const vx = clamp(Math.sign(dx) * (70 + d*5), -220, 220);
    return {vx, vy:m.chaseVy};
  }
  if (m.mode==='BOUNCE'){
    if (e.x<15 || e.x>W-15) m.driftVx *= -1;
    if (e.y>H*0.42 && m.driftVy>0) m.driftVy *= -1;
    if (e.y<H*0.10 && m.driftVy<0) m.driftVy *= -1;
    return {vx: clamp(m.driftVx, -220,220), vy: clamp(m.driftVy, -220,220)};
  }
  if (m.mode==='ORBIT'){ // MoveMixer 内置的 Orbit 逻辑比较特殊（为了平滑退出），保留
    const hf = hellFactor();
    m.oa += dt*m.ospd*(1.0 + 0.10*hf);
    const rt = lerp(m.oradT, 0, m.exitK);
    m.orad = lerp(m.orad, rt, 1 - Math.exp(-3.0*dt));
    const tx = m.ocx + Math.cos(m.oa)*m.orad;
    const ty = m.ocy + Math.sin(m.oa)*m.orad*0.45 + (m.exitK>0 ? 80*m.exitK : 0);
    const sv = seek(tx, ty, 10.0, 360);
    return {vx:sv.vx, vy:sv.vy};
  }

  
  // 1. 如果当前模式对应的幽灵不存在，或者模式切换了，就创建一个新的
  if (!m.ghost || m.ghostMode !== m.mode) {
    if (MoveCatalog[m.mode]) {
      // 实例化原生的移动逻辑控制器
      m.ghost = MoveCatalog[m.mode](d); 
      m.ghostMode = m.mode;
      
      m.ghost.x = e.x;
      m.ghost.y = e.y;
      
      // 赋予幽灵必要的属性 (比如 SMART_EVADER 需要 radius)
      m.ghost.r = e.r; 
      m.ghost.vx = m.vx; // 继承速度惯性
      m.ghost.vy = m.vy;
    } else {
      // 如果模式名根本不存在（比如拼写错误），回退到下落
      return {vx:0, vy:80 + d*3.0};
    }
  }

  // 2. 运行幽灵的一帧逻辑
  const g = m.ghost;
  if (!Number.isFinite(g.x)) g.x = e.x;
  if (!Number.isFinite(g.y)) g.y = e.y;

  const startX = g.x;
  const startY = g.y;

  // 让幽灵在“平行世界”里走一步
  g.move(dt);

  // 幽灵异常时，立即回退到稳定速度，防止 NaN 扩散到实体坐标
  if (!Number.isFinite(g.x) || !Number.isFinite(g.y)){
    g.x = e.x;
    g.y = e.y;
    return {vx: Number.isFinite(m.vx) ? m.vx : 0, vy: Math.max(50, Number.isFinite(m.vy) ? m.vy : (80 + d*3.0))};
  }

  // 3. 逆向计算速度 (Velocity Inference)
  // 既然我们知道幽灵从 A 走到了 B，那么需要的速度就是 (B-A)/dt
  const safeDt = Math.max(dt, 0.001); // 防止除以零
  const targetVx = (g.x - startX) / (safeDt*3);
  const targetVy = (g.y - startY) / (safeDt*3);

  return {
    vx: Number.isFinite(targetVx) ? targetVx : 0,
    vy: Number.isFinite(targetVy) ? targetVy : (80 + d*3.0)
  };
}

function mmxMaybeSwitch(e, d){
  const m = e.mmx;
  
  // --- 新逻辑：优先使用指定的“播放列表” ---
  if (Array.isArray(m.availableModes) && m.availableModes.length > 1) {
    const currentIndex = m.availableModes.indexOf(m.mode);
    // 循环切换到下一个模式
    const nextIndex = (currentIndex + 1) % m.availableModes.length;
    const nextMode = m.availableModes[nextIndex];

    // 为平滑切换做准备（与旧逻辑相同）
    if (nextMode === 'ORBIT') mmxInitOrbitFromHere(e);
    if (nextMode === 'HOLD'){
      m.holdY = clamp(e.y, H*0.14, H*0.28);
      m.forceExit = false;
      m.exitK = 0;
    }
    if (nextMode !== 'ORBIT' && nextMode !== 'HOLD'){
      m.forceExit = false;
      m.exitK = 0;
    }
    m.mode = nextMode;
    return; // 完成切换，退出函数
  }

  // --- 旧的随机切换逻辑，作为没有指定列表时的后备方案 ---
  const w = Game.wave;
  const allowHover = (w>=4) && (countHoverers() < 3);

  const pool = [];
  pool.push(['DRIFT', 3.0]);
  pool.push(['SWEEP', 2.2]);
  if(w>=4) pool.push(['CHASE', 1.8]);
  if(w>=5) pool.push(['GRID_SNAP', 1.2]);
  if(w>=6) pool.push(['PHASER', 1.1]);
  if(allowHover){
    pool.push(['HOLD', 1.6]);
    pool.push(['ORBIT', 1.4]);
  }

  const cur = m.mode;
  let sum=0;
  for(const [,wt] of pool) sum += wt;
  let r = Math.random()*sum;

  let pick = cur;
  for(const [k,wt] of pool){ r -= wt; if (r<=0){ pick=k; break; } }
  if (pick === cur && pool.length>2){
    pick = pool[randi(0,pool.length-1)][0];
  }

  if (pick === 'ORBIT') mmxInitOrbitFromHere(e);
  if (pick === 'HOLD'){
    m.holdY = clamp(e.y, H*0.14, H*0.28);
    m.forceExit = false;
    m.exitK = 0;
  }
  if (pick !== 'ORBIT' && pick !== 'HOLD'){
    m.forceExit = false;
    m.exitK = 0;
  }

  m.mode = pick;
}

function countHoverers(){
  let n=0;
  for(const e of enemies){
    if (!e.alive || e.type==='BOSS' || !e.mmx) continue;
    if (e.mmx.mode==='ORBIT' || e.mmx.mode==='HOLD'){
      // consider as hoverer when within upper area
      if (e.y < H*0.38 && !e.mmx.forceExit) n++;
    }
  }
  return n;
}

function enemyColor(e){ return e.tint || e.baseCol || C.E1; }

function wrapDraw(e, wrapper){
  const old = e.draw?.bind(e) || (()=>{});
  e.draw = ()=>wrapper(old);
}

function spawnEnemyCoreFromSpecs(spec, d){
  // 确保 moveKey/moveKeys 存在且合法
  const moveKeys = (Array.isArray(spec.moveKeys) && spec.moveKeys.length > 0)
    ? spec.moveKeys
    : [spec.moveKey || 'DRIFT'];
  const initialMoveKey = moveKeys[0];
  
  // 使用第一个移动模式来创建基础敌人实例
  const e = MoveCatalog[initialMoveKey](d);
  
  e.emCdMul = (e.emCdMul || 1.0) * DiffConfig.fireCdMul;

  e.baseCol = spec.baseCol;
  e.tint = spec.tint || null;
  e.bodySeed = (spec.bodySeed ^ randi(0, 1e9))|0;
  e.body = genEnemyBody(e.bodySeed);
  e.waveBulletMods = spec.waveBulletMods || [];
  
  // 记录原型信息，以便克隆或提取
  e._protoMoveKeys = moveKeys; // 存储完整的移动模式列表
  e._protoMoveKey = initialMoveKey;

  e.emitters = (spec.emitters||[]).map(em => {
    let instance;
    if (em.type === '_COMPOSITE' && em._compositeInstance) {
      instance = em._compositeInstance;
    } else {
      const factory = EmitterCatalog[em.type];
      instance = factory ? factory(em.cfg || {}) : EmitterCatalog.AIM(em.cfg||{});
    }

    
    
    return instance;
  });

  // --- 核心修正：只有在需要时才附加和配置混合器 ---
  if (moveKeys.length > 1) {
    // 调用混合器，它会覆盖 e.move
    attachMoveMixer(e, d, initialMoveKey);
    // 把移动模式“播放列表”交给混合器
    if (e.mmx) {
      e.mmx.availableModes = moveKeys;
    }
  }
  
  return e;
}


  const EnemyFactory = {
    spawnFromProto(proto, d){
      const moveKeys = (Array.isArray(proto.moveKeys) && proto.moveKeys.length) ? proto.moveKeys : [proto.moveKey||'DRIFT'];
      const e = MoveCatalog[moveKeys[0]](d);
      e.baseCol = proto.baseCol;
      e.body = genEnemyBody(proto.bodySeed ^ ((e.x*1000)|0) ^ ((e.y*1000)|0));
      e.emitters = proto.emitters.map(em => {
        if (em.type === '_COMPOSITE' && em._compositeInstance) return em._compositeInstance;
        return EmitterCatalog[em.type]?.(em.cfg) ?? EmitterCatalog.AIM(em.cfg||{});
      });
      // keep proto specs for cloning / orbiter, etc.
e._protoMoveKey = moveKeys[0];
e._protoMoveKeys = moveKeys;
e._protoEmitters = proto.emitters;
e._protoWaveBulletMods = proto.waveBulletMods;
e._protoBodySeed = proto.bodySeed;
e._protoBaseCol = proto.baseCol;

      // wave-level bullet mods pack for this enemy (applied by emitters if cfg.mods not set)
      e.waveBulletMods = proto.waveBulletMods;
     
attachMoveMixer(e, d, moveKeys[0]);
if (e.mmx) e.mmx.availableModes = moveKeys;

      // apply traits
      applyEnemyTraits(e, proto.traitsForced, d);
      // extra cosmetic style (doesn't consume normal slots)
if (chance(0.75)){
  const styleKeys = Object.keys(EnemyTraitCatalog).filter(k => EnemyTraitCatalog[k].group==='style' && (EnemyTraitCatalog[k].minWave||1)<=Game.wave);
  if (styleKeys.length){
    const pick = styleKeys[randi(0, styleKeys.length-1)];
    EnemyTraitCatalog[pick].apply(e, d);
  }
}

      // random extra traits
      const ctx = {d, proto};
      let traitCount=0, forceChampion=false, groupCaps=null;
      for(const stage of EnemyTraitFilters){
        const out = stage(ctx) || {};
        if (out.traitCount!=null) traitCount = out.traitCount;
        if (out.forceChampion!=null) forceChampion = out.forceChampion;
        if (out.groupCaps!=null) groupCaps = out.groupCaps;
      }
      const extra = pickEnemyTraits(forceChampion, traitCount, [], groupCaps);
      applyEnemyTraits(e, extra, d);

      return e;
    }
  };
  
  
  const CompositeWrappers = {

    // 同时朝多方向发射同一 emitter
    MULTI_DIR(baseFactory, cfg={}){
      const dirs       = cfg.dirs ?? 3;
      const spreadMode = cfg.spreadMode ?? 'even';
      const baseEm     = baseFactory(cfg.baseCfg || cfg);
      function angles(){
        if (spreadMode === 'front'){
          const sp = 0.8;
          return Array.from({length:dirs}, (_,i)=> (i/(dirs-1)-0.5)*sp);
        }
        if (spreadMode === 'sides'){
          const o = [0];
          for(let i=1;i<dirs;i++) o.push(i%2===1 ? Math.PI*0.5 : -Math.PI*0.5);
          return o.slice(0,dirs);
        }
        return Array.from({length:dirs}, (_,i)=> i*(Math.PI*2/dirs));
      }
      return {
        type:`MULTI_DIR<${baseEm.type||'?'}>`, _baseType:baseEm.type,
        _composite:'MULTI_DIR', _base:baseEm,
        cd: baseEm.cd * 1.15,
        nextCd(o,dt){ return (baseEm.nextCd?.(o,dt) ?? 1) * 1.15; },
        fire(owner){
          const prevOffset = owner?._emitAngleOffset || 0;
          for(const a of angles()){
            owner._emitAngleOffset = prevOffset + a;
            baseEm.fire(owner);
          }
          owner._emitAngleOffset = prevOffset;
        }
      };
    },

    // 子母弹：母弹死亡/延时后释放 child emitter 的弹
    CHILD_BURST(baseFactory, cfg={}){
      const childType  = cfg.childType  ?? 'RING';
      const childCfg   = cfg.childCfg   ?? {};
      const childDelay = cfg.childDelay  ?? 0;
      const baseEm     = baseFactory(cfg.baseCfg || cfg);
      return {
        type:`CHILD_BURST<${baseEm.type||'?'},${childType}>`, _baseType:baseEm.type,
        _composite:'CHILD_BURST', _childType:childType, _base:baseEm,
        cd: baseEm.cd * 1.25,
        nextCd(o,dt){ return (baseEm.nextCd?.(o,dt) ?? 1) * 1.25; },
        fire(owner){
          const beforeP = bulletsP.length;
          const beforeE = bulletsE.length;
          baseEm.fire(owner);
          for(const arr of [bulletsP, bulletsE]){
            const before = (arr === bulletsP) ? beforeP : beforeE;
            for(let i=before;i<arr.length;i++){
              const b = arr[i];
              if (!b?.alive) continue;
              if (childDelay > 0){
                b.mineT = childDelay;
              } else if (!b.mods.includes('_CHILD_BURST')){
                b.mods.push('_CHILD_BURST');
              }
              b._childBurstType  = childType;
              b._childBurstCfg   = childCfg;
              b._childBurstOwner = owner;
            }
          }
        }
      };
    },

    // 时间上交错两种 emitter（A B A B …）
    INTERLEAVE(factoryA, cfg={}){
      if (!cfg.factoryB) return factoryA(cfg.baseCfg || cfg);
      const emA = factoryA(cfg.baseCfgA || cfg.baseCfg || cfg);
      const emB = cfg.factoryB(cfg.baseCfgB || cfg.baseCfg || cfg);
      const pattern = cfg.pattern ?? [0,1];
      const phaseCd = cfg.phaseCd ?? null;
      let step = 0;
      return {
        type:`INTERLEAVE<${emA.type||'?'},${emB.type||'?'}>`, _baseType:emA.type,
        _composite:'INTERLEAVE', _emA:emA, _emB:emB, _pattern:pattern,
        cd: Math.min(emA.cd, emB.cd),
        nextCd(o,dt){
          const em = pattern[step%pattern.length]===0 ? emA : emB;
          return phaseCd ?? (em.nextCd?.(o,dt) ?? 1);
        },
        fire(owner){
          (pattern[step%pattern.length]===0 ? emA : emB).fire(owner);
          step++;
        }
      };
    },

    // 快速连发 N 次
    SALVO(baseFactory, cfg={}){
      const count    = cfg.salvoCount    ?? 3;
      const interval = cfg.salvoInterval ?? 0.08;
      const baseEm   = baseFactory(cfg.baseCfg || cfg);
      const em = {
        type:`SALVO<${baseEm.type||'?'},${count}>`, _baseType:baseEm.type,
        _composite:'SALVO', _base:baseEm, _count:count, _interval:interval,
        _queue:0,
        cd: baseEm.cd * 1.4,
        nextCd(o,dt){
          if (em._queue>0) return interval;
          return (baseEm.nextCd?.(o,dt) ?? 1) * 1.4;
        },
        fire(owner){
          if (em._queue<=0) em._queue = count - 1;
          else em._queue--;
          baseEm.fire(owner);
        }
      };
      return em;
    },

    // 左右镜像发射
    MIRROR(baseFactory, cfg={}){
      const offset = cfg.mirrorOffset ?? 28;
      const baseEm = baseFactory(cfg.baseCfg || cfg);
      return {
        type:`MIRROR<${baseEm.type||'?'}>`, _baseType:baseEm.type,
        _composite:'MIRROR', _base:baseEm,
        cd: baseEm.cd * 1.1,
        nextCd(o,dt){ return (baseEm.nextCd?.(o,dt) ?? 1) * 1.1; },
        fire(owner){
      if (!owner) return;
      const ox = owner.x;
      owner.x = clamp(ox - offset, 16, W-16); 
      baseEm.fire(owner);
      owner.x = clamp(ox + offset, 16, W-16); 
      baseEm.fire(owner);
      owner.x = ox;
    }
      };
    },

    // 发射方向随时间左右扫描
    ROTATE_SWEEP(baseFactory, cfg={}){
  const speed = cfg.sweepSpeed ?? 1.2;
  const arc   = cfg.sweepArc   ?? Math.PI*0.6;
  const baseEm = baseFactory(cfg.baseCfg || cfg);
  return {
    type:`ROTATE_SWEEP<${baseEm.type||'?'}>`, _baseType:baseEm.type,
    _composite:'ROTATE_SWEEP', _base:baseEm,
    cd: baseEm.cd,
    nextCd(o,dt){ return baseEm.nextCd?.(o,dt) ?? 1; },
    fire(owner){
      if (!owner) return;
      const prevOffset = owner._emitAngleOffset || 0;
      const sweepPhase = Game.time * speed;
      owner._emitAngleOffset = prevOffset + Math.sin(sweepPhase)*arc;
      baseEm.fire(owner);
      owner._emitAngleOffset = prevOffset;
    }
  };
},

    // 子弹先停顿再加速
    DELAYED_WAVE(baseFactory, cfg={}){
      const pause = cfg.pauseDur ?? 0.35;
      const baseEm = baseFactory(cfg.baseCfg || cfg);
      return {
        type:`DELAYED_WAVE<${baseEm.type||'?'}>`, _baseType:baseEm.type,
        _composite:'DELAYED_WAVE', _base:baseEm,
        cd: baseEm.cd,
        nextCd(o,dt){ return baseEm.nextCd?.(o,dt) ?? 1; },
        fire(owner){
          const beforeP = bulletsP.length;
          const beforeE = bulletsE.length;
          baseEm.fire(owner);
          for(const arr of [bulletsP, bulletsE]){
            const before = (arr === bulletsP) ? beforeP : beforeE;
            for(let i=before;i<arr.length;i++){
              const b = arr[i];
              if (!b?.alive) continue;
              b.pauseT = pause;
              b.accel  = (b.accel||0) + 180;
            }
          }
        }
      };
    },
    
        // 渐进扇形：每次射击扇形角度递增然后重置
    WIDENING_FAN(baseFactory, cfg={}){
  const maxSpread = cfg.maxSpread ?? Math.PI * 0.8;
  const steps     = cfg.steps ?? 5;
  const baseEm    = baseFactory(cfg.baseCfg || cfg);
  let step = 0;
  return {
    type:`WIDENING_FAN<${baseEm.type||'?'}>`, _baseType:baseEm.type,
    _composite:'WIDENING_FAN', _base:baseEm,
    cd: baseEm.cd * 0.85,
    nextCd(o,dt){ return (baseEm.nextCd?.(o,dt) ?? 1) * 0.85; },
    fire(owner){
      if (!owner) return;
      const prevOffset = owner._emitAngleOffset || 0;
      const k = step / Math.max(1, steps - 1);
      const spread = 0.12 + k * maxSpread;
      owner._emitAngleOffset = prevOffset - spread * 0.5;
      baseEm.fire(owner);
      owner._emitAngleOffset = prevOffset + spread * 0.5;
      baseEm.fire(owner);
      owner._emitAngleOffset = prevOffset;
      step = (step + 1) % steps;
    }
  };
},

    // 螺旋多臂：N条螺旋臂同时旋转发射
    SPIRAL_ARMS(baseFactory, cfg={}){
  const arms    = cfg.arms ?? 3;
  const rotSpeed = cfg.rotSpeed ?? 1.5;
  const baseEm  = baseFactory(cfg.baseCfg || cfg);
  let phase = 0;
  return {
    type:`SPIRAL_ARMS<${baseEm.type||'?'},${arms}>`, _baseType:baseEm.type,
    _composite:'SPIRAL_ARMS', _base:baseEm,
    cd: baseEm.cd * 0.7,
    nextCd(o,dt){ 
      phase += (dt||0.016)*rotSpeed; 
      return (baseEm.nextCd?.(o,dt) ?? 1) * 0.7; 
    },
    fire(owner){
      if (!owner) return;
      const prevOffset = owner._emitAngleOffset || 0;
      for(let i=0;i<arms;i++){
        owner._emitAngleOffset = prevOffset + phase + i*(Math.PI*2/arms);
        baseEm.fire(owner);
      }
      owner._emitAngleOffset = prevOffset;
    }
  };
},

    // 交替镜像：奇数次向左偏，偶数次向右偏
    ALTERNATING(baseFactory, cfg={}){
      const offset = cfg.altOffset ?? 0.45;
      const baseEm = baseFactory(cfg.baseCfg || cfg);
      let tick = 0;
      return {
        type:`ALTERNATING<${baseEm.type||'?'}>`, _baseType:baseEm.type,
        _composite:'ALTERNATING', _base:baseEm,
        cd: baseEm.cd,
        nextCd(o,dt){ return baseEm.nextCd?.(o,dt) ?? 1; },
        fire(owner){
          if (!owner) return;
          const prevOffset = owner._emitAngleOffset || 0;
          owner._emitAngleOffset = prevOffset + (tick%2===0 ? offset : -offset);
          baseEm.fire(owner);
          owner._emitAngleOffset = prevOffset;
          tick++;
        }
      };
    },

    // 层叠环：快速连续发射多个半径递增的环
    STACKED_RING(baseFactory, cfg={}){
      const layers   = cfg.layers ?? 3;
      const interval = cfg.layerInterval ?? 0.12;
      const baseEm   = baseFactory(cfg.baseCfg || cfg);
      const em = {
        type:`STACKED_RING<${baseEm.type||'?'},${layers}>`, _baseType:baseEm.type,
        _composite:'STACKED_RING', _base:baseEm,
        _queue:0, _queueTimer:0,
        cd: baseEm.cd * 1.6,
        nextCd(o,dt){
          if (em._queue>0) return interval;
          return (baseEm.nextCd?.(o,dt) ?? 1) * 1.6;
        },
        fire(owner){
          const prevOffset = owner?._emitAngleOffset || 0;
          if (em._queue<=0) em._queue = layers - 1;
          else em._queue--;
          // 每层角度偏移制造旋转感
          owner._emitAngleOffset = prevOffset + em._queue * 0.18;
          baseEm.fire(owner);
          owner._emitAngleOffset = prevOffset;
        }
      };
      return em;
    },

    // 瞄准散射：朝目标方向密集散射
    FOCUSED_SCATTER(baseFactory, cfg={}){
      const count  = cfg.scatterCount ?? 7;
      const spread = cfg.scatterSpread ?? 0.55;
      const baseEm = baseFactory(cfg.baseCfg || cfg);
      return {
        type:`FOCUSED_SCATTER<${baseEm.type||'?'}>`, _baseType:baseEm.type,
        _composite:'FOCUSED_SCATTER', _base:baseEm,
        cd: baseEm.cd * 1.3,
        nextCd(o,dt){ return (baseEm.nextCd?.(o,dt) ?? 1) * 1.3; },
        fire(owner){
          const prevOffset = owner?._emitAngleOffset || 0;
          for(let i=0;i<count;i++){
            owner._emitAngleOffset = prevOffset + (Math.random()-0.5) * spread;
            baseEm.fire(owner);
          }
          owner._emitAngleOffset = prevOffset;
        }
      };
    },

    // 回旋：发射后子弹先前进再倒飞回来
    BOOMERANG_WRAP(baseFactory, cfg={}){
      const reverseAt = cfg.reverseAt ?? 2.5;
      const baseEm = baseFactory(cfg.baseCfg || cfg);
      return {
        type:`BOOMERANG_WRAP<${baseEm.type||'?'}>`, _baseType:baseEm.type,
        _composite:'BOOMERANG_WRAP', _base:baseEm,
        cd: baseEm.cd * 1.15,
        nextCd(o,dt){ return (baseEm.nextCd?.(o,dt) ?? 1) * 1.15; },
        fire(owner){
          const beforeP = bulletsP.length;
          const beforeE = bulletsE.length;
          baseEm.fire(owner);
          // 检查两个数组中新增的子弹
          for(const arr of [bulletsP, bulletsE]){
            const before = (arr === bulletsP) ? beforeP : beforeE;
            for(let i=before;i<arr.length;i++){
              const b = arr[i];
              if (!b?.alive) continue;
              const rt = reverseAt + rand(-0.08, 0.08);
              b.reverseT = rt;
              b.life = Math.max(b.life, rt * 2 + 1.2);
            }
          }
        }
      };
    },

    // 加速波：子弹先慢后快
    ACCEL_WAVE(baseFactory, cfg={}){
      const accelVal = cfg.accelVal ?? 280;
      const baseEm = baseFactory(cfg.baseCfg || cfg);
      return {
        type:`ACCEL_WAVE<${baseEm.type||'?'}>`, _baseType:baseEm.type,
        _composite:'ACCEL_WAVE', _base:baseEm,
        cd: baseEm.cd,
        nextCd(o,dt){ return baseEm.nextCd?.(o,dt) ?? 1; },
        fire(owner){
          const beforeP = bulletsP.length;
          const beforeE = bulletsE.length;
          baseEm.fire(owner);
          for(const arr of [bulletsP, bulletsE]){
            const before = (arr === bulletsP) ? beforeP : beforeE;
            for(let i=before;i<arr.length;i++){
              const b = arr[i];
              if (!b?.alive) continue;
              b.vx *= 0.35; b.vy *= 0.35;
              b.accel = (b.accel||0) + accelVal;
            }
          }
        }
      };
    },

    // 双螺旋：两条反向旋转的螺旋同时发射
    DOUBLE_HELIX(baseFactory, cfg={}){
      const rotSpeed = cfg.helixSpeed ?? 2.0;
      const baseEm = baseFactory(cfg.baseCfg || cfg);
      let phase = 0;
      return {
        type:`DOUBLE_HELIX<${baseEm.type||'?'}>`, _baseType:baseEm.type,
        _composite:'DOUBLE_HELIX', _base:baseEm,
        cd: baseEm.cd * 0.75,
        nextCd(o,dt){ phase += (dt||0.016)*rotSpeed; return (baseEm.nextCd?.(o,dt) ?? 1) * 0.75; },
        fire(owner){
          const prevOffset = owner?._emitAngleOffset || 0;
          const beforeP = bulletsP.length;
          const beforeE = bulletsE.length;

          // 螺旋臂 A：正相位偏移
          owner._emitAngleOffset = prevOffset + Math.sin(phase) * 0.45;
          baseEm.fire(owner);
          // 螺旋臂 B：反相位偏移（对称，不加 PI）
          owner._emitAngleOffset = prevOffset - Math.sin(phase) * 0.45;
          baseEm.fire(owner);
          owner._emitAngleOffset = prevOffset;

          // 给新生成的子弹加上螺旋运动属性
          for(const arr of [bulletsP, bulletsE]){
            const before = (arr === bulletsP) ? beforeP : beforeE;
            const half = before + Math.floor((arr.length - before) / 2);
            for(let i=before;i<arr.length;i++){
              const b = arr[i];
              if (!b?.alive) continue;
              const isArmA = (i < half);
              // 用 waveA/waveF 实现正弦横向摆动，两臂反相 → DNA 双螺旋
              b.angVel = 0;  // 不用 angVel 弯曲方向，保持直飞
              b.waveA  = 28 + rotSpeed * 12;
              b.waveF  = rotSpeed * 2.8;
              b.waveP  = isArmA ? phase : phase + Math.PI;  // 反相
            }
          }
        }
      };
    },
    // 星穹礼赞：显著多层旋涡花冠（强烈旋转+摆动+二段加速）
    CELESTIAL_CROWN(baseFactory, cfg={}){
      const petals = cfg.petals ?? 10;
      const spin = cfg.spinSpeed ?? 2.8;
      const baseEm = baseFactory(cfg.baseCfg || cfg);
      let phase = 0;
      return {
        type:`CELESTIAL_CROWN<${baseEm.type||'?'},${petals}>`, _baseType:baseEm.type,
        _composite:'CELESTIAL_CROWN', _base:baseEm,
        cd: baseEm.cd * 1.9,
        nextCd(o,dt){ phase += (dt||0.016) * spin; return (baseEm.nextCd?.(o,dt) ?? 1) * 1.9; },
        fire(owner){
          const prevOffset = owner?._emitAngleOffset || 0;
          const beforeP = bulletsP.length, beforeE = bulletsE.length;
          for (let ring=0; ring<3; ring++){
            const off = ring * (Math.PI/petals);
            const per = petals - ring;
            for (let i=0;i<per;i++){
              owner._emitAngleOffset = prevOffset + phase + off + i * (Math.PI*2/per);
              baseEm.fire(owner);
            }
          }
          owner._emitAngleOffset = prevOffset;
          for(const arr of [bulletsP, bulletsE]){
            const before = (arr===bulletsP)?beforeP:beforeE;
            for(let i=before;i<arr.length;i++){
              const b = arr[i]; if(!b?.alive) continue;
              const side = (i-before)%2===0 ? 1 : -1;
              b.angVel = (b.angVel||0) + side*(1.8 + Math.random()*0.8);
              b.waveA = Math.max(b.waveA||0, 42);
              b.waveF = Math.max(b.waveF||0, 7.4);
              b.pauseT = Math.max(b.pauseT||0, 0.12);
              b.accel = (b.accel||0) + 220;
              b.life = Math.max(b.life||1.8, 3.1);
            }
          }
        }
      };
    },

    // 天罚长矛：超宽扇区双次齐射，明显延迟后爆发突刺
    TIDAL_LANCE(baseFactory, cfg={}){
      const lanes = cfg.lanes ?? 7;
      const arc = cfg.arc ?? 1.15;
      const accel = cfg.accel ?? 360;
      const baseEm = baseFactory(cfg.baseCfg || cfg);
      let tick = 0;
      return {
        type:`TIDAL_LANCE<${baseEm.type||'?'},${lanes}>`, _baseType:baseEm.type,
        _composite:'TIDAL_LANCE', _base:baseEm,
        cd: baseEm.cd * 1.55,
        nextCd(o,dt){ return (baseEm.nextCd?.(o,dt) ?? 1) * 1.55; },
        fire(owner){
          const prevOffset = owner?._emitAngleOffset || 0;
          const beforeP = bulletsP.length, beforeE = bulletsE.length;
          for (let wave=0; wave<2; wave++){
            for (let i=0;i<lanes;i++){
              const t = lanes<=1 ? 0 : (i/(lanes-1)-0.5);
              owner._emitAngleOffset = prevOffset + t * arc + (wave?0.14:-0.14) + Math.sin(tick*0.9)*0.08;
              baseEm.fire(owner);
            }
          }
          owner._emitAngleOffset = prevOffset;
          tick++;
          for(const arr of [bulletsP, bulletsE]){
            const before = (arr===bulletsP)?beforeP:beforeE;
            for(let i=before;i<arr.length;i++){
              const b = arr[i]; if(!b?.alive) continue;
              b.pauseT = Math.max(b.pauseT||0, 0.18);
              b.accel = (b.accel||0) + accel;
              b.waveA = Math.max(b.waveA||0, 28);
              b.waveF = Math.max(b.waveF||0, 6.2);
              b.angVel = (b.angVel||0) + (((i-before)%3)-1)*0.7;
              b.life = Math.max(b.life||1.8, 3.0);
            }
          }
        }
      };
    },
  };
  
  

  // ------ B.3 组合规则（控制哪些 wrapper+base 有意义） ------
  const CompositionRules = {
    rules:[
      // MULTI_DIR
      { wrapper:'MULTI_DIR', bases:['AIM','FAN','SHOTGUN'], weight:1.2, minWave:6, tags:['geometric'],
        cfgGen:(b,d,hf)=>({ dirs:chance(0.6)?3:(chance(0.5)?4:2), spreadMode:chance(0.5)?'even':'front' }) },
      { wrapper:'MULTI_DIR', bases:['SPIRAL'], weight:0.9, minWave:8, tags:['geometric','dense'],
        cfgGen:(b,d,hf)=>({ dirs:2+(hf>0.5?1:0), spreadMode:'even' }) },

      // CHILD_BURST
      { wrapper:'CHILD_BURST', bases:['AIM','FAN','CROSS'], weight:0.85, minWave:8, tags:['layered'],
        cfgGen:(b,d,hf)=>({ childType:chance(0.5)?'RING':'FAN',
          childCfg:{baseCd:2.0,speed:170+d*5,count:6+Math.round(4*hf)},
          childDelay:chance(0.4)?(0.5+rand(0,0.4)):0 }) },
      { wrapper:'CHILD_BURST', bases:['RING'], weight:0.65, minWave:10, tags:['layered','dense'],
        cfgGen:(b,d,hf)=>({ childType:'SPIRAL',
          childCfg:{baseCd:0.5,speed:160+d*4}, childDelay:0.6+rand(0,0.3) }) },

      // INTERLEAVE
      { wrapper:'INTERLEAVE', bases:['AIM','FAN'], weight:1.0, minWave:5, tags:['rhythmic'],
        secondBases:['RING','CROSS','SHOTGUN'],
        cfgGen:(b,d,hf,sb)=>({ factoryB:EmitterCatalog[sb],
          pattern:chance(0.5)?[0,1]:[0,0,1],
          baseCfgA:{baseCd:lerp(1.4,0.85,hf)}, baseCfgB:{baseCd:lerp(1.8,1.1,hf)} }) },
      { wrapper:'INTERLEAVE', bases:['SPIRAL'], weight:0.8, minWave:7, tags:['rhythmic'],
        secondBases:['RING','MINE'],
        cfgGen:(b,d,hf,sb)=>({ factoryB:EmitterCatalog[sb], pattern:[0,0,0,1] }) },

      // SALVO
      { wrapper:'SALVO', bases:['AIM','FAN','SHOTGUN','CROSS'], weight:0.95, minWave:6, tags:['burst'],
        cfgGen:(b,d,hf)=>({ salvoCount:2+(hf>0.6?1:0), salvoInterval:lerp(0.12,0.06,hf) }) },

      // MIRROR
      { wrapper:'MIRROR', bases:['AIM','FAN','SPIRAL','FLOWER'], weight:0.85, minWave:7, tags:['geometric'],
        cfgGen:(b,d,hf)=>({ mirrorOffset:24+randi(0,18) }) },

      // ROTATE_SWEEP
      { wrapper:'ROTATE_SWEEP', bases:['AIM','FAN','SHOTGUN'], weight:0.9, minWave:6, tags:['sweep'],
        cfgGen:(b,d,hf)=>({ sweepSpeed:0.8+0.6*hf, sweepArc:Math.PI*(0.3+0.4*hf) }) },

      // DELAYED_WAVE
      { wrapper:'DELAYED_WAVE', bases:['RING','CROSS','FAN'], weight:0.75, minWave:7, tags:['rhythmic'],
        cfgGen:(b,d,hf)=>({ pauseDur:0.25+0.20*hf }) },

      // 复合：MIRROR + SALVO
      { wrapper:'MIRROR', bases:['AIM','FAN'], weight:0.45, minWave:10,
        tags:['compound','dense'], compound:'SALVO',
        cfgGen:(b,d,hf)=>({ mirrorOffset:30 }),
        compoundCfgGen:(b,d,hf)=>({ salvoCount:2, salvoInterval:0.09 }) },

      // 复合：MULTI_DIR + DELAYED_WAVE
      { wrapper:'MULTI_DIR', bases:['FAN','CROSS'], weight:0.40, minWave:11,
        tags:['compound','dense'], compound:'DELAYED_WAVE',
        cfgGen:(b,d,hf)=>({ dirs:3, spreadMode:'even' }),
        compoundCfgGen:(b,d,hf)=>({ pauseDur:0.30 }) },
        
      // WIDENING_FAN
      { wrapper:'WIDENING_FAN', bases:['AIM','FAN','SHOTGUN'], weight:1.0, minWave:1,
        cfgGen:(b,d,hf)=>({ maxSpread:Math.PI*(0.3+0.5*hf), steps:3+Math.round(3*hf) }) },

      // SPIRAL_ARMS
      { wrapper:'SPIRAL_ARMS', bases:['AIM','FAN'], weight:0.9, minWave:1,
        cfgGen:(b,d,hf)=>({ arms:2+Math.round(2*hf), rotSpeed:1.0+1.2*hf }) },
      { wrapper:'SPIRAL_ARMS', bases:['RING'], weight:0.6, minWave:3,
        cfgGen:(b,d,hf)=>({ arms:2, rotSpeed:0.8+0.8*hf }) },

      // ALTERNATING
      { wrapper:'ALTERNATING', bases:['AIM','FAN','SHOTGUN','CROSS'], weight:1.1, minWave:1,
        cfgGen:(b,d,hf)=>({ altOffset:0.25+0.45*hf }) },

      // STACKED_RING
      { wrapper:'STACKED_RING', bases:['RING','CROSS'], weight:0.7, minWave:2,
        cfgGen:(b,d,hf)=>({ layers:2+(hf>0.5?1:0), layerInterval:lerp(0.16,0.08,hf) }) },

      // FOCUSED_SCATTER
      { wrapper:'FOCUSED_SCATTER', bases:['AIM','SHOTGUN'], weight:0.85, minWave:1,
        cfgGen:(b,d,hf)=>({ scatterCount:4+Math.round(4*hf), scatterSpread:0.35+0.45*hf }) },

      // BOOMERANG_WRAP
      { wrapper:'BOOMERANG_WRAP', bases:['AIM','FAN','CROSS'], weight:0.75, minWave:2,
        cfgGen:(b,d,hf)=>({ reverseAt:0.45+0.25*hf }) },

      // ACCEL_WAVE
      { wrapper:'ACCEL_WAVE', bases:['RING','FAN','CROSS','SPIRAL'], weight:0.90, minWave:1,
        cfgGen:(b,d,hf)=>({ accelVal:180+160*hf }) },

      // DOUBLE_HELIX
      { wrapper:'DOUBLE_HELIX', bases:['AIM','FAN'], weight:0.80, minWave:2,
        cfgGen:(b,d,hf)=>({ helixSpeed:1.2+1.5*hf }) },
      { wrapper:'DOUBLE_HELIX', bases:['SPIRAL'], weight:0.55, minWave:4,
        cfgGen:(b,d,hf)=>({ helixSpeed:0.8+1.0*hf }) },

      // ===== 复合（wrapper 套 wrapper） =====
      // SPIRAL_ARMS + DELAYED_WAVE
      { wrapper:'SPIRAL_ARMS', bases:['FAN','CROSS'], weight:0.35, minWave:5,
        tags:['compound','dense'], compound:'DELAYED_WAVE',
        cfgGen:(b,d,hf)=>({ arms:3, rotSpeed:1.0+0.8*hf }),
        compoundCfgGen:(b,d,hf)=>({ pauseDur:0.28 }) },

      // DOUBLE_HELIX + SALVO
      { wrapper:'DOUBLE_HELIX', bases:['AIM','FAN'], weight:0.30, minWave:6,
        tags:['compound','dense'], compound:'SALVO',
        cfgGen:(b,d,hf)=>({ helixSpeed:1.5+1.0*hf }),
        compoundCfgGen:(b,d,hf)=>({ salvoCount:2, salvoInterval:0.08 }) },

      // WIDENING_FAN + MIRROR
      { wrapper:'WIDENING_FAN', bases:['AIM','SHOTGUN'], weight:0.32, minWave:5,
        tags:['compound'], compound:'MIRROR',
        cfgGen:(b,d,hf)=>({ maxSpread:Math.PI*0.6, steps:4 }),
        compoundCfgGen:(b,d,hf)=>({ mirrorOffset:26 }) },

      // STACKED_RING + ACCEL_WAVE
      { wrapper:'STACKED_RING', bases:['RING'], weight:0.28, minWave:4,
        tags:['compound','dense'], compound:'ACCEL_WAVE',
        cfgGen:(b,d,hf)=>({ layers:3, layerInterval:0.10 }),
        compoundCfgGen:(b,d,hf)=>({ accelVal:220+120*hf }) },
        
              // ============= 新词条协同规则 =============

      // BOOMERANG_WRAP + 分裂词条 → 回旋分裂走廊
      // 这条规则让 rollComposite 更倾向于给带分裂 mods 的 emitter 配 BOOMERANG
      { wrapper:'BOOMERANG_WRAP', bases:['AIM','FAN','SPIRAL'], weight:0.85, minWave:6,
        tags:['synergy'],
        cfgGen:(b,d,hf)=>({ reverseAt: 0.50 + 0.20*hf }) },

      // SPIRAL_ARMS + RESONANCE 协同：螺旋臂飞行中释放小环
      { wrapper:'SPIRAL_ARMS', bases:['AIM','CROSS'], weight:0.70, minWave:7,
        tags:['synergy','dense'],
        cfgGen:(b,d,hf)=>({ arms: 2 + (hf>0.5?1:0), rotSpeed: 1.0+1.0*hf }) },

      // DOUBLE_HELIX + REFRACT 协同：双螺旋命中后折射出弧线碎片
      { wrapper:'DOUBLE_HELIX', bases:['AIM','FAN','SHOTGUN'], weight:0.65, minWave:8,
        tags:['synergy'],
        cfgGen:(b,d,hf)=>({ helixSpeed: 1.4+1.2*hf }) },

      // ACCEL_WAVE + RESONANCE 协同：加速弹沿途释放越来越快的环
      { wrapper:'ACCEL_WAVE', bases:['AIM','FAN','SPIRAL'], weight:0.75, minWave:5,
        tags:['synergy'],
        cfgGen:(b,d,hf)=>({ accelVal: 200+140*hf }) },

      // DELAYED_WAVE + PHASE_SHIFT 协同：暂停隐形突然出现
      { wrapper:'DELAYED_WAVE', bases:['RING','FAN','CROSS'], weight:0.65, minWave:5,
        tags:['synergy'],
        cfgGen:(b,d,hf)=>({ pauseDur: 0.30+0.15*hf }) },

      // MULTI_DIR + SYMPATHETIC 协同：多方向弹互相增益
      { wrapper:'MULTI_DIR', bases:['AIM','FAN'], weight:0.60, minWave:7,
        tags:['synergy','dense'],
        cfgGen:(b,d,hf)=>({ dirs: 3+(hf>0.6?1:0), spreadMode:'even' }) },

      // MIRROR + ECHO 协同：镜像弹死亡回响形成呼吸弹幕
      { wrapper:'MIRROR', bases:['AIM','FAN','CROSS'], weight:0.60, minWave:8,
        tags:['synergy'],
        cfgGen:(b,d,hf)=>({ mirrorOffset: 26+randi(0,14) }) },

      // SALVO + CASCADE + 分裂 复合：连发弹级联分裂
      { wrapper:'SALVO', bases:['AIM','FAN','SHOTGUN'], weight:0.40, minWave:10,
        tags:['synergy','compound'], compound:'BOOMERANG_WRAP',
        cfgGen:(b,d,hf)=>({ salvoCount: 2+(hf>0.5?1:0), salvoInterval: 0.08 }),
        compoundCfgGen:(b,d,hf)=>({ reverseAt: 0.45+0.15*hf }) },

      // STACKED_RING + DELAYED_WAVE 复合：层叠环暂停后同时释放
      { wrapper:'STACKED_RING', bases:['RING','CROSS'], weight:0.35, minWave:7,
        tags:['synergy','compound'], compound:'DELAYED_WAVE',
        cfgGen:(b,d,hf)=>({ layers: 2+(hf>0.5?1:0), layerInterval: 0.10 }),
        compoundCfgGen:(b,d,hf)=>({ pauseDur: 0.25+0.10*hf }) },

      // WIDENING_FAN + ACCEL_WAVE 复合：渐宽扇形加速波
      { wrapper:'WIDENING_FAN', bases:['AIM','FAN'], weight:0.38, minWave:6,
        tags:['synergy','compound'], compound:'ACCEL_WAVE',
        cfgGen:(b,d,hf)=>({ maxSpread: Math.PI*(0.4+0.4*hf), steps: 3+Math.round(2*hf) }),
        compoundCfgGen:(b,d,hf)=>({ accelVal: 200+120*hf }) },

      // SPIRAL_ARMS + BOOMERANG_WRAP 复合：螺旋臂回旋
      { wrapper:'SPIRAL_ARMS', bases:['AIM','FAN'], weight:0.32, minWave:8,
        tags:['synergy','compound','dense'], compound:'BOOMERANG_WRAP',
        cfgGen:(b,d,hf)=>({ arms: 2+(hf>0.6?1:0), rotSpeed: 1.0+0.8*hf }),
        compoundCfgGen:(b,d,hf)=>({ reverseAt: 0.50+0.15*hf }) },

      // DOUBLE_HELIX + DELAYED_WAVE 复合：双螺旋暂停后加速
      { wrapper:'DOUBLE_HELIX', bases:['AIM','FAN'], weight:0.30, minWave:8,
        tags:['synergy','compound'], compound:'DELAYED_WAVE',
        cfgGen:(b,d,hf)=>({ helixSpeed: 1.3+1.0*hf }),
        compoundCfgGen:(b,d,hf)=>({ pauseDur: 0.28 }) },
    ],

    // 按权重随机抽取一条规则并构建 composite emitter
    rollComposite(wave, d){
      const hf = hellFactor();
      const pool = this.rules.map(r => {
  let w = r.weight || 1;
  const minW = r.minWave || 1;
  if (wave < minW) w *= Math.max(0.05, wave / minW);
  if (r.tags?.includes('compound') && wave < 6) w *= 0.15;
  if (r.tags?.includes('dense') && wave < 4) w *= 0.25;
  // 协同规则在高波次权重提升，鼓励涌现式组合
  if (r.tags?.includes('synergy')){
    w *= (wave >= 10) ? 1.35 : (wave >= 7) ? 1.15 : 0.85;
  }
  return { rule:r, w };
}).filter(x => x.w > 0.01);
      if (!pool.length) return null;

            let sum = 0;
      for(const x of pool) sum += x.w;
      let roll = Math.random() * sum;
      let picked = pool[0].rule;
      for(const x of pool){ roll -= x.w; if(roll<=0){ picked=x.rule; break; } }

      const base = picked.bases[randi(0, picked.bases.length-1)];
      const baseFactory = EmitterCatalog[base];
      if (!baseFactory) return null;

      let secondBase = null;
      if (picked.secondBases?.length)
        secondBase = picked.secondBases[randi(0, picked.secondBases.length-1)];

      const cfg = picked.cfgGen(base, d, hf, secondBase);
      const wrapperFn = CompositeWrappers[picked.wrapper];
      if (!wrapperFn) return null;

      // 复合包装（wrapper 套 wrapper）
      if (picked.compound && CompositeWrappers[picked.compound]){
        const innerFn  = CompositeWrappers[picked.compound];
        const innerCfg = picked.compoundCfgGen?.(base,d,hf) || {};
        const innerFactory = (bc) => innerFn(baseFactory, Object.assign({}, innerCfg, {baseCfg:bc}));
        return wrapperFn(innerFactory, cfg);
      }

      return wrapperFn(baseFactory, cfg);
    },

    describe(em){
      if (!em?._composite) return em?.type || '?';
      let s = em._composite;
      if (em._base?._composite) s += '(' + this.describe(em._base) + ')';
      else s += '(' + (em._baseType || '?') + ')';
      if (em._childType) s += '→' + em._childType;
      if (em._emA && em._emB) s += `[${em._emA.type}/${em._emB.type}]`;
      return s;
    }
  };
  

  const WaveDirector = {
    wave:1,
    deck:[],
    liteDeck:[],
    onWave(w){
      this.wave = w;
      this.deck.length = 0;
      this.liteDeck.length = 0;

      const hf = hellFactor();

      // 每波生成 N 个原型
      const size = clamp(2 + Math.floor(w/3), 2, 8);
      const liteSize = clamp(2 + Math.floor(w/5), 2, 5);

      const moveKeys = Object.keys(MoveCatalog);
      const emitterTypes = Object.keys(EmitterCatalog);

      // wave-level bullet affixes pack（作为“本波弹幕风味”）
      const baseModsCount = (w<8?1:(w<14?2:3));
const waveBulletMods = (w<4) ? [] : rollAffixes({
  wave:w, 
  maxCount: baseModsCount + DiffConfig.extraAffix
});

      // forced enemy traits (small chance)
      const forcedTraits = [];
      if (w>=4 && chance(0.22)) forcedTraits.push('FAST');
      if (w>=6 && chance(0.18)) forcedTraits.push('ARMORED');
      if (w>=7 && chance(0.14)) forcedTraits.push('SHIELD_LAYER');
      if (w>=8 && chance(0.10)) forcedTraits.push('REGEN');
      if (w>=8 && chance(0.08)) forcedTraits.push('AURA_SLOW');

      const colPool = [C.E1, C.E2, C.E3, C.E4, C.E5, C.E6, C.E7, C.Y];
      const pickCol = ()=> colPool[randi(0,colPool.length-1)];

      function emitterPick(w){
        // wave gating: early very simple
        if (w<=2) return 'AIM';
        if (w<=4) return chance(0.65)?'AIM':'FAN';
        if (w<=6) return chance(0.50)?'FAN':(chance(0.6)?'AIM':'RING');
        if (w<=8) return chance(0.30)?'SHOTGUN':(chance(0.5)?'RING':(chance(0.5)?'FAN':'SPIRAL'));
        if (w<=10) return chance(0.25)?'MINE':(chance(0.4)?'CROSS':'SPIRAL');
        
        const roll = Math.random();
        if(roll<0.10) return 'LASER';
        if(roll<0.20) return 'FLOWER';
        if(roll<0.32) return 'SHOTGUN';
        if(roll<0.44) return 'CROSS';
        if(roll<0.56) return 'RING';
        if(roll<0.68) return 'SPIRAL';
        if(roll<0.80) return 'EMPYREAN_LANCE';
        if(roll<0.92) return 'CELESTIAL_CORONA';
        return chance(0.5)?'NOVA_PULSE':'DRAGON_BREATH';
      }

      function rollEmitterMods(w, type){
  const max = (w<4?0:(w<8?1:(w<14?2:3)));
  if (!max) return [];
  const forbid = new Set(['_internal']);  // ← 加上 _internal
  if (w<10) forbid.add('timerfx');
  if (type==='LASER') return [];
  return rollAffixes({wave:w, maxCount:max, forbidTags:forbid});
}

      function makeEmitterCfg(type, w){
        const hf = hellFactor();
        const baseCol = pickCol();
        const d = Game.difficulty;
        
        if (type==='AIM') return {type, cfg:{baseCd: lerp(1.35, 0.85, hf), speed: 220 + d*6, col: baseCol, spr:'glowE', r:2.9}};
        if (type==='FAN') return {type, cfg:{baseCd: lerp(1.55, 0.95, hf), speed: 230 + d*6, col: baseCol, spr:'glowE2', r:2.8, count: (w<4?3:(4+Math.round(3*hf))), spread: 0.55+0.55*hf}};
        if (type==='RING') return {type, cfg:{baseCd: lerp(2.8, 1.5, hf), speed: 175 + d*6, col: baseCol, spr:'glowE2', r:2.6, count: 8+Math.round(10*hf)}};
        if (type==='SPIRAL') return {type, cfg:{baseCd: lerp(0.90, 0.32, hf), speed: 190 + d*7 + 55*hf, col: baseCol, spr:'glowE3', r:2.6, step: 0.30+0.35*hf}};
        if (type==='MINE') return {type, cfg:{baseCd: lerp(3.2, 2.0, hf), col: baseCol, spr:'glowE3'}};
        if (type==='LASER') return {type, cfg:{baseCd: lerp(3.8, 2.4, hf)}};
        
        // --- 新增 ---
        if (type==='CROSS') return {type, cfg:{baseCd: lerp(1.8, 1.0, hf), speed: 200 + d*5, col: baseCol}};
        if (type==='SHOTGUN') return {type, cfg:{baseCd: lerp(2.2, 1.2, hf), col: baseCol}};
        if (type==='FLOWER') return {type, cfg:{col: baseCol}};
        if (type==='EMPYREAN_LANCE') return {type, cfg:{baseCd: lerp(2.1, 1.2, hf), speed: 300 + d*7, col: baseCol, spr:'glowE6'}};
        if (type==='CELESTIAL_CORONA') return {type, cfg:{baseCd: lerp(2.8, 1.6, hf), speed: 250 + d*6, col: baseCol, spr:'glowE7'}};
        if (type==='NOVA_PULSE') return {type, cfg:{baseCd: lerp(2.4, 1.4, hf), col: baseCol, spr:'glowE5'}};
        if (type==='DRAGON_BREATH') return {type, cfg:{baseCd: lerp(1.9, 1.1, hf), speed: 280 + d*8, col: baseCol, spr:'glowE6'}};

        return {type:'AIM', cfg:{baseCd:1.2, col:baseCol}};
      }

      function mkProto(isLite=false){
  const moveKeysSource = Object.keys(MoveCatalog);
  const baseCol = pickCol();
  const bodySeed = (w*2654435761) ^ randi(0, 1e9);

  // --- 核心改动：生成 moveKeys 数组 ---
  let moveKeys = [];
  // 高波数下有概率生成多移动模式的敌人
  if (!isLite && w >= 8 && chance(0.35)) {
    const count = (w < 15) ? 2 : (chance(0.6) ? 2 : 3);
    // 从一个兼容的池子里随机选择，避免 SMART_EVADER 和简单 DRIFT 混用
    const compatiblePool = ['DRIFT', 'SWEEP', 'DODGE', 'SWAY_SINE', 'SWAY_ZIG', 'LANE_SNAP'];
    while(moveKeys.length < count && compatiblePool.length > 0) {
      const idx = randi(0, compatiblePool.length - 1);
      moveKeys.push(compatiblePool.splice(idx, 1)[0]);
    }
  }
  
  // 如果没有生成多模式，或者这是个lite敌人，就只选一个
  if (moveKeys.length === 0) {
    moveKeys.push(moveKeysSource[randi(0, moveKeysSource.length-1)]);
  }

  const protoWaveMods = (isLite?[]:waveBulletMods);
  const protoBulletMods = mergeMods(protoWaveMods, []);

  const emCount = isLite ? 1 : (w<6 ? 1 : (w<12 ? (chance(0.55)?1:2) : (chance(0.35)?2:3)));

  const emitters = [];
  for(let i=0;i<emCount;i++){
    const t = emitterPick(w);
    const em = makeEmitterCfg(t, w);
    const emMods = rollEmitterMods(w, t);
    em.cfg.mods = mergeMods(protoBulletMods, emMods);
    emitters.push(em);
  }

  const hpMul = (w<4 ? 1.55 : (w<8 ? 1.35 : 1.22)) * (1 + w*0.018);
  const scoreMul = 1.0;
  const traitsForced = Array.from(new Set(forcedTraits.filter(()=>chance(0.45))));

  return {
    // 传递 moveKeys 数组
    moveKeys: moveKeys,
    moveKey: moveKeys[0], // 第一个作为初始模式
    baseCol, bodySeed,
    waveBulletMods: protoBulletMods,
    emitters,
    traitsForced,
    hpMul, scoreMul
  };
}

      for(let i=0;i<size;i++) this.deck.push(mkProto(false));
      for(let i=0;i<liteSize;i++) this.liteDeck.push(mkProto(true));
      const compositeChance = (w<2) ? 0.04 : (w<4) ? 0.10 : (w<6) ? 0.18 : (w<9) ? 0.28 : (w<13) ? 0.38 : 0.52;
      for(const proto of this.deck){
        if (!proto.emitters?.length || !chance(compositeChance)) continue;
        const idx = randi(0, proto.emitters.length - 1);
        const comp = CompositionRules.rollComposite(w, Game.difficulty);
        if (comp){
          proto.emitters[idx] = { type:'_COMPOSITE', _compositeInstance:comp, cfg:proto.emitters[idx].cfg||{} };
        }
      }
      // 给拥有 composite 的 proto 额外概率获得协同词条
for (const proto of this.deck){
  if (!proto.emitters?.some(e => e.type === '_COMPOSITE')) continue;
  // 有 composite 的 proto，30% 概率额外获得一个 stat 类协同词条
  if (!chance(0.30)) continue;
  const synergy = ['CASCADE','SYMPATHETIC','INHERIT_BOOST','PHASE_SHIFT'];
  const pick = synergy[randi(0, synergy.length-1)];
  if (!proto.waveBulletMods.includes(pick) && proto.waveBulletMods.length < 5){
    proto.waveBulletMods.push(pick);
    // 同步到所有 emitter 的 mods
    for (const em of proto.emitters){
      if (em.cfg?.mods && !em.cfg.mods.includes(pick) && em.cfg.mods.length < 5){
        em.cfg.mods.push(pick);
      }
    }
  }
}
if (Game.mode==='fortress' || Game.mode==='lab'){
  for (const proto of this.deck){
    if (!proto.emitters || !proto.emitters.length) continue;
    if (chance(0.45)){
      const idx = randi(0, proto.emitters.length-1);
      const base = proto.emitters[idx];
      const t = base.type;
      if (EmitterCatalog[t]){
        const fancy = ['DOUBLE_HELIX','SPIRAL_ARMS','WIDENING_FAN','ACCEL_WAVE','STACKED_RING','CELESTIAL_CROWN','TIDAL_LANCE'];
        const key = fancy[randi(0, fancy.length-1)];
        const wrap = CompositeWrappers[key];
        if (wrap){
          const c = Object.assign({}, base.cfg || {});
          const mixCfg = {
            baseCfg: c,
            helixSpeed: 1.6 + Math.random()*1.1,
            arms: randi(2,4),
            rotSpeed: 1.0 + Math.random()*1.3,
            maxSpread: Math.PI*(0.25 + Math.random()*0.35),
            steps: randi(3,5),
            accelVal: 180 + Math.random()*240,
            layers: randi(2,4),
            layerInterval: 0.08 + Math.random()*0.09,
          };
          proto.emitters[idx] = { type:'_COMPOSITE', _compositeInstance:wrap(()=>EmitterCatalog[t](c), mixCfg), cfg:c };
        }
      }
    }
    if (proto.emitters.length < 3 && chance(0.26)){
      const extraType = emitterPick(Math.max(4, w + randi(0,3)));
      const ex = makeEmitterCfg(extraType, Math.max(4, w + 1));
      ex.cfg.mods = mergeMods(proto.waveBulletMods, rollEmitterMods(Math.max(4,w+1), extraType));
      proto.emitters.push(ex);
    }
  }
}
    },

    pick(){
      if (!this.deck.length) this.onWave(1);
      return this.deck[randi(0, this.deck.length-1)];
    },
    pickLiteProto(){
      if (!this.liteDeck.length) this.onWave(Game.wave||1);
      return this.liteDeck[randi(0, this.liteDeck.length-1)];
    }
  };

  function mergeMods(...lists){
    const out=[];
    const seen=new Set();
    for(const L of lists){
      if (!L) continue;
      for(const k of L){
        if (seen.has(k)) continue;
        seen.add(k);
        out.push(k);
        if (out.length>=6) return out; // hard cap to avoid explosion
      }
    }
    return out;
  }

  function propagateMods(mods){
  if (!mods || !mods.length) return [];
  const out = [];
  for (const k of mods){
    const def = BulletAffixCatalog[k];
    if (!def) continue;
    const tags = def.tags || [];
    // 内部词条永不传播
    if (tags.includes('_internal')) continue;
    // 计时器词条不传播（MINE 只爆一次）
    if (tags.includes('timerfx')) continue;
    // 爆炸/分裂类：50% 概率传播（逐层衰减而非完全断裂）
    if (tags.includes('deathfx') || tags.includes('hitfx') || tags.includes('spawnfx')){
      if (chance(0.50)) out.push(k);
      continue;
    }
    // 其余全部传播
    out.push(k);
    if (out.length >= 4) break;
  }
  return out;
}
  // ================= Boss (more durable + modular emitters) =================
  function spawnBoss(d){
    Game.bossAlive = true;
    const w = Game.wave;
    const hf = hellFactor();

    // much tankier early; also scales with wave
    const hp = Math.round((2200 + d*260) * (1 + w*0.06) * (w<8?1.25:1.0));
    const e = baseEnemy('BOSS', 56, hp, 2200);

    // Boss 造型/颜色强随机：避免首个 Boss 固定红色月牙
    const bossPalette = [C.E1, C.E2, C.E3, C.E4, C.E5, C.E6, C.E7, C.Y, '#ff9b72', '#9dd7ff'];
    const col = bossPalette[randi(0, bossPalette.length-1)];
    e.baseCol = col;
    e.tint = chance(0.7) ? col : bossPalette[randi(0, bossPalette.length-1)];
    e.bodySeed = ((Game.spawnSeq||0) * 2654435761 + randi(0, 0x7fffffff) + ((w*1315423911)>>>0)) >>> 0;
    e.body = genEnemyBody(e.bodySeed);
    e._protoBodySeed = e.bodySeed;

    e.x = W * 0.5; e.y = -180; e.vy = 46;
    e.phase = 0;
    e.state = 'enter';



    // boss gets a proto-like bullet mods pack
    e.waveBulletMods = rollAffixes({wave: Math.max(10,w), maxCount: (w<12?2:4)});

    // emitters: profile-based mix，避免固定模板
    const bossProfiles = [
      ['FAN','SPIRAL','RING'],
      ['SHOTGUN','CROSS','FLOWER'],
      ['EMPYREAN_LANCE','CELESTIAL_CORONA','SPIRAL'],
      ['DRAGON_BREATH','NOVA_PULSE','RING'],
      ['FAN','LASER','MINE'],
    ];
    const profile = bossProfiles[randi(0, bossProfiles.length-1)];
    const mkBossEm = (type)=>{
      const cfg = {
        baseCd: lerp(2.2, 0.95, hf),
        speed: 210 + d*8,
        col: e.tint || e.baseCol,
        spr: 'glowE2',
        mods: mergeMods(e.waveBulletMods, ['TRAIL'])
      };
      if (type==='SPIRAL') cfg.mods = mergeMods(e.waveBulletMods, ['SPIN']);
      if (type==='RING') cfg.mods = mergeMods(e.waveBulletMods, ['WAVE']);
      if (type==='MINE') cfg.mods = mergeMods(e.waveBulletMods, ['MINE']);
      if (type==='LASER') cfg.mods = mergeMods(e.waveBulletMods, ['PIERCE_LINE']);
      if (type==='SHOTGUN') cfg.baseCd *= 0.82;
      if (type==='FLOWER' || type==='NOVA_PULSE') cfg.baseCd *= 1.25;
      const fac = EmitterCatalog[type] || EmitterCatalog.AIM;
      return fac(cfg);
    };
    e.emitters = profile.slice(0, 2).map(mkBossEm);
    if (w>=9) e.emitters.push(mkBossEm(profile[2] || 'RING'));
    if (w>=11 && chance(0.65)) e.emitters.push(mkBossEm(chance(0.5)?'MINE':'LASER'));
    if (w>=13 && chance(0.45)) e.emitters.push(mkBossEm(chance(0.5)?'FAN':'SPIRAL'));

    // defense traits for boss baseline
    applyEnemyTraits(e, ['ARMORED','SHIELD_LAYER'], d);

    e.update = (dt) => {
      e.hit = Math.max(0, e.hit - dt);
      
      const safeD = Number.isFinite(d) ? d : 1.0;

      if (e.state === 'enter') {
        e.y += e.vy * dt;
        const targetY = (H || window.innerHeight) * 0.16;
        if (e.y >= targetY) { e.y = targetY; e.state = 'fight'; }
        return;
      }

      // [补丁 3] 坐标计算绝对防御
      // 1. 确保 dt 有效
      const safeDt = Number.isFinite(dt) ? dt : 0.016;
      
      // 2. 更新相位 (使用清洗后的 safeD)
      e.phase = (e.phase || 0) + safeDt * (0.75 + safeD * 0.012);
      
      // 3. 计算 X 坐标
      const centerX = W * 0.5;
      const amp = W * 0.22;
      e.x = centerX + Math.sin(e.phase) * amp;

      // 4. 【最后防线】如果算出来是 NaN，强制归位到屏幕中心
      if (!Number.isFinite(e.x)) {
        e.x = centerX;
        e.phase = 0; // 重置相位，试图恢复正常
      }

      updateEmitters(e, dt);
    };

e.draw = () => {

      if (!Number.isFinite(e.x) || !Number.isFinite(e.y)) return;

      drawEnemyGeneric(e);

      const bw = Math.min(380, W * 0.82);
      const p = clamp(e.hp / e.maxHp, 0, 1);
      ctx.save();
      ctx.globalAlpha = 0.60;
      ctx.fillStyle = 'rgba(255,255,255,0.14)';
      ctx.fillRect(W / 2 - bw / 2, e.y - 70, bw, 9);
      ctx.globalAlpha = 0.95;
      ctx.fillStyle = rgbToRgba(e.tint || C.E2, 0.92);
      ctx.fillRect(W / 2 - bw / 2, e.y - 70, bw * p, 9);
      ctx.restore();
    };
    e.spawnId = (Game.spawnSeq = (Game.spawnSeq||0) + 1);
    if (w >= 9 && e.emitters.length >= 2 && chance(0.55)){
      const ci = randi(0, e.emitters.length - 1);
      const comp = CompositionRules.rollComposite(w, Game.difficulty);
      if (comp) e.emitters[ci] = comp;
    }
    if (w >= 13 && e.emitters.length >= 3 && chance(0.35)){
      const ci = randi(0, e.emitters.length - 1);
      if (!e.emitters[ci]._composite){
        const comp = CompositionRules.rollComposite(w, Game.difficulty);
        if (comp) e.emitters[ci] = comp;
      }
    }
    
    // Boss 的 composite emitter 有 40% 概率获得协同词条
for (const em of e.emitters){
  if (!em._composite) continue;
  if (!chance(0.40)) continue;
  const synergy = ['CASCADE','SYMPATHETIC','INHERIT_BOOST','PHASE_SHIFT'];
  const pick = synergy[randi(0, synergy.length-1)];
  if (e.waveBulletMods.length < 5 && !e.waveBulletMods.includes(pick)){
    e.waveBulletMods.push(pick);
  }
}

    enemies.push(e);
    textPop(W*0.5, H*0.24, 'WARNING: BOSS', C.E1);
    spawnShockwave(W*0.5, H*0.24, C.E1, 420, 0.7);
    addShake(12,0.32);
    SFX.bossWarn();
  }

  function amplifyFortressEnemy(e, proto, d){
    if (Game.mode!=='fortress' || !e || e.type==='BOSS') return;
    const w = Game.wave || 1;
    const hpMul = 1.12 + clamp((w-1)*0.018, 0, 0.38);
    e.maxHp = Math.round(e.maxHp * hpMul);
    e.hp = Math.min(e.maxHp, Math.round(e.hp * hpMul));
    e.emCdMul = (e.emCdMul || 1) * 0.86;

    const extraWaveMods = rollAffixes({
      wave: Math.max(w+2, 6),
      maxCount: (w<8?1:(w<14?2:3)),
      forbidTags: new Set(['_internal'])
    });
    e.waveBulletMods = mergeMods(e.waveBulletMods || [], extraWaveMods).slice(0, 6);

    if (Array.isArray(e.emitters)){
      for (const em of e.emitters){
        if (em?._composite && em._base?.mods) em._base.mods = mergeMods(e.waveBulletMods, em._base.mods).slice(0, 6);
        if (em?.mods) em.mods = mergeMods(e.waveBulletMods, em.mods).slice(0, 6);
      }
    }

    const wantEmitters = clamp(1 + Math.floor(w/4), 2, 4);
    while ((e.emitters?.length || 0) < wantEmitters){
      const keyPool = ['AIM','FAN','RING','SPIRAL','SHOTGUN','CROSS','FLOWER'];
      const t = keyPool[randi(0, keyPool.length-1)];
      const fac = EmitterCatalog[t] || EmitterCatalog.AIM;
      const cfg = {
        baseCd: lerp(1.25, 0.72, clamp((d-1)/10, 0, 1)),
        speed: 220 + d*9 + w*3,
        col: e.tint || e.baseCol || C.E6,
        mods: mergeMods(e.waveBulletMods, [])
      };
      const em = fac(cfg);
      if (em) e.emitters.push(em);
      if ((e.emitters?.length || 0) >= wantEmitters) break;
    }

    if (w>=7 && e.emitters?.length && chance(0.45)){
      const idx = randi(0, e.emitters.length-1);
      if (!e.emitters[idx]?._composite){
        const comp = CompositionRules.rollComposite(Math.max(w+1, 8), d*1.1);
        if (comp) e.emitters[idx] = comp;
      }
    }
  }

  // ================= Spawner =================
  const Spawner = {
    cd:0,
    reset(){ this.cd=0; },
    update(dt){
      const t = Game.time;
      
      if (Game.mode === 'fortress' || Game.mode === 'fortress_duel' || Game.mode === 'lab') {
        Fortress.update(dt);
        if (Game.mode !== 'fortress') return;
        if (Fortress.phase !== 'assault') return;

        const timeSlope = (t < BAL.diffSwitchT) ? BAL.diffTimeEarly : BAL.diffTimeLate;
        Game.difficulty = 1 + t*timeSlope + Game.score*BAL.diffScore;

        const d = Game.difficulty * 1.14 + clamp((Game.wave-1)*0.03, 0, 0.55);
        const k = clamp((d-1)/9, 0, 1);
        const baseRate = lerp(BAL.spawnRateEarly, BAL.spawnRateLate, k);

        // fortress: 与 survival 同一套节奏，但额外受本波预算 spawnLeft 控制
        this.cd -= dt;
        if (this.cd<=0 && Fortress.spawnLeft>0){
          this.cd = baseRate * DiffConfig.spawnRateMul * 0.86 * rand(0.68, 1.18);

          if (Game.bossAlive && chance(0.55)) return;
          if (enemies.length >= 10 && !Game.bossAlive) return;

          const proto = WaveDirector.pick();
          const e = EnemyFactory.spawnFromProto(proto, d);
          if (e.mmx){
            e.mmx.nextT = Math.max(0.85, e.mmx.nextT * 0.72);
            if (Array.isArray(e.mmx.availableModes) && e.mmx.availableModes.length > 1){
              const modeFlip = ((Game.wave + enemies.length) % 3) === 0;
              if (modeFlip) e.mmx.availableModes = [...e.mmx.availableModes].reverse();
            }
          }

          e.maxHp = Math.round(e.maxHp * proto.hpMul * DiffConfig.enemyHpMul);
          e.emCdMul = (e.emCdMul || 1.0) * DiffConfig.fireCdMul;
          e.hp = e.maxHp;
          e.score = Math.round(e.score * proto.scoreMul);
          amplifyFortressEnemy(e, proto, d);
          applySpawnEntropy(e);

          normalizeFortressSpawn(e);
          resolveSpawnOverlap(e, 12);
          enemies.push(e);
          Fortress.spawnLeft -= 1;
        }

        // 每 5 波固定出 Boss，一次且仅一次
        if (!Game.bossAlive && !Fortress.bossSpawned && Fortress.spawnLeft<=0 && Game.wave>0 && Game.wave%5===0){
          Game.lastBossAt = t;
          Fortress.bossSpawned = true;
          spawnBoss(Game.difficulty);
        }
        return;
      }

      if (Game.mode === 'challenge') {
        // 如果场上没有活着的敌人，生成下一波
        // 注意：Game.bossAlive 在这里不作为限制，因为我们每次只出一只“Boss级”怪
        const aliveCount = enemies.filter(e => e.alive).length;
        
        if (aliveCount === 0) {
          // 增加一点延迟感，不要瞬间刷出来
          this.cd -= dt;
          if (this.cd <= 0) {
            spawnChaosEnemy(Game.wave);
            // 更新 UI
            ui.wave.textContent = `CHAOS ${Game.wave}`;
            // 准备下一波
            Game.wave++;
            // 每次生成后给 1.5 秒间隔
            this.cd = 1.5; 
          }
        }
        return; // 阻止后续普通生成逻辑
      }
      const timeSlope = (t < BAL.diffSwitchT) ? BAL.diffTimeEarly : BAL.diffTimeLate;
      Game.difficulty = 1 + t*timeSlope + Game.score*BAL.diffScore;

      const prevWave = Game.wave;
      Game.wave = 1 + (t/22|0);
      if (Game.wave !== prevWave){
        WaveDirector.onWave(Game.wave);
        textPop(W*0.5, 92, 'WAVE '+Game.wave, C.P1);
        spawnShockwave(W*0.5, 92, C.P1, 240, 0.55);
        SFX.wave();
      }
      ui.wave.textContent = (Game.mode==='duel') ? 'DUEL' : (Game.mode==='lab' ? 'LAB' : (Game.mode==='workshop' ? 'WORKSHOP' : (Game.mode==='fortress_duel' ? 'F-DUEL' : Game.wave)));

      if (!Game.bossAlive && t > BAL.bossMinTime && t-Game.lastBossAt > BAL.bossInterval){
        Game.lastBossAt = t;
        spawnBoss(Game.difficulty);
      }

      const d = Game.difficulty;
      const k = clamp((d-1)/9, 0, 1);
      const baseRate = lerp(BAL.spawnRateEarly, BAL.spawnRateLate, k);

      this.cd -= dt;
      if (this.cd<=0){
        this.cd = baseRate * DiffConfig.spawnRateMul * rand(0.72, 1.26);
        
        if (Game.bossAlive && chance(0.55)) return;
        
        // 如果场上已有 7 只普通怪，暂时停止生成，防止堆积
        if (enemies.length >= 7 && !Game.bossAlive) return

        const proto = WaveDirector.pick();
        const e = EnemyFactory.spawnFromProto(proto, d);

        e.maxHp = Math.round(e.maxHp * proto.hpMul * DiffConfig.enemyHpMul);
        e.emCdMul = (e.emCdMul || 1.0) * DiffConfig.fireCdMul;
        e.hp = e.maxHp;
        e.score = Math.round(e.score * proto.scoreMul);
        applySpawnEntropy(e);

        normalizeFortressSpawn(e);
        resolveSpawnOverlap(e, 12);
        enemies.push(e);
      }
    }
  };

  // ================= Player fire (uses bullet affixes) =================
  function findNearestEnemy(x,y, maxD=560){
    let best=null, bestD=maxD*maxD;
    for(const e of enemies){
      if (!e.alive) continue;
      const d2 = dist2(x,y,e.x,e.y);
      if (d2<bestD){ bestD=d2; best=e; }
    }

    if (Game.mode==='fortress_duel' && Multiplayer?.peers?.size){
      let bestFlag = null, bestFlagD = maxD*maxD;
      let bestPeer = null, bestPeerD = maxD*maxD;
      let bestStruct = null, bestStructD = maxD*maxD;
      for (const peer of Multiplayer.peers.values()){
        const pf = Multiplayer.projectedPeerFortress?.(peer);
        if (pf){
          const d2f = dist2(x,y,pf.flagX,pf.flagY);
          if (d2f < bestFlagD){ bestFlagD = d2f; bestFlag = {x:pf.flagX,y:pf.flagY,vx:0,vy:0,alive:true,r:22,type:'PEER_FLAG'}; }
        }

        const pp = Multiplayer.projectedPeer(peer);
        if (pp && peer.alive !== false){
          const d2p = dist2(x,y,pp.x,pp.y);
          if (d2p < bestPeerD){ bestPeerD = d2p; bestPeer = {x:pp.x,y:pp.y,vx:pp.vx||0,vy:pp.vy||0,alive:true,r:Player.r||16,type:'PEER'}; }
        }

        if (pf?.structures?.length){
          for (const st of pf.structures){
            if ((st.hp||0)<=0) continue;
            const d2s = dist2(x,y,st.x,st.y);
            if (d2s < bestStructD){ bestStructD = d2s; bestStruct = {x:st.x,y:st.y,vx:0,vy:0,alive:true,r:Math.max(st.w||20,st.h||20)*0.35,type:'PEER_STRUCT'}; }
          }
        }
      }
      if (bestFlag) return bestFlag;
      if (bestPeer) return bestPeer;
      if (bestStruct) return bestStruct;
    }
    return best;
  }

  function predictEnemyPos(srcX, srcY, target, speed=520){
    if (!target) return null;
    const tvx = Number.isFinite(target.vx) ? target.vx : (target.mmx?.vx || 0);
    const tvy = Number.isFinite(target.vy) ? target.vy : (target.mmx?.vy || 0);
    const dx = target.x - srcX, dy = target.y - srcY;
    const dist = Math.hypot(dx, dy);
    const tof = clamp(dist / Math.max(80, speed), 0, 1.25);
    return {x:target.x + tvx*tof, y:target.y + tvy*tof};
  }

  function bulletPerfTier(){
    const n = (bulletsP?.length || 0) + (bulletsE?.length || 0);
    if (n >= 440) return 3;
    if (n >= 320) return 2;
    if (n >= 220) return 1;
    return 0;
  }

  function solveLinearInterceptTime(rx, ry, rvx, rvy, speed){
    const vv = rvx*rvx + rvy*rvy;
    const rr = rx*rx + ry*ry;
    const rv = rx*rvx + ry*rvy;
    const a = vv - speed*speed;
    const b = 2*rv;
    const c = rr;

    if (Math.abs(a) < 1e-6){
      if (Math.abs(b) < 1e-6) return null;
      const t = -c / b;
      return (t > 0) ? t : null;
    }

    const disc = b*b - 4*a*c;
    if (disc < 0) return null;

    const sqrtD = Math.sqrt(disc);
    const t1 = (-b - sqrtD) / (2*a);
    const t2 = (-b + sqrtD) / (2*a);

    let t = Infinity;
    if (t1 > 0) t = Math.min(t, t1);
    if (t2 > 0) t = Math.min(t, t2);
    return Number.isFinite(t) ? t : null;
  }

  function predictInterceptAim(srcX, srcY, target, opt={}){
    if (!target) return null;

    const speed = Math.max(60, Number(opt.speed) || 320);
    const launchDelay = clamp(Number(opt.launchDelay) || 0, 0, 2.0);
    const angVel = Number.isFinite(opt.angVel) ? opt.angVel : 0;
    const maxTime = clamp(Number(opt.maxTime) || 2.8, 0.35, 4.5);

    const perf = bulletPerfTier();
    const simDt = clamp(Number(opt.simDt) || (perf>=2 ? 1/36 : 1/60), 1/180, 1/20);
    const iterN = clamp((opt.iterN ?? (perf>=2 ? 2 : 4))|0, 1, 6);

    const svx = Number.isFinite(opt.shooterVx) ? opt.shooterVx : 0;
    const svy = Number.isFinite(opt.shooterVy) ? opt.shooterVy : 0;
    const tvx = Number.isFinite(target.vx) ? target.vx : (target.mmx?.vx || 0);
    const tvy = Number.isFinite(target.vy) ? target.vy : (target.mmx?.vy || 0);

    const launchX = srcX + svx * launchDelay;
    const launchY = srcY + svy * launchDelay;
    const tgt0X = (target.x || 0) + tvx * launchDelay;
    const tgt0Y = (target.y || 0) + tvy * launchDelay;

    const rx = tgt0X - launchX;
    const ry = tgt0Y - launchY;

    // 无角速度时优先走解析拦截（更快）
    if (Math.abs(angVel) < 1e-4){
      const t = solveLinearInterceptTime(rx, ry, tvx - svx, tvy - svy, speed);
      if (t != null){
        const tc = clamp(t, 0, maxTime);
        const aimX = tgt0X + tvx * tc;
        const aimY = tgt0Y + tvy * tc;
        return { angle: Math.atan2(aimY - launchY, aimX - launchX), launchX, launchY, targetX:tgt0X, targetY:tgt0Y };
      }
    }

    let guessA = Math.atan2(ry, rx);
    const maxStep = Math.max(1, Math.ceil(maxTime / simDt));

    for (let iter=0; iter<iterN; iter++){
      let px = launchX, py = launchY;
      let a = guessA;
      let bestT = 0;
      let bestD2 = Infinity;

      for (let i=0; i<=maxStep; i++){
        const t = i * simDt;
        const tx = tgt0X + tvx * t;
        const ty = tgt0Y + tvy * t;

        const dx = tx - px;
        const dy = ty - py;
        const d2 = dx*dx + dy*dy;
        if (d2 < bestD2){
          bestD2 = d2;
          bestT = t;
          if (d2 < 16) break;
        }

        if (angVel !== 0) a += angVel * simDt;
        px += Math.cos(a) * speed * simDt;
        py += Math.sin(a) * speed * simDt;
      }

      const aimX = tgt0X + tvx * bestT;
      const aimY = tgt0Y + tvy * bestT;
      guessA = Math.atan2(aimY - launchY, aimX - launchX);
    }

    return {
      angle: guessA,
      launchX, launchY,
      targetX: tgt0X,
      targetY: tgt0Y
    };
  }


  function fortressSpawnBullet(team, x, y, vx, vy, opt){
    const b = spawnBullet(team, x, y, vx, vy, Object.assign({}, opt, {fortressSafe:true}));
    if (b) b.fortressSafe = true;
    return b;
  }

  function findEnemyFocus(x,y, maxD=99999){
    if (UnitBattle.active) return UnitBattle.findOpponent(UnitBattle._source, x, y, maxD);
    if (Game.mode==='fortress' || Game.mode==='lab' || Game.mode==='fortress_duel') return Fortress.getEnemyTarget(x,y,maxD);
    return Player.alive ? Player : null;
  }

  function spawnHomingMissile(x,y,target){
  if (!target) return;
  const speed = 300;
  const pred = predictInterceptAim(x, y, target, {
    speed,
    shooterVx: Player.vx || 0,
    shooterVy: Player.vy || 0,
    launchDelay: 0.03,
    angVel: 0,
    maxTime: 2.8
  });
  const a = pred?.angle ?? Math.atan2(target.y-y, target.x-x);

  const b = spawnBullet('P', x,y, Math.cos(a)*speed, Math.sin(a)*speed, {
    r:3.2,
    dmg: (14+Math.log2(1+Player.lv)*6.2)*Player.dmgMul,
    col:C.P2, spr:'glowP2', life:2.6, style:1,
    mods: mergeMods(Player.gunMods, ['HOMING']),
    modCtx: {owner:Player, team:'P'}
  });
  if (b) {
    b.homing = 1;
    b._homeCd = 0;
  }
}
  

  // ================= Unified Emitter Catalog (Player & Rival reuse) =================
function makeEmitterCatalog(ctx){
  const yOff = (ctx.team==='P') ? -20 : +10;
  const defaultA = (ctx.team==='P') ? -Math.PI/2 : Math.PI/2;

  function aimA(o, opt={}){
    o = o || ctx.getOwner();
    const t = opt.target || ctx.getTarget();
    if (!o || !t) return defaultA;

    const shotSpeed = Number(opt.speed);
    const shouldPredict = Number.isFinite(shotSpeed) && shotSpeed > 0;
    if (!shouldPredict) return Math.atan2(t.y - o.y, t.x - o.x);

    const pred = predictInterceptAim(o.x, o.y, t, {
      speed: shotSpeed,
      shooterVx: o.vx || 0,
      shooterVy: o.vy || 0,
      launchDelay: opt.launchDelay || 0,
      angVel: opt.angVel || 0,
      maxTime: opt.maxTime || 2.8
    });
    return pred?.angle ?? Math.atan2(t.y - o.y, t.x - o.x);
  }

function spawnAt(o, a, sp, opt={}){
    o = o || ctx._cur; 
    if (!o) return null;

    // 统一把 owner 偏移角叠加到所有 spawnAt 发射路径，保证 wrapper 可组合
    a += (o._emitAngleOffset || 0);

    // 1. 优先获取本次发射指定的 mods (例如分形爆炸产生的内部词条)
    // 2. 加上 Context 提供的全局词条 (Bullet Affix)
    // 3. mergeMods 会自动处理数组合并与去重
    const mods = mergeMods(opt.mods, ctx.getMods()); 

    const col  = opt.col || ctx.getColor();
    const spr  = opt.spr || (ctx.team==='P' ? (col===C.P2?'glowP2':'glowP') : sprFromColor(col,'E'));

    const b = spawnBullet(ctx.team, o.x, o.y + yOff, Math.cos(a)*sp, Math.sin(a)*sp, {
      r: opt.r ?? 2.6,
      dmg: opt.dmg ?? 6,
      col, spr,
      style: opt.style ?? 1,
      life: opt.life ?? 1.8,
      pierce: opt.pierce ?? 0,
      mods, // 此时 mods 是合并后的完整列表
      modCtx: { owner: o, team: ctx.team } 
    });
    



    // 属性透传
    if (b) {
      if (opt.angVel!=null) b.angVel = opt.angVel;
      if (opt.waveA!=null)  b.waveA  = opt.waveA;
      if (opt.waveF!=null)  b.waveF  = opt.waveF;
      if (opt.waveP!=null)  b.waveP  = opt.waveP;
      if (opt.mineT!=null)  b.mineT  = opt.mineT;
      if (opt.onDeath) b.onDeath = opt.onDeath; // 支持分形爆炸
    }
    return b;
  }

  const cat = {
    // AIM: 瞄准玩家发射单发子弹
    AIM: () => ({
      // 这里的属性会被外部 cfg 覆盖
      type: 'AIM',
      // 初始 CD
      cd: 1.2, 
      
      // 动态计算下一次射击间隔
      nextCd(o, dt) {
        const d = Game.difficulty;
        const hf = hellFactor();
        // this.baseCd 是由包装器从 cfg.baseCd 自动合并过来的
        return (this.baseCd ?? lerp(1.25, 0.70, hf)) * rand(0.80, 1.25) / Math.sqrt(d);
      },

      fire(o) {
        const d = Game.difficulty;
        
        // 1. 获取动态数值 (优先使用 cfg 传入的，否则使用公式)
        const sp = (this.speed || (220 + d * 7));
        const dmg = (this.dmg || (10 + d * 0.70)) * ctx.getDmgMul();

        // 2. 播放音效 (ctx.getColor() 会自动识别当前敌人颜色)
        SFX.enemyShoot(ctx.getColor());

        // 3. 使用辅助函数发射
        // aimA(o): 计算 o 到 Player 的角度
        // spawnAt: 自动处理坐标偏移(y+8)、颜色映射、全局词条合并
        const mergedMods = ctx.getMods();
        const tracking = this.predictive || mergedMods.includes('HOMING') || this.homing === 1;
        const fireA = tracking
          ? aimA(o, {speed:sp, launchDelay:this.launchDelay || 0, angVel:this.angVel || 0, maxTime:2.4})
          : aimA(o);

        spawnAt(o,fireA, sp, {
          dmg: dmg,
          r: this.r ?? 2.9,
          life: this.life ?? 2.2,
          style: 1, // 拖尾风格
          spr: this.spr // 如果 cfg 指定了贴图则使用，否则辅助函数自动匹配颜色
        });
      }
    }),
    FAN: ()=>({
      cd:0.25,
      nextCd(){ return Math.max(0.12, 0.55 / Math.max(0.6, ctx.getFireRate())); },
      fire(o){
        const base = aimA(o);
        const n=5, spread=0.55;
        const sp = (ctx.team==='P') ? 620 : 420;
        const dmg = (6 + Math.log2(1+ctx.getLv())*3.2) * ctx.getDmgMul() * (ctx.team==='E'?0.55:1);

        for(let i=0;i<n;i++){
          const k=(i/(n-1))-0.5;
          spawnAt(o,base + k*spread, sp, {dmg, r:2.6, style:1});
        }
      }
    }),

    SPIRAL: ()=>({
      _a: defaultA,
      cd:0.12,
      nextCd(){ return Math.max(0.05, 0.12 / Math.max(0.6, ctx.getFireRate())); },
      fire(o){
        this._a += 0.28;
        const sp = (ctx.team==='P') ? 560 : 360;
        const dmg = (5 + Math.log2(1+ctx.getLv())*2.9) * ctx.getDmgMul() * (ctx.team==='E'?0.50:1);
        spawnAt(o,this._a, sp, {dmg, r:2.4, style:0, col:ctx.getAltColor()});
      }
    }),

    RING: ()=>({
      cd:0.95,
      nextCd(){ return Math.max(0.35, 1.25 / Math.max(0.6, ctx.getFireRate())); },
      fire(o){
        const n=10;
        const sp = (ctx.team==='P') ? 360 : 260;
        const dmg = (4.6 + Math.log2(1+ctx.getLv())*2.6) * ctx.getDmgMul() * (ctx.team==='E'?0.45:1);
        const ph = Math.random()*Math.PI*2;
        for(let i=0;i<n;i++){
          spawnAt(o,ph + i*(Math.PI*2/n), sp, {dmg, r:2.3, style:0, life:1.4});
        }
      }
    }),

    SHOTGUN: ()=>({
      cd:0.65,
      nextCd(){ return Math.max(0.18, 0.85 / Math.max(0.6, ctx.getFireRate())); },
      fire(o){
        const base = aimA(o);
        const pellets=7, spread=0.80;
        const sp0 = (ctx.team==='P') ? 660 : 420;
        const dmg = (6.5 + Math.log2(1+ctx.getLv())*3.0) * ctx.getDmgMul() * 0.50;

        for(let i=0;i<pellets;i++){
          const a = base + (Math.random()-0.5)*spread;
          const sp = sp0*(0.82 + Math.random()*0.30);
          spawnAt(o,a, sp, {dmg, r:2.5, style:1, life:1.35});
        }
      }
    }),
    
    // MINE: 投放地雷，并在一定时间后爆炸
    MINE: () => ({
      type: 'MINE',
      cd: 2.4,
      nextCd(o, dt) {
        const d = Game.difficulty;
        const hf = hellFactor();
        return (this.baseCd ?? lerp(3.2, 1.9, hf)) * rand(0.90, 1.25) / Math.sqrt(d);
      },
      fire(o) {
        // 颜色自动跟随
        SFX.enemyShoot(ctx.getColor());
        
        // 模拟原版向下飘动的随机速度
        const vx = rand(-35, 35);
        const vy = rand(85, 130);
        const ang = Math.atan2(vy, vx);
        const sp = Math.hypot(vx, vy);

        // spawnAt 会自动执行 mergeMods(['MINE'], ctx.getMods())
        // 从而完美支持：局部 MINE + 敌人全局 Affix (如 SPIN 或 BOUNCE)
        spawnAt(o, ang, sp, {
          r: this.r ?? 6.2,
          dmg: 0,      // 地雷碰撞本身不伤人，靠爆炸
          style: 0,    // 圆球形
          life: 2.1,
          mods: ['MINE'], // 注入地雷逻辑
          spr: this.spr || 'glowE3'
        });
      }
    }),

    // LASER: 蓄力发射直线贯穿激光
    LASER: () => ({
      type: 'LASER',
      cd: 3.0,
      nextCd(o, dt) {
        const d = Game.difficulty;
        const hf = hellFactor();
        return (this.baseCd ?? lerp(3.6, 2.2, hf)) * rand(0.90, 1.25) / Math.sqrt(d);
      },
      fire(o) {
        // 激光音效
        SFX.enemyShoot(ctx.getColor());
        
        const d = Game.difficulty;
        const beamCol = C.Y; // 激光固定黄色视觉
        
        // 计算最终角度：基础瞄准 + Owner偏移（支持复合包装器如旋转/镜像）
        const finalA = aimA(o);

        // 计算射线终点 (长度1200足以穿透屏幕)
        const tx = o.x + Math.cos(finalA) * 1200;
        const ty = (o.y + 10) + Math.sin(finalA) * 1200;

        // 渲染激光束
        spawnBeam(o.x, o.y + 10, tx, ty, 9, 0.18, (this.dmg || (14 + d * 1.45)), beamCol);

        // 视觉反馈
        sparks(o.x, o.y + 10, 'glowY', 18, 620);
        spawnShockwave(o.x, o.y + 10, beamCol, 240, 0.55);
        addShake(3.2, 0.10);
      }
    }),

    CROSS: ()=>({
      cd:0.90,
      nextCd(){ return Math.max(0.30, 1.15 / Math.max(0.6, ctx.getFireRate())); },
      fire(o){
        const rot = Game.time*0.6;
        const sp = (ctx.team==='P') ? 520 : 320;
        const dmg = (6.0 + Math.log2(1+ctx.getLv())*3.0) * ctx.getDmgMul() * 0.50;
        for(let i=0;i<4;i++){
          spawnAt(o,rot + i*(Math.PI/2), sp, {dmg, r:2.5, style:1});
        }
      }
    }),

    TWIN_RAIL: ()=>({
      cd:1.05,
      nextCd(){ return Math.max(0.35, 1.40 / Math.max(0.6, ctx.getFireRate())); },
      fire(o){
        const base = aimA(o);
        const sp = (ctx.team==='P') ? 980 : 560;
        const dmg = (7.0 + Math.log2(1+ctx.getLv())*3.6) * ctx.getDmgMul() * 0.65;
        const off = 10;

        const mods = ctx.getMods();
        const col  = ctx.getAltColor();
        const spr  = (ctx.team==='P') ? 'glowP2' : sprFromColor(col,'E');

        spawnBullet(ctx.team, o.x-off, o.y+yOff, Math.cos(base)*sp, Math.sin(base)*sp, {
          r:2.4, dmg, col, spr, style:1, life:1.05, pierce:1, mods, modCtx:{owner:o,team:ctx.team}
        });
        spawnBullet(ctx.team, o.x+off, o.y+yOff, Math.cos(base)*sp, Math.sin(base)*sp, {
          r:2.4, dmg, col, spr, style:1, life:1.05, pierce:1, mods, modCtx:{owner:o,team:ctx.team}
        });
      }
    }),

    HOMING_PULSE: ()=>({
      cd:1.15,
      nextCd(){ return Math.max(0.45, 1.65 / Math.max(0.6, ctx.getFireRate())); },
      fire(o){
        const t = ctx.getTarget();
        if (!o || !t) return;
        const sp = (ctx.team==='P') ? 420 : 280;
        const a = aimA(o, {
          target: t,
          speed: sp,
          launchDelay: this.launchDelay || 0,
          angVel: this.angVel || 0,
          maxTime: 2.8
        });

        const dmg = (7.5 + Math.log2(1+ctx.getLv())*4.0) * ctx.getDmgMul() * 0.75;

        const mods = (typeof mergeMods==='function') ? mergeMods(ctx.getMods(), ['HOMING']) : ['HOMING'];
        const b = spawnAt(o,a, sp, {dmg, r:3.0, col:ctx.getAltColor(), life:2.3, mods});
        if (b) b.homing = 1;
      }
    }),
    
    // [新] V_SHAPE: 向前方发射 V 字形排列的子弹（类似回旋镖结构，但直线飞行）
    V_SHAPE: ()=>({
      cd: 0.9,
      nextCd(){ return Math.max(0.35, 1.1 / Math.max(0.6, ctx.getFireRate())); },
      fire(o){
        const base = aimA(o);
        const sp = (ctx.team==='P') ? 600 : 400;
        const dmg = (7 + Math.log2(1+ctx.getLv())*3.0) * ctx.getDmgMul() * 0.6;
        // 左翼
        spawnAt(o,base - 0.15, sp, {dmg, r:2.5, style:1, life:1.4});
        spawnAt(o,base - 0.30, sp*0.9, {dmg, r:2.5, style:1, life:1.4});
        // 右翼
        spawnAt(o,base + 0.15, sp, {dmg, r:2.5, style:1, life:1.4});
        spawnAt(o,base + 0.30, sp*0.9, {dmg, r:2.5, style:1, life:1.4});
        // 核心
        spawnAt(o,base, sp*1.1, {dmg:dmg*1.5, r:3.5, style:1, life:1.5});
      }
    }),

// [随机化增强版] GRID: 发射一个动态尺寸的子弹方阵
    GRID: () => ({
      cd: 1.5,
      nextCd() { return Math.max(0.6, 1.8 / Math.max(0.6, ctx.getFireRate())); },
      fire(owner) {
        const o = owner || ctx._cur;
        if (!o) return;

        const base = aimA(o);
        const sp = (ctx.team === 'P') ? 480 : 300;
        const lv = ctx.getLv();

        // --- 核心随机化逻辑 ---
        // 1. 决定网格的长宽 (2到4之间随机，高等级/高波次最高可达7)
        const limit = lv < 10 ? 4 : 7;
        const cols = randi(2, limit); // 横向子弹数
        const rows = randi(2, limit); // 纵向子弹数
        
        // 2. 随机间距 (让方阵有时紧凑有时稀疏)
        const spacing = rand(16, 24); 

        const col = ctx.getColor();
        const mods = ctx.getMods();
        const dmg = (6 + lv * 0.5) * ctx.getDmgMul();

        // 计算旋转分量，使网格垂直于射击方向
        const cosA = Math.cos(base);
        const sinA = Math.sin(base);

        for (let ix = 0; ix < cols; ix++) {
          for (let iy = 0; iy < rows; iy++) {
            // 计算相对于中心点的偏移
            // ix/iy 转换为中心对齐坐标 (例如 3x3 变为 -1, 0, 1)
            const offX = (ix - (cols - 1) / 2) * spacing;
            const offY = (iy - (rows - 1) / 2) * spacing;

            // [坐标投影] 将本地网格坐标转换到世界坐标，并绕 owner 旋转
            // 确保网格总是“正对着”玩家飞过去
            const worldX = o.x + (offX * -sinA) + (offY * cosA);
            const worldY = o.y + (offX * cosA) + (offY * sinA);

            spawnBullet(ctx.team, worldX, worldY, cosA * sp, sinA * sp, {
              r: 2.2, 
              dmg: dmg, 
              col: col, 
              style: 0, 
              life: 1.8,
              mods: mods, 
              modCtx: { owner: o, team: ctx.team }
            });
          }
        }
        
        // 增加一点震动感，根据规模决定强度
        if (ctx.team === 'P') addShake(cols + rows, 0.1);
      }
    }),

    // [新] CHAOS: 随机速率、随机角度抖动的快速射击
    CHAOS: ()=>({
      cd: 0.15,
      nextCd(){ return 0.08 + Math.random() * 0.15; }, // 极其不稳定的射速
      fire(o){
        const base = aimA(o) + (Math.random()-0.5) * 0.8; // 大幅抖动
        const sp = ((ctx.team==='P') ? 550 : 350) * (0.8 + Math.random()*0.4);
        const dmg = (6 + Math.log2(1+ctx.getLv())*2.5) * ctx.getDmgMul() * 0.7;
        spawnAt(o,base, sp, {
          dmg, r: 2 + Math.random()*2, // 大小不一
          style: chance(0.5)?1:0, 
          life: 1.2 + Math.random()*0.8
        });
      }
    }),
    
    // [新] WAVE_BEAM: 发射一道横扫屏幕的能量波
    // 视觉效果：类似《斑鸠》中的 Boss 能量剑
    WAVE_BEAM: ()=>({
      cd: 1.8,
      nextCd(){ return Math.max(0.8, 2.5 / Math.max(0.6, ctx.getFireRate())); },
      fire(o){
        
        if (!o) return;
        const dmg = (8 + Math.log2(1+ctx.getLv())*3.5) * ctx.getDmgMul() * 0.8;
        
        // 能量波由大量紧密排列的子弹构成，创造出“面”的效果
        const count = 35; 
        const sp = (ctx.team==='P') ? 600 : 420;
        const width = 180; // 能量波的宽度

        for(let i=0; i<count; i++){
          // 计算每个子弹在能量波上的位置
          const k = (i / (count-1)) - 0.5; // -0.5 to 0.5
          
          // 子弹发射点偏移
          const spawnX = o.x + k * width;
          const spawnY = o.y + (ctx.team==='P' ? -20 : 20);
          
          // 子弹速度方向（全部向下/上）
          const angle = (ctx.team==='P') ? -Math.PI/2 : Math.PI/2;

          spawnBullet(ctx.team, spawnX, spawnY, Math.cos(angle)*sp, Math.sin(angle)*sp, {
            r: 3.5, dmg, 
            col: ctx.getAltColor(), // 使用 P2 紫色或黄色，增加辨识度
            style: 1, // 带拖尾
            life: 1.8,
            mods: ctx.getMods(),
            modCtx: {owner:o, team:ctx.team}
          });
        }
        // 视觉/听觉反馈
        spawnShockwave(o.x, o.y, ctx.getAltColor(), width, 0.4);
        SFX.bomb(); // 借用炸弹音效，有冲击感
      }
    }),

    // [新] RISING_CRESCENT: 从屏幕底部升起两道月牙形弹幕，形成包夹
    RISING_CRESCENT: ()=>({
      cd: 2.2,
      nextCd(){ return Math.max(1.0, 3.0 / Math.max(0.6, ctx.getFireRate())); },
      fire(o){
        
        if(!o) return;
        const dmg = (6 + Math.log2(1+ctx.getLv())*2.8) * ctx.getDmgMul() * 0.7;
        
        // 左右两道月牙
        for(const side of [-1, 1]) {
          const count = 18;
          const sp = (ctx.team==='P') ? 500 : 350;
          const arcRadius = 120; // 月牙弧度半径
          
          for(let i=0; i<count; i++) {
            const k = i / (count - 1); // 0 to 1
            const angle = k * Math.PI; // 形成半圆
            
            // 计算每个子弹的初始位置 (在屏幕外底部)
            const spawnX = o.x + side * (arcRadius + 50);
            const spawnY = H + 40; // 从屏幕下方不可见处生成
            
            // 计算飞行方向 (朝向弧心，再向上偏移)
            const targetX = o.x + side * Math.cos(angle) * arcRadius;
            const targetY = o.y - Math.sin(angle) * arcRadius; // 向上弯曲
            
            const launchAngle = Math.atan2(targetY - spawnY, targetX - spawnX);
            
            spawnBullet(ctx.team, spawnX, spawnY, Math.cos(launchAngle)*sp, Math.sin(launchAngle)*sp, {
              r: 3.0, dmg, col: ctx.getColor(), style:0, life: 2.5,
              mods: ctx.getMods(), modCtx: {owner:o, team:ctx.team}
            });
          }
        }
        SFX.wave(); // 借用波次音效，有“警告”感
      }
    }),

DANCING_BLADES: () => ({
      cd: 3.0,
      nextCd: () => 4.0 / Math.max(0.6, ctx.getFireRate()),
      fire(o) {
        // 产生两个卫星刀片
        for (let i = 0; i < 2; i++) {
          // 初始速度设为 0，因为由词条控制位置
          spawnAt(o,0, 0, {
            r: 6, 
            dmg: 0, 
            life: 6, 
            style: 0, 
            col: C.E6, 
            mods: ['_BLADE_CORE'] 
          });
        }
      }
    }),

// [炫酷重载] FRACTAL_BURST: 发射分形母弹
    FRACTAL_BURST: () => ({
      cd: 2.2,
      nextCd: () => Math.max(1.0, 2.8 / Math.max(0.6, ctx.getFireRate())),
      fire(o) {
        const sp = (ctx.team === 'P') ? 350 : 220;
        const baseA = aimA(o);
        
        // 发射第一颗种子 (0代)
        const seed = spawnAt(o,baseA, sp, {
          r: 6.5,
          dmg: 20,
          life: 0.8, // 很快就会爆开
          style: 1,
          mods: ['_FRACTAL_SEED']
        });
        
        if (seed) seed._fGen = 0;
      }
    }),
  };

  /* ===================== NEW EMITTERS ===================== */

  // 3-shot fan (轻量)
  cat.TRI_FAN = ()=>({
    cd:0.33,
    nextCd(){ return Math.max(0.14, 0.48 / Math.max(0.6, ctx.getFireRate())); },
    fire(o){
      const base = aimA(o);
      const sp = (ctx.team==='P') ? 720 : 460;
      const dmg = (6.2 + Math.log2(1+ctx.getLv())*2.8) * ctx.getDmgMul() * 0.55;
      for(const k of [-1,0,1]){
        spawnAt(o,base + k*0.14, sp, {dmg, r:2.45, style:1, life:1.35});
      }
    }
  });

  // Burst 3 (直线高速三连)
  cat.BURST = ()=>({
    cd:0.75,
    nextCd(){ return Math.max(0.22, 1.00 / Math.max(0.6, ctx.getFireRate())); },
    fire(o){
      const base = aimA(o);
      const sp = (ctx.team==='P') ? 860 : 520;
      const dmg = (6.8 + Math.log2(1+ctx.getLv())*3.0) * ctx.getDmgMul() * 0.45;
      for(let i=0;i<3;i++){
        spawnAt(o,base + (i-1)*0.06, sp, {dmg, r:2.3, style:1, life:1.15});
      }
    }
  });

  // Flower (旋转连续，但自动留空隙)
  cat.FLOWER = ()=>({
    _a: defaultA,
    cd:0.10,
    nextCd(){ return Math.max(0.06, 0.10 / Math.max(0.6, ctx.getFireRate())); },
    fire(o){
      this._a += 0.33;
      if (Math.sin(this._a*2.4) > 0.82) return; // gap
      const sp = (ctx.team==='P') ? 520 : 320;
      const dmg = (5.6 + Math.log2(1+ctx.getLv())*2.6) * ctx.getDmgMul() * 0.55;
      spawnAt(o,this._a, sp, {dmg, r:2.3, style:0, life:2.0});
    }
  });

  // Nova pulse (小环)
  cat.NOVA_PULSE = ()=>({
    cd:1.10,
    nextCd(){ return Math.max(0.50, 1.50 / Math.max(0.6, ctx.getFireRate())); },
    fire(o){
      const n = (ctx.team==='P') ? 8 : 8;
      const sp = (ctx.team==='P') ? 420 : 260;
      const dmg = (5.4 + Math.log2(1+ctx.getLv())*2.4) * ctx.getDmgMul() * 0.45;
      const ph = Math.random()*Math.PI*2;
      for(let i=0;i<n;i++){
        spawnAt(o,ph + i*(Math.PI*2/n), sp, {dmg, r:2.2, style:0, life:1.35});
      }
    }
  });

  // Backshot (向“背后”打一发)
  cat.BACKSHOT = ()=>({
    cd:0.45,
    nextCd(){ return Math.max(0.16, 0.65 / Math.max(0.6, ctx.getFireRate())); },
    fire(o){
      const base = aimA(o) + Math.PI;
      const sp = (ctx.team==='P') ? 680 : 420;
      const dmg = (5.2 + Math.log2(1+ctx.getLv())*2.1) * ctx.getDmgMul() * 0.55;
      spawnAt(o,base, sp, {dmg, r:2.35, style:1, life:1.25});
    }
  });

  // Mini mine (复用 MINE 词条；玩家 mine 会爆炸打怪，敌方 mine 按你原逻辑爆炸打玩家)
  cat.MINI_MINE = ()=>({
    cd:1.10,
    nextCd(){ return Math.max(0.55, 1.55 / Math.max(0.6, ctx.getFireRate())); },
    fire(o){
      const sp = (ctx.team==='P') ? 120 : 95;
      const dmg = (8.0 + Math.log2(1+ctx.getLv())*3.2) * ctx.getDmgMul() * 0.55;

      const mods = (typeof mergeMods==='function') ? mergeMods(ctx.getMods(), ['MINE']) : ['MINE'];
      const a = (ctx.team==='P') ? (-Math.PI/2 + (Math.random()*0.3-0.15)) : (Math.PI/2 + (Math.random()*0.3-0.15));

      // 直接设 mineT，保证生效
      spawnAt(o,a, sp, {dmg, r:5.8, style:0, life:2.2, mods, mineT:0.95});
    }
  });

  /* ===================== 壮美新发射器 - 精心设计 ===================== */

  // SPIRAL_GALAXY - 螺旋星系：双螺旋臂向外扩散，形成星系般的壮美弹幕
  cat.SPIRAL_GALAXY = ()=>({
    _phase: 0,
    cd: 0.08,
    nextCd(){ return Math.max(0.04, 0.10 / Math.max(0.6, ctx.getFireRate())); },
    fire(o){
      this._phase += 0.22;
      const hf = hellFactor();
      const sp = (ctx.team==='P') ? 450 : 280;
      const dmg = (5.8 + Math.log2(1+ctx.getLv())*2.7) * ctx.getDmgMul() * 0.52;
      
      // 双螺旋臂，每条臂由多个子弹组成
      for(const arm of [0, Math.PI]){
        for(let layer=0; layer<2; layer++){
          const a = this._phase + arm + layer*0.15;
          const radius = 8 + layer*6;
          spawnBullet(ctx.team, 
            o.x + Math.cos(a)*radius, 
            o.y + yOff + Math.sin(a)*radius,
            Math.cos(a)*sp, Math.sin(a)*sp, {
              r: 2.6 + layer*0.4,
              dmg, 
              col: layer===0 ? ctx.getColor() : ctx.getAltColor(),
              spr: layer===0 ? (ctx.team==='P' ? 'glowP':'glowE') : (ctx.team==='P' ? 'glowP2':'glowE2'),
              style:1, 
              life:2.2,
              mods: ctx.getMods(),
              modCtx: {owner:o, team:ctx.team}
            });
        }
      }
      
      // 每隔一定角度产生星云效果
      if(Math.abs(Math.sin(this._phase*3)) > 0.92){
        sparks(o.x, o.y+yOff, ctx.team==='P'?'glowP2':'glowE3', 5, 280);
      }
    }
  });

  // PHOENIX_WING - 凤凰之翼：左右对称的华丽弧形弹幕，如凤凰展翅
  cat.PHOENIX_WING = ()=>({
    cd: 1.8,
    nextCd(){ return Math.max(0.9, 2.4 / Math.max(0.6, ctx.getFireRate())); },
    fire(o){
      const hf = hellFactor();
      const sp = (ctx.team==='P') ? 520 : 340;
      const dmg = (7.5 + Math.log2(1+ctx.getLv())*3.2) * ctx.getDmgMul() * 0.68;
      const baseA = aimA(o);
      
      // 每侧翅膀由多层羽毛组成
      for(const side of [-1, 1]){
        const count = 12;
        for(let i=0; i<count; i++){
          const k = i / (count-1); // 0 to 1
          
          // 翅膀弧度：从前方向两侧展开，形成优雅的曲线
          const wingAngle = baseA + side * (0.3 + k*1.2);
          const wingRadius = 15 + k*25;
          
          // 羽毛渐变色彩
          const featherCol = k < 0.5 ? ctx.getColor() : ctx.getAltColor();
          const featherSpr = k < 0.5 ? (ctx.team==='P'?'glowP':'glowE') : (ctx.team==='P'?'glowP2':'glowE2');
          
          spawnBullet(ctx.team,
            o.x + Math.cos(wingAngle)*wingRadius,
            o.y + yOff + Math.sin(wingAngle)*wingRadius,
            Math.cos(wingAngle)*sp*(0.9+k*0.3),
            Math.sin(wingAngle)*sp*(0.9+k*0.3), {
              r: 3.2 - k*0.8,
              dmg: dmg*(1.0 - k*0.3),
              col: featherCol,
              spr: featherSpr,
              style: 1,
              life: 2.0 + k*0.5,
              mods: ctx.getMods(),
              modCtx: {owner:o, team:ctx.team}
            });
        }
      }
      
      // 翅膀中心的核心能量球
      spawnAt(o, baseA, sp*1.2, {
        dmg: dmg*1.5, r:4.5, style:1, life:1.8,
        col: ctx.team==='P' ? C.Y : C.E6
      });
      
      // 壮美的视觉效果
      spawnShockwave(o.x, o.y+yOff, ctx.getColor(), 200, 0.5);
      SFX.bomb();
    }
  });

  // STELLAR_NOVA - 恒星新星：爆发式的全方位闪耀弹幕，层层递进
  cat.STELLAR_NOVA = ()=>({
    cd: 2.5,
    nextCd(){ return Math.max(1.2, 3.2 / Math.max(0.6, ctx.getFireRate())); },
    fire(o){
      const hf = hellFactor();
      const dmg = (6.8 + Math.log2(1+ctx.getLv())*2.9) * ctx.getDmgMul() * 0.58;
      
      // 三层爆发，每层不同速度和密度
      const layers = [
        {count:8, speed:180, r:2.2, delay:0},
        {count:16, speed:280, r:2.8, delay:0.08},
        {count:24, speed:380, r:3.4, delay:0.16}
      ];
      
      layers.forEach((layer, idx) => {
        setTimeout(() => {
          if(!o || !o.alive) return;
          const phase = rand(0, Math.PI*2);
          // 不同层使用不同颜色
          const layerCol = idx===0 ? ctx.getColor() : (idx===1 ? ctx.getAltColor() : C.Y);
          const layerSpr = idx===0 ? (ctx.team==='P'?'glowP':'glowE') : 
                          idx===1 ? (ctx.team==='P'?'glowP2':'glowE2') : 'glowY';
          
          for(let i=0; i<layer.count; i++){
            const a = phase + (i/layer.count)*Math.PI*2;
            const sp = (ctx.team==='P' ? layer.speed*1.4 : layer.speed);
            
            spawnBullet(ctx.team, o.x, o.y+yOff,
              Math.cos(a)*sp, Math.sin(a)*sp, {
                r: layer.r,
                dmg: dmg * (1.0 - idx*0.15),
                col: layerCol,
                spr: layerSpr,
                style: 1,
                life: 2.0 - idx*0.3,
                mods: ctx.getMods(),
                modCtx: {owner:o, team:ctx.team}
              });
          }
          
          // 每层爆发的视觉效果
          sparks(o.x, o.y+yOff, layerSpr, 15+idx*8, 400+idx*200);
          spawnShockwave(o.x, o.y+yOff, layerCol, 120+idx*60, 0.4+idx*0.1);
          
        }, layer.delay * 1000);
      });
      
      // 主爆发音效
      SFX.bomb();
      addShake(5, 0.15);
    }
  });

  // LOTUS_BLOOM - 莲花绽放：像莲花一样优雅绽放的多层次弹幕
  cat.LOTUS_BLOOM = ()=>({
    cd: 2.0,
    nextCd(){ return Math.max(1.0, 2.6 / Math.max(0.6, ctx.getFireRate())); },
    fire(o){
      const hf = hellFactor();
      const dmg = (6.5 + Math.log2(1+ctx.getLv())*2.8) * ctx.getDmgMul() * 0.60;
      
      // 莲花瓣层数，从内到外
      const petalLayers = [
        {count:6, radius:12, speed:220, r:2.5},
        {count:8, radius:24, speed:260, r:3.0},
        {count:12, radius:38, speed:300, r:3.5}
      ];
      
      petalLayers.forEach((layer, idx) => {
        const phase = idx * (Math.PI/layer.count); // 错开排列
        
        for(let i=0; i<layer.count; i++){
          const a = phase + (i/layer.count)*Math.PI*2;
          const sp = (ctx.team==='P' ? layer.speed*1.3 : layer.speed);
          
          // 花瓣从中心位置向外射出
          const startX = o.x + Math.cos(a)*layer.radius;
          const startY = o.y + yOff + Math.sin(a)*layer.radius;
          
          // 渐变色彩模拟花瓣
          const petalCol = idx===0 ? C.P2 : (idx===1 ? ctx.getColor() : ctx.getAltColor());
          const petalSpr = idx===0 ? 'glowP2' : (idx===1 ? (ctx.team==='P'?'glowP':'glowE') : 'glowE2');
          
          spawnBullet(ctx.team, startX, startY,
            Math.cos(a)*sp, Math.sin(a)*sp, {
              r: layer.r,
              dmg: dmg * (1.1 - idx*0.15),
              col: petalCol,
              spr: petalSpr,
              style: 1,
              life: 2.2,
              angVel: (chance(0.5)?1:-1) * (0.8 + idx*0.3), // 花瓣旋转
              mods: ctx.getMods(),
              modCtx: {owner:o, team:ctx.team}
            });
        }
      });
      
      // 莲花中心的光芒
      spawnAt(o, 0, 0, {
        dmg: 0, r:8, style:0, life:0.6,
        col: C.Y, spr: 'glowY'
      });
      
      sparks(o.x, o.y+yOff, 'glowP2', 20, 350);
      spawnShockwave(o.x, o.y+yOff, C.P2, 180, 0.45);
    }
  });

  // DRAGON_BREATH - 龙息：波浪形的前方强力弹幕，如龙吐息
  cat.DRAGON_BREATH = ()=>({
    cd: 1.5,
    nextCd(){ return Math.max(0.7, 2.0 / Math.max(0.6, ctx.getFireRate())); },
    fire(o){
      const hf = hellFactor();
      const dmg = (8.2 + Math.log2(1+ctx.getLv())*3.5) * ctx.getDmgMul() * 0.72;
      const baseA = aimA(o);
      
      // 龙息由多股火焰流组成
      const streams = 5;
      const breathWidth = 0.65; // 龙息扩散角度
      
      for(let stream=0; stream<streams; stream++){
        const streamAngle = baseA + (stream/(streams-1) - 0.5)*breathWidth;
        const bullets = 8;
        
        for(let i=0; i<bullets; i++){
          const progress = i/bullets;
          const sp = (ctx.team==='P' ? 450 : 320) * (0.8 + progress*0.5);
          
          // 火焰渐变从红到黄
          const flameCol = progress < 0.3 ? C.R : (progress < 0.6 ? C.Y : ctx.getColor());
          const flameSpr = progress < 0.3 ? 'glowR' : (progress < 0.6 ? 'glowY' : (ctx.team==='P'?'glowP':'glowE'));
          
          // 错开发射时间，形成连续火焰流
          setTimeout(() => {
            if(!o || !o.alive) return;
            
            // 龙息带有波动
            const waveOffset = Math.sin(progress*Math.PI*3 + Game.time*8)*0.12;
            
            spawnBullet(ctx.team, o.x, o.y+yOff,
              Math.cos(streamAngle + waveOffset)*sp,
              Math.sin(streamAngle + waveOffset)*sp, {
                r: 3.5 - progress*0.8,
                dmg: dmg * (1.2 - progress*0.4),
                col: flameCol,
                spr: flameSpr,
                style: 1,
                life: 1.8 - progress*0.3,
                mods: mergeMods(ctx.getMods(), ['TRAIL']), // 龙息留下轨迹
                modCtx: {owner:o, team:ctx.team}
              });
          }, i * 25);
        }
      }
      
      // 龙息音效和视觉
      SFX.enemyShoot(C.R);
      addShake(3, 0.12);
    }
  });

  // COSMIC_VORTEX - 宇宙漩涡：旋转收缩再爆发的复杂弹幕
  cat.COSMIC_VORTEX = ()=>({
    cd: 3.0,
    nextCd(){ return Math.max(1.5, 3.8 / Math.max(0.6, ctx.getFireRate())); },
    fire(o){
      const hf = hellFactor();
      const dmg = (7.0 + Math.log2(1+ctx.getLv())*3.0) * ctx.getDmgMul() * 0.65;
      
      // 第一阶段：向内旋转收缩
      const spiralArms = 3;
      const bulletsPerArm = 16;
      
      for(let arm=0; arm<spiralArms; arm++){
        const armPhase = (arm/spiralArms)*Math.PI*2;
        
        for(let i=0; i<bulletsPerArm; i++){
          const progress = i/bulletsPerArm;
          const spiralRadius = 180 - progress*160; // 从外到内
          const spiralAngle = armPhase + progress*Math.PI*4;
          
          // 计算目标点（漩涡中心）
          const targetX = o.x + Math.cos(spiralAngle)*spiralRadius;
          const targetY = o.y + yOff + Math.sin(spiralAngle)*spiralRadius;
          
          setTimeout(() => {
            if(!o || !o.alive) return;
            
            // 向中心飞行
            const toCenter = Math.atan2(o.y+yOff - targetY, o.x - targetX);
            const sp = (ctx.team==='P' ? 350 : 240);
            
            const vortexCol = progress < 0.5 ? C.P2 : ctx.getColor();
            const vortexSpr = progress < 0.5 ? 'glowP2' : (ctx.team==='P'?'glowP':'glowE');
            
            const bullet = spawnBullet(ctx.team, targetX, targetY,
              Math.cos(toCenter)*sp, Math.sin(toCenter)*sp, {
                r: 2.8,
                dmg: dmg * 0.5,
                col: vortexCol,
                spr: vortexSpr,
                style: 1,
                life: 1.5,
                angVel: (arm%2===0?1:-1)*3.5, // 旋转
                mods: ctx.getMods(),
                modCtx: {owner:o, team:ctx.team}
              });
              
            // 到达中心后爆发
            if(bullet) {
              bullet.onDeath = () => {
                if(Math.hypot(bullet.x - o.x, bullet.y - (o.y+yOff)) < 40){
                  // 中心爆发
                  const burstCount = 6;
                  for(let j=0; j<burstCount; j++){
                    const burstA = (j/burstCount)*Math.PI*2 + rand(-0.2,0.2);
                    spawnBullet(ctx.team, o.x, o.y+yOff,
                      Math.cos(burstA)*280, Math.sin(burstA)*280, {
                        r: 3.2, dmg: dmg*0.7,
                        col: C.Y, spr: 'glowY', style:1, life:1.6,
                        depth: 1
                      });
                  }
                }
              };
            }
            
          }, i * 40);
        }
      }
      
      // 漩涡视觉效果
      spawnShockwave(o.x, o.y+yOff, C.P2, 200, 0.5);
      SFX.wave();
    }
  });

  // Arc pair (一对弯曲弹)
  cat.ARC_PAIR = ()=>({
    cd:0.55,
    nextCd(){ return Math.max(0.20, 0.80 / Math.max(0.6, ctx.getFireRate())); },
    fire(o){
      const base = aimA(o);
      const sp = (ctx.team==='P') ? 640 : 420;
      const dmg = (6.0 + Math.log2(1+ctx.getLv())*2.6) * ctx.getDmgMul() * 0.55;
      spawnAt(o,base, sp, {dmg, r:2.4, style:1, life:1.55, angVel: +1.8});
      spawnAt(o,base, sp, {dmg, r:2.4, style:1, life:1.55, angVel: -1.8});
    }
  });
  
    // ================= Composite Emitter 预设 =================

  cat.MIRROR_FAN = ()=>{
    const b = cat.FAN();
    const w = CompositeWrappers.MIRROR(()=>b, {mirrorOffset:22});
    w.type = 'MIRROR_FAN';
    return w;
  };

  cat.MIRROR_SPIRAL = ()=>{
    const b = cat.SPIRAL();
    const w = CompositeWrappers.MIRROR(()=>b, {mirrorOffset:20});
    w.type = 'MIRROR_SPIRAL';
    return w;
  };

  cat.SALVO_SHOTGUN = ()=>{
    const b = cat.SHOTGUN();
    const w = CompositeWrappers.SALVO(()=>b, {salvoCount:3, salvoInterval:0.07});
    w.type = 'SALVO_SHOTGUN';
    return w;
  };

  cat.SALVO_BURST = ()=>{
    const b = cat.BURST();
    const w = CompositeWrappers.SALVO(()=>b, {salvoCount:3, salvoInterval:0.06});
    w.type = 'SALVO_BURST';
    return w;
  };

  cat.SWEEP_FAN = ()=>{
    const b = cat.FAN();
    const w = CompositeWrappers.ROTATE_SWEEP(()=>b, {sweepSpeed:1.4, sweepArc:0.9});
    w.type = 'SWEEP_FAN';
    return w;
  };

  cat.ALT_FAN_RING = ()=>{
    const w = CompositeWrappers.INTERLEAVE(()=>cat.FAN(), {
      factoryB:()=>cat.RING(), pattern:[0,0,1]
    });
    w.type = 'ALT_FAN_RING';
    return w;
  };

  cat.ALT_SHOT_SPIRAL = ()=>{
    const w = CompositeWrappers.INTERLEAVE(()=>cat.SHOTGUN(), {
      factoryB:()=>cat.SPIRAL(), pattern:[0,1,1]
    });
    w.type = 'ALT_SHOT_SPIRAL';
    return w;
  };

  cat.DELAYED_RING = ()=>{
    const b = cat.RING();
    const w = CompositeWrappers.DELAYED_WAVE(()=>b, {pauseDur:0.25});
    w.type = 'DELAYED_RING';
    return w;
  };
  
  cat.WIDENING_FAN_AIM = ()=>{
    const b = cat.FAN();
    const w = CompositeWrappers.WIDENING_FAN(()=>b, {maxSpread:Math.PI*0.5, steps:4});
    w.type = 'WIDENING_FAN_AIM';
    return w;
  };

  cat.SPIRAL_ARMS_FAN = ()=>{
    const b = cat.FAN();
    const w = CompositeWrappers.SPIRAL_ARMS(()=>b, {arms:3, rotSpeed:1.3});
    w.type = 'SPIRAL_ARMS_FAN';
    return w;
  };

  cat.DOUBLE_HELIX_AIM = ()=>{
    const b = cat.TRI_FAN();
    const w = CompositeWrappers.DOUBLE_HELIX(()=>b, {helixSpeed:1.8});
    w.type = 'DOUBLE_HELIX_AIM';
    return w;
  };

  cat.ACCEL_RING = ()=>{
    const b = cat.RING();
    const w = CompositeWrappers.ACCEL_WAVE(()=>b, {accelVal:240});
    w.type = 'ACCEL_RING';
    return w;
  };

  cat.BOOMERANG_FAN = ()=>{
    const b = cat.FAN();
    const w = CompositeWrappers.BOOMERANG_WRAP(()=>b, {reverseAt:0.50});
    w.type = 'BOOMERANG_FAN';
    return w;
  };

  cat.SCATTER_BURST = ()=>{
    const b = cat.BURST();
    const w = CompositeWrappers.FOCUSED_SCATTER(()=>b, {scatterCount:5, scatterSpread:0.40});
    w.type = 'SCATTER_BURST';
    return w;
  };

  cat.STACKED_NOVA = ()=>{
    const b = cat.NOVA_PULSE();
    const w = CompositeWrappers.STACKED_RING(()=>b, {layers:3, layerInterval:0.10});
    w.type = 'STACKED_NOVA';
    return w;
  };

  cat.ALT_HELIX_RING = ()=>{
    const w = CompositeWrappers.INTERLEAVE(
      ()=> CompositeWrappers.DOUBLE_HELIX(()=>cat.TRI_FAN(), {helixSpeed:1.6}),
      { factoryB:()=>cat.RING(), pattern:[0,0,0,1] }
    );
    w.type = 'ALT_HELIX_RING';
    return w;
  };

  // EMpyrean Lance：神圣长枪，分段刺击 + 侧翼副炮
  cat.EMPYREAN_LANCE = ()=>({
    cd: 1.45,
    nextCd(){ return Math.max(0.68, 1.9 / Math.max(0.6, ctx.getFireRate())); },
    fire(o){
      const a = aimA(o);
      const sp = (ctx.team==='P') ? 700 : 520;
      const dmg = (8.4 + Math.log2(1+ctx.getLv())*3.6) * ctx.getDmgMul() * (ctx.team==='P' ? 0.9 : 0.62);
      for (let i=0;i<3;i++){
        const k = i/2;
        spawnAt(o, a, sp*(0.82 + k*0.32), {
          dmg: dmg*(1.0 + k*0.2), r: 2.6 + k*0.7,
          life: 1.35 + k*0.2, pierce: 1,
          col: (i===2) ? ctx.getAltColor() : ctx.getColor(),
          spr: (i===2) ? (ctx.team==='P'?'glowP2':'glowE2') : (ctx.team==='P'?'glowP':'glowE')
        });
      }
      for (const side of [-1,1]){
        spawnAt(o, a + side*0.22, sp*0.76, {
          dmg:dmg*0.58, r:2.4, life:1.65,
          col:ctx.getAltColor(),
        });
      }
    }
  });

  // Celestial Corona：天冠涌环，先内后外封锁空间
  cat.CELESTIAL_CORONA = ()=>({
    cd: 2.15,
    nextCd(){ return Math.max(1.05, 2.8 / Math.max(0.6, ctx.getFireRate())); },
    fire(o){
      const base = aimA(o);
      const sp = (ctx.team==='P') ? 540 : 360;
      const dmg = (7.2 + Math.log2(1+ctx.getLv())*3.0) * ctx.getDmgMul() * (ctx.team==='P' ? 0.82 : 0.58);
      const rings = [10, 16, 22];
      rings.forEach((count, idx)=>{
        const phase = base + idx*0.18;
        for (let i=0;i<count;i++){
          const a = phase + i*(Math.PI*2/count);
          const b = spawnAt(o, a, sp*(0.86 + idx*0.18), {
            dmg:dmg*(1.05 - idx*0.16), r:2.4 + idx*0.3,
            life:2.1 - idx*0.15,
            col: idx===0 ? ctx.getColor() : (idx===1 ? ctx.getAltColor() : C.Y),
            spr: idx===2 ? 'glowY' : (idx===1 ? (ctx.team==='P'?'glowP2':'glowE2') : (ctx.team==='P'?'glowP':'glowE')),
          });
          if (b){
            b.waveA = 20 + idx*8;
            b.waveF = 4.5 + idx*0.8;
            b.waveP = phase;
          }
        }
      });
      spawnShockwave(o.x, o.y+yOff, ctx.getColor(), 130, 0.24);
    }
  });
  
  // [核心机制] 全自动包装器
for (const key in cat) {
  const originalFactory = cat[key];
  cat[key] = (cfg) => {
    const em = originalFactory();
    if (cfg) Object.assign(em, cfg);

    const originalFire = em.fire;
    em.fire = function(owner) {
      const lastCur = ctx._cur;   // 备份上一个执行者
      const lastEm = ctx._curEm;  // 备份上一个发射器
      
      ctx._cur = owner;
      ctx._curEm = this;
      
      originalFire.call(this, owner);
      
      ctx._cur = lastCur;         // 还原，而不是直接设为 null
      ctx._curEm = lastEm;        // 还原
    };

    em.type = em.type || key;
    return em;
  };
}

  return cat;
}

// ----- Player side: reuse unified catalog -----
const PlayerEmitterCatalog = makeEmitterCatalog({
  team:'P',
  getOwner: ()=>Player,
  getTarget: ()=>findNearestEnemy(Player.x, Player.y-140, 760),
  getFireRate: ()=> Player.fireRate * (Player.overdriveT>0 ? 1.10 : 1.0),
  getDmgMul: ()=> Player.dmgMul * (Player.overdriveT>0 ? 1.05 : 1.0),
  getLv: ()=> Player.lv,
  getMods: ()=> Player.gunMods,
  getColor: ()=> C.P1,
  getAltColor: ()=> C.P2,
});

function setupPlayerEmittersFromBuild(build){
  Player.emitters = Player.emitters || [];
  Player.emitterSeq = 0;
  Player.emitters.length = 0;

  const list = (build?.emitters || []).slice(0, Player.emittersMax || 3);
  for(const type of list){
    const mk = PlayerEmitterCatalog[type];
    if (!mk) continue;
    const em = mk();
    em.type = type;
    em.cd = 0.15 + Math.random()*0.35;
    em._born = ++Player.emitterSeq;
    Player.emitters.push(em);
  }
}

function isFortressPrepPhase(){
  return (Game.mode==='fortress' || Game.mode==='lab' || Game.mode==='fortress_duel') && Fortress?.phase==='fortify';
}

function updatePlayerEmitters(dt){
  if (isFortressPrepPhase()) return;
  if (!Player.emitters?.length) return;
  for(const em of Player.emitters){
    em.cd -= dt;
    if (em.cd>0) continue;
    em.cd = em.nextCd(Player, dt);
    em.fire(Player);
  }
}

// ----- Rival side (Build B): reuse the SAME unified catalog -----
function setupRivalEmittersFromBuild(e, build){
  const b = build || {};
  const RivalCatalog = makeEmitterCatalog({
    team:'E',
    getOwner: ()=>e,
    getTarget: ()=> (Player.alive ? Player : null),
    getFireRate: ()=> clamp(b.fireRate||1, 0.5, 3.0),
    getDmgMul: ()=> (b.dmgMul||1),
    getLv: ()=> Player.lv, // scale with player level (same as你之前风格)
    getMods: ()=> (b.gunMods||[]).slice(0, 6),
    getColor: ()=> (e.tint || e.baseCol || C.E6),
    getAltColor: ()=> C.Y,
  });

  e._emitters = [];
  e._emitSeq = 0;

  const list = (b.emitters || []).slice(0, 3);
  for(const type of list){
    const mk = RivalCatalog[type];
    if (!mk) continue;
    const em = mk();
    em.type = type;
    em.cd = 0.15 + Math.random()*0.35;
    em._born = ++e._emitSeq;
    e._emitters.push(em);
  }
}

function updateRivalEmitters(e, dt){
if (e._emitters?.length){
  for(const emitter of e._emitters){
    emitter.cd -= dt;
    if (emitter.cd <= 0){
      emitter.cd = emitter.nextCd(e, dt);
      emitter.fire(e);
    }
  }
}
}

function grantPlayerComposite(){
    if (Game.mode==='fortress_duel') return;
    if (!Player.emitters?.length) {
      // 没有 emitter，先给一个基础的
      grantPlayerEmitter();
      return;
    }

    // 可用包装器列表（从简单到复杂，波数越高解锁越多）
    const w = Game.wave;
    const pool = [];
    pool.push({key:'ALTERNATING',    weight:1.2, cfg:{altOffset:0.35}});
    pool.push({key:'ACCEL_WAVE',     weight:1.0, cfg:{accelVal:220}});
    pool.push({key:'WIDENING_FAN',   weight:1.0, cfg:{maxSpread:Math.PI*0.5, steps:4}});
    if (w>=2) pool.push({key:'MIRROR',         weight:0.9, cfg:{mirrorOffset:22}});
    if (w>=2) pool.push({key:'BOOMERANG_WRAP', weight:0.8, cfg:{reverseAt:0.50}});
    if (w>=3) pool.push({key:'SALVO',          weight:0.9, cfg:{salvoCount:2, salvoInterval:0.07}});
    if (w>=3) pool.push({key:'DOUBLE_HELIX',   weight:0.7, cfg:{helixSpeed:1.5}});
    if (w>=4) pool.push({key:'ROTATE_SWEEP',   weight:0.8, cfg:{sweepSpeed:1.2, sweepArc:0.8}});
    if (w>=4) pool.push({key:'SPIRAL_ARMS',    weight:0.6, cfg:{arms:2, rotSpeed:1.2}});
    if (w>=5) pool.push({key:'DELAYED_WAVE',   weight:0.7, cfg:{pauseDur:0.25}});
    if (w>=5) pool.push({key:'STACKED_RING',   weight:0.5, cfg:{layers:2, layerInterval:0.10}});
    if (w>=6) pool.push({key:'FOCUSED_SCATTER', weight:0.5, cfg:{scatterCount:5, scatterSpread:0.45}});

    // 加权随机选一个包装器
    let sum = 0;
    for(const p of pool) sum += p.weight;
    let roll = Math.random() * sum;
    let picked = pool[0];
    for(const p of pool){ roll -= p.weight; if(roll<=0){ picked=p; break; } }

    const wrapperFn = CompositeWrappers[picked.key];
    if (!wrapperFn) return;

    // 选一个现有 emitter 进行包装
    const idx = randi(0, Player.emitters.length - 1);
    const oldEm = Player.emitters[idx];

    // 如果已经是 composite，有 40% 概率替换而不是嵌套
    if (oldEm._composite && chance(0.40)){
      // 把原始 base 拿出来重新包装
      const baseEm = oldEm._base || oldEm;
      const wrapped = wrapperFn(() => baseEm, Object.assign({}, picked.cfg, {baseCfg:{}}));
      wrapped.type = `${picked.key}<${baseEm.type||'?'}>`;
      wrapped.cd = oldEm.cd;
      wrapped._born = oldEm._born;
      Player.emitters[idx] = wrapped;
      textPop(Player.x, Player.y-16, `REWRAP: ${picked.key}`, C.Y);
    } else {
      // 正常包装
      const wrapped = wrapperFn(() => oldEm, Object.assign({}, picked.cfg, {baseCfg:{}}));
      wrapped.type = `${picked.key}<${oldEm.type||'?'}>`;
      wrapped.cd = oldEm.cd;
      wrapped._born = oldEm._born;
      Player.emitters[idx] = wrapped;
      textPop(Player.x, Player.y-16, `WRAP: ${picked.key}`, C.Y);
    }

    spawnShockwave(Player.x, Player.y, C.Y, 260, 0.50);
    addShake(4, 0.12);
    beep({f:660, t:0.06, g:0.03, type:'triangle', slide:1.15});
  }

function grantPlayerEmitter(){
  if (Game.mode==='fortress_duel') return false;
  const keys = Object.keys(PlayerEmitterCatalog);
  if (!keys.length) return false;

  // 尽量不给重复；都拥有了就允许重复
  const owned = new Set(Player.emitters.map(e=>e.type));
  const pool = keys.filter(k=>!owned.has(k));
  const pick = (pool.length ? pool : keys)[(Math.random()*(pool.length?pool.length:keys.length))|0];

  // new emitter instance
  const em = PlayerEmitterCatalog[pick]();
  em.type = pick;
  em.cd = 0.15 + Math.random()*0.35;
  em._born = (Player.emitterSeq = (Player.emitterSeq||0) + 1); // 用于找“最旧”

  // 未满：直接加
  if (Player.emitters.length < Player.emittersMax){
    Player.emitters.push(em);
    textPop(Player.x, Player.y-16, 'EMIT: '+pick, C.Y);
    spawnShockwave(Player.x, Player.y, C.Y, 220, 0.45);
    return true;
  }

  // 已满：顶掉最旧
  let idx = 0, best = Infinity;
  for(let i=0;i<Player.emitters.length;i++){
    const b = Player.emitters[i]._born ?? 0;
    if (b < best){ best=b; idx=i; }
  }
  const old = Player.emitters[idx]?.type || 'OLD';
  Player.emitters[idx] = em;

  textPop(Player.x, Player.y-16, `EMIT: ${old} > ${pick}`, C.Y);
  spawnShockwave(Player.x, Player.y, C.Y, 240, 0.45);
  return true;
}

  function firePlayer(dt){
    if (!Player.alive) return;
    if (UnitBattle.active) return;
    if (isFortressPrepPhase()) return;
    Player.fireCd -= dt;
    if (Player.fireCd>0) return;

    const lv=Player.lv;
    const od = Player.overdriveT>0;
    const rateMul = Player.fireRate * (od?1.28:1.0);

    const baseCd = 0.20 - Math.min(0.11, Math.log2(1+lv)*0.012);
    Player.fireCd = Math.max(0.060, baseCd / rateMul);

    const dmgBase = (9 + Math.log2(1+lv)*6.2) * Player.dmgMul * (od?1.12:1.0);
    const sp = 620;
    const x=Player.x, y=Player.y-Player.r-8;

    const lanes = (lv<3)?1:(lv<8?3:(lv<14?4:(lv<22?5:(lv<30?6:7))));
    const spread = clamp(0.10 + Math.log2(1+lv)*0.03, 0.10, 0.34);

    const baseMods = od ? mergeMods(Player.gunMods, ['TRAIL']) : Player.gunMods;

    for(let i=0;i<lanes;i++){
      const t = (lanes===1)?0:(i/(lanes-1))-0.5;
      const a = t*spread;
      const vx = Math.sin(a)*140;
      const vy = -sp*Math.cos(a);
      const b = spawnBullet('P', x+t*16, y, vx, vy, {
        r:3.0, dmg:dmgBase, col:C.P1, spr:'glowP', style:1, life:2.1,
        pierce: Player.pierceBase,
        mods: baseMods,
        modCtx: {owner:Player, team:'P'}
      });
      if (!b) continue;
      if (chance(Player.crit)) { b.dmg *= 1.55; b.col=C.P2; b.spr='glowP2'; b.r=3.3; }
    }

    // side wing shots (mild)
    if (lv >= 6 && chance(0.35)){
      spawnBullet('P', x-14, y+6, -240, -520, {r:2.7, dmg:dmgBase*0.50, col:C.P1, spr:'glowP', style:1, life:1.6, pierce:1, mods: baseMods, modCtx:{owner:Player,team:'P'}});
      spawnBullet('P', x+14, y+6,  240, -520, {r:2.7, dmg:dmgBase*0.50, col:C.P1, spr:'glowP', style:1, life:1.6, pierce:1, mods: baseMods, modCtx:{owner:Player,team:'P'}});
    }

    // rail shot (rare)
    if (lv>=10 && chance(0.14)){
      const b = spawnBullet('P', x, y-6, 0, -940, {r:2.7, dmg:dmgBase*1.25, col:C.P2, spr:'glowP2', style:1, life:1.15, pierce:Math.max(Player.pierceBase,2), mods: baseMods, modCtx:{owner:Player,team:'P'}});
      if(b) b.noHitT=0.04;
    }

    // missiles
    if (lv>=14 && Player.homingAmmo>0 && chance(0.18)){
      const t = findNearestEnemy(x,y);
      if (t){
        Player.homingAmmo--;
        spawnHomingMissile(x-10, y+8, t);
        spawnHomingMissile(x+10, y+8, t);
      }
    }

    // drones
    if (Player.drones>0){
      for(let i=0;i<Player.drones;i++){
        const ang = Game.time*2.2 + i*(Math.PI*2/Player.drones);
        const dx = Math.cos(ang)*22;
        const dy = Math.sin(ang)*10;
        if (chance(0.55)){
          spawnBullet('P', Player.x+dx, Player.y+dy, 0, -560, {r:2.5, dmg:dmgBase*0.62, col:C.P1, spr:'glowP', style:1, life:1.7, pierce:1, mods: baseMods, modCtx:{owner:Player,team:'P'}});
        }
      }
    }

    if (audioOn && chance(0.14)) beep({f:560,t:0.02,g:0.010,type:'triangle',slide:1.10});
  }

  // ================= Bomb =================
  function useBomb(){
    if (UnitBattle.active) return;
    if (Player.bomb<=0) return;
    Player.bomb--;
    ui.bombText.textContent = Player.bomb;

    const sx = Player.x, sy = Player.y;
    const shockR = (Game.mode==='fortress_duel') ? 260 : 520;

    // 对战模式：改为冲击波直达判定；其余模式保留原炸屏
    if (Game.mode==='fortress_duel' && Multiplayer?.isActive?.()){
      Multiplayer.sendServer({type:'peer_hit', kind:'bomb_shock', dmg:1, x:sx, y:sy, r:shockR});
      const lineRectHit = (ax,ay,bx,by, st)=>{
        const steps = Math.max(8, Math.ceil(Math.hypot(bx-ax, by-ay) / 10));
        const l = st.x - st.w*0.5, r = st.x + st.w*0.5, t = st.y - st.h*0.5, b = st.y + st.h*0.5;
        for (let i=0;i<=steps;i++){
          const k = i/steps;
          const px = ax + (bx-ax)*k, py = ay + (by-ay)*k;
          if (px>=l && px<=r && py>=t && py<=b) return true;
        }
        return false;
      };
      const blockedByStruct = (ax,ay,bx,by, structures, ignoreId=null)=>{
        for (const st of (structures||[])){
          if (!st || (st.hp||0)<=0) continue;
          if (ignoreId!=null && st.id===ignoreId) continue;
          if (lineRectHit(ax,ay,bx,by, st)) return true;
        }
        return false;
      };

      for (const peer of Multiplayer.peers.values()){
        const pp = Multiplayer.projectedPeer(peer);
        const pf = Multiplayer.projectedPeerFortress?.(peer);
        if (pf){
          for (const st of (pf.structures||[])){
            if ((st.hp||0)<=0) continue;
            if (Math.hypot(st.x-sx, st.y-sy) > shockR) continue;
            if (blockedByStruct(sx,sy,st.x,st.y,pf.structures, st.id)) continue;
            Multiplayer.sendServer({type:'peer_hit', dmg:Math.max(1, (st.hp||1)*0.5), kind:'structure', sid:st.id});
          }
          if ((pf.flagInvulnT||0)<=0 && Math.hypot(pf.flagX-sx, pf.flagY-sy) <= shockR){
            if (!blockedByStruct(sx,sy,pf.flagX,pf.flagY,pf.structures,null)){
              const fdmg = Math.max(1, (pf.flagHp||1)*0.5);
              Multiplayer.sendServer({type:'peer_hit', dmg:fdmg, kind:'flag'});
              if (fdmg >= (pf.flagHp||1)){
                spawnShockwave(pf.flagX, pf.flagY, C.E1, 220, 0.75);
                sparks(pf.flagX, pf.flagY, 'glowE2', 46, 620);
                beep({f:160,t:0.25,g:0.05,type:'sawtooth',slide:0.6});
              }
            }
          }
        }
        if (pp && peer.alive!==false && Math.hypot(pp.x-sx, pp.y-sy) <= shockR){
          if (!blockedByStruct(sx,sy,pp.x,pp.y,pf?.structures||[],null)){
            Multiplayer.sendServer({type:'peer_hit', dmg:Math.max(1, (pp.hp||1)*0.5), kind:'player_half'});
          }
        }
      }

      sparks(Player.x, Player.y, 'glowY', 70, 720);
      spawnShockwave(Player.x, Player.y, C.Y, shockR, 0.72);
      addShake(16,0.36);
      textPop(Player.x, Player.y-18, 'SHOCKWAVE', C.Y);
      SFX.bomb?.();
      return;
    }

    for(const b of bulletsE) b.alive=false;
    beams.length = 0;

    for(const e of enemies){
      if (!e.alive) continue;
      e.onHit(240 + Game.difficulty*36);
    }

    sparks(Player.x, Player.y, 'glowY', 70, 720);
    spawnShockwave(Player.x, Player.y, C.Y, 520, 0.72);
    addShake(16,0.36);
    textPop(Player.x, Player.y-18, 'BOMB', C.Y);
    SFX.bomb?.();
  }

  // ================= Damage =================
  function onPlayerHit(dmg, slow=0){
    if (UnitBattle.active) return;
    if (Player.invuln>0) return;
    SFX.playerHit();

    if (Player.shield>0){
      Player.shield = Math.max(0, Player.shield-0.95);
      Player.hp -= Math.max(1, dmg*0.20);
      textPop(Player.x, Player.y-16, 'SHIELD', C.P1);
      sparks(Player.x, Player.y, 'glowP', 10, 360);
      addShake(2.2,0.08);
    } else {
      Player.hp -= dmg;
      textPop(Player.x, Player.y-16, '-'+(dmg|0), C.E1);
      sparks(Player.x, Player.y, 'glowE', 14, 420);
      addShake(5.5,0.14);
    }
    if (slow>0) Player.slowT = Math.min(2.2, Player.slowT + slow);
    Player.invuln = 0.55;
  }

  // ================= Updates =================
  function updateBullets(dt, arr){
    if (!Array.isArray(arr) || !arr.length) return;
    for(const b of arr){
      if (!b?.alive) continue;
      if (!Array.isArray(b.mods)) b.mods = [];
      b.t = (Number.isFinite(b.t) ? b.t : 0) + dt;
      b.noHitT = Math.max(0, (Number.isFinite(b.noHitT) ? b.noHitT : 0) - dt);
      b.life = (Number.isFinite(b.life) ? b.life : 1.2) - dt;
      if (!Number.isFinite(b.turnAfter)) b.turnAfter = 0;
      if (!Number.isFinite(b.reverseT)) b.reverseT = 0;
      if (!Number.isFinite(b.accel)) b.accel = 0;
      if (!Number.isFinite(b.angVel)) b.angVel = 0;
      if (!Number.isFinite(b.pauseT)) b.pauseT = 0;
      if (!Number.isFinite(b.homing)) b.homing = 0;
      if (!Number.isFinite(b.waveA)) b.waveA = 0;
      if (!Number.isFinite(b.waveF)) b.waveF = 0;
      if (!Number.isFinite(b.waveP)) b.waveP = 0;
      if (!Number.isFinite(b.mineT)) b.mineT = 0;
      if (!Number.isFinite(b.bounce)) b.bounce = 0;

      // affix onUpdate
      const prevBulletSource = UnitBattle._bulletSource;
      UnitBattle._bulletSource = b;
      if (b.mods.length){
        for(const k of b.mods){
          BulletAffixCatalog[k]?.onUpdate?.(b, dt, null);
        }
      }
      UnitBattle._bulletSource = prevBulletSource;

      // delayed homing
      if (b.turnAfter > 0) {
        b.turnAfter -= dt;
        if (b.turnAfter <= 0) b.homing = Math.max(b.homing, 1);
      }

      // boomerang
      if (b.reverseT > 0) {
        b.reverseT -= dt;
        if (b.reverseT <= 0) { b.vx *= -1; b.vy *= -1; }
      }

      // accel / decel along direction
      if (b.accel !== 0) {
        const sp = Math.hypot(b.vx, b.vy) || 1;
        const ux = b.vx / sp, uy = b.vy / sp;
        b.vx += ux * b.accel * dt;
        b.vy += uy * b.accel * dt;
      }

      // curve
      if (b.angVel !== 0) {
        const sp = Math.hypot(b.vx, b.vy) || 1;
        const ang = Math.atan2(b.vy, b.vx) + b.angVel * dt;
        b.vx = Math.cos(ang) * sp;
        b.vy = Math.sin(ang) * sp;
      }

      // pause
      let move = 1;
      if (b.pauseT > 0) {
        b.pauseT -= dt;
        if (b.pauseT > 0) move = 0;
      }

      // homing steer (FIX: never stall; P homes to enemy, E homes to player)
if (b.homing > 0){
  let tx = null, ty = null;

  b._homeCd = (b._homeCd || 0) - dt;
  const perf = bulletPerfTier();
  if (b._homeCd <= 0 || !b._homeTarget || !b._homeTarget.alive){
    b._homeCd = [0.05, 0.08, 0.12, 0.16][perf] || 0.12;
    if (b.team === 'P') b._homeTarget = findNearestEnemy(b.x, b.y, 760);
    else b._homeTarget = findEnemyFocus(b.x,b.y);
  }

  const t = b._homeTarget;
  if (t && t.alive){
    tx = t.x + (t.vx || 0) * b._homeCd;
    ty = t.y + (t.vy || 0) * b._homeCd;
  }

  if (tx != null){
    const ax = tx - b.x, ay = ty - b.y;
    const ang = Math.atan2(ay, ax);

    // sanitize current velocity
    if (!Number.isFinite(b.vx) || !Number.isFinite(b.vy)){
      b.vx = 0; b.vy = 0;
    }

    let sp = Math.hypot(b.vx, b.vy);

    // FIX: give homing bullets a minimum speed so they never appear frozen
    const minSp = (b.team === 'P') ? 240 : 180;

    // if almost zero speed, snap to min speed toward target
    if (!Number.isFinite(sp) || sp < 1e-3){
      b.vx = Math.cos(ang) * minSp;
      b.vy = Math.sin(ang) * minSp;
      sp = minSp;
    }

    // steer direction while preserving speed
    const tvx = Math.cos(ang) * sp;
    const tvy = Math.sin(ang) * sp;
    b.vx = lerp(b.vx, tvx, 1 - Math.exp(-6*dt));
    b.vy = lerp(b.vy, tvy, 1 - Math.exp(-6*dt));

    // enforce min speed after steering
    const sp2 = Math.hypot(b.vx, b.vy);
    if (sp2 < minSp){
      const k = minSp / Math.max(1e-3, sp2);
      b.vx *= k; b.vy *= k;
    }
  }
}


      if (move){
        b.x += b.vx*dt;
        b.y += b.vy*dt;
      }

      // wave offset
      if (b.waveA !== 0 && b.waveF !== 0) {
        const sp = Math.hypot(b.vx, b.vy) || 1;
        const px = -b.vy / sp, py = b.vx / sp;
        const s = Math.sin(b.waveP + b.t * b.waveF);
        b.x += px * b.waveA * s * dt;
        b.y += py * b.waveA * s * dt;
      }

      if (UnitBattle.active && b.team==='E' && tryHitUnitBattleOpponentByBullet(b)) continue;

      if ((Game.mode==='fortress' || Game.mode==='lab' || Game.mode==='fortress_duel') && b.team==='E' && !b.fortressSafe){
        const shieldHit = Fortress.pickShieldInterceptor(b.x, b.y, b.r||2);
        if (shieldHit){
          const absorb = Math.max(4, (b.dmg||10) * 0.58);
          shieldHit.hp -= absorb;
          if (Game.mode==='fortress_duel' && Game.lastStart?.net && Multiplayer?.isActive?.()){
            Multiplayer.sendServer({
              type:'peer_hit',
              kind:'shield_absorb',
              sid: shieldHit.id,
              dmg: absorb,
              x: b.x,
              y: b.y,
            });
          }
          sparks(b.x,b.y,'glowP2', 8, 220);
          spawnShockwave(shieldHit.x, shieldHit.y, '#b36cff', 42, 0.14);
          killBullet(b, 'shield', {childMods: []});
          continue;
        }
        let blocked = false;
        for (const fs of Fortress.structures){
          if (fs.hp<=0) continue;
          if (circleRectOverlap(b.x, b.y, b.r||2, fs)){
            fs.hp -= Math.max(8, b.dmg||10);
            sparks(b.x,b.y,'glowP2', 6, 180);
            killBullet(b, 'wall', {childMods: []});
            blocked = true;
            break;
          }
        }
        if (blocked) continue;
        // 敌方子弹直击旗帜
        if (Game.mode!=='lab' && b.y > H-72 && Math.abs(b.x - W*0.5) < 52){
          Fortress.hitFlag(Math.max(6, b.dmg||10));
          killBullet(b, 'flag', {childMods: []});
          continue;
        }
      }

      // ricochet for enemy shots
      if (b.team==='E' && b.bounce>0){
        let bounced=false;
        if (b.x<10){ b.x=10; b.vx=Math.abs(b.vx); b.bounce--; bounced=true; }
        else if (b.x>W-10){ b.x=W-10; b.vx=-Math.abs(b.vx); b.bounce--; bounced=true; }
        if (b.y<8 && b.bounce>0){ b.y=8; b.vy=Math.abs(b.vy); b.bounce--; bounced=true; }
        if (bounced){
          sparks(b.x,b.y,'glowE2', 8, 300);
          spawnShockwave(b.x,b.y,C.E2, 120, 0.35);
          if (b.mods.length){
            for(const k of b.mods) BulletAffixCatalog[k]?.onBounce?.(b, null);
          }
        }
      }

      // mines explode (legacy + affix MINE uses mineT)
      if (b.mineT>0){
        b.mineT -= dt;
        if (b.mineT<=0){
          // explode then die
          const d = Game.difficulty;
          const hf = hellFactor();
          const n = 10 + Math.round(8*hf);
          const sp = 190 + d*7;
          for(let i=0;i<n;i++){
            const a = rand(0,Math.PI*2);
            spawnBullet((b.fortressSafe?'P':b.team), b.x,b.y, Math.cos(a)*sp, Math.sin(a)*sp, {
              r:2.7, dmg: (b.team==='E' ? (10+d*0.65) : b.dmg*0.35),
              col: b.col, spr: b.spr, style:0, life:1.35,
              depth: b.depth+1,
              mods: propagateMods(b.mods),
              modCtx: null
            });
          }
          sparks(b.x,b.y, b.spr, 20+Math.round(14*hf), 620);
          spawnShockwave(b.x,b.y, b.col, 220, 0.50);
          addShake(3.4,0.10);
          killBullet(b, 'mine', {childMods: propagateMods(b.mods)});
          continue;
        }
      }

const zm = 1 / Math.max(0.5, Camera.zoom);
if (b.life<=0 || b.x < -120*zm || b.x > W+120*zm || b.y < -160*zm || b.y > H+160*zm){
        const reason = (b.life<=0) ? 'expire' : 'oob';
        
        // 如果是自然超时，先触发 onExpire 钩子，允许 Affix 续命或变形
        if (reason === 'expire' && b.mods.length){
           for(const k of b.mods) BulletAffixCatalog[k]?.onExpire?.(b, null);
        }
        
        // 如果钩子处理完 bullet 还是死的，才真正 kill
        if (b.life <= 0 || reason === 'oob') {
           killBullet(b, reason, {childMods: propagateMods(b.mods)});
        }
      }
    }
  }

  function cleanupBullets(arr){
    let w=0;
    for(const b of arr){
      if (b.alive) arr[w++]=b;
      else bulletPool.put(b);
    }
    arr.length=w;
  }

  function updateParticles(dt){
    let w=0;
    for(const p of particles){
      if (!p.alive) { particlePool.put(p); continue; }
      p.t += dt;
      const k = p.t/p.life;
      p.x += p.vx*dt; p.y += p.vy*dt;
      p.vx *= Math.exp(-4.2*dt);
      p.vy *= Math.exp(-4.2*dt);
      p.a = 1-k;
      if (p.t>=p.life){ p.alive=false; particlePool.put(p); continue; }
      particles[w++] = p;
    }
    particles.length=w;
  }

  function updateShockwaves(dt){
    let w=0;
    for(const s of shockwaves){
      s.t += dt;
      if (s.t<s.life) shockwaves[w++]=s;
    }
    shockwaves.length=w;
  }

function updateBeams(dt){
  let w=0;
  for(const b of beams){
    b.t += dt;
    b.life -= dt;

    if (Game.state==='playing' && Player.alive && Player.invuln<=0){
      const d2 = distPointSeg2(Player.x,Player.y, b.x1,b.y1, b.x2,b.y2);
      const rr = (Player.r + b.width) * (Player.r + b.width);
      if (d2 <= rr){
        // shield 完全免疫激光伤害（只消耗少量 shield 时间）
        if (Player.shield > 0){
          Player.shield = Math.max(0, Player.shield - 0.35);
          // 给一段无敌帧防止每帧重复扣 shield
          Player.invuln = Math.max(Player.invuln, 0.18);
          sparks(Player.x, Player.y, 'glowP2', 6, 280);
          textPop(Player.x, Player.y-16, 'BLOCKED', C.P2);
        } else {
          onPlayerHit(b.dmg, 0.8);
        }
      }
    }

    if (b.life>0) beams[w++]=b;
  }
  beams.length=w;
}

  function updateSupplies(dt){
    for(const p of supplies){
      p.t += dt;
      if (Player.magnetT>0){
        const dx = Player.x-p.x, dy = Player.y-p.y;
        const d2 = dx*dx+dy*dy;
        if (d2 < 280*280){
          const d = Math.max(1, Math.sqrt(d2));
          p.vx += (dx/d)*420*dt;
          p.vy += (dy/d)*420*dt;
        }
      }
      p.x += p.vx*dt;
      p.y += p.vy*dt;
      p.vx *= Math.exp(-1.8*dt);

      if (p.y>H+70) p.dead=true;
      if (!p.dead && hitCircle(p.x,p.y,p.r, Player.x,Player.y, Player.r+10)){
        p.dead=true;
        SFX.pickup();
        Supply[p.key]?.apply?.();
      }
    }
    let w=0;
    for(const p of supplies) if (!p.dead) supplies[w++]=p;
    supplies.length=w;
  }

  function updateTexts(dt){
    for(const t of texts){ t.t+=dt; t.y-=20*dt; if (t.t>t.life) t.dead=true; }
    let w=0;
    for(const t of texts) if(!t.dead) texts[w++]=t;
    texts.length=w;
  }
  
  function repairEnemyPose(e, reason='runtime'){
  if (!e) return false;
  let patched = false;

  const fallbackX = clamp(
    Number.isFinite(e.tx) ? e.tx :
    Number.isFinite(e.cx) ? e.cx :
    Number.isFinite(e.mmx?.ocx) ? e.mmx.ocx :
    (Number.isFinite(Player?.x) ? Player.x : W*0.5),
    18, W-18
  );
  const fallbackY = clamp(
    Number.isFinite(e.ty) ? e.ty :
    Number.isFinite(e.cy) ? e.cy :
    Number.isFinite(e.holdY) ? e.holdY :
    Number.isFinite(e.mmx?.ocy) ? e.mmx.ocy :
    -42,
    -120, H*0.72
  );

  if (!Number.isFinite(e.x)) { e.x = fallbackX; patched = true; }
  if (!Number.isFinite(e.y)) { e.y = fallbackY; patched = true; }

  if (e.mmx){
    const m = e.mmx;
    if (!Number.isFinite(m.vx)) m.vx = 0;
    if (!Number.isFinite(m.vy)) m.vy = 80 + Game.difficulty*3.0;
    if (!Number.isFinite(m.driftVx)) m.driftVx = 0;
    if (!Number.isFinite(m.driftVy)) m.driftVy = 90 + Game.difficulty*2.0;
    if (!Number.isFinite(m.ocx)) m.ocx = e.x;
    if (!Number.isFinite(m.ocy)) m.ocy = clamp(e.y, H*0.12, H*0.30);
    if (!Number.isFinite(m.orad)) m.orad = 0;
    if (!Number.isFinite(m.oradT)) m.oradT = 64;
    if (!Number.isFinite(m.oa)) m.oa = 0;
    if (!Number.isFinite(m.nextT)) m.nextT = rand(1.4, 2.8);
  }

  if (e.tx != null && !Number.isFinite(e.tx)) e.tx = e.x;
  if (e.ty != null && !Number.isFinite(e.ty)) e.ty = e.y;

  if (patched){
    e._repairedAt = Game.time;
    if (reason==='runtime') sparks(e.x, e.y, 'glowW', 5, 140);
  }
  return patched;
}

  function separateEnemies(dt){
  const pad = 18;
  for(let i=0;i<enemies.length;i++){
    const a = enemies[i];
    if (!a.alive || a.type==='BOSS') continue;
    if (a.y<0 || a.y>H*0.70) continue;

    for(let j=i+1;j<enemies.length;j++){
      const b = enemies[j];
      if (!b.alive || b.type==='BOSS') continue;
      if (b.y<0 || b.y>H*0.70) continue;

      const dx = a.x-b.x, dy = a.y-b.y;
      const rr = a.r + b.r + pad;
      const d2 = dx*dx+dy*dy;
      if (d2>=rr*rr || d2<1e-6) continue;

      const d = Math.sqrt(d2);
      const ux = dx/d, uy = dy/d;
      const push = (rr - d) * 0.5;

      // mostly x separation; little y to avoid jitter
      a.x += ux * push * 0.60;
      b.x -= ux * push * 0.60;
      a.y += uy * push * 0.20;
      b.y -= uy * push * 0.20;

      a.x = clamp(a.x, 18, W-18);
      b.x = clamp(b.x, 18, W-18);

      if (a.cx!=null) a.cx += ux * push * 0.60;
      if (b.cx!=null) b.cx -= ux * push * 0.60;
      if (a.phase!=null){
        const amp = W*0.30;
        a.phase = Math.asin(clamp((a.x-W*0.5)/amp, -1, 1));
      }
      if (b.phase!=null){
        const amp = W*0.30;
        b.phase = Math.asin(clamp((b.x-W*0.5)/amp, -1, 1));
      }
    }
  }
}

  function applySpawnEntropy(e){
    if (!e || e.type==='BOSS') return;
    const seq = (Game.spawnSeq = (Game.spawnSeq||0) + 1);
    const entropy = ((Date.now() & 0xfffffff) ^ ((Game.wave||1)*2654435761) ^ (seq*2246822519) ^ (randi(0, 0x7fffffff))) >>> 0;
    e.bodySeed = ((e.bodySeed||0) ^ entropy) >>> 0;
    e.body = genEnemyBody(e.bodySeed);

    const laneJitter = clamp(W*0.08 + rand(0, W*0.12), 24, W*0.22);
    e.x = clamp(e.x + rand(-laneJitter, laneJitter), 24, W-24);
    if (e.cx!=null) e.cx = clamp(e.cx + rand(-laneJitter*0.5, laneJitter*0.5), W*0.18, W*0.82);
    if (e.phase!=null){
      const amp = W*0.30;
      e.phase = Math.asin(clamp((e.x-W*0.5)/amp, -1, 1));
    }
  }

  function resolveSpawnOverlap(e, tries=10){
  if (e.type==='BOSS') return;
  const pad = 26;

  for(let k=0;k<tries;k++){
    let ok = true;
    for(const o of enemies){
      if (!o.alive || o===e || o.type==='BOSS') continue;
      // 只在上半屏附近避免堆叠
      if (Math.abs(o.y - e.y) > 180) continue;
      const rr = e.r + o.r + pad;
      if (dist2(e.x,e.y,o.x,o.y) < rr*rr){ ok=false; break; }
    }
    if (ok) return;

    // try new x
    const nx = clamp(rand(26, W-26), 26, W-26);
    const dx = nx - e.x;
    e.x = nx;

    // keep orbit/sweep consistent
    if (e.cx!=null) e.cx += dx; // ORBIT
    if (e.phase!=null){ // SWEEP: adjust phase so x matches
      const amp = W*0.30;
      const s = clamp((e.x - W*0.5)/amp, -1, 1);
      e.phase = Math.asin(s);
    }
  }
}

function normalizeFortressSpawn(e){
  if (Game.mode!=='fortress' || !e || e.type==='BOSS') return;
  // 堡垒模式敌人必须从屏幕上方入场，避免在可见区域“凭空出现”
  if (!Number.isFinite(e.y) || e.y > H*0.06){
    e.y = -60 - rand(0, 40);
  }
  // 避免频繁在左上角聚集
  if (e.x < W*0.14) e.x = clamp(e.x + rand(40, 110), 24, W-24);
}

function enforceHoverLimit(){
  const hover = [];
  for(const e of enemies){
    if (!e.alive || e.type=='BOSS' || !e.mmx) continue;
    if ((e.mmx.mode==='ORBIT' || e.mmx.mode==='HOLD') && e.y < H*0.40){
      hover.push(e);
    }
  }
  if (hover.length <= 3) return;

  // keep 3; force rest to exit smoothly
  hover.sort((a,b)=>(a.spawnId||0)-(b.spawnId||0));
  for(let i=3;i<hover.length;i++){
    hover[i].mmx.forceExit = true;
  }
}

// ------ 补丁 Q.1：空间网格系统 ------
  const SpatialGrid = {
    cellSize: 128,
    cells: new Map(), // key: hash, val: [enemy, enemy...]
    
    // 清空网格
    clear(){
      this.cells.clear();
    },

    // 生成网格 Hash Key
    getKey(x, y){
      // 位运算取整，比 Math.floor 快
      const cx = (x / this.cellSize) | 0;
      const cy = (y / this.cellSize) | 0;
      // 简单的位移组合 hash (支持约 65535x65535 的范围)
      return (cx & 0xFFFF) | ((cy & 0xFFFF) << 16);
    },

    // 将敌人加入网格
    add(e){
      // 考虑到敌人有半径，简单的做法是只注册中心点
      // 并在查询时查询周围 3x3 九宫格，确保不漏判边缘碰撞
      const k = this.getKey(e.x, e.y);
      let list = this.cells.get(k);
      if (!list) {
        list = [];
        this.cells.set(k, list);
      }
      list.push(e);
    },

    // 获取某点附近的潜在目标列表
    query(x, y, outList){
      const cx = (x / this.cellSize) | 0;
      const cy = (y / this.cellSize) | 0;
      
      // 查询 3x3 邻域 (处理跨网格碰撞)
      for(let i=-1; i<=1; i++){
        for(let j=-1; j<=1; j++){
          const k = ((cx+i) & 0xFFFF) | (((cy+j) & 0xFFFF) << 16);
          const list = this.cells.get(k);
          if (list) {
            // 简单的把所有潜在目标推入数组，外层再做精确距离检测
            // 避免这里做过多逻辑
            for(let n=0; n<list.length; n++) outList.push(list[n]);
          }
        }
      }
    }
  };
  
  // ================= MOVING POINTS BACKGROUND =================

// C++ MovingPoint -> JS Class
class MovingPoint {
  constructor(pos, direction, speed, color) {
    this.pos = { x: pos.x, y: pos.y };
    this.speed = speed;
    this.color = color;

    // Normalize direction vector
    const length = Math.hypot(direction.x, direction.y);
    if (length > 0) {
      this.dir = { x: direction.x / length, y: direction.y / length };
    } else {
      this.dir = { x: 0, y: 0 };
    }
  }

  updatePosition(deltaTime) {
    this.pos.x += this.dir.x * this.speed * deltaTime;
    this.pos.y += this.dir.y * this.speed * deltaTime;
  }

  setDirection(newDirection) {
    const length = Math.hypot(newDirection.x, newDirection.y);
    if (length > 0) {
      this.dir = { x: newDirection.x / length, y: newDirection.y / length };
    }
  }

  isOffscreen(windowSize) {
    return this.pos.x < -10 || this.pos.x > windowSize.width + 10 ||
           this.pos.y < -10 || this.pos.y > windowSize.height + 10;
  }
}

const BG_Effect = {
  points: [],
  maxPoints: 10,       // 粒子最大数量
  pointSpeed: 60,       // 粒子基础速度
  attractionRadius: 100,// 吸引半径
  timerInterval: 30,    // 模拟的更新间隔 (ms)
  
  // 触摸/鼠标状态
  pointerPos: { x: -1, y: -1 },
  pointerActive: false,

  init() {
    this.points = [];
    for (let i = 0; i < this.maxPoints / 2; ++i) {
      this.generateRandomPoint();
    }
  },

  update(dt) {
    // 1. 同步输入状态 (适配手机触摸和桌面鼠标)
    this.pointerActive = Input.active;
    if (this.pointerActive) {
      this.pointerPos.x = Input.px; // 使用游戏内的平滑坐标
      this.pointerPos.y = Input.py;
    }

    // 2. 更新所有点的位置和方向
    for (let i = 0; i < this.points.length; ++i) {
      const p = this.points[i];
      const currentPos = p.pos;
      const currentDir = p.dir;

      // 如果指针在范围内，计算吸引力
      if (this.pointerActive) {
        const distToMouse = Math.hypot(currentPos.x - this.pointerPos.x, currentPos.y - this.pointerPos.y);

        if (distToMouse < this.attractionRadius) {
          // 计算粒子在六边形上的目标点
          const targetPoint = this.calculateHexagonPoint(this.pointerPos, i % 6, 80.0);
          
          // 计算朝向目标点的向量
          const attractionVector = { x: targetPoint.x - currentPos.x, y: targetPoint.y - currentPos.y };
          const attractionLength = Math.hypot(attractionVector.x, attractionVector.y);
          if (attractionLength > 0) {
            attractionVector.x /= attractionLength;
            attractionVector.y /= attractionLength;
          }

          // 根据距离计算吸引强度 (线性插值)
          const attractionFactor = 1.0 - (distToMouse / this.attractionRadius);
          
          // 混合原始方向和吸引方向
          const newDir = {
            x: currentDir.x * (1.0 - attractionFactor) + attractionVector.x * attractionFactor,
            y: currentDir.y * (1.0 - attractionFactor) + attractionVector.y * attractionFactor
          };
          p.setDirection(newDir);
        }
      }
      p.updatePosition(dt);
    }
    
    // 3. 移除屏幕外的点，并补充新的点
    let w = 0;
    for (const p of this.points) {
      if (!p.isOffscreen({ width: W, height: H })) {
        this.points[w++] = p;
      }
    }
    this.points.length = w;

    while (this.points.length < this.maxPoints) {
      this.generateRandomPoint();
    }
  },

  draw(ctx) {
    if (FXState.additiveOn) ctx.globalCompositeOperation = 'lighter';
    
    // 1. 绘制点之间的连线
    for (let i = 0; i < this.points.length; ++i) {
      for (let j = i + 1; j < this.points.length; ++j) {
        const pos1 = this.points[i].pos;
        const pos2 = this.points[j].pos;
        const dist = Math.hypot(pos1.x - pos2.x, pos1.y - pos2.y);

        if (dist < 230) {
          let alpha = (dist < 100) ? 255 : Math.round(255 * (1.0 - (dist - 100) / 130));
          alpha = Math.max(0, Math.min(255, alpha));
          
          ctx.strokeStyle = `rgba(255, 255, 255, ${alpha / 255 * 0.4})`; // 降低亮度以匹配游戏风格
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(pos1.x, pos1.y);
          ctx.lineTo(pos2.x, pos2.y);
          ctx.stroke();
        }
      }
    }

    // 2. 绘制粒子点
    ctx.fillStyle = '#fff'; // 粒子点统一为白色，更符合赛博朋克风格
    for (const point of this.points) {
      ctx.beginPath();
      ctx.arc(point.pos.x, point.pos.y, 1.5, 0, Math.PI * 2); // 粒子稍微大一点
      ctx.fill();
    }

    if (PERF.additive) ctx.globalCompositeOperation = 'source-over';
  },
  
  // --- 辅助函数 (直接从 C++ 翻译) ---
  generateRandomPoint() {
    let startPos, direction;
    const edge = Math.floor(Math.random() * 4);

    switch (edge) {
      case 0: // Top
        startPos = { x: Math.random() * W, y: -5.0 };
        direction = this.generateRandomDirection();
        if (direction.y < 0) direction.y = -direction.y;
        break;
      case 1: // Right
        startPos = { x: W + 5.0, y: Math.random() * H };
        direction = this.generateRandomDirection();
        if (direction.x > 0) direction.x = -direction.x;
        break;
      case 2: // Bottom
        startPos = { x: Math.random() * W, y: H + 5.0 };
        direction = this.generateRandomDirection();
        if (direction.y > 0) direction.y = -direction.y;
        break;
      case 3: // Left
        startPos = { x: -5.0, y: Math.random() * H };
        direction = this.generateRandomDirection();
        if (direction.x < 0) direction.x = -direction.x;
        break;
    }
    
    // 颜色统一为赛博朋克主色调，而不是随机彩色
    const colors = [C.P1, C.P2, C.Y, C.E4];
    const color = colors[Math.floor(Math.random()*colors.length)];

    this.points.push(new MovingPoint(startPos, direction, this.pointSpeed, color));
  },

  generateRandomDirection() {
    const angle = Math.random() * 360 * Math.PI / 180;
    return { x: Math.cos(angle), y: Math.sin(angle) };
  },

  calculateHexagonPoint(center, index, radius) {
    let angle_rad = (Math.PI / 3.0) * index + (Math.PI / 6.0);
    return {
      x: center.x + radius * Math.cos(angle_rad),
      y: center.y + radius * Math.sin(angle_rad)
    };
  }
};

// 初始化背景
BG_Effect.init();

  // ================= Multiplayer (WebSocket) =================
  const Multiplayer = {
    socket: null,
    connected: false,
    serverUrl: '',
    room: '',
    nick: 'PILOT',
    localId: `P-${Math.random().toString(36).slice(2,8)}`,
    peers: new Map(),
    heartbeatCd: 0,
    stateCd: 0,
    worldSyncCd: 0,
    worldSyncSeq: 0,
    joinedAt: 0,
    lastRoomSeq: 0,
    lastWorldVersion: 0,
    localPrepared: false,
    pendingCfg: null,
    waitingStart: false,
    roomLeaderId: '',
    hitCache: new Map(),

    setStatus(msg){ if (ui.mpStatus) ui.mpStatus.textContent = msg; },
    isActive(){ return this.connected && !!this.room; },

    normalizeRoom(v){
      return (v || '').trim().replace(/\s+/g,'-').replace(/[^a-zA-Z0-9_-]/g,'').slice(0,20).toUpperCase();
    },

    normalizeServer(v){
      const raw = (v || '').trim();
      if (!raw) return '';
      if (/^wss?:\/\//i.test(raw)) return raw;
      return `ws://${raw}`;
    },

    connect(serverInput, nickInput){
      const url = this.normalizeServer(serverInput) || 'ws://127.0.0.1:8787';
      this.nick = (nickInput || '').trim().slice(0,16) || 'PILOT';
      this.disconnect(false);
      this.serverUrl = url;
      this.setStatus(`连接服务器中 ${url} ...`);
      try {
        const ws = new WebSocket(url);
        this.socket = ws;
        ws.onopen = ()=>{
          this.connected = true;
          this.joinedAt = performance.now();
          this.sendServer({type:'hello', nick:this.nick});
          this.setStatus(`服务器在线 · ${url}`);
        };
        ws.onmessage = (ev)=>{
          try { this.onServerMessage(JSON.parse(ev.data)); } catch(_){ }
        };
        ws.onclose = ()=>{
          const hadRoom = !!this.room;
          this.connected = false;
          this.socket = null;
          this.room = '';
          this.peers.clear();
          if (this.localPrepared || hadRoom || (Game.lastStart && Game.lastStart.net)){
            this.onPeerDisconnected('SERVER');
          } else {
            this.setStatus('服务器已断开');
          }
          this.localPrepared = false;
          this.pendingCfg = null;
          this.waitingStart = false;
          this.roomLeaderId = '';
          if (ui.btnMpStart) ui.btnMpStart.textContent = 'PREPARE';
        };
        ws.onerror = ()=> this.setStatus('服务器连接失败');
      } catch(_){
        this.setStatus('服务器地址无效');
      }
    },

    disconnect(announce=true){
      this.leaveRoom(false);
      if (announce) this.sendServer({type:'bye'});
      if (this.socket){ try { this.socket.close(); } catch(_){} }
      this.socket = null;
      this.connected = false;
      this.serverUrl = '';
      this.peers.clear();
      this.localPrepared = false;
      this.pendingCfg = null;
      this.waitingStart = false;
      this.roomLeaderId = '';
      this.hitCache.clear();
      this.worldSyncCd = 0;
      this.worldSyncSeq = 0;
      this.lastRoomSeq = 0;
      this.lastWorldVersion = 0;
      this.setStatus('联机未连接');
      if (ui.btnMpStart) ui.btnMpStart.textContent = 'PREPARE';
    },

    joinRoom(roomInput){
      if (!this.connected) return this.setStatus('请先 CONNECT 到服务器');
      const room = this.normalizeRoom(roomInput);
      if (!room) return this.setStatus('请输入房间号');
      this.sendServer({type:'join_room', room, nick:this.nick});
      this.setStatus(`加入房间 ${room} 中...`);
    },

    leaveRoom(announce=true){
      if (announce && this.connected && this.room){ this.sendServer({type:'leave_room'}); }
      this.room = '';
      this.peers.clear();
      this.heartbeatCd = 0;
      this.stateCd = 0;
      this.localPrepared = false;
      this.pendingCfg = null;
      this.waitingStart = false;
      this.roomLeaderId = '';
      this.hitCache.clear();
      this.worldSyncCd = 0;
      this.worldSyncSeq = 0;
      this.lastRoomSeq = 0;
      this.lastWorldVersion = 0;
      if (ui.btnMpStart) ui.btnMpStart.textContent = 'PREPARE';
      this.refreshStatus();
    },

    sendServer(payload){
      if (!this.socket || this.socket.readyState !== 1) return;
      const msg = { from: this.localId, t: performance.now(), ...payload };
      msg.room = (payload && payload.room != null) ? payload.room : this.room;
      this.socket.send(JSON.stringify(msg));
    },

    serializeWorldState(includeBullets=true){
      return {
        t: performance.now(),
        mode: Game.mode,
        wave: Game.wave,
        score: Game.score,
        spawnerCd: Spawner.cd,
        enemies: enemies.slice(0,64).map((e, i)=>({
          k: e.spawnId || `${e.type||'E'}:${i}`,
          x:e.x,y:e.y,vx:e.vx,vy:e.vy,hp:e.hp,maxHp:e.maxHp,r:e.r,
          col:e.baseCol||e.tint||C.E1,type:e.type||'ENEMY'
        })),
        bulletsE: includeBullets
          ? bulletsE.slice(0,72).map((b)=>({x:b.x,y:b.y,vx:b.vx,vy:b.vy,r:b.r,col:b.col,dmg:b.dmg,t:b.t,spr:b.spr,style:b.style}))
          : null
      };
    },

    applyWorldState(world, relayTs=0, isFullState=false){
      if (!world || !world.mode || world.mode !== Game.mode || Game.state !== 'playing') return;
      const leadS = clamp(((Date.now() - (relayTs || 0)) / 1000) + 0.015, 0, isFullState ? 0.26 : 0.18);
      if (world.wave != null) Game.wave = world.wave;
      if (world.score != null) Game.score = Math.max(Game.score, world.score);
      if (world.spawnerCd != null) Spawner.cd = world.spawnerCd;
      const byId = new Map(enemies.map((e, i)=>[(e.spawnId || `${e.type||'E'}:${i}`), e]));
      const used = new Set();
      for (const src of (world.enemies || [])){
        const key = src.k || '';
        let e = byId.get(key);
        if (!e){
          e = baseEnemy(src.type || 'ENEMY', src.r || 18, src.maxHp || 50, 200);
          e.spawnId = key || `NET-${Math.random().toString(36).slice(2,8)}`;
          const seedFromKey = (src.bodySeed != null) ? (src.bodySeed>>>0) : (key
            ? key.split('').reduce((acc, ch)=>hash32(acc ^ ch.charCodeAt(0)), 0x9e3779b9)
            : hash32(((src.x||0)*1000|0) ^ ((src.y||0)*1000|0) ^ ((src.r||18)*13|0)));
          e.bodySeed = seedFromKey;
          e.body = genEnemyBody(seedFromKey);
          e.emitters = [];
          enemies.push(e);
        }
        if (!e.body){
          const fallbackSeed = (src.bodySeed != null) ? (src.bodySeed>>>0) : (e.bodySeed || hash32(((src.x||0)*1000|0) ^ ((src.y||0)*1000|0) ^ ((src.r||18)*13|0)));
          e.bodySeed = fallbackSeed;
          e.body = genEnemyBody(fallbackSeed);
        }
        const tx = clamp((src.x ?? e.x) + (src.vx ?? e.vx ?? 0) * leadS, -160, W + 160);
        const ty = clamp((src.y ?? e.y) + (src.vy ?? e.vy ?? 0) * leadS, -220, H + 220);
        if (e._netSnapSeen){
          const follow = isFullState ? 0.9 : 0.62;
          e.x = lerp(e.x, tx, follow);
          e.y = lerp(e.y, ty, follow);
        } else {
          e.x = tx; e.y = ty;
          e._netSnapSeen = true;
        }
        e.vx = clamp(src.vx ?? e.vx, -520, 520); e.vy = clamp(src.vy ?? e.vy, -520, 520);
        e.hp = src.hp ?? e.hp; e.maxHp = src.maxHp ?? e.maxHp;
        e.r = src.r ?? e.r;
        e.type = src.type || e.type;
        e.isBoss = (e.type === 'BOSS');
        e.isNetGhost = true;
        if (src.col) { e.baseCol = src.col; e.tint = src.col; }
        e.alive = true;
        used.add(e);
      }
      for (let i=enemies.length-1; i>=0; i--){
        const e = enemies[i];
        if (!used.has(e) && !e.isBoss) enemies.splice(i,1);
      }
      if (Array.isArray(world.bulletsE)){
        bulletsE.length = 0;
        for (const b of world.bulletsE){
          const vx = Number.isFinite(b?.vx) ? b.vx : 0;
          const vy = Number.isFinite(b?.vy) ? b.vy : 0;
          bulletsE.push({
            ...b,
            team: 'E',
            x:(b?.x ?? 0) + vx * leadS,
            y:(b?.y ?? 0) + vy * leadS,
            vx,
            vy,
            t: Number.isFinite(b?.t) ? b.t : 0,
            life: Number.isFinite(b?.life) ? b.life : 1.2,
            noHitT: Number.isFinite(b?.noHitT) ? b.noHitT : 0,
            turnAfter: Number.isFinite(b?.turnAfter) ? b.turnAfter : 0,
            reverseT: Number.isFinite(b?.reverseT) ? b.reverseT : 0,
            accel: Number.isFinite(b?.accel) ? b.accel : 0,
            angVel: Number.isFinite(b?.angVel) ? b.angVel : 0,
            pauseT: Number.isFinite(b?.pauseT) ? b.pauseT : 0,
            homing: Number.isFinite(b?.homing) ? b.homing : 0,
            waveA: Number.isFinite(b?.waveA) ? b.waveA : 0,
            waveF: Number.isFinite(b?.waveF) ? b.waveF : 0,
            waveP: Number.isFinite(b?.waveP) ? b.waveP : 0,
            mineT: Number.isFinite(b?.mineT) ? b.mineT : 0,
            bounce: Number.isFinite(b?.bounce) ? b.bounce : 0,
            mods: Array.isArray(b?.mods) ? b.mods : [],
            alive:true
          });
        }
      }
    },

    onServerMessage(msg){
      if (!msg) return;
      if (msg.type === 'welcome'){
        this.localId = msg.id || this.localId;
        return;
      }
      if (msg.type === 'room_joined'){
        this.room = msg.room || '';
        this.roomLeaderId = msg.leaderId || this.roomLeaderId;
        this.peers.clear();
        this.lastRoomSeq = 0;
        this.lastWorldVersion = 0;
        const peers = Array.isArray(msg.peers) ? msg.peers : [];
        for (const p of peers){
          if (!p || p.id === this.localId) continue;
          this.peers.set(p.id, {id:p.id, nick:p.nick||'PILOT', x:W*0.5, y:H*0.75, hp:100, hpMax:100, alive:true, score:0, wave:1, prepared:false, lastSeen:performance.now(), smoothBullets:[]});
        }
        this.setStatus(`已进入房间 ${this.room} · ${this.peers.size+1} 人`);
        return;
      }
      if (msg.type === 'peer_joined'){
        if (!msg.peer || msg.peer.id === this.localId) return;
        const p = msg.peer;
        this.peers.set(p.id, {id:p.id, nick:p.nick||'PILOT', x:W*0.5, y:H*0.75, hp:100, hpMax:100, alive:true, score:0, wave:1, prepared:false, lastSeen:performance.now(), smoothBullets:[]});
        this.roomLeaderId = msg.leaderId || this.roomLeaderId;
        this.refreshStatus();
        return;
      }
      if (msg.type === 'peer_left'){
        const peer = this.peers.get(msg.peerId);
        if (peer){
          this.peers.delete(msg.peerId);
          const isStrictDuel = !!(Game.lastStart?.net && (Game.mode==='workshop' || Game.mode==='fortress_duel'));
          if (isStrictDuel && Game.state !== 'menu') this.onPeerDisconnected(peer.nick);
          else this.clearRemoteTransientState();
        }
        this.refreshStatus();
        return;
      }
      if (msg.type === 'room_event'){
        this.onRoomEvent(msg);
        return;
      }
      if (msg.type === 'room_state'){
        this.applyRoomState(msg);
        return;
      }
      if (msg.type === 'error') this.setStatus(msg.message || '服务器错误');
    },

    onRoomEvent(msg){
      if (!msg || !msg.event) return;
      if (msg.event === 'prepared_updated'){
        const prepared = new Set(Array.isArray(msg.prepared) ? msg.prepared : []);
        this.roomLeaderId = msg.leaderId || this.roomLeaderId;
        for (const p of this.peers.values()) p.prepared = prepared.has(p.id);
        this.refreshStatus();
      } else if (msg.event === 'start_match' && msg.cfg){
        if (!this.localPrepared && !this.waitingStart) {
          this.setStatus('房间已开局（你未准备）');
          return;
        }
        this.startPreparedMatch(msg.cfg, msg.starterId || this.roomLeaderId || this.localId);
      } else if (msg.event === 'peer_hit'){
        if ((Game.mode === 'workshop' || Game.mode==='fortress_duel') && Game.state === 'playing' && Player.alive){
          const peer = this.peers.get(msg.from);
          const kind = (msg.kind||'player');
          if (kind==='player'){
            onPlayerHit(Math.max(1, msg.dmg || 1), 0);
            textPop(Player.x, Player.y - 28, `HIT BY ${peer?.nick || 'PILOT'}`, C.R);
          } else if (kind==='player_half'){
            Player.hp = Math.max(1, Player.hp - Math.max(1, msg.dmg||0));
            textPop(Player.x, Player.y - 28, `SHOCK HALF HP`, C.E1);
          } else if (kind==='bomb_shock'){
            const srcPeer = this.peers.get(msg.from);
            const pp = srcPeer ? this.projectedPeer(srcPeer) : null;
            const fxX = Number.isFinite(pp?.x) ? pp.x : (Number.isFinite(msg.x) ? msg.x : W*0.5);
            const fxY = Number.isFinite(pp?.y) ? pp.y : (Number.isFinite(msg.y) ? msg.y : H*0.5);
            const fxR = Math.max(80, Number(msg.r)||260);
            spawnShockwave(fxX, fxY, C.Y, fxR, 0.72);
            sparks(fxX, fxY, 'glowY', 42, 520);
            SFX.bomb?.();
          } else if (kind==='flag_destroyed_fx'){
            const srcPeer = this.peers.get(msg.from);
            const pf = srcPeer ? this.projectedPeerFortress(srcPeer) : null;
            const fxX = pf?.flagX ?? (Number.isFinite(msg.x) ? msg.x : W*0.5);
            const fxY = pf?.flagY ?? (Number.isFinite(msg.y) ? msg.y : H-52);
            const fxR = Math.max(120, Number(msg.r)||260);
            spawnShockwave(fxX, fxY, C.E1, fxR, 0.85);
            sparks(fxX, fxY, 'glowE2', 62, 760);
            beep({f:130,t:0.32,g:0.06,type:'sawtooth',slide:0.55});
          } else if (kind==='shield_absorb'){
            const sid = msg.sid|0;
            const st = Fortress.structures.find(v=>v.id===sid && v.hp>0 && v.type==='shield');
            if (st){
              st.hp -= Math.max(4, Number(msg.dmg)||8);
              const fxX = Number.isFinite(msg.x) ? msg.x : st.x;
              const fxY = Number.isFinite(msg.y) ? msg.y : st.y;
              sparks(fxX, fxY, 'glowP2', 8, 220);
              spawnShockwave(st.x, st.y, '#b36cff', 42, 0.14);
            }
          }
        }
        if (Game.mode==='fortress_duel' && (msg.kind==='flag' || msg.kind==='structure')){
          if (msg.kind==='flag'){
            Fortress.hitFlag(Math.max(1, msg.dmg||1));
          } else if (msg.kind==='structure'){
            const sid = msg.sid;
            const st = Fortress.structures.find(v=>v.id===sid && v.hp>0);
            if (st){
              st.hp -= Math.max(1, msg.dmg||1);
              if (st.hp<=0) sparks(st.x, st.y, 'glowE2', 6, 180);
            }
          }
        }
      }
    },

    applyRoomState(msg){
      if (!msg || !this.room || msg.room !== this.room) return;
      const inNetRun = !!Game.lastStart?.net;
      const seq = Number(msg.seq) || 0;
      if (seq && seq <= this.lastRoomSeq) return;
      this.lastRoomSeq = Math.max(this.lastRoomSeq, seq);
      this.roomLeaderId = msg.leaderId || this.roomLeaderId;
      const now = performance.now();
      const incoming = new Set();
      const list = Array.isArray(msg.players) ? msg.players : [];
      for (const item of list){
        if (!item || item.id === this.localId) continue;
        incoming.add(item.id);
        const peer = this.peers.get(item.id) || {id:item.id, nick:item.nick||'PILOT', x:W*0.5, y:H*0.75, hp:100, hpMax:100, alive:true, score:0, wave:1, prepared:false, smoothBullets:[]};
        peer.nick = item.nick || peer.nick;
        peer.lastSeen = now;
        peer.prepared = !!item.prepared;
        if (item.state && inNetRun){
          Object.assign(peer, item.state);
          peer.netBullets = Array.isArray(item.state.bullets) ? item.state.bullets.slice(0, 120) : [];
          peer.smoothBullets = this.smoothBulletState(peer, peer.netBullets);
          peer.netFortress = item.state.fortress || null;
        } else {
          peer.netBullets = [];
          peer.smoothBullets = [];
          peer.netFortress = null;
          peer.alive = false;
        }
        this.peers.set(item.id, peer);
      }
      for (const id of [...this.peers.keys()]) if (!incoming.has(id)) this.peers.delete(id);
      if (msg.world && inNetRun){
        this.lastWorldVersion = Math.max(this.lastWorldVersion, Number(msg.worldVersion) || 0);
        this.applyWorldState(msg.world, msg.serverTime || 0, !!msg.fullState);
      }
      if (Game.mode==='fortress_duel' && Game.state==='playing' && Game.lastStart?.net){
        const leader = list.find((v)=>v && v.id===this.roomLeaderId) || null;
        const lf = leader?.state?.fortress;
        if (lf && this.roomLeaderId !== this.localId){
          const phase = (lf.phase==='assault' || lf.phase==='fortify') ? lf.phase : Fortress.phase;
          const prevPhase = Fortress.phase;
          Fortress.phase = phase;
          const oldWave = Game.wave|0;
          const syncedWave = Math.max(1, Number(lf.wave) || oldWave || 1);
          Game.wave = syncedWave;
          if (syncedWave > oldWave && syncedWave%5===0){
            Player.bomb = Math.min(3, (Player.bomb||0) + 1);
            textPop(W*0.5, H*0.12, `BOMB +1 (W${syncedWave})`, C.Y);
          }
          Fortress.duelTimer = Math.max(0, Number(lf.duelTimer) || 0);
          Fortress.duelRound = Math.max(1, Number(lf.duelRound) || Fortress.duelRound || 1);
          if (prevPhase==='assault' && phase==='fortify'){
            Fortress.onEnterFortifyEffects?.();
            Fortress.stock += 28;
            Fortress.updatePanel?.();
          }
        }
      }
      this.refreshStatus();
    },

    smoothBulletState(peer, incoming){
      const prev = Array.isArray(peer.smoothBullets) ? peer.smoothBullets : [];
      const now = performance.now()/1000;
      const byKey = new Map(prev.map((b)=>[b.key, b]));
      const next = [];
      for (let i=0; i<incoming.length; i++){
        const src = incoming[i] || {};
        const key = `${src.seed || ''}:${(src.t||0).toFixed(2)}:${i}`;
        const old = byKey.get(key);
        const tx = src.x ?? 0, ty = src.y ?? 0;
        const nx = old ? lerp(old.x, tx, 0.7) : tx;
        const ny = old ? lerp(old.y, ty, 0.7) : ty;
        next.push({
          key, alive:true, x:nx, y:ny,
          nx:(src.nx != null) ? src.nx : null,
          ny:(src.ny != null) ? src.ny : null,
          vx:src.vx ?? (old?.vx || 0), vy:src.vy ?? (old?.vy || 0),
          nvx:(src.nvx != null) ? src.nvx : null,
          nvy:(src.nvy != null) ? src.nvy : null,
          r:src.r ?? 3, col:src.col || C.P2, dmg:src.dmg ?? 8,
          spr:src.spr || 'glowP2', style:src.style ?? 1, team:'P',
          t:src.t || now, _phaseAlpha: src._phaseAlpha, _phaseVisible: src._phaseVisible,
        });
      }
      return next;
    },

    projectedPeer(peer){
      if (!peer) return null;
      const srcW = Math.max(1, peer.vw || W), srcH = Math.max(1, peer.vh || H);
      const npx = (peer.nx != null) ? clamp(peer.nx, -0.2, 1.2) : null;
      const npy = (peer.ny != null) ? clamp(peer.ny, -0.2, 1.2) : null;
      const px = (npx != null) ? (npx * W) : ((peer.x ?? W*0.5) * (W/srcW));
      const py = (npy != null) ? (npy * H) : ((peer.y ?? H*0.75) * (H/srcH));
      const workshopMirror = (Game.mode === 'workshop');
      const duelMirror = (Game.mode === 'fortress_duel');
      const mappedY = workshopMirror ? (H - py) : (duelMirror ? ((1 - (npy != null ? npy : (py/Math.max(1,H)))) * H) : py);
      return {
        ...peer,
        x: workshopMirror ? (W - px) : px,
        y: mappedY,
        bullets: (peer.smoothBullets || []).map((b, i)=>{
          const bnx = (b.nx != null) ? clamp(b.nx, -0.25, 1.25) : null;
          const bny = (b.ny != null) ? clamp(b.ny, -0.25, 1.25) : null;
          const bx = (bnx != null) ? (bnx * W) : ((b.x ?? 0) * (W/srcW));
          const by = (bny != null) ? (bny * H) : ((b.y ?? 0) * (H/srcH));
          const bvx = (b.nvx != null) ? (b.nvx * W) : ((b.vx ?? 0) * (W/srcW));
          const bvy = (b.nvy != null) ? (b.nvy * H) : ((b.vy ?? 0) * (H/srcH));
          return {
            ...b,
            id: `${peer.id}:${i}:${(b.t||0).toFixed(2)}`,
            x: workshopMirror ? (W - bx) : bx,
            y: workshopMirror ? (H - by) : (duelMirror ? ((1 - (bny != null ? bny : (by/Math.max(1,H)))) * H) : by),
            vx: workshopMirror ? -bvx : bvx,
            vy: (workshopMirror || duelMirror) ? -bvy : bvy,
          };
        }),
      };
    },

    collectLocalBulletState(){
      const out = [];
      const vw = Math.max(1, W|0), vh = Math.max(1, H|0);
      for (const b of bulletsP){
        if (!b.alive) continue;
        out.push({x:b.x, y:b.y, nx:clamp(b.x/vw,-0.25,1.25), ny:clamp(b.y/vh,-0.25,1.25), vx:b.vx, vy:b.vy, nvx:b.vx/vw, nvy:b.vy/vh, r:b.r, col:b.col, dmg:b.dmg, t:b.t, spr:b.spr, style:b.style, _phaseAlpha:b._phaseAlpha, _phaseVisible:b._phaseVisible});
        if (out.length >= 90) break;
      }
      return out;
    },

    cfgCompatible(cfgA, cfgB){ return !!cfgA && !!cfgB && cfgA.mode === cfgB.mode; },

    validateRoomForMode(mode){
      const players = this.peers.size + 1;
      if ((mode === 'workshop' || mode==='fortress_duel') && players !== 2){ this.setStatus('该对战模式必须 2 人（你 + 1 对手）'); return false; }
      if (players < 2){ this.setStatus('至少需要 2 人才可开始联机'); return false; }
      return true;
    },

    getWorkshopOpponentBuild(){
      const firstPeer = this.peers.values().next().value;
      return firstPeer?.buildA ? deepClone(firstPeer.buildA) : null;
    },

    prepare(cfg){
      if (!this.isActive()) return;
      if (!this.validateRoomForMode(cfg.mode)) return;
      this.localPrepared = true;
      this.pendingCfg = deepClone(cfg);
      this.waitingStart = true;
      this.sendServer({ type:'prepare', nick:this.nick, cfg:this.pendingCfg, buildA: cfg.mode==='workshop' ? deepClone(Builds.A) : null });
      if (ui.btnMpStart) ui.btnMpStart.textContent = 'CANCEL PREPARE';
      this.tryAutoStart();
      this.refreshStatus();
    },

    cancelPrepare(announce=true){
      this.localPrepared = false;
      this.pendingCfg = null;
      this.waitingStart = false;
      if (announce && this.isActive()) this.sendServer({type:'unprepare', nick:this.nick});
      if (ui.btnMpStart) ui.btnMpStart.textContent = 'PREPARE';
      this.refreshStatus();
    },

    leaderId(){ return this.roomLeaderId || [this.localId, ...this.peers.keys()].sort()[0]; },

    tryAutoStart(){
      if (!this.isActive() || !this.localPrepared || !this.pendingCfg) return;
      const peers = [...this.peers.values()];
      if (!this.validateRoomForMode(this.pendingCfg.mode)) return;
      if (!peers.length || peers.some(p => !p.prepared)) return;
      // Server is authoritative for room start; any prepared player can request start.
      this.sendServer({type:'start_request', cfg:this.pendingCfg, nick:this.nick});
    },

    startPreparedMatch(cfg, starterId){
      if (!cfg) return;
      this.clearRemoteTransientState();
      const starter = (starterId === this.localId) ? this.nick : (this.peers.get(starterId)?.nick || 'PILOT');
      const netCfg = deepClone(cfg);
      if (netCfg.mode === 'workshop') netCfg.opponentBuild = this.getWorkshopOpponentBuild();
      startRun({...netCfg, net:true});
      this.localPrepared = false;
      this.pendingCfg = null;
      this.waitingStart = false;
      if (ui.btnMpStart) ui.btnMpStart.textContent = 'PREPARE';
      textPop(W*0.5, 120, `PREPARE OK · ${starter}`, C.P2);
    },

    onPeerDisconnected(nick='PILOT'){
      this.setStatus(`${nick} 掉线，已自动踢出房间`);
      this.leaveRoom(false);
      toMenu();
      textPop(W*0.5, 120, `对手掉线 · 已退房`, C.R);
    },

    clearRemoteTransientState(){
      for (const peer of this.peers.values()){
        peer.alive = false;
        peer.netBullets = [];
        peer.smoothBullets = [];
        peer.netFortress = null;
      }
    },

    refreshStatus(){
      if (!this.connected){ this.setStatus('联机未连接'); return; }
      if (!this.room){ this.setStatus(`已连接服务器 ${this.serverUrl} · 未加入房间`); return; }
      const list = [...this.peers.values()];
      const names = list.slice(0,4).map(p=>p.nick).join(', ');
      const preparedPeers = list.filter(p=>p.prepared).length;
      const preparedTotal = (this.localPrepared ? 1 : 0) + preparedPeers;
      const prepText = (preparedTotal > 0) ? ` · PREPARE ${preparedTotal}/${list.length+1}` : '';
      const leader = this.leaderId() === this.localId ? '你' : (this.peers.get(this.leaderId())?.nick || '未知');
      this.setStatus(`房间 ${this.room} · 在线 ${list.length+1} 人 · LEADER:${leader}${names?` · ${names}`:''}${prepText}`);
    },

    update(dt){
      if (!this.connected || !this.room) return;
      const inNetRun = !!Game.lastStart?.net;
      this.heartbeatCd -= dt;
      this.stateCd -= dt;
      if (this.heartbeatCd <= 0){ this.heartbeatCd = 0.8; this.sendServer({type:'hello', nick:this.nick}); }
      const netKeepAliveState = !!(inNetRun && (Game.mode==='fortress_duel' || Game.mode==='workshop') && (Game.state==='paused' || Game.state==='over'));
      if ((Game.state === 'playing' || netKeepAliveState) && this.stateCd <= 0){
        this.stateCd = 1/24;
        if (inNetRun) this.sendServer({
          type:'input_state',
          nick:this.nick,
          state:{ x: Player.x, y: Player.y, nx: clamp(Player.x/Math.max(1,W),-0.2,1.2), ny: clamp(Player.y/Math.max(1,H),-0.2,1.2), vw:Math.max(1,W|0), vh:Math.max(1,H|0), hp: Player.hp, hpMax: Player.maxHp, alive: Player.alive, shield: Player.shield, invuln: Player.invuln, score: Game.score, wave: Game.wave, bullets: this.collectLocalBulletState(), fortress: (Game.mode==='fortress_duel') ? {phase:Fortress.phase, wave:Game.wave|0, duelTimer:Fortress.duelTimer||0, duelRound:Fortress.duelRound||1, flagHp:Fortress.flagHp, flagMaxHp:Fortress.flagMaxHp, flagInvulnT:Fortress.flagInvulnT||0, structures:Fortress.structures.map(st=>({id:st.id,x:st.x,y:st.y,nx:clamp(st.x/Math.max(1,W),-0.2,1.2),ny:clamp(st.y/Math.max(1,H),-0.2,1.2),w:st.w,h:st.h,nw:st.w/Math.max(1,W),nh:st.h/Math.max(1,H),hp:st.hp,maxHp:st.maxHp,col:st.col,type:st.type}))} : null }
        });
      }
      // Server-authoritative world simulation: clients no longer relay world snapshots.
      if (Game.state === 'playing' && Game.mode !== 'workshop'){
        this.worldSyncCd = 0;
      }
      const nowS = performance.now()/1000;
      for (const [k,exp] of this.hitCache.entries()) if (exp <= nowS) this.hitCache.delete(k);
      this.refreshStatus();
    },

    drawPeers(){
      if (!Game.lastStart?.net) return;
      if (!this.room || !this.peers.size) return;
      ctx.save();
      ctx.globalCompositeOperation = PERF.additive ? 'lighter' : 'source-over';
      for (const peer of this.peers.values()){
        const pp = this.projectedPeer(peer);
        const rx = pp.x, ry = pp.y;
        if (peer.alive !== false){
          ctx.save();
          ctx.translate(rx, ry);
          if (Game.mode==='workshop' || Game.mode==='fortress_duel') ctx.rotate(Math.PI);
          ctx.strokeStyle = C.P2;
          ctx.fillStyle = 'rgba(179,108,255,0.16)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0,-18); ctx.lineTo(-8,10); ctx.lineTo(0,15); ctx.lineTo(8,10); ctx.closePath();
          ctx.fill(); ctx.stroke();
          drawGlow(Spr.glowP2, 0, 15, 0.85, 0.7);
          ctx.restore();
        }
        ctx.fillStyle = '#E7D8FF';
        ctx.font = '700 10px "Consolas", monospace';
        ctx.textAlign = 'center';
        ctx.fillText(`${peer.nick}  HP:${Math.max(0, Math.ceil(peer.hp||0))} SHD:${(peer.shield||0).toFixed(1)}`, rx, ry - 24);
        if ((peer.shield||0) > 0 && peer.alive !== false){
          ctx.strokeStyle = 'rgba(179,108,255,0.8)';
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.arc(rx, ry, 18 + Math.sin(Game.time*8)*1.5, 0, Math.PI*2);
          ctx.stroke();
        }

        if (Game.mode==='fortress_duel'){
          const pf = this.projectedPeerFortress(peer);
          if (pf){
            ctx.save();
            ctx.strokeStyle = 'rgba(255,120,120,0.85)';
            ctx.fillStyle = 'rgba(255,80,80,0.14)';
            for (const st of (pf.structures||[])){
              if ((st.hp||0)<=0) continue;
              ctx.fillRect(st.x-st.w*0.5, st.y-st.h*0.5, st.w, st.h);
              ctx.strokeRect(st.x-st.w*0.5, st.y-st.h*0.5, st.w, st.h);
              const nm = ({barricade:'木障',wall:'钢壁',heavywall:'合金墙',bunker:'堡垒墙',shield:'棱镜盾',turret:'炮塔',gatling:'加特林',sniper:'狙击塔',missile:'导弹井',tesla:'特斯拉',flame:'喷火塔',mortar:'迫击炮',dronepad:'无人机坪',pulse:'脉冲器',mine:'地雷',slow:'减速塔',repair:'旗帜修',repairplayer:'医疗站',repairfield:'工程站',factory:'补给站',spinner:'旋刃塔',ram:'冲锋桩',beacon:'信标',taunt:'诱敌堡'})[st.type] || st.type;
              ctx.fillStyle = 'rgba(255,220,220,0.95)';
              ctx.font = '700 9px "Consolas", monospace';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(nm, st.x, st.y);
              const hpPct = clamp((st.hp||0)/Math.max(1,st.maxHp||1),0,1);
              ctx.fillStyle = 'rgba(0,0,0,0.55)';
              ctx.fillRect(st.x-st.w*0.5, st.y-st.h*0.5-6, st.w, 4);
              ctx.fillStyle = 'rgba(255,130,130,0.95)';
              ctx.fillRect(st.x-st.w*0.5, st.y-st.h*0.5-6, st.w*hpPct, 4);
              ctx.fillStyle = 'rgba(255,80,80,0.14)';
            }
            const baseY = pf.flagY;
            ctx.fillStyle = 'rgba(10,20,40,0.75)';
            ctx.fillRect(pf.flagX-26, baseY-12, 52, 16);
            ctx.strokeStyle = 'rgba(255,80,110,0.8)';
            ctx.strokeRect(pf.flagX-26, baseY-12, 52, 16);
            ctx.fillStyle = '#ff5577';
            ctx.fillRect(pf.flagX-1.5, baseY-26, 3, 14);
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(pf.flagX+1.5, baseY-26);
            ctx.lineTo(pf.flagX+14, baseY-21);
            ctx.lineTo(pf.flagX+1.5, baseY-16);
            ctx.closePath();
            ctx.fill();
            if ((pf.flagInvulnT||0) > 0){
              ctx.strokeStyle='rgba(120,220,255,0.95)';
              ctx.lineWidth=2;
              ctx.beginPath();
              ctx.arc(pf.flagX, pf.flagY-8, 24 + Math.sin(Game.time*7)*1.2, 0, Math.PI*2);
              ctx.stroke();
            }
            const fPct = clamp((pf.flagHp||1)/Math.max(1,pf.flagMaxHp||1),0,1);
            const bw=120, bh=6, bx=pf.flagX-bw*0.5, by=pf.flagY-34;
            ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(bx,by,bw,bh);
            ctx.fillStyle='rgba(255,90,110,0.95)'; ctx.fillRect(bx,by,bw*fPct,bh);
            ctx.restore();
          }
        }
      }
      ctx.restore();
    },

    drawPeerBullets(){
      if (!Game.lastStart?.net) return;
      if (!this.room || !this.peers.size) return;
      ctx.save();
      if (PERF.additive) ctx.globalCompositeOperation='lighter';
      const minX = -50, maxX = W+50, minY = -50, maxY = H+50;
      for (const peer of this.peers.values()){
        const pp = this.projectedPeer(peer);
        for (const b of pp.bullets){
          if (b._blockedUntil && b._blockedUntil > Game.time) continue;
          if (b.x < minX || b.x > maxX || b.y < minY || b.y > maxY) continue;
          drawBulletVisual(b);
        }
      }
      ctx.globalCompositeOperation='source-over';
      ctx.restore();
    },

    resolvePeerBulletInterception(){
      if (!this.room || Game.mode!=='fortress_duel' || Game.state!=='playing') return;
      if (!bulletsP.length || !this.peers.size) return;
      for (const peer of this.peers.values()){
        const pp = this.projectedPeer(peer);
        const src = Array.isArray(peer.smoothBullets) ? peer.smoothBullets : [];
        for (let i=0; i<pp.bullets.length; i++){
          const eb = pp.bullets[i];
          if (!eb || eb._blockedUntil > Game.time) continue;
          for (const pb of bulletsP){
            if (!pb?.alive || pb._phaseGhost) continue;
            if (!hitCircle(pb.x,pb.y,pb.r||2, eb.x,eb.y, eb.r||2)) continue;
            killBullet(pb, 'hit', {childMods: propagateMods(pb.mods)});
            if (src[i]) src[i]._blockedUntil = Game.time + 0.14;
            sparks(eb.x, eb.y, 'glowP2', 4, 140);
            break;
          }
        }
      }
    },

    projectedPeerFortress(peer){
      const pp = this.projectedPeer(peer);
      const f = peer?.netFortress;
      if (!pp || !f) return null;
      const srcW = Math.max(1, peer?.vw || W), srcH = Math.max(1, peer?.vh || H);
      const structures = (f.structures||[]).map(st=>{
        const sx = (st.nx != null) ? (st.nx * W) : ((st.x ?? W*0.5) * (W/srcW));
        const sy = (st.ny != null) ? (st.ny * H) : ((st.y ?? H*0.75) * (H/srcH));
        const sw = (st.nw != null) ? (st.nw * W) : ((st.w ?? 28) * (W/srcW));
        const sh = (st.nh != null) ? (st.nh * H) : ((st.h ?? 18) * (H/srcH));
        return { ...st, x: sx, y: H - sy, w: sw, h: sh };
      });
      return {
        flagHp: f.flagHp || 1,
        flagMaxHp: f.flagMaxHp || 1,
        flagInvulnT: Math.max(0, Number(f.flagInvulnT)||0),
        flagX: W*0.5,
        flagY: 62,
        structures
      };
    },


    applyPeerBulletPressure(dt){
      if (!this.room || Game.mode !== 'fortress_duel' || Game.state!=='playing') return;
      // 命中结算以 peer_hit 事件为准，避免镜像/插值误差导致幽灵扣血
      return;
      for (const peer of this.peers.values()){
        const pp = this.projectedPeer(peer);
        for (const b of (pp?.bullets||[])){
          if (!b || !b.alive) continue;
          if (hitCircle(Player.x, Player.y, Player.r, b.x, b.y, b.r||3) && Player.invuln<=0){
            onPlayerHit(Math.max(2, (b.dmg||8)*0.35), 0);
          }
          for (const fs of Fortress.structures){
            if (!fs || fs.hp<=0) continue;
            if (circleRectOverlap(b.x, b.y, b.r||2, fs)){
              fs.hp -= Math.max(2, (b.dmg||8)*0.20);
              break;
            }
          }
          if (b.y > H-72 && Math.abs(b.x - W*0.5) < 52){
            Fortress.hitFlag(Math.max(2, (b.dmg||8)*0.22));
          }
        }
      }
    },

    tryHitWorkshopPeerByBullet(b){
      if (!this.room || (Game.mode !== 'workshop' && Game.mode!=='fortress_duel') || !b || !b.alive) return false;
      for (const peer of this.peers.values()){
        const pp = this.projectedPeer(peer);
        if (Game.mode==='fortress_duel'){
          const pf = this.projectedPeerFortress(peer);
          if (pf && Math.abs(b.x - pf.flagX) < 52 && Math.abs(b.y - pf.flagY) < 28){
            if (b.pierce>0){ b.pierce--; b.noHitT = 0.03; } else { killBullet(b, 'hit', {childMods: propagateMods(b.mods)}); }
            if ((pf.flagInvulnT||0) <= 0){
              this.sendServer({type:'peer_hit', dmg:Math.max(1, b.dmg||1), kind:'flag'});
            } else {
              sparks(pf.flagX, pf.flagY, 'glowP2', 5, 140);
            }
            return true;
          }
          if (pf){
            let hitSt = null;
            for (const st of pf.structures){
              if ((st.hp||0)<=0) continue;
              if (circleRectOverlap(b.x,b.y,b.r||2, st)){ hitSt = st; break; }
            }
            if (hitSt){
              if (b.pierce>0){ b.pierce--; b.noHitT = 0.03; } else { killBullet(b, 'hit', {childMods: propagateMods(b.mods)}); }
              this.sendServer({type:'peer_hit', dmg:Math.max(1, b.dmg||1), kind:'structure', sid:hitSt.id});
              return true;
            }
          }
        }
        if (peer.alive === false) continue;
        if (!hitCircle(b.x,b.y,b.r, pp.x,pp.y, Player.r)) continue;
        if ((pp.invuln||0) > 0) continue;
        sparks(b.x,b.y,'glowP2', 8, 220);
        if (b.pierce>0){ b.pierce--; b.noHitT = 0.03; }
        else { killBullet(b, 'hit', {childMods: propagateMods(b.mods)}); }
        this.sendServer({type:'peer_hit', dmg:b.dmg, nick:this.nick, kind:'player'});
        return true;
      }
      return false;
    }
  };

// ================= Main update =================
  function update(dt){
    BG_Effect.update(dt);
    Multiplayer.applyPeerBulletPressure?.(dt);
    Game.time += dt;

    // 仅在主循环中消费一次鼠标目标，避免 pointermove 高频触发计算
    if (!IS_TOUCH && inputMode === 'mouse') MouseAim.consume();

    if (AutoPilot.active) {
      AutoPilot.update(dt);
    }

    Player.magnetT = Math.max(0, Player.magnetT-dt);
    Player.overdriveT = Math.max(0, Player.overdriveT-dt);
    Player.slowT = Math.max(0, Player.slowT-dt);
    if (UnitBattle.active) Player.invuln = Math.max(Player.invuln||0, 999);
    Player.invuln = Math.max(0, Player.invuln-dt);
    Player.shield = Math.max(0, Player.shield-dt);
    
        
    if (!AutoPilot.active){
    // ── 玩家移动：四种模式统一处理 ──
    const slowMul = Player.slowT > 0 ? 0.55 : 1.0;

    if (inputMode === 'joystick'){
      // 摇杆：匀速移动，方向由摇杆决定
      const SPEED = 280 * slowMul;
      if (Joy.active && (Math.abs(Joy.dx) > 0.01 || Math.abs(Joy.dy) > 0.01)){
        Player.x += Joy.dx * SPEED * dt;
        Player.y += Joy.dy * SPEED * dt;
      }
      Player.x = clamp(Player.x, 16, W - 16);
      Player.y = clamp(Player.y, (Game.mode==='fortress_duel' ? H*0.5 + 16 : 40), H - 22);
      Input.px = Player.x;
      Input.py = Player.y;
      Input.tx = Player.x;
      Input.ty = Player.y;

    } else if (inputMode === 'keyboard'){
      // WASD：匀速移动，方向由按键决定
      const SPEED = 320 * slowMul;
      const {kx, ky} = keyDir();
      Player.x += kx * SPEED * dt;
      Player.y += ky * SPEED * dt;
      Player.x = clamp(Player.x, 16, W - 16);
      Player.y = clamp(Player.y, (Game.mode==='fortress_duel' ? H*0.5 + 16 : 40), H - 22);
      Input.px = Player.x;
      Input.py = Player.y;
      Input.tx = Player.x;
      Input.ty = Player.y;

} else {
      // drag / mouse：吸附跟随
      // 正常跟随系数约 14，减速时降为 2.5。
      // 这会产生强烈的“迟滞感”和“惯性”，飞机很难跟上手指，但最终能到达目的地。
      const slowMul = Player.slowT > 0 ? 0.18 : 1.0; 
      const follow = (Input.active ? 14 : 7) * slowMul;
      
      // 标准 Lerp 跟随
      Input.px = lerp(Input.px, Input.tx, 1 - Math.exp(-follow * dt));
      Input.py = lerp(Input.py, Input.ty, 1 - Math.exp(-follow * dt));

      Player.x = clamp(Input.px, 16, W - 16);
      Player.y = clamp(Input.py, (Game.mode==='fortress_duel' ? H*0.5 + 16 : 40), H - 22);
    }
    }

    firePlayer(dt);
    updatePlayerEmitters(dt);
    const isNetAuthoritative = !!(Game.lastStart && Game.lastStart.net);
    if ((Game.mode === 'fortress_duel' || Game.mode === 'lab') || (!isNetAuthoritative && (Game.mode === 'survival' || Game.mode === 'challenge' || Game.mode === 'fortress'))) Spawner.update(dt);

    updateBullets(dt, bulletsP);
    updateBullets(dt, bulletsE);
    Multiplayer.resolvePeerBulletInterception?.();

    // enemies
    for(const e of enemies){
      if (!e.alive) continue;
      if (!Number.isFinite(e.x) || !Number.isFinite(e.y)){
        repairEnemyPose(e, 'runtime');
        if (!Number.isFinite(e.x) || !Number.isFinite(e.y)) continue;
      }
      const prevEx = e.x, prevEy = e.y;
      e.hit = Math.max(0, e.hit-dt);
      // ------ FREEZE_HIT 支持 ------
      if (e._freezeT > 0){
        e._freezeT -= dt;
        // 冻结期间不调用 update（不移动不射击）
        if (chance(0.12)) sparks(e.x, e.y, 'glowP', 2, 120);
      } else if (!(isNetAuthoritative && e.isNetGhost)) {
        UnitBattle._source = e;
      e.update(dt);
      UnitBattle._source = null;
      }
      // timers for support buffs
      if (e._fortT>0){
        e._fortT = Math.max(0, e._fortT - dt);
        e.armor = Math.max(e.armor||0, 2);
      }
      if (e._cmdBuffT>0) e._cmdBuffT = Math.max(0, e._cmdBuffT - dt);

      // ram
      if (Player.alive && Player.invuln<=0 && hitCircle(Player.x,Player.y,Player.r, e.x,e.y, e.r*0.92)){
        onPlayerHit(20 + Game.difficulty*1.6);
        e.onHit(9999);
      }

      if (Game.mode==='fortress' || Game.mode==='lab'){
        let siegeTarget = Fortress.pickStrategicTarget(e.x, e.y, 420);
        resolveEnemyFortressCollision(e, Fortress.structures, prevEx, prevEy);

        // 近战拆墙/拆塔逻辑：敌人会先拆防线，再图谋旗帜
        if (siegeTarget && siegeTarget.type!=='flag'){
          e._fortSiegeCd = Math.max(0, (e._fortSiegeCd||0) - dt);
          const rr = (e.r || 18) + Math.max(siegeTarget.w||20, siegeTarget.h||20) * 0.28;
          if (dist2(e.x,e.y,siegeTarget.x,siegeTarget.y) < rr*rr && e._fortSiegeCd<=0){
            const siegeDmg = 18 + Game.difficulty*2.3 + Game.wave*0.42;
            siegeTarget.hp -= siegeDmg;
            e._fortSiegeCd = 0.48;
            sparks(siegeTarget.x, siegeTarget.y, 'glowE2', 6, 180);
            if (siegeTarget.hp<=0){
              spawnShockwave(siegeTarget.x, siegeTarget.y, C.E2, 115, 0.22);
            }
          }
        }

        if (Game.mode !== 'lab' && e.y > H - 70){
          Fortress.hitFlag(58 + Game.wave*2.5);
          e.alive = false;
          spawnShockwave(e.x, H-62, C.E1, 120, 0.3);
        }
      }

      if (!Number.isFinite(e.x) || !Number.isFinite(e.y)){
        repairEnemyPose(e, 'runtime');
        if (!Number.isFinite(e.x) || !Number.isFinite(e.y)) continue;
      }

      const offscreenBottomY = H/Camera.zoom + 220;
      if (Game.mode === 'lab') {
        if (e.y > offscreenBottomY) {
          e.y = -120;
          e.age = 0;
          if (e.mmx && (e.mmx.mode === 'HOLD' || e.mmx.mode === 'ORBIT')) {
            e.mmx.state = 'enter';
            if (typeof mmxInitOrbitFromHere === 'function') mmxInitOrbitFromHere(e);
          }
        }
      } else if (e.y > offscreenBottomY) {
        e.alive=false;
      }
    }
    if (!isNetAuthoritative){
      enforceHoverLimit();
      separateEnemies(dt);
    }

    // P bullets vs enemies
    
   
    for(const bp of bulletsP){
      if (!bp.alive || bp.noHitT>0 || bp._phaseGhost) continue;
      
      for(const be of bulletsE){
        if (!be.alive || be.noHitT>0 || be._phaseGhost) continue;
        
        // 检测碰撞 (半径相加)
        if (hitCircle(bp.x, bp.y, bp.r, be.x, be.y, be.r)){
          // 双方销毁
          killBullet(bp, 'clash');
          killBullet(be, 'clash');
          
          // 对撞视觉效果 (白色火花，位置在两者中间)
          const mx = (bp.x + be.x) * 0.5;
          const my = (bp.y + be.y) * 0.5;
          sparks(mx, my, 'glowW', 6, 180);
           
          
          break; // bp 已经没了，跳出内层循环，检查下一个 bp
        }
      }
    }
    
    
    // 1. 构建本帧的敌人网格
    SpatialGrid.clear();
    for(const e of enemies){
      if (e.alive) SpatialGrid.add(e);
    }

    // 缓存数组，避免每颗子弹都创建新数组造成 GC 压力
    const _potentialTargets = [];

    // 2. 玩家子弹 vs 敌人 (优化版：只检测附近的敌人)
        // P bullets vs enemies
    for(const b of bulletsP){
      if (!b.alive || b.noHitT>0 || b._phaseGhost) continue;

      if (Multiplayer.tryHitWorkshopPeerByBullet(b)) continue;
      
      // 清空上一轮的潜在目标
      _potentialTargets.length = 0;
      // 从网格获取附近的敌人
      SpatialGrid.query(b.x, b.y, _potentialTargets);

      // 遍历筛选出的潜在敌人（数量远少于 enemies 总数）
      for(const e of _potentialTargets){
        if (!e.alive) continue;
        
        // --- ORBITER 判定 (护盾球) ---
        if (e.orbiters && e.orbiters.length){
          let intercepted = false;
          for (const o of e.orbiters){
            if (o.hp<=0) continue;
            if (hitCircle(b.x,b.y,b.r, o.x,o.y,o.r)){
              o.hp -= b.dmg;
              sparks(b.x,b.y, sprFromColor(enemyColor(e),'E'), 8, 260);
              spawnShockwave(o.x,o.y, enemyColor(e), 120, 0.35);
              killBullet(b, 'hit', {childMods: propagateMods(b.mods)});
              intercepted = true;
              break;
            }
          }
          if (intercepted) break;
        }

        // --- STEALTH 判定 (隐身闪避) ---
        if (e.stealthT>0){
          if (chance(0.70)){
            // 子弹穿过，微小闪光
            sparks(b.x,b.y,'glowW', 3, 180);
            b.noHitT = Math.max(b.noHitT, 0.03);
            continue;
          }
        }

        // --- 实际本体碰撞检测 ---
        if (hitCircle(b.x,b.y,b.r, e.x,e.y,e.r)){
          // 触发子弹命中钩子
          if (b.mods.length){
            for(const k of b.mods) BulletAffixCatalog[k]?.onHit?.(b, e, null);
          }
          
          // --- REFLECT 判定 (反弹盾) ---
          if (e.reflectT>0){
            const col = enemyColor(e);
            const sp = Math.hypot(b.vx,b.vy) || 260;
            const base = Math.atan2(-b.vy, -b.vx) + rand(-0.10, 0.10);
            // 反弹生成敌人子弹
            spawnBullet('E', b.x, b.y, Math.cos(base)*sp*0.95, Math.sin(base)*sp*0.95, {
              r: Math.max(2.4, b.r*0.95),
              dmg: Math.max(6, b.dmg*0.75),
              col, style: 1, life: 2.0
            });
            sparks(b.x,b.y, sprFromColor(col,'E'), 10, 360);
            spawnShockwave(b.x,b.y, col, 140, 0.35);
            killBullet(b, 'reflect', {childMods: propagateMods(b.mods)});
            break;
          }

          // 造成伤害
          e.onHit(b.dmg);
          SFX.enemyHit();
          sparks(b.x,b.y, b.spr, 7, 260);

          // 穿透逻辑
          if (b.pierce>0){
            b.pierce--;
            b.noHitT = 0.03;
          } else {
            killBullet(b, 'hit', {childMods: propagateMods(b.mods)});
          }

          // 敌人死亡逻辑
          if (e.hp<=0){
            e.alive=false;
            SFX.enemyKill();
            Game.score += e.score;

            // XP 计算
            const xp = clamp(Math.floor(3 + e.score*0.028), 2, 14);
            addXP(xp);

            sparks(e.x,e.y, 'glowE', 18, 420);
            spawnShockwave(e.x,e.y, e.tint||e.baseCol||C.E1, 240, 0.55);

            e.onDeath?.();

            if (e.type==='BOSS'){
              Game.bossAlive=false;
              SFX.bossDown?.();
              textPop(e.x,e.y,'BOSS DOWN', C.G);
              sparks(e.x,e.y,'glowE2', 90, 780);
              spawnShockwave(e.x,e.y,C.E2, 520, 0.85);
              addShake(18,0.52);
              spawnSupply(e.x-60, e.y, 'MOD');
              spawnSupply(e.x, e.y, 'WXP');
              spawnSupply(e.x+60, e.y, 'OVERDRIVE');
            } else {
              dropSupply(e.x,e.y);
            }
          }
          // 击中一个敌人后跳出当前潜在目标循环（除非是穿透，但穿透由 noHitT 控制，这里 break 也没问题，下一帧再判）
          break; 
        }
      }
    }

       // E bullets vs player
    for(const b of bulletsE){
      if (!b.alive || b._phaseGhost) continue;
      if (UnitBattle.active){
        if (tryHitUnitBattleOpponentByBullet(b)) continue;
        continue;
      }
      if (!Player.alive) continue;
      if (hitCircle(b.x,b.y,b.r, Player.x,Player.y, Player.r)){
        if (b.mods.length){
          for(const k of b.mods) BulletAffixCatalog[k]?.onHit?.(b, Player, null);
        }
        killBullet(b, 'hit', {childMods: propagateMods(b.mods)});
        onPlayerHit(b.dmg, b.slow||0);
        sparks(b.x,b.y,'glowE', 10, 360);
      }
    }

    updateBeams(dt);
    if (Game._slowZones){
      let zw = 0;
      for(const z of Game._slowZones){
        z.t += dt;
        if (z.t >= z.life) continue;
        Game._slowZones[zw++] = z;
        // 减速区内的玩家
        if (Player.alive && dist2(Player.x,Player.y,z.x,z.y) < z.r*z.r){
          Player.slowT = Math.max(Player.slowT, 0.15);
        }
        // 视觉粒子
        if (chance(0.08)){
          const p = particlePool.get();
          p.alive=true; p.x=z.x+rand(-z.r,z.r); p.y=z.y+rand(-z.r,z.r);
          p.vx=0; p.vy=0; p.t=0; p.life=0.35; p.a=0.25; p.spr='glowP2'; p.scale=0.35;
          pushParticle(p);
        }
      }
      Game._slowZones.length = zw;
    }
    updateSupplies(dt);
    updateParticles(dt);
    updateShockwaves(dt);
    updateTexts(dt);

    // cleanup enemies
    let w = 0;
    let foundBoss = false; // 记录当前数组里是否真的有 Boss 对象
    for (const e of enemies) {
      if (e.alive) {
        enemies[w++] = e;
        if (e.type === 'BOSS') foundBoss = true;
      } else {
        if (e.type === 'BOSS') Game.bossAlive = false;
      }
    }
    enemies.length = w;

    // 如果数组里没 Boss 了，但标记还是 true，强制重置
    if (!foundBoss && Game.mode !== 'lab') {
      Game.bossAlive = false;
    }

    cleanupBullets(bulletsP);
    cleanupBullets(bulletsE);

    // --- UI Updates (Adapted for Cyberpunk HUD) ---
ui.score.textContent = formatValue(Game.score);
    if (Game.mode==='fortress' || Game.mode==='lab' || Game.mode==='fortress_duel'){
      ui.wave.textContent = `${Game.wave}`;
    } else {
      ui.wave.textContent = Game.wave;
    }
    ui.lvText.textContent = Player.lv;
    ui.droneText.textContent = Player.drones;
    ui.modText.textContent = Player.mods;
    ui.bombText.textContent = Player.bomb;

    // HP Bar & Text
    const hpPct = clamp(Player.hp/Player.maxHp,0,1);
    ui.hpFill.style.width = (hpPct*100).toFixed(1)+'%';
    ui.hpText.textContent = `${Math.ceil(Player.hp)}/${Math.ceil(Player.maxHp)}`;

    // Shield Bar (Thin overlay)
    const shdPct = clamp(Player.shield/12,0,1);
    ui.shieldFill.style.width = (shdPct*100).toFixed(1)+'%';

    // XP Bar
    const xpPct = clamp(Player.xp/Player.xpNeed,0,1);
    ui.xpFill.style.width = (xpPct*100).toFixed(1)+'%';
    ui.xpText.textContent = `${Player.xp|0}/${Player.xpNeed}`;

    // Status Bars
    ui.odFill.style.width = (clamp(Player.overdriveT/10,0,1)*100).toFixed(1)+'%';
    ui.magFill.style.width = (clamp(Player.magnetT/12,0,1)*100).toFixed(1)+'%';

    // Chips Visibility
    ui.chipSlow.style.display = Player.slowT>0 ? 'flex' : 'none';
    ui.chipOD.style.display = Player.overdriveT>0 ? 'flex' : 'none';
    ui.chipMag.style.display = Player.magnetT>0 ? 'flex' : 'none';
    ui.chipShield.style.display = Player.shield>0 ? 'flex' : 'none';
    
    // Update chip timers
    if(Player.overdriveT>0) ui.odText.textContent = Player.overdriveT.toFixed(1);
    if(Player.magnetT>0) ui.magText.textContent = Player.magnetT.toFixed(1);
    if(Player.shield>0) ui.shText.textContent = Player.shield.toFixed(1);

    // Bomb Icons
    if (ui.bombIcons){
      // Re-render dots if count changed or init
      const currentDots = ui.bombIcons.childElementCount;
      if(currentDots !== 3) {
         ui.bombIcons.innerHTML = '<span class="bomb-dot"></span><span class="bomb-dot"></span><span class="bomb-dot"></span>';
      }
      const dots = ui.bombIcons.children;
      for(let i=0;i<3;i++){
        if(i < Player.bomb) dots[i].classList.add('on');
        else dots[i].classList.remove('on');
      }
    }

// death
    if (Player.hp <= 0 && Player.alive){
      
      if (TimeMachine.enabled) {
        const rewound = TimeMachine.rewind();
        if (rewound) {
          return; // 成功回溯，跳过死亡逻辑
        }
        // 如果 buffer 为空（比如刚开局就死），则继续执行下面的死亡逻辑
      }
      Game.killerData = null;
      if (Game.failReason !== 'flag'){
        Game.failReason = '';
        Game.failSnapshot = null;
      }
      // 查找最近的敌人作为"杀手"
      let killer = null, killerD = Infinity;
      for (const e of enemies){
        if (!e.alive) continue;
        const d2 = dist2(Player.x, Player.y, e.x, e.y);
        if (d2 < killerD){ killerD = d2; killer = e; }
      }
      if (killer) Game.killerData = extractEnemyForForge(killer);

      Player.alive=false;
      Player.deathT = 1.10;
      sparks(Player.x,Player.y,'glowP2', 80, 760);
      spawnShockwave(Player.x,Player.y,C.P2, 520, 0.8);
      addShake(22,0.58);
      setTimeout(gameOver, 900); // slightly longer delay for drama
    }
  }
  
  
const AutoPilot = {
  active: false,

  // AI 直接控制的目标点（将直接写 Player.x/y）
  goalX: 0,
  goalY: 0,

  // 节流
  _thinkCd: 0,
  _safeT: 0,
  _fortBuildCd: 0,
  _fortSellsThisFortify: 0,
  _fortPhaseSeen: 'idle',


  CONFIG: {
    // 决策频率与仿真
    THINK_HZ: 26,          // 每秒决策次数（建议 16~26）
    HORIZON: 0.90,         // 前视时间窗（秒）
    SIM_STEPS: 15,         // 仿真步数（8~14）
    MAX_SIM_BULLETS: 90,   // 只仿真最危险的前 N 颗子弹（性能/效果折中）

    // 候选点采样（“下一步站哪儿”）
    RING_R: 140,
    RING_N: 14,
    EXTRA_POINTS: true,

    // 安全边距（越大越不撞弹/撞机，但越保守）
    SAFE_MARGIN: 30,

    // 子弹风险权重
    BULLET_W: 1.0,
    HOMING_W: 3.6,
    BEAM_W: 2.4,
    MINE_W: 2.8,

    // 敌机：强硬禁止靠近（解决“被逼到撞机”）
    ENEMY_HARD_PAD: 34,     // 额外 padding
    ENEMY_HARD_PENALTY: 1e8, // 进入此半径直接判死刑
    ENEMY_SOFT_W: 1.2,       // 软惩罚（让 AI 也不贴太近）

    // 墙边惩罚
    WALL_PAD: 38,
    TOP_PAD: 78,
    WALL_W: 1.0,

    // 输出（仅在“连续安全”时）
    ATTACK_ENABLE: true,
    SAFE_SCORE_GATE: 0.65,  // “足够安全”的阈值（score 越小越安全）
    SAFE_BUILDUP: 0.35,     // 连续安全 >= 才增强输出
    ATTACK_X_W: 120,        // 对齐目标 X 的奖励（减分）
    IDEAL_Y: 0.74,
    IDEAL_Y_W: 70,

    // 直接写 Player.x/y 时的“最大瞬移距离”
    // 你说要“强制设定忽略 lerp”，这里给你一个安全阀：
    // 想完全瞬移就设成 Infinity。
    MAX_TELEPORT_PER_TICK: 99999,

    // 堡垒建造随机探索（可控）
    FORT_RANDOMNESS: 0.26,
    FORT_EXPLORE_RATE: 0.34,
  },

  setActive(on){
    this.active = !!on;
    const btn = document.getElementById('btnAutoPilot');
    if (btn){
      btn.textContent = 'AI: ' + (this.active ? 'ON' : 'OFF');
      btn.style.backgroundColor = this.active ? 'rgba(179,108,255,0.3)' : 'transparent';
    }
    if (this.active){
      this.goalX = Player.x;
      this.goalY = Player.y;
      this._thinkCd = 0;
      this._safeT = 0;
      this._fortBuildCd = 0;
      this._fortSellsThisFortify = 0;
      this._fortPhaseSeen = Fortress?.phase || 'idle';
    }
  },

  toggle(){
    this.setActive(!this.active);
  },

  _fortItemPower(type){
    const score = {
      barricade:0.8, wall:1.2, heavywall:2.0, bunker:2.8, shield:2.3,
      turret:2.6, gatling:2.9, sniper:2.5, missile:3.6, tesla:3.0, flame:2.7, mortar:3.2,
      dronepad:2.5, pulse:2.6, mine:1.0, slow:1.3,
      repair:2.2, repairplayer:3.2, repairfield:2.0, factory:1.6,
      spinner:2.6, ram:2.2, beacon:2.4, taunt:2.8
    };
    return score[type] || 1.0;
  },

  _fortOverlapRatio(x, y, cfg){
    if (!cfg) return 0;
    const l1 = x - cfg.w*0.5, r1 = x + cfg.w*0.5;
    const t1 = y - cfg.h*0.5, b1 = y + cfg.h*0.5;
    let worst = 0;
    for (const st of Fortress.structures){
      if (!st || st.hp <= 0) continue;
      const l2 = st.x - st.w*0.5, r2 = st.x + st.w*0.5;
      const t2 = st.y - st.h*0.5, b2 = st.y + st.h*0.5;
      const iw = Math.min(r1, r2) - Math.max(l1, l2);
      const ih = Math.min(b1, b2) - Math.max(t1, t2);
      if (iw <= 0 || ih <= 0) continue;
      const inter = iw * ih;
      const base = Math.min(cfg.w*cfg.h, st.w*st.h);
      worst = Math.max(worst, inter / Math.max(1, base));
    }
    return worst;
  },

  _fortOverlapThreshold(itemType){
    const p = this._fortItemPower(itemType);
    const scoreK = clamp((Game.score - 900) / 3200, 0, 1);
    return clamp(0.12 + scoreK * 0.28 + (p >= 2.8 ? 0.06 : 0), 0.10, 0.46);
  },

  _fortTryPlaceSmart(itemType, x, y, tries=4){
    const cfg = Fortress.catalog[itemType];
    if (!cfg) return false;
    const th = this._fortOverlapThreshold(itemType);

    for (let i=0; i<Math.max(1, tries); i++){
      const ox = (i===0) ? 0 : (i%2 ? 10 : -10) * (1 + ((i/2)|0));
      const oy = (i===0) ? 0 : (((i%3)-1) * 8);
      const tx = clamp(x + ox, 30, W-30);
      const ty = clamp(y + oy, H*0.40, H-70);
      const over = this._fortOverlapRatio(tx, ty, cfg);
      if (over > th) continue;
      Fortress.selected = itemType;
      if (Fortress.placeAt(tx, ty)) return true;
    }

    return false;
  },

  _fortPreferredPlacement(type, have, rows, slots){
    const left = slots[Math.max(0, Math.floor(slots.length*0.25)-1)] || slots[1] || W*0.32;
    const right = slots[Math.min(slots.length-1, Math.floor(slots.length*0.75))] || slots[4] || W*0.68;
    const center = W*0.5;
    const lane = slots[have % slots.length] || center;

    if (['barricade','wall','heavywall','bunker','shield'].includes(type)){
      const x = slots[(have*2 + 1) % slots.length] || lane;
      return {x, y: rows[0] + ((have%2)?8:-6)};
    }
    if (type==='repairplayer') return {x: clamp(center + ((have%2)?-72:72), 40, W-40), y: rows[1] + 18};
    if (type==='repair') return {x:center, y:rows[1]};
    if (type==='sniper' || type==='mortar' || type==='missile') return {x:(have%2?left:right), y:rows[2]-4};
    if (type==='gatling' || type==='flame' || type==='spinner' || type==='ram') return {x:lane, y:rows[0]-6};
    if (type==='tesla' || type==='pulse' || type==='dronepad' || type==='beacon') return {x:lane, y:rows[1]-4};
    if (type==='mine' || type==='slow') return {x:slots[(have*2+1)%slots.length] || lane, y:rows[2]-14};
    if (type==='factory' || type==='repairfield') return {x:(have%2?left:right), y:rows[2]+6};
    if (type==='taunt') return {x:center, y:rows[2]-10};
    return {x:lane, y:rows[1]};
  },

  _fortTrySellFor(itemType, preferredSacrifice=[]){
    const cfg = Fortress.catalog[itemType];
    if (!cfg) return false;
    const need = cfg.cost - Fortress.stock;
    if (need <= 0) return false;
    if ((this._fortSellsThisFortify||0) >= 1) return false;
    if (need > Math.max(4, cfg.cost * 0.5)) return false;

    // 早期严禁卖建筑，避免“第一轮建了拆、拆了建”
    if ((Game.wave||1) <= 3) return false;
    if ((Game.time||0) - (this._fortLastSellT||-999) < 2.6) return false;

    const minKeep = { wall:2, heavywall:1, turret:1, repairplayer:1 };
    const liveCountByType = Fortress.structures.reduce((m, st)=>{
      if (st?.hp>0) m[st.type] = (m[st.type]||0) + 1;
      return m;
    }, Object.create(null));

    const targetPower = this._fortItemPower(itemType);
    const sacSet = new Set(preferredSacrifice);
    const candidates = Fortress.structures
      .filter(st => st.hp>0)
      .map(st => {
        const c = Fortress.catalog[st.type];
        const refund = Math.max(1, Math.floor((st.cost||c?.cost||6)*0.6));
        const hpPct = clamp(st.hp / Math.max(1, st.maxHp||1), 0, 1);
        const builtAge = (Game.time||0) - (st._builtAt||0);
        const builtWaveAge = (Game.wave||1) - (st._builtWave||1);
        const keepMin = (liveCountByType[st.type]||0) <= (minKeep[st.type]||0);
        const sellable = !keepMin && (builtAge >= 18 || builtWaveAge >= 2);
        const oldPower = this._fortItemPower(st.type);
        const powerGain = targetPower - oldPower;
        const pref = sacSet.has(st.type) ? 0 : 1;
        const score = pref*1000 + hpPct*100 + (st.cost||c?.cost||0) - powerGain*80;
        return {st, refund, score, sellable, powerGain};
      })
      .filter(it => it.refund > 0 && it.sellable && it.powerGain > 0.55)
      .sort((a,b)=>a.score-b.score);

    for (const it of candidates){
      if ((Fortress.stock + it.refund) < cfg.cost) continue;
      if (Fortress.sellAt(it.st.x, it.st.y)){
        this._fortLastSellT = Game.time || 0;
        this._fortSellsThisFortify = (this._fortSellsThisFortify||0) + 1;
        return true;
      }
    }
    return false;
  },

  _fortPlaceGuardForHealer(rows, slots){
    const healer = Fortress.structures.find(st=>st.hp>0 && st.type==='repairplayer');
    if (!healer) return false;

    const guards = [
      {x:healer.x, y:clamp(healer.y-38, rows[2]-18, rows[0]+20)},
      {x:clamp(healer.x-52, 36, W-36), y:clamp(healer.y-8, rows[1]-16, rows[0]+22)},
      {x:clamp(healer.x+52, 36, W-36), y:clamp(healer.y-8, rows[1]-16, rows[0]+22)}
    ];

    const guardNeed = guards.find(g => !Fortress.structures.some(st => st.hp>0 && ['barricade','wall','heavywall','bunker','shield'].includes(st.type) && dist2(st.x, st.y, g.x, g.y) < 52*52));
    if (!guardNeed) return false;

    const pick = (Fortress.stock >= (Fortress.catalog.heavywall?.cost||999)) ? 'heavywall'
      : (Fortress.stock >= (Fortress.catalog.wall?.cost||999)) ? 'wall'
      : (Fortress.stock >= (Fortress.catalog.barricade?.cost||999)) ? 'barricade'
      : null;

    if (!pick){
      if (this._fortTrySellFor('wall', ['mine','slow','taunt','factory'])) return true;
      return false;
    }

    Fortress.selected = pick;
    if (this._fortTryPlaceSmart(pick, guardNeed.x, guardNeed.y, 5)) return true;
    for (const sx of slots){
      Fortress.selected = pick;
      if (this._fortTryPlaceSmart(pick, sx, guardNeed.y, 3)) return true;
    }
    return false;
  },

  _fortWithExploration(plan, byType){
    const rnd = clamp(this.CONFIG.FORT_RANDOMNESS || 0, 0, 0.75);
    if (rnd <= 0 || !Array.isArray(plan) || plan.length < 3) return plan;
    if (Math.random() > (this.CONFIG.FORT_EXPLORE_RATE || 0.3)) return plan;

    const candidates = plan.filter(step => {
      const cfg = Fortress.catalog[step.type];
      const have = byType[step.type] || 0;
      return cfg && Fortress.stock >= cfg.cost && have < step.max;
    });
    if (!candidates.length) return plan;

    const pick = candidates[(Math.random() * candidates.length) | 0];
    const copy = plan.slice();
    const idx = copy.findIndex(v => v.type === pick.type);
    if (idx <= 0) return copy;
    copy.splice(idx, 1);
    const shift = 1 + ((Math.random() * Math.max(1, Math.floor(5 * rnd))) | 0);
    copy.splice(Math.min(copy.length, shift), 0, pick);
    return copy;
  },

  _autoFortressBuild(dt){
    if (Game.mode!=='fortress' || Fortress.phase!=='fortify' || !Fortress.canBuild()) return;
    if (this._fortPhaseSeen !== Fortress.phase){
      this._fortPhaseSeen = Fortress.phase;
      if (Fortress.phase==='fortify') this._fortSellsThisFortify = 0;
    }
    this._fortBuildCd = Math.max(0, (this._fortBuildCd||0) - dt);
    if (this._fortBuildCd > 0) return;

    const byType = {};
    for (const st of Fortress.structures){
      byType[st.type] = (byType[st.type]||0) + 1;
    }

    const hpRatio = Player.maxHp>0 ? (Player.hp/Player.maxHp) : 1;
    const flagRatio = Fortress.flagMaxHp>0 ? (Fortress.flagHp/Fortress.flagMaxHp) : 1;
    // 残血时优先建立“回血站”（医疗站+前置墙）
    if ((byType.repairplayer||0) < 1 && hpRatio < 0.90){
      const needStock = (Fortress.catalog.repairplayer?.cost||12) - Fortress.stock;
      if (needStock > 0 && this._fortTrySellFor('repairplayer', ['mine','slow','factory','taunt','barricade'])){
        this._fortBuildCd = 0.08;
        return;
      }
    }

    if ((byType.repairplayer||0) < 1 && hpRatio < 0.82){
      const cfg = Fortress.catalog.repairplayer;
      if (cfg && Fortress.stock >= cfg.cost){
        Fortress.selected = 'repairplayer';
        if (this._fortTryPlaceSmart('repairplayer', clamp(Player.x, 44, W-44), clamp(Player.y + 34, H*0.52, H-72), 4)){
          this._fortBuildCd = 0.12;
          return;
        }
      }
    }

    if ((byType.repair||0) < 1 && flagRatio < 0.94){
      const cfg = Fortress.catalog.repair;
      if (cfg && Fortress.stock >= cfg.cost){
        Fortress.selected = 'repair';
        if (this._fortTryPlaceSmart('repair', W*0.5, H-112, 5)){
          this._fortBuildCd = 0.12;
          return;
        }
      }
    }

    const baseY = H - 132;
    const rows = [baseY, baseY - 58, baseY - 108];
    const slots = [0.18,0.32,0.46,0.54,0.68,0.82].map(k=>W*k);

    if (this._fortPlaceGuardForHealer(rows, slots)){
      this._fortBuildCd = 0.10;
      return;
    }

    // 先封住所有前线通道，不再只补左半边少量钢壁
    const laneOpen = slots.map(x => !Fortress.structures.some(st=>st.hp>0 && ['barricade','wall','heavywall','bunker','shield'].includes(st.type) && Math.abs(st.x-x) < (st.w*0.55 + 12) && st.y > H*0.46));
    const openLanes = [];
    for (let i=0;i<laneOpen.length;i++) if (laneOpen[i]) openLanes.push(i);
    if (openLanes.length){
      const order = openLanes.sort((a,b)=>Math.abs(a-(slots.length-1)/2)-Math.abs(b-(slots.length-1)/2));
      const low = Fortress.catalog.barricade;
      const mid = Fortress.catalog.wall;
      const high = Fortress.catalog.heavywall;
      const pick = (Fortress.stock >= (high?.cost||999)) ? 'heavywall'
        : (Fortress.stock >= (mid?.cost||999)) ? 'wall'
        : (Fortress.stock >= (low?.cost||999)) ? 'barricade' : null;
      if (pick){
        Fortress.selected = pick;
        const idx = order[0];
        if (this._fortTryPlaceSmart(pick, slots[idx], baseY+4, 6)){
          this._fortBuildCd = 0.10;
          return;
        }
      }
    }

    const planBase = [
      {type:'barricade', max:7, y:rows[0]},
      {type:'wall', max:6, y:rows[0]},
      {type:'heavywall', max:3, y:rows[1]},
      {type:'bunker', max:1, y:rows[2]},
      {type:'shield', max:2, y:rows[1]},
      {type:'repairplayer', max:2, y:rows[1]},
      {type:'repair', max:2, y:rows[1]},
      {type:'repairfield', max:2, y:rows[2]},
      {type:'turret', max:4, y:rows[1]},
      {type:'gatling', max:3, y:rows[0]},
      {type:'tesla', max:2, y:rows[1]},
      {type:'sniper', max:2, y:rows[2]},
      {type:'missile', max:1, y:rows[2]},
      {type:'flame', max:2, y:rows[0]},
      {type:'mortar', max:1, y:rows[2]},
      {type:'dronepad', max:1, y:rows[1]},
      {type:'pulse', max:1, y:rows[1]},
      {type:'mine', max:5, y:rows[2]},
      {type:'slow', max:3, y:rows[2]},
      {type:'factory', max:1, y:rows[1]},
      {type:'spinner', max:1, y:rows[1]},
      {type:'ram', max:1, y:rows[1]},
      {type:'beacon', max:1, y:rows[1]},
      {type:'taunt', max:1, y:rows[2]},
    ];

    const offenseSet = new Set(['turret','gatling','sniper','missile','tesla','flame','mortar','dronepad','pulse']);
    const defenseSet = new Set(['barricade','wall','heavywall','bunker','shield']);
    let offN=0, defN=0;
    for (const st of Fortress.structures){
      if (st.hp<=0) continue;
      if (offenseSet.has(st.type)) offN++;
      if (defenseSet.has(st.type)) defN++;
    }
    const wantOffense = (offN < 3) || (offN < Math.max(2, Math.floor((offN+defN)*0.35)));

    const plan = this._fortWithExploration(planBase, byType);
    for (const step of plan){
      const have = byType[step.type] || 0;
      if (have >= step.max) continue;
      if (step.type==='mine' && Game.mode==='fortress_duel' && Game.lastStart?.net) continue;
      const cfg = Fortress.catalog[step.type];
      if (!cfg || Fortress.stock < cfg.cost) continue;
      if (wantOffense && defenseSet.has(step.type) && !['repair','repairplayer','repairfield'].includes(step.type)) continue; // 优先补攻击位，但维修站不降级
      Fortress.selected = step.type;
      const p = this._fortPreferredPlacement(step.type, have, rows, slots);
      const x = p.x;
      const y = p.y;
      if (this._fortTryPlaceSmart(step.type, x, y, 5)){
        this._fortBuildCd = 0.18;
        return;
      }
    }

    if (Fortress.flagHp < Fortress.flagMaxHp*0.72 && Fortress.stock >= 6){
      Fortress.repairFlag(6, 180);
      this._fortBuildCd = 0.15;
      return;
    }

    const curOff = Fortress.structures.filter(s=>s.hp>0 && ['turret','gatling','sniper','missile','tesla','flame','mortar','dronepad','pulse'].includes(s.type)).length;
    if (curOff < 2){
      const targetAtk = (Fortress.stock >= (Fortress.catalog.missile?.cost||999)) ? 'missile' : 'turret';
      if (this._fortTrySellFor(targetAtk, ['barricade','mine','slow','factory','taunt'])){
        this._fortBuildCd = 0.10;
        return;
      }
    }
    if (curOff===0){
      const firstAtk = (Fortress.stock >= (Fortress.catalog.turret?.cost||999)) ? 'turret' : ((Fortress.stock >= (Fortress.catalog.gatling?.cost||999)) ? 'gatling' : null);
      if (firstAtk){
        Fortress.selected = firstAtk;
        if (this._fortTryPlaceSmart(firstAtk, W*0.5, rows[1], 6)){ this._fortBuildCd = 0.2; return; }
      }
    }

    // 兜底：若有可负担的建筑但布局冲突，尝试从全目录扫描任意可放置项
    const placeAnyAffordable = () => {
      const keys = Object.keys(Fortress.catalog);
      const affordable = keys.filter(k => Fortress.stock >= (Fortress.catalog[k]?.cost || 1e9));
      if (!affordable.length) return false;
      for (const k of affordable){
        const cfg = Fortress.catalog[k];
        Fortress.selected = k;
        for (let i=0;i<slots.length;i++){
          const x = slots[i] + ((i%2) ? 16 : -16);
          const y = rows[(i + (cfg?.w||0)) % rows.length] + ((i%3)-1)*10;
          if (this._fortTryPlaceSmart(k, x, y, 3)) return true;
        }
      }
      return false;
    };
    if (placeAnyAffordable()){
      this._fortBuildCd = 0.18;
      Fortress.autoAssaultStall = 0;
      return;
    }

    const minCost = Object.values(Fortress.catalog).reduce((m, it)=>Math.min(m, it.cost||999), 999);
    const cannotAffordAny = Fortress.stock < minCost;
    const dynamicCap = clamp(18 + Math.floor(Fortress.stock/8) + Math.floor(Game.wave/2), 18, 56);
    const canStillAffordMany = Fortress.stock >= (minCost * 2);
    Fortress.autoAssaultStall = (Fortress.autoAssaultStall||0) + 1;
    if ((cannotAffordAny || Fortress.structures.length >= dynamicCap) && !canStillAffordMany && Fortress.autoAssaultStall >= 8){
      Fortress.beginAssault();
      this._fortBuildCd = 0.25;
      Fortress.autoAssaultStall = 0;
      return;
    }

    // 卡住但仍有大额材料：继续尝试，不急着开波
    if (Fortress.stock >= 30){
      this._fortBuildCd = 0.10;
      return;
    }
  },

  _fortressSelfPreservePoint(){
    if (Game.mode!=='fortress' || Game.state!=='playing' || !Player.alive) return null;
    const hpRatio = Player.maxHp>0 ? (Player.hp/Player.maxHp) : 1;
    if (hpRatio > 0.62 && Player.invuln<=0 && Player.shield>0) return null;

    let threat = 0;
    for (const b of bulletsE){
      if (!b.alive) continue;
      const d2 = dist2(Player.x, Player.y, b.x, b.y);
      if (d2 < 180*180) threat += 1.0 - Math.sqrt(d2)/180;
    }

    const needRetreat = hpRatio < 0.52 || threat > 2.2;
    if (!needRetreat) return null;

    const healers = Fortress.structures.filter(st => st.hp>0 && st.type==='repairplayer');
    if (healers.length){
      let best = healers[0], bd = Infinity;
      for (const st of healers){
        const d2 = dist2(Player.x, Player.y, st.x, st.y);
        if (d2 < bd){ bd = d2; best = st; }
      }
      return { x: clamp(best.x, 20, W-20), y: clamp(best.y - 20, 60, H-28) };
    }

    return { x: clamp(W*0.5 + (Player.x<W*0.5?-66:66), 20, W-20), y: clamp(H-130, 70, H-24) };
  },

  _fortressFlagInterceptPoint(){
    if (Game.mode!=='fortress' || Game.state!=='playing' || Fortress.phase!=='assault') return null;
    const flagX = W*0.5, flagY = H-62;
    let best = null, bestScore = -1e18;
    for (const e of enemies){
      if (!e.alive) continue;
      const downThreat = (e.vy||0) > -30 ? 1 : 0.6;
      const toFlagX = Math.abs(e.x - flagX);
      if (toFlagX > 230) continue;
      const nearBottom = clamp((e.y - H*0.36)/(H*0.52), 0, 1);
      const flagRush = clamp((flagY - e.y)/Math.max(30, flagY), 0, 1);
      const score = nearBottom*1.6 + (1 - toFlagX/230)*1.4 + downThreat*0.9 + (1-flagRush)*0.8;
      if (score > bestScore){ bestScore = score; best = e; }
    }
    if (!best || bestScore < 1.1) return null;
    return {
      x: clamp(best.x, W*0.5-170, W*0.5+170),
      y: clamp(Math.min(H-120, best.y + 34), H*0.56, H-76)
    };
  },

  _fortressGapGuardPoint(){
    if (Game.mode!=='fortress' || Game.state!=='playing' || Fortress.phase!=='assault') return null;
    const slots = [0.18,0.32,0.46,0.54,0.68,0.82].map(k=>W*k);

    let best = null;
    let bestRisk = -1e18;

    for (const x of slots){
      // 该通道防线强度（HP + 厚度）
      let defenseHp = 0;
      let defenseCount = 0;
      for (const st of Fortress.structures){
        if (st.hp<=0) continue;
        if (Math.abs(st.x - x) > (st.w*0.55 + 20)) continue;
        if (st.y < H*0.46) continue;
        defenseHp += st.hp;
        defenseCount += 1;
      }
      const defenseNorm = clamp(defenseHp / 2400, 0, 1.4);

      // 该通道来袭威胁（敌机 + 敌弹）
      let enemyThreat = 0;
      let nearestEnemyY = -9999;
      for (const e of enemies){
        if (!e.alive) continue;
        const lane = Math.abs(e.x - x);
        if (lane > 130) continue;
        const nearFlag = clamp((e.y - H*0.28) / (H*0.70), 0, 1);
        const laneW = 1 - lane/130;
        enemyThreat += laneW * (0.7 + nearFlag*1.6);
        if (e.y > nearestEnemyY) nearestEnemyY = e.y;
      }

      let bulletThreat = 0;
      for (const b of bulletsE){
        if (!b.alive) continue;
        if (b.vy <= 0) continue;
        const lane = Math.abs(b.x - x);
        if (lane > 95) continue;
        const nearFlag = clamp((b.y - H*0.30) / (H*0.72), 0, 1);
        bulletThreat += (1 - lane/95) * (0.4 + nearFlag*1.5);
      }

      const laneThreat = enemyThreat + bulletThreat*0.85;
      const weakness = clamp(1.55 - defenseNorm - defenseCount*0.08, 0.25, 1.75);
      const flagLowMul = (Fortress.flagHp < Fortress.flagMaxHp*0.45) ? 1.35 : 1.0;
      const centerBonus = 1 - Math.min(1, Math.abs(x - W*0.5)/(W*0.5));
      const distW = 1 / (1 + Math.abs(Player.x - x) * 0.011);

      const risk = laneThreat * weakness * flagLowMul + centerBonus*0.45 + distW*0.25;
      if (risk > bestRisk){
        bestRisk = risk;
        const targetY = (nearestEnemyY > 0)
          ? clamp(nearestEnemyY + 46, H*0.58, H-116)
          : clamp(H-152, 84, H-44);
        best = {x, y:targetY, risk};
      }
    }

    if (!best) return null;
    const urgent = best.risk > 1.05 || Fortress.flagHp < Fortress.flagMaxHp*0.55;
    if (!urgent) return null;
    return {x:best.x, y:best.y};
  },

  _fortressGuardPoint(){
    if (Game.mode!=='fortress' || Game.state!=='playing' || !Player.alive) return null;
    const danger = bulletsE.filter(b=>b.alive && b.y>H*0.45 && b.vy>0 && Math.abs(b.x-W*0.5)<170);
    const flood = danger.length;
    const brave = (Player.invuln>0 || Player.shield>0);
    const th = brave ? 4 : 8;
    if (flood < th) return null;
    const avgX = danger.reduce((a,b)=>a+b.x,0)/Math.max(1,flood);
    return {
      x: clamp(avgX, W*0.5-120, W*0.5+120),
      y: clamp(H-168, 80, H-40)
    };
  },

  _autoFortressUseUtilities(dt){
    if (Game.mode!=='fortress' || Game.state!=='playing' || Fortress.phase!=='assault') return;
    this._fortUtilCd = Math.max(0, (this._fortUtilCd||0) - dt);
    if (this._fortUtilCd > 0) return;

    const threat = enemies
      .filter(e=>e.alive)
      .sort((a,b)=> (Math.abs(a.x-W*0.5)*0.45 + Math.abs((H-62)-a.y)) - (Math.abs(b.x-W*0.5)*0.45 + Math.abs((H-62)-b.y)))[0] || null;

    for (const st of Fortress.structures){
      if (st.hp<=0) continue;
      if (st.type==='spinner'){
        const near = enemies.find(e=>e.alive && dist2(st.x,st.y,e.x,e.y) < 220*220);
        if (near){
          st.spinBoost = Math.max(st.spinBoost||0, 1.1);
          st.rot = Math.atan2(near.y-st.y, near.x-st.x);
        }
      } else if (st.type==='ram'){
        if ((st.dashT||0) > 0 || (st._aiRamCd||0) > 0) { st._aiRamCd = Math.max(0,(st._aiRamCd||0)-dt); continue; }
        const t = enemies.find(e=>e.alive && dist2(st.x,st.y,e.x,e.y) < 260*260);
        if (t){
          st.rot = Math.atan2(t.y-st.y, t.x-st.x);
          st.baseX = st.x; st.baseY = st.y;
          st.dashT = 0.40;
          st._aiRamCd = 2.2;
          spawnShockwave(st.x, st.y, '#ffcb66', 90, 0.16);
        }
      } else if (st.type==='beacon'){
        const danger = enemies.filter(e=>e.alive && e.y>H*0.38 && Math.abs(e.x-W*0.5)<220).length;
        const wantMode = (Fortress.flagHp < Fortress.flagMaxHp*0.55 || danger>=5) ? 1 : (Fortress.stock < 10 ? 2 : 0);
        st.mode = wantMode;
        if (threat){
          const tx = clamp(threat.x, W*0.5-170, W*0.5+170);
          const ty = clamp(threat.y + 40, H*0.42, H-70);
          st.x = clamp(lerp(st.x, tx, 0.55), 24, W-24);
          st.y = clamp(lerp(st.y, ty, 0.55), H*0.36, H-54);
          st.rot = (st.rot||0) + 0.35;
        }
      }
    }

    this._fortUtilCd = 0.22;
  },

  /**
   * 返回 true 表示 AI 已经接管并写入 Player.x/y，外部应跳过正常输入移动。
   */
  update(dt){
    if (!this.active || !Player.alive || Game.state !== 'playing') return false;

    if (Game.mode==='fortress') { this._autoFortressBuild(dt); this._autoFortressUseUtilities(dt); }

    const C = this.CONFIG;

    const fortSelf = this._fortressSelfPreservePoint();
    const fortFlagIntercept = this._fortressFlagInterceptPoint();
    const fortGuard = this._fortressGuardPoint();
    const fortGap = this._fortressGapGuardPoint();
    if (fortSelf){
      this.goalX = fortSelf.x;
      this.goalY = fortSelf.y;
      this._thinkCd = Math.max(this._thinkCd, 1 / C.THINK_HZ);
    } else if (fortFlagIntercept){
      this.goalX = fortFlagIntercept.x;
      this.goalY = fortFlagIntercept.y;
      this._thinkCd = Math.max(this._thinkCd, 1 / C.THINK_HZ);
    } else if (fortGuard){
      this.goalX = fortGuard.x;
      this.goalY = fortGuard.y;
      this._thinkCd = Math.max(this._thinkCd, 1 / C.THINK_HZ);
    } else if (fortGap){
      // 次级策略：补位旗帜防线空档，再看建筑保护
      this.goalX = fortGap.x;
      this.goalY = fortGap.y;
      this._thinkCd = Math.max(this._thinkCd, 1 / C.THINK_HZ);
    } else {
      // 限频思考
      this._thinkCd -= dt;
      if (this._thinkCd <= 0){
        this._thinkCd = 1 / C.THINK_HZ;
        this._decideGoal();
      }
    }

    // 直接强制设定 Player 坐标（带一个安全的最大步长钳制）
    const dx = this.goalX - Player.x;
    const dy = this.goalY - Player.y;
    const d  = Math.hypot(dx, dy);

    let nx = this.goalX, ny = this.goalY;
    const maxStep = C.MAX_TELEPORT_PER_TICK;
    if (d > maxStep){
      const k = maxStep / d;
      nx = Player.x + dx * k;
      ny = Player.y + dy * k;
    }

    Player.x = clamp(nx, 16, W - 16);
    Player.y = clamp(ny, (Game.mode==='fortress_duel' ? H*0.5 + 16 : 40), H - 22);

    // 同步 Input，避免其他系统依赖 Input 时出现断裂
    Input.px = Player.x; Input.py = Player.y;
    Input.tx = Player.x; Input.ty = Player.y;
    Input.active = true;

    return true;
  },

  // ========================= 决策：采样候选点 + 全仿真评分 =========================

  _pickSupplyPoint(px, py){
    if (!supplies.length) return null;
    let best = null;
    let bestScore = -1e18;
    const hpRatio = Player.maxHp>0 ? (Player.hp/Player.maxHp) : 1;
    for (const s of supplies){
      if (!s || s.dead) continue;
      const d = Math.hypot((s.x||0)-px, (s.y||0)-py);
      if (d > 520) continue;
      let score = 420 - d;
      if (hpRatio < 0.55) score += 85;
      if ((s.key||'') === 'HEAL') score += 120;
      if ((s.key||'') === 'SHIELD') score += 70;
      // 屏幕底部补给更容易顺手吃到
      score += clamp(((s.y||0)-H*0.45)/H, -0.2, 0.3) * 55;
      if (score > bestScore){ bestScore = score; best = s; }
    }
    if (!best || bestScore < -40) return null;
    return { x:clamp(best.x, 18, W-18), y:clamp(best.y, 52, H-28) };
  },

  _decideGoal(){
    const C = this.CONFIG;
    const px = Player.x, py = Player.y;

    // 1) 预筛子弹（只选最危险的前 N 个，避免爆算力）
    const bullets = this._selectThreatBullets(px, py, C.MAX_SIM_BULLETS);

    // 2) 候选点集合
    const cand = [];
    cand.push({x:px, y:py});

    const R = C.RING_R;
    const N = C.RING_N;

    // 轻微偏下，降低“上飘撞机”
    const yBias = R * 0.18;

    for (let i=0;i<N;i++){
      const a = (i/N) * Math.PI * 2;
      cand.push({
        x: px + Math.cos(a) * R,
        y: py + Math.sin(a) * R + yBias
      });
    }

    if (C.EXTRA_POINTS){
      cand.push({x: W*0.50, y: H*0.80});
      cand.push({x: W*0.32, y: H*0.82});
      cand.push({x: W*0.68, y: H*0.82});
      if (Game.mode==='fortress' || Game.mode==='lab'){
        cand.push({x:W*0.50, y:H*0.72});
        cand.push({x:W*0.40, y:H*0.74});
        cand.push({x:W*0.60, y:H*0.74});
      }
    }

    // 3) 进攻偏好（只在“连续安全”时启用）
    let predX = null;
    let idealY = clamp(H * C.IDEAL_Y, 90, H - 70);
    if (Game.mode==='fortress') idealY = clamp(H * 0.68, 86, H - 86);

    if (C.ATTACK_ENABLE){
      // 用当前点的 score 粗测环境安全
      const curScore = this._scoreCandidate(px, py, bullets, 0, null, idealY, null);

      if (curScore < C.SAFE_SCORE_GATE) this._safeT += (1 / C.THINK_HZ);
      else this._safeT = Math.max(0, this._safeT - (2.0 / C.THINK_HZ));

      const atkBoost = clamp((this._safeT - C.SAFE_BUILDUP) / 0.8, 0, 1);

      if (atkBoost > 0.01){
        const t = this._pickTarget(px, py);
        if (t){
          predX = this._predictTargetX(t, px, py);
          // 把“对齐输出点”也作为候选点（但只在安全窗口里）
          cand.push({x: predX, y: idealY});
          cand.push({x: predX, y: idealY - 40});
        }
      }
    }

    const supplyPt = this._pickSupplyPoint(px, py);
    if (supplyPt){
      cand.push({x:supplyPt.x, y:supplyPt.y});
      cand.push({x:supplyPt.x, y:clamp(supplyPt.y + 24, 40, H-22)});
    }

    // 4) 评分选最优
    let best = cand[0];
    let bestScore = 1e18;

    for (const p of cand){
      const x = clamp(p.x, 16, W - 16);
      const y = clamp(p.y, 40, H - 22);

      const score = this._scoreCandidate(x, y, bullets, predX, null, idealY, supplyPt);
      if (score < bestScore){
        bestScore = score;
        best = {x, y};
      }
    }

    this.goalX = best.x;
    this.goalY = best.y;
  },

  // 选最危险的子弹（按距离+速度+homing 等排序）
  _selectThreatBullets(px, py, maxN){
    const arr = [];
    const R = 860;
    const R2 = R*R;

    for (const b of bulletsE){
      if (!b.alive) continue;
      if (b._phaseGhost) continue;

      const dx = b.x - px, dy = b.y - py;
      const d2 = dx*dx + dy*dy;
      if (d2 > R2) continue;

      const sp = Math.hypot(b.vx, b.vy);
      const hom = (b.homing > 0) ? 1 : 0;
      const mine = (b.mineT > 0) ? 1 : 0;

      // 分数越低越危险（优先仿真）
      const key = (d2 / (1 + sp*0.02)) * (hom ? 0.35 : 1.0) * (mine ? 0.65 : 1.0);
      arr.push({b, key});
    }

    arr.sort((a,b)=>a.key-b.key);
    const out = [];
    for (let i=0;i<Math.min(maxN, arr.length); i++) out.push(arr[i].b);
    return out;
  },

  // 对候选点 (x,y) 打分：越小越好
  _scoreCandidate(x, y, bullets, predX, _unused, idealY, supplyPt){
    const C = this.CONFIG;

    let score = 0;

    // A) 墙边惩罚
    score += this._wallPenalty(x, y);

    // B) 敌机硬约束/软惩罚
    score += this._enemyPenalty(x, y);

    // C) 光束
    for (const bm of beams){
      const d2 = distPointSeg2(x, y, bm.x1,bm.y1, bm.x2,bm.y2);
      const rr = Player.r + bm.width + C.SAFE_MARGIN;
      if (d2 < rr*rr){
        score += (rr*rr) / (d2 + 25) * C.BEAM_W;
      }
    }

    // D) 子弹全仿真（核心）
    score += this._simulateBulletsDangerAtPoint(x, y, bullets);



    // E) 安全期输出奖励（只作为弱奖励，且依赖 predX 是否存在）
    if (predX != null){
      const dx = Math.abs(x - predX);
      const dy = Math.abs(y - idealY);
      // 对齐 X：减分（奖励）
      score -= (1 / (dx + 50)) * C.ATTACK_X_W;
      // 维持理想 Y：加分（偏离惩罚）
      score += dy * 0.0035 * C.IDEAL_Y_W;
    }

    // F) 补给奖励：在安全前提下主动接近可拾取补给
    if (supplyPt){
      const sd = Math.hypot(x - supplyPt.x, y - supplyPt.y);
      score -= 1.6 / (sd + 30);
    }

    return score;
  },

  _wallPenalty(x, y){
    const C = this.CONFIG;
    const pad = C.WALL_PAD;
    let p = 0;

    if (x < pad) p += (pad - x);
    if (x > W - pad) p += (x - (W - pad));
    if (y < C.TOP_PAD) p += (C.TOP_PAD - y) * 1.25;
    if (y > H - pad) p += (y - (H - pad));

    return p * 0.06 * C.WALL_W;
  },

  _enemyPenalty(x, y){
    const C = this.CONFIG;
    let s = 0;

    for (const e of enemies){
      if (!e.alive) continue;
      const dx = e.x - x, dy = e.y - y;
      const d2 = dx*dx + dy*dy;

      const hardR = e.r + Player.r + C.ENEMY_HARD_PAD;
      const hardR2 = hardR * hardR;

      if (d2 < hardR2){
        // 直接判死刑：强行避免“被逼到撞机”
        return C.ENEMY_HARD_PENALTY;
      }

      const softR = hardR + 140;
      const softR2 = softR * softR;
      if (d2 < softR2){
        s += (softR2 / (d2 + 70)) * C.ENEMY_SOFT_W;
      }
    }

    return s;
  },

  // ==================== 核心：仿真 updateBullets 的运动学并对点 (x,y) 估计危险 ====================
  _simulateBulletsDangerAtPoint(px, py, bullets){
    const C = this.CONFIG;

    const horizon = C.HORIZON;
    const steps = C.SIM_STEPS;
    const dt = horizon / steps;

    let danger = 0;

    // 对每颗子弹做局部副本仿真（不修改真实子弹）
    for (const b0 of bullets){
      // 克隆必要状态（对应你 updateBullets 里会改变的字段）
      let bx = b0.x, by = b0.y;
      let vx = b0.vx, vy = b0.vy;

      let t = b0.t || 0;
      let life = b0.life || 9;

      let turnAfter = b0.turnAfter || 0;
      let reverseT  = b0.reverseT || 0;
      let accel     = b0.accel || 0;
      let angVel    = b0.angVel || 0;

      let waveA     = b0.waveA || 0;
      let waveF     = b0.waveF || 0;
      let waveP     = b0.waveP || 0;

      let pauseT    = b0.pauseT || 0;
      let mineT     = b0.mineT || 0;

      let homing    = b0.homing || 0;
      const isHoming = (homing > 0) || (b0.homing > 0);

      let bounce    = b0.bounce || 0;

      const br = b0.r || 3;
      const rrBase = Player.r + br + C.SAFE_MARGIN;
      const rr2Base = rrBase * rrBase;

      // 步进仿真
      for (let i=0;i<steps;i++){
        t += dt;
        life -= dt;

        // delayed homing
        if (turnAfter > 0){
          turnAfter -= dt;
          if (turnAfter <= 0) homing = Math.max(homing, 1);
        }

        // boomerang
        if (reverseT > 0){
          reverseT -= dt;
          if (reverseT <= 0){ vx *= -1; vy *= -1; }
        }

        // accel / decel along direction
        if (accel !== 0){
          const sp = Math.hypot(vx, vy) || 1;
          const ux = vx / sp, uy = vy / sp;
          vx += ux * accel * dt;
          vy += uy * accel * dt;
        }

        // curve
        if (angVel !== 0){
          const sp = Math.hypot(vx, vy) || 1;
          const ang = Math.atan2(vy, vx) + angVel * dt;
          vx = Math.cos(ang) * sp;
          vy = Math.sin(ang) * sp;
        }

        // pause
        let move = 1;
        if (pauseT > 0){
          pauseT -= dt;
          if (pauseT > 0) move = 0;
        }

        // homing steer（复刻你 updateBullets 的核心逻辑，目标点=候选点）
        if (homing > 0){
          const ax = px - bx;
          const ay = py - by;
          const ang = Math.atan2(ay, ax);

          let sp = Math.hypot(vx, vy);

          // 给追踪弹一个最小速度
          const minSp = 180;
          if (!Number.isFinite(sp) || sp < 1e-3){
            vx = Math.cos(ang) * minSp;
            vy = Math.sin(ang) * minSp;
            sp = minSp;
          }

          const tvx = Math.cos(ang) * sp;
          const tvy = Math.sin(ang) * sp;
          const k = 1 - Math.exp(-6 * dt);
          vx = lerp(vx, tvx, k);
          vy = lerp(vy, tvy, k);

          const sp2 = Math.hypot(vx, vy);
          if (sp2 < minSp){
            const kk = minSp / Math.max(1e-3, sp2);
            vx *= kk; vy *= kk;
          }
        }

        if (move){
          bx += vx * dt;
          by += vy * dt;
        }

        // wave offset
        if (waveA !== 0 && waveF !== 0){
          const sp = Math.hypot(vx, vy) || 1;
          const pxn = -vy / sp, pyn = vx / sp;
          const ss = Math.sin(waveP + t * waveF);
          bx += pxn * waveA * ss * dt;
          by += pyn * waveA * ss * dt;
        }

        // bounce（敌弹反弹）
        if (bounce > 0){
          let bounced = false;
          if (bx < 10){ bx = 10; vx = Math.abs(vx); bounce--; bounced = true; }
          else if (bx > W - 10){ bx = W - 10; vx = -Math.abs(vx); bounce--; bounced = true; }
          if (by < 8 && bounce > 0){ by = 8; vy = Math.abs(vy); bounce--; bounced = true; }
          // bounced 不需要特效，仿真只关心位置
          void bounced;
        }

        // mine explode（用“爆炸半径危险”近似后续弹幕）
        if (mineT > 0){
          mineT -= dt;
          if (mineT <= 0){
            const R = 220;
            const d2m = dist2(px, py, bx, by);
            if (d2m < R*R){
              // 越近越致命
              danger += (R*R) / (d2m + 40) * C.MINE_W * 2.8;
            } else {
              danger += 0.05 * C.MINE_W;
            }
            break;
          }
        }

        // 与候选点距离（越早越近越危险）
        const d2 = dist2(px, py, bx, by);
        if (d2 < rr2Base * 9){
          const timeW = 1 / (0.10 + i*dt);
          const nearW = rr2Base / (d2 + 18);
          const homW  = (b0.homing > 0 || homing > 0) ? C.HOMING_W : C.BULLET_W;
          danger += nearW * timeW * homW;
        }

        if (life <= 0) break;
      }
    }

    return danger;
  },

  _pickTarget(px, py){
    let best = null;
    let bestS = 1e18;

    for (const e of enemies){
      if (!e.alive) continue;
      const dx = Math.abs(e.x - px);
      const dy = e.y - py;

      let s = dx + Math.abs(dy) * 0.55;
      if (dy < -40) s *= 0.75;
      if (dy > 260) s *= 1.35;
      if (e.type === 'BOSS') s *= 0.65;
      if (Game.mode==='fortress' || Game.mode==='lab'){
        const toFlag = Math.abs(e.x - W*0.5) * 0.45 + Math.abs((H-62) - e.y) * 1.35;
        s = s * 0.72 + toFlag * 0.48;
      }

      if (s < bestS){ bestS = s; best = e; }
    }
    return best;
  },

  _collectEmitterSpeeds(em, out, depth=0){
    if (!em || depth > 5) return;
    const sp = Number.isFinite(em.speed) ? em.speed : (Number.isFinite(em?.cfg?.speed) ? em.cfg.speed : NaN);
    if (Number.isFinite(sp) && sp > 30) out.push(sp);
    this._collectEmitterSpeeds(em._base, out, depth+1);
    this._collectEmitterSpeeds(em._emA, out, depth+1);
    this._collectEmitterSpeeds(em._emB, out, depth+1);
  },

  _estimatePlayerShotSpeed(){
    const samples = [];
    for (const em of (Player.emitters || [])) this._collectEmitterSpeeds(em, samples, 0);
    if (!samples.length) return 520;
    samples.sort((a,b)=>a-b);
    const mid = samples[(samples.length/2)|0];
    return clamp(mid, 180, 980);
  },

  _predictTargetX(target, px, py){
    if (!target) return clamp(px, 20, W - 20);

    const tx = Number.isFinite(target.x) ? target.x : px;
    const ty = Number.isFinite(target.y) ? target.y : py;
    const tvx = Number.isFinite(target.vx) ? target.vx : (target.mmx?.vx || 0);
    const tvy = Number.isFinite(target.vy) ? target.vy : (target.mmx?.vy || 0);

    const rx = tx - px;
    const ry = ty - py;
    const shotSpeed = this._estimatePlayerShotSpeed();

    const a = (tvx*tvx + tvy*tvy) - shotSpeed*shotSpeed;
    const b = 2 * (rx*tvx + ry*tvy);
    const c = rx*rx + ry*ry;

    let tof = NaN;
    if (Math.abs(a) < 1e-6){
      if (Math.abs(b) > 1e-6) tof = -c / b;
    } else {
      const disc = b*b - 4*a*c;
      if (disc >= 0){
        const sd = Math.sqrt(disc);
        const t1 = (-b - sd) / (2*a);
        const t2 = (-b + sd) / (2*a);
        const ts = [t1, t2].filter(t=>Number.isFinite(t) && t > 0);
        if (ts.length) tof = Math.min(...ts);
      }
    }

    if (!Number.isFinite(tof) || tof <= 0){
      const approxDist = Math.hypot(rx, ry);
      tof = approxDist / Math.max(140, shotSpeed);
    }

    // 普通模式下优先真实拦截，堡垒模式仍限制预测幅度避免离旗太远
    const maxTof = (Game.mode==='fortress') ? 0.95 : 1.35;
    tof = clamp(tof, 0, maxTof);

    return clamp(tx + tvx * tof, 20, W - 20);
  },
};

const TimeMachine = {
  enabled: false,
  buffer: [],
  maxFrames: 180, 
  speed: 1.0,

  _reconstructEmitter(data) {
    if (!data) return null;
    if (data.wrapperType === 'INTERLEAVE') {
      const wrapperFn = CompositeWrappers['INTERLEAVE'];
      if (!wrapperFn) return null;
      const factoryA = () => this._reconstructEmitter(data.innerA);
      const factoryB = () => this._reconstructEmitter(data.innerB);
      const em = wrapperFn(factoryA, { ...data.compCfg, factoryB: factoryB });
      if (em && data.cd != null) em.cd = data.cd;
      return em;
    }
    if (data.isWrapper) {
      const wrapperFn = CompositeWrappers[data.wrapperType];
      if (!wrapperFn) return null;
      const innerFactory = () => this._reconstructEmitter(data.inner);
      const em = wrapperFn(innerFactory, data.compCfg || {});
      if (em && data.cd != null) em.cd = data.cd;
      return em;
    }
    const factory = EmitterCatalog[data.type || 'AIM'];
    if (!factory) return null;
    return factory({ baseCd: data.cd, speed: data.speed, mods: data.mods || [] });
  },

  record() {
    if (!this.enabled || Game.state !== 'playing') return;
    
    const serializedEnemies = enemies.map(e => ({
      spec: extractEnemyForForge(e),
      state: {
        x: e.x, y: e.y,
        vx: e.vx, vy: e.vy,
        hp: e.hp,
        maxHp: e.maxHp,
        shieldHP: e.shieldHP || 0,
        r: e.r, 
        mmxState: e.mmx ? JSON.parse(JSON.stringify(e.mmx)) : null,
        emCds: (e.emitters || []).map(em => em.cd),
        timers: { hit: e.hit || 0, freeze: e._freezeT || 0, charge: e.snCharge || 0 },
        spawnId: e.spawnId,
        isBoss: (e.type === 'BOSS'),
        bossStage: e.state, // 'enter' 或 'fight'
        bossPhase: e.phase,
        isChaos: (e.type === 'CHAOS_BEAST'),
        baseCol: e.baseCol,
        tint: e.tint,
      }
    }));

    const frame = {
      input: { px: Input.px, py: Input.py, tx: Input.tx, ty: Input.ty, active: Input.active },
      player: { 
        ...Player, 
        gunMods: [...Player.gunMods],
        emitters: Player.emitters ? Player.emitters.map(em => ({...em, cd: em.cd})) : []
      },
game: { 
  score: Game.score, 
  time: Game.time, 
  wave: Game.wave, 
  difficulty: Game.difficulty,
  lastBossAt: Game.lastBossAt, // 记录上一次 Boss 出场时间
  bossAlive: Game.bossAlive     // 记录 Boss 是否存活状态
},
spawnerCd: Spawner.cd,
      enemiesData: serializedEnemies,
      bulletsP: bulletsP.map(b => ({...b, mods: b.mods ? [...b.mods] : []})),
      bulletsE: bulletsE.map(b => ({...b, mods: b.mods ? [...b.mods] : []})),
      supplies: supplies.map(s => ({...s})),
      fortress: ((Game.mode==='fortress' || Game.mode==='lab' || Game.mode==='fortress_duel')) ? {
        phase: Fortress.phase, timer: Fortress.timer, stock: Fortress.stock,
        flagHp: Fortress.flagHp, flagMaxHp: Fortress.flagMaxHp,
        selected: Fortress.selected, spawnCd: Fortress.spawnCd, spawnLeft: Fortress.spawnLeft,
        sid: Fortress.sid, sellMode: Fortress.sellMode, bossSpawned: Fortress.bossSpawned,
        structures: Fortress.structures.map(st => ({...st})),
        undoStack: Fortress.undoStack.map(it => ({...it})),
        activeDrag: Fortress.activeDrag ? {...Fortress.activeDrag} : null,
        preview: Fortress.preview ? {...Fortress.preview} : null,
        previewPointerId: Fortress.previewPointerId,
      } : null
    };

    this.buffer.push(frame);
    if (this.buffer.length > this.maxFrames) this.buffer.shift();
  },

  rewind(reason='manual') {
    if (this.buffer.length === 0) return false;
    const frame = this.buffer[0]; 
    this.buffer = []; 

    if (frame.input) Object.assign(Input, frame.input);
    Object.assign(Player, frame.player);
    Player.x = frame.player.x; Player.y = frame.player.y;
    if (frame.player.emitters && Player.emitters) {
       for(let i=0; i<Math.min(Player.emitters.length, frame.player.emitters.length); i++) {
          Player.emitters[i].cd = frame.player.emitters[i].cd;
       }
    }
    Object.assign(Game, frame.game);
if (frame.spawnerCd !== undefined) Spawner.cd = frame.spawnerCd;

Game.bossAlive = frame.game.bossAlive;
    
    enemies.length = 0;
    

    frame.enemiesData.forEach(item => {
      if (!item || !item.spec) return;
      const specData = item.spec;
      const state = item.state;
      const d = Game.difficulty;
      
      let e;

      if (state.isBoss && Game.mode === 'survival') {
          e = baseEnemy('BOSS', state.r, state.maxHp, 2200);
          e.state = state.bossStage;
          e.phase = state.bossPhase;
          
          // 重新挂载 spawnBoss 中的原生 AI 逻辑
          e.update = (dt) => {
              e.hit = Math.max(0, e.hit - dt);
              if (e.state === 'enter') {
                  e.y += e.vy * dt;
                  if (e.y >= H * 0.16) { e.y = H * 0.16; e.state = 'fight'; }
                  return;
              }
              e.phase += dt * (0.75 + d * 0.012);
              e.x = W * 0.5 + Math.sin(e.phase) * (W * 0.22);
              updateEmitters(e, dt);
          };
      } else {
          // 普通怪统一通过 EnemyFactory 重建，确保 move mixer / emitters 与堡垒机制完全一致
          const rebuildProto = {
            moveKeys: (Array.isArray(specData.moveKeys) && specData.moveKeys.length) ? specData.moveKeys : [specData.moveKey || 'DRIFT'],
            moveKey: specData.moveKey || ((Array.isArray(specData.moveKeys) && specData.moveKeys[0]) ? specData.moveKeys[0] : 'DRIFT'),
            baseCol: specData.baseCol || specData.col,
            bodySeed: specData.bodySeed || 1337,
            waveBulletMods: specData.mods || specData.waveBulletMods || [],
            emitters: specData.emitters || [],
            traitsForced: specData.traits || [],
            hpMul: 1,
            scoreMul: 1,
          };
          e = EnemyFactory.spawnFromProto(rebuildProto, d);
      }

      if (e) {
        e.type = state.isBoss ? 'BOSS' : (state.isChaos ? 'CHAOS_BEAST' : 'ENEMY');
        if (state.isBoss) Game.bossAlive = true;

        e.baseCol = state.baseCol || specData.baseCol || specData.col;
        e.tint = (state.tint != null) ? state.tint : (specData.tint || specData.col);
        e.maxHp = state.maxHp;
        e.hp = state.hp;
        e.x = Number.isFinite(state.x) ? state.x : (Number.isFinite(e.x) ? e.x : W*0.5);
        e.y = Number.isFinite(state.y) ? state.y : (Number.isFinite(e.y) ? e.y : -40);
        e.vx = Number.isFinite(state.vx) ? state.vx : (Number.isFinite(e.vx) ? e.vx : 0);
        e.vy = Number.isFinite(state.vy) ? state.vy : (Number.isFinite(e.vy) ? e.vy : (80 + d*3.0));
        e.r = state.r;
        e.spawnId = state.spawnId;

        e.body = genEnemyBody(specData.bodySeed || 1337);
        if (specData.bodyOpt) applyBodyOverrides(e.body, specData.bodyOpt);
        if (specData.bodyKind && specData.bodyKind !== 'AUTO') e.body.kind = specData.bodyKind;

        e.emitters = [];
        const slot1 = this._reconstructEmitter(specData.slot1);
        const slot2 = this._reconstructEmitter(specData.slot2);
        if (slot1) e.emitters.push(slot1);
        if (slot2) e.emitters.push(slot2);

        if (specData.traits) applyEnemyTraits(e, specData.traits, d);

        e._protoMoveKeys = specData.moveKeys;
        e._protoMoveKey = specData.moveKey;
        e._protoEmitters = specData.emitters; 
        e._protoWaveBulletMods = specData.waveBulletMods;
        e._protoBodySeed = specData.bodySeed;
        e._protoBaseCol = specData.baseCol;

        if (e.mmx && state.mmxState) Object.assign(e.mmx, state.mmxState);
        repairEnemyPose(e, 'rewind');

        if (state.isBoss) {
          e.draw = () => {
            drawEnemyGeneric(e); // 绘制身体
            const bw = Math.min(380, W * 0.82);
            const p = clamp(e.hp / e.maxHp, 0, 1);
            ctx.save();
            ctx.globalAlpha = 0.60; ctx.fillStyle = 'rgba(255,255,255,0.14)';
            ctx.fillRect(W / 2 - bw / 2, e.y - 70, bw, 9);
            ctx.globalAlpha = 0.95; ctx.fillStyle = rgbToRgba(enemyColor(e), 0.92);
            ctx.fillRect(W / 2 - bw / 2, e.y - 70, bw * p, 9);
            ctx.restore();
          };
        }

        // 恢复场景循环
        if ((Game.mode === 'lab' || Game.mode === 'challenge') && !state.isBoss) {
          const _superUpdate = e.update.bind(e);
          e.update = (dt) => {
            e.age = 0; _superUpdate(dt);
            const zoom = (typeof Camera !== 'undefined' && Camera.zoom) ? Camera.zoom : 1.0;
            const limitY = (H / zoom) + 150;
            if (!UnitBattle.active && e.y > limitY) {
              e.y = -150; e.x = clamp(e.x + rand(-100, 100), 50, W - 50);
            }
          };
        }

        if (e.emitters && state.emCds) {
          e.emitters.forEach((em, i) => { if (state.emCds[i] != null) em.cd = state.emCds[i]; });
        }
        e.hit = state.timers.hit;
        e._freezeT = state.timers.freeze;
        e.snCharge = state.timers.charge;

        e.alive = true;
        enemies.push(e);
      }
    });
    
    bulletsP.length = 0; frame.bulletsP.forEach(b => bulletsP.push(b));
    bulletsE.length = 0; frame.bulletsE.forEach(b => bulletsE.push(b));
    supplies.length = 0; frame.supplies.forEach(s => supplies.push(s));

    particles.length = 0; shockwaves.length = 0; beams.length = 0; texts.length = 0;

if (frame.fortress && (Game.mode==='fortress' || Game.mode==='lab' || Game.mode==='fortress_duel')) {
  Fortress.phase = frame.fortress.phase;
  Fortress.timer = frame.fortress.timer;
  Fortress.stock = frame.fortress.stock;
  Fortress.flagHp = frame.fortress.flagHp;
  Fortress.flagMaxHp = frame.fortress.flagMaxHp;
  Fortress.selected = frame.fortress.selected;
  Fortress.spawnCd = frame.fortress.spawnCd;
  Fortress.spawnLeft = frame.fortress.spawnLeft;
  Fortress.sid = frame.fortress.sid;
  Fortress.sellMode = frame.fortress.sellMode;
  Fortress.bossSpawned = frame.fortress.bossSpawned;
  Fortress.structures = frame.fortress.structures.map(st => ({...st}));
  Fortress.undoStack = frame.fortress.undoStack.map(it => ({...it}));
  Fortress.activeDrag = frame.fortress.activeDrag ? {...frame.fortress.activeDrag} : null;
  Fortress.preview = frame.fortress.preview ? {...frame.fortress.preview} : null;
  Fortress.previewPointerId = frame.fortress.previewPointerId ?? null;
  Fortress.syncSelectionUI();
  Fortress.updatePanel();
  syncAutoPilotBtnVisibility();
}

    textPop(Player.x, Player.y - 40, "TAS: TIMELINE REBUILT", C.P1);
    spawnShockwave(Player.x, Player.y, C.P1, 900, 1.2);
    addShake(25, 0.5);
    
    Player.invuln = 2.0; 
    Player.alive = true;
    return true;
  }
};
  
  
function formatValue(n) {
  if (n < 10000) return Math.floor(n).toLocaleString(); // 10万以下显示全称
  if (n < 1000000) return (n/10000).toFixed(0) + 'W';      // 万级显示W
  if (n < 1000000000) return (n/1000000).toFixed(2) + 'M'; // 百万级显示M
  return (n/1000000000).toFixed(2) + 'B';                 // 十亿级显示B
}

  // ================= Render =================
  function drawGrid(dt){
    const s = PERF.gridSpacing;
    const ox = (Game.time*36)%s;
    const oy = (Game.time*48)%s;

    ctx.save();
    if (PERF.additive) ctx.globalCompositeOperation='lighter';

    // Vertical lines
    ctx.beginPath();
    const gw = W/Camera.zoom, gh = H/Camera.zoom;
for(let x=-s; x<=gw+s; x+=s){
      const xx = x + ox;
      ctx.moveTo(xx, 0);
      ctx.lineTo(xx, H);
    }
    // Horizontal lines (perspective illusion not needed for top down, but parallax helps)
    for(let y=-s; y<=gh+s; y+=s){
      const yy = y + oy;
      ctx.moveTo(0, yy);
      ctx.lineTo(W, yy);
    }
    ctx.strokeStyle = 'rgba(82,230,255,0.08)'; // Cyan faint
    ctx.lineWidth = 1;
    ctx.stroke();

    // Background Gradient Vignette
    const gw2 = W/Camera.zoom, gh2 = H/Camera.zoom;
const g = ctx.createRadialGradient(gw2/2, gh2/2, 0, gw2/2, gh2/2, gh2);
g.addColorStop(0,'rgba(14,23,56,0.0)');
g.addColorStop(1,'rgba(0,0,0,0.8)');
ctx.fillStyle=g;
ctx.fillRect(-100,-100,gw2+200,gh2+200);

    ctx.restore();
  }

  function drawShockwaves(){
    if (!shockwaves.length) return;
    ctx.save();
    if (PERF.additive) ctx.globalCompositeOperation='lighter';
    for(const s of shockwaves){
      const k = clamp(s.t/s.life, 0,1);
      const r = s.maxR * (0.10 + 0.90*k);
      const a = (1-k);
      ctx.globalAlpha = 0.4*a;
      ctx.strokeStyle = rgbToRgba(s.col, 0.95);
      ctx.lineWidth = 2 + 10*(1-k); // thicker
      ctx.beginPath(); ctx.arc(s.x,s.y,r,0,Math.PI*2); ctx.stroke();
      
      // Secondary ring
      ctx.globalAlpha = 0.2*a;
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.arc(s.x,s.y,r*0.7,0,Math.PI*2); ctx.stroke();
      
      ctx.globalAlpha = 1;
    }
    ctx.restore();
  }

  function drawBeams(){
    if (!beams.length) return;
    ctx.save();
    if (PERF.additive) ctx.globalCompositeOperation='lighter';
    for(const b of beams){
      const k = clamp(b.t/0.08, 0,1);
      // Core
      ctx.globalAlpha = 0.4 + 0.6*k;
      ctx.strokeStyle = rgbToRgba(b.col, 1.0);
      ctx.lineWidth = b.width * (0.5 + 0.5*Math.random());
      ctx.beginPath();
      ctx.moveTo(b.x1,b.y1);
      ctx.lineTo(b.x2,b.y2);
      ctx.stroke();
      
      // Glow
      ctx.globalAlpha = 0.2;
      ctx.lineWidth = b.width * 4;
      ctx.beginPath();
      ctx.moveTo(b.x1,b.y1);
      ctx.lineTo(b.x2,b.y2);
      ctx.stroke();
      
      ctx.globalAlpha=1;
    }
    ctx.restore();
  }


  function drawBulletVisual(b){
    if (!b || !b.alive) return;
    if (b._phaseVisible === false){
      const spr = Spr[b.spr] || Spr.glowW;
      drawGlow(spr, b.x, b.y, 0.20, 0.15);
      return;
    }
    if (b.style===1){
      const n = Math.hypot(b.vx,b.vy) || 1;
      const ux=b.vx/n, uy=b.vy/n;
      const len = (b.team==='P') ? 22 : 14;
      ctx.globalAlpha = 0.6 * ((b._phaseAlpha != null) ? b._phaseAlpha : 1.0);
      ctx.strokeStyle = rgbToRgba(b.col, 0.9);
      ctx.lineWidth = b.r;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(b.x,b.y);
      ctx.lineTo(b.x-ux*len, b.y-uy*len);
      ctx.stroke();
    }
    const spr = Spr[b.spr] || Spr.glowW;
    const pulse = 1.0 + 0.2*Math.sin(Game.time*20 + (b.t||0)*10);
    const alpha = (b._phaseAlpha != null) ? b._phaseAlpha : 1.0;
    drawGlow(spr, b.x,b.y, (0.50 + b.r*0.08)*pulse, alpha);
  }

  function drawBullets(arr){
    if (FXState.additiveOn) ctx.globalCompositeOperation='lighter';
    const tier = PERF.dynamicFX ? FXState.tier : 0;
    const minX = -50, maxX = W+50, minY = -50, maxY = H+50;
    for(const b of arr){
      if (!b.alive) continue;
      if (tier >= 3 && b.team==='E' && b.r <= 2.4 && ((PERF.fxFrameMod + ((b.id||0)&1)) & 1)) continue;
      if (b.x < minX || b.x > maxX || b.y < minY || b.y > maxY) continue;
      drawBulletVisual(b);
    }
    ctx.globalCompositeOperation='source-over';
  }

  function drawSupplies(){
    if (PERF.additive) ctx.globalCompositeOperation='lighter';
    for(const p of supplies){
      const def = Supply[p.key];
      if (!def) continue;
      const spr = Spr[def.spr] || Spr.glowP;
      
      // Rotating Box for supply
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(Game.time * 2);
      ctx.strokeStyle = rgbToRgba(def.col || '#fff', 0.8);
      ctx.lineWidth = 2;
      ctx.strokeRect(-8, -8, 16, 16);
      ctx.restore();

      // Glow
      drawGlow(spr, p.x,p.y, 0.8 + 0.2*Math.sin((p.t||0)*8), 1.0);
      
      // Text
      ctx.globalAlpha=1;
      ctx.fillStyle='#fff';
      ctx.font='700 10px "Consolas", monospace';
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.fillText(def.name || 'SUP', p.x, p.y);
    }
    ctx.globalCompositeOperation='source-over';
  }


  function drawFortress(){
    if (Game.mode!=='fortress' && Game.mode!=='lab' && Game.mode!=='fortress_duel') return;

    const fy = H - 44;
    ctx.save();
    if (Game.mode!=='lab'){
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = 'rgba(10,20,40,0.75)';
      ctx.fillRect(W*0.5-38, fy-16, 76, 22);
      ctx.strokeStyle = 'rgba(255,80,110,0.8)';
      ctx.strokeRect(W*0.5-38, fy-16, 76, 22);
    }
    if (Game.mode!=='lab' && Game.mode!=='fortress_duel'){
      ctx.fillStyle = '#ff5577';
      ctx.fillRect(W*0.5-2, fy-34, 4, 18);
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.moveTo(W*0.5+2, fy-34);
      ctx.lineTo(W*0.5+26, fy-27);
      ctx.lineTo(W*0.5+2, fy-20);
      ctx.closePath();
      ctx.fill();
    } else if (Game.mode==='fortress_duel') {
      ctx.fillStyle = 'rgba(160,220,255,0.95)';
      ctx.fillRect(W*0.5-8, fy-30, 16, 10);
    }

    if ((Fortress.flagInvulnT||0) > 0){
      ctx.strokeStyle='rgba(120,220,255,0.95)';
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.arc(W*0.5, fy-22, 28 + Math.sin(Game.time*7)*1.4, 0, Math.PI*2);
      ctx.stroke();
      ctx.fillStyle='rgba(160,220,255,0.95)';
      ctx.font='700 10px "Consolas", monospace';
      ctx.textAlign='center';
      ctx.fillText(`INVULN ${(Fortress.flagInvulnT||0).toFixed(1)}s`, W*0.5, fy-64);
    }

    const barW = 170, barH = 8, barX = W*0.5 - barW*0.5, barY = fy - 54;
    if (Game.mode!=='lab' && Game.mode!=='fortress_duel'){
      const flagPct = clamp(Fortress.flagHp / Math.max(1, Fortress.flagMaxHp), 0, 1);
      ctx.globalAlpha = 0.96;
      ctx.fillStyle = 'rgba(0,0,0,0.66)';
      ctx.fillRect(barX, barY, barW, barH);
      ctx.fillStyle = '#ff5b7f';
      ctx.fillRect(barX, barY, barW*flagPct, barH);
      ctx.strokeStyle = 'rgba(255,255,255,0.90)';
      ctx.lineWidth = 1;
      ctx.strokeRect(barX, barY, barW, barH);
    }
    ctx.font='700 10px "Consolas", monospace';
    ctx.textAlign='center';
    ctx.textBaseline='bottom';
    ctx.fillStyle='#fff';
    if (Game.mode!=='lab') ctx.fillText(`FLAG ${Math.ceil(Fortress.flagHp)}/${Math.ceil(Fortress.flagMaxHp)}`, W*0.5, barY-2);

    for (const fs of Fortress.structures){
      const hpPct = clamp(fs.hp / Math.max(1, fs.maxHp), 0, 1);
      const itemCfg = Fortress.catalog[fs.type] || null;
      const itemCol = itemCfg?.col || '#d0f5ff';
      ctx.save();
      ctx.translate(fs.x, fs.y);
      if (fs.rot) ctx.rotate(fs.rot);
      ctx.fillStyle = 'rgba(0,0,0,0.62)';
      ctx.fillRect(-fs.w*0.5, -fs.h*0.5, fs.w, fs.h);
      ctx.strokeStyle = itemCol;
      ctx.lineWidth = 1.5;
      ctx.strokeRect(-fs.w*0.5, -fs.h*0.5, fs.w, fs.h);
      ctx.restore();
      ctx.fillStyle = 'rgba(255,255,255,0.20)';
      ctx.globalAlpha = 0.98;
      ctx.fillRect(fs.x-fs.w*0.5, fs.y-fs.h*0.5-6, fs.w, 4);
      ctx.fillStyle = itemCol;
      ctx.globalAlpha = 0.92;
      ctx.fillRect(fs.x-fs.w*0.5, fs.y-fs.h*0.5-6, fs.w*hpPct, 4);
      ctx.globalAlpha = 0.96;
      ctx.fillStyle = itemCol;
      ctx.font='700 10px "Consolas", monospace';
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      const nm = ({barricade:'木障',wall:'钢壁',heavywall:'合金墙',bunker:'堡垒墙',shield:'棱镜盾',turret:'炮塔',gatling:'加特林',sniper:'狙击塔',missile:'导弹井',tesla:'特斯拉',flame:'喷火塔',mortar:'迫击炮',dronepad:'无人机坪',pulse:'脉冲器',mine:'地雷',slow:'减速塔',repair:'旗帜修',repairplayer:'医疗站',repairfield:'工程站',factory:'补给站',spinner:'旋刃塔',ram:'冲锋桩',beacon:'信标',taunt:'诱敌堡'})[fs.type] || fs.type;
      ctx.fillText(nm, fs.x, fs.y);
      ctx.globalAlpha = 0.9;
      if (fs.type==='turret'){
        ctx.beginPath();
        ctx.arc(fs.x, fs.y-2, 6, 0, Math.PI*2);
        ctx.stroke();
      } else if (fs.type==='spinner'){
        ctx.save();
        ctx.translate(fs.x, fs.y);
        ctx.rotate(fs.rot||0);
        ctx.beginPath();
        ctx.moveTo(-9,0); ctx.lineTo(0,-8); ctx.lineTo(9,0); ctx.lineTo(0,8); ctx.closePath();
        ctx.stroke();
        ctx.restore();
      } else if (fs.type==='ram'){
        ctx.save();
        ctx.translate(fs.x, fs.y);
        ctx.rotate(fs.rot||0);
        ctx.strokeRect(-10,-4,20,8);
        ctx.beginPath();
        ctx.moveTo(10,-6); ctx.lineTo(16,0); ctx.lineTo(10,6);
        ctx.stroke();
        ctx.restore();
      } else if (fs.type==='beacon'){
        ctx.strokeStyle = itemCol;
        ctx.beginPath();
        ctx.arc(fs.x, fs.y, 6 + Math.sin(Game.time*7 + (fs.rot||0))*1.6, 0, Math.PI*2);
        ctx.stroke();
      } else if (fs.type==='pulse'){
        ctx.beginPath();
        ctx.arc(fs.x, fs.y, 8 + Math.sin(Game.time*6)*2, 0, Math.PI*2);
        ctx.stroke();
      }
      Fortress.getBehavior(fs.type)?.onDraw?.(fs, ctx, {fortress:Fortress});
      ctx.globalAlpha = 0.85;
    }
    if (Fortress.preview && Fortress.canBuild() && !Fortress.sellMode){
      const cfg = Fortress.catalog[Fortress.preview.item];
      if (cfg){
        const afford = Fortress.stock >= cfg.cost;
        const px = Fortress.preview.x, py = Fortress.preview.y;
        const rot = Fortress.preview.rot || 0;
        ctx.save();
        ctx.translate(px, py);
        if (rot) ctx.rotate(rot);
        ctx.globalAlpha = 0.26;
        ctx.fillStyle = afford ? 'rgba(126,249,192,0.92)' : 'rgba(255,94,122,0.92)';
        ctx.fillRect(-cfg.w*0.5, -cfg.h*0.5, cfg.w, cfg.h);
        ctx.globalAlpha = 0.92;
        ctx.strokeStyle = afford ? 'rgba(190,255,236,0.95)' : 'rgba(255,168,188,0.95)';
        ctx.lineWidth = 1.5;
        ctx.strokeRect(-cfg.w*0.5, -cfg.h*0.5, cfg.w, cfg.h);
        ctx.globalAlpha = 0.65;
        ctx.setLineDash([5,4]);
        ctx.strokeRect(-cfg.w*0.5-2, -cfg.h*0.5-2, cfg.w+4, cfg.h+4);
        ctx.setLineDash([]);
        ctx.restore();
      }
    }
    ctx.restore();
  }

  function drawParticles(){
    if (!particles.length) return;
    if (FXState.additiveOn) ctx.globalCompositeOperation='lighter';
    
    // 粒子只需要较小的 buffer
    const minX = -20, maxX = W+20, minY = -20, maxY = H+20;

    const tier = PERF.dynamicFX ? FXState.tier : 0;
    for(const p of particles){
      if (!p.alive) continue;
      if (tier >= 3 && (PERF.fxFrameMod % 3) !== 0 && (p.scale||0) < 0.5) continue;
      
      // 1. 剔除屏幕外粒子
      if (p.x < minX || p.x > maxX || p.y < minY || p.y > maxY) continue;

      const spr = Spr[p.spr] || Spr.glowW;
      const scale = p.scale * (p.life - p.t)/p.life;
      
      // 2. 降级渲染优化：
      // 如果粒子非常小（< 0.15 缩放），直接画 2x2 矩形，而不是调用drawImage
      // 在大量粒子爆炸时，这能极大减少 GPU 填充率压力
      if (scale < 0.15) {
         ctx.fillStyle = p.spr === 'glowP' ? C.P1 : C.W; // 简化的颜色映射
         ctx.globalAlpha = p.a * 0.8;
         ctx.fillRect(p.x, p.y, 2, 2);
      } else {
         // 正常绘制光晕贴图
         drawGlow(spr, p.x,p.y, scale, p.a);
      }
    }
    ctx.globalCompositeOperation='source-over';
  }

  function drawTexts(){
    if (!texts.length) return;
    if (PERF.additive) ctx.globalCompositeOperation='lighter';
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.font = '700 14px "Consolas", monospace';
    
    for(const t of texts){
      const k = clamp(t.t/t.life,0,1);
      ctx.globalAlpha = 1-k;
      ctx.fillStyle = rgbToRgba(t.color, 1.0);
      // Glitch offset
      const ox = (Math.random()-0.5)*4 * k;
      ctx.fillText(t.s, t.x+ox, t.y);
    }
    ctx.globalAlpha=1;
    ctx.globalCompositeOperation='source-over';
  }

  
  // 代码位置：完全替换 drawPlayer 函数
function drawPlayer() {
  const hpRatio = Player.hp / Player.maxHp;
  const isLowHp = hpRatio < 0.35;
  const isCritLow = hpRatio < 0.15;
  const isOd = Player.overdriveT > 0;
  const inv = Player.invuln > 0;

  // 1. 计算随机抖动 (Low HP Jitter)
  // 低血量时，机体部件会发生位移错乱
  const jitter = (mag) => (Math.random() - 0.5) * mag;
  const jMain = isLowHp ? jitter(isCritLow ? 5 : 2) : 0;
  const jWingL = isLowHp ? jitter(isCritLow ? 6 : 3) : 0;
  const jWingR = isLowHp ? jitter(isCritLow ? 6 : 3) : 0;

  ctx.save();
  
  // 无敌闪烁
  if (inv) ctx.globalAlpha = 0.4 + 0.3 * Math.sin(Game.time * 30);
  else ctx.globalAlpha = 1.0;

  if (PERF.additive) ctx.globalCompositeOperation = 'lighter';

  // 确定主色调
  let baseCol = C.P1; // 青色
  let glowCol = 'rgba(82,230,255,0.6)';
  if (isOd) { baseCol = C.Y; glowCol = 'rgba(255,176,32,0.8)'; } // 过载金
  else if (isLowHp) { baseCol = C.E2; glowCol = 'rgba(255,47,87,0.6)'; } // 残血红

  // --- 绘制机体 (拆分为部件以实现故障效果) ---
  ctx.translate(Player.x + jMain, Player.y + jMain);

  // A. 尾焰 (Overdrive时变成巨大光翼)
  if (isOd) {
    // 巨大的光翼
    const wingSize = 40 + Math.sin(Game.time * 20) * 5;
    const wingW = 12;
    ctx.fillStyle = glowCol;
    for (const s of [-1, 1]) {
      ctx.beginPath();
      ctx.moveTo(s * 8, 15);
      ctx.lineTo(s * (8 + wingW), 15 + wingSize);
      ctx.lineTo(s * 4, 15 + wingSize * 0.8);
      ctx.fill();
    }
    // 核心喷射
    drawGlow(Spr.glowY, 0, 25, 1.5, 0.9);
  } else {
    // 普通尾焰 (低血量时断断续续)
    if (!isLowHp || chance(0.7)) {
      drawGlow(isLowHp ? Spr.glowE : Spr.glowP, -8, 18, 0.6, 0.8);
      drawGlow(isLowHp ? Spr.glowE : Spr.glowP, 8, 18, 0.6, 0.8);
    }
  }

  // B. 机体主体
  ctx.strokeStyle = baseCol;
  ctx.lineWidth = 2;
  ctx.fillStyle = 'rgba(0,0,0,0.8)';

  // 左翼
  ctx.beginPath();
  ctx.moveTo(-6, 10);
  ctx.lineTo(-14 + jWingL, 14 + jWingL);
  ctx.lineTo(-6, -10 + jWingL); // Wing tip
  ctx.lineTo(-6, 10);
  ctx.fill(); ctx.stroke();

  // 右翼
  ctx.beginPath();
  ctx.moveTo(6, 10);
  ctx.lineTo(14 + jWingR, 14 + jWingR);
  ctx.lineTo(6, -10 + jWingR);
  ctx.lineTo(6, 10);
  ctx.fill(); ctx.stroke();

  // 核心舱
  ctx.beginPath();
  ctx.moveTo(0, -22);
  ctx.lineTo(-6, 10);
  ctx.lineTo(0, 16);
  ctx.lineTo(6, 10);
  ctx.closePath();
  ctx.fill(); ctx.stroke();

  // 驾驶舱盖
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.moveTo(0, -8);
  ctx.lineTo(-3, 2);
  ctx.lineTo(0, 6);
  ctx.lineTo(3, 2);
  ctx.fill();

  // --- 状态特效 ---

  // 1. 低血量冒烟/电火花
  if (isLowHp && chance(isCritLow ? 0.4 : 0.15)) {
    // 这里的粒子其实是正方形，因为之前的 drawParticles 优化
    const p = particlePool.get();
    p.alive = true;
    p.x = Player.x + rand(-10, 10);
    p.y = Player.y + rand(-5, 15);
    p.vx = rand(-20, 20);
    p.vy = rand(30, 80); // 向后冒
    p.life = rand(0.3, 0.7);
    p.t = 0;
    p.scale = rand(0.3, 0.6);
    p.a = 0.7;
    p.spr = chance(0.5) ? 'glowW' : 'glowE'; // 白烟或红火
    pushParticle(p);
  }

  // 2. 护盾 (明显可见的六边形力场)
  if (Player.shield > 0) {
    const sCol = 'rgb(179,108,255)'; // P2 Purple
    const r = Player.r + 16;
    const pulse = Math.sin(Game.time * 8) * 2;
    
    ctx.strokeStyle = sCol;
    ctx.lineWidth = 2;
    ctx.shadowColor = sCol;
    ctx.shadowBlur = 10;
    ctx.globalAlpha = 0.3 + 0.1 * Math.sin(Game.time * 10); // 脉冲透明度

    // 绘制六边形
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
      const a = i * Math.PI / 3 + Game.time * 0.5;
      const sx = Math.cos(a) * (r + pulse);
      const sy = Math.sin(a) * (r + pulse);
      if (i === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
    }
    ctx.closePath();
    ctx.stroke();
    
    // 内部填充微弱光辉
    ctx.fillStyle = 'rgba(179,108,255,0.15)';
    ctx.fill();
    
    ctx.shadowBlur = 0; // 重置阴影
  }

  ctx.restore();
}
  
const Camera = {
  zoom: 1.0,
  targetZoom: 1.0,
  minZoom: 0.72,
  maxZoom: 1.0,
  smoothSpeed: 2.5,
  enabled: true, // 现在仅控制是否缩放，不再控制跟随

  update(dt) {
    if (!this.enabled) {
      this.zoom = lerp(this.zoom, 1.0, dt * 3);
      return;
    }

    // 动态缩放逻辑 (根据屏幕混乱程度)
    const density = (bulletsP.length + bulletsE.length) + enemies.length * 10 + beams.length * 20;
    
    // Boss 战或高密度时拉远镜头
    if (Game.bossAlive || density > 250) {
      this.targetZoom = this.minZoom;
    } else if (density < 80) {
      this.targetZoom = this.maxZoom;
    } else {
      // 中间平滑过渡
      const k = (density - 80) / 170;
      this.targetZoom = lerp(this.maxZoom, this.minZoom, smoothstep(0, 1, k));
    }

    this.zoom = lerp(this.zoom, this.targetZoom, 1 - Math.exp(-this.smoothSpeed * dt));
  },

  apply() {
    // 1. 找到屏幕中心
    const cx = W / 2;
    const cy = H / 2;
    
    // 2. 计算缩放中心变换: Translate(-cx,-cy) -> Scale -> Translate(cx,cy)
    // 最终矩阵:
    // x' = (x - cx) * z + cx  =>  x * z + cx * (1-z)
    // y' = (y - cy) * z + cy  =>  y * z + cy * (1-z)
    
    const z = this.zoom;
    const tx = cx * (1 - z);
    const ty = cy * (1 - z);

    // 应用变换 (包含 DPR 适配)
    ctx.setTransform(DPR * z, 0, 0, DPR * z, tx * DPR, ty * DPR);
  },
  
  // 辅助：重置为 UI 绘制状态 (无缩放，仅 DPR)
  reset() {
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
};

const DiffConfig = {
  mode: 1, // 0=Casual, 1=Normal, 2=Hard, 3=Hell
  apply(mode) {
    this.mode = parseInt(mode) ?? 1;
  },
  // 生成间隔倍率：越大约慢（Casual = 2.2倍间隔，即怪物少一半以上）
  get spawnRateMul() { return [2.2, 1.5, 0.9, 0.5][this.mode]; }, 
  // 敌人血量倍率
  get enemyHpMul()   { return [0.5, 1.0, 1.4, 2.0][this.mode]; },
  // 额外词条数量 (Casual 无额外，Hell +2)
  get extraAffix()   { return [0, 0, 1, 2][this.mode]; }, 
  // 分数倍率
  get scoreMul()     { return [0.5, 1.0, 1.5, 2.5][this.mode]; },
  
  // [新增] 全局子弹速度倍率 (让简单模式子弹飞得慢，容易躲)
  get bulletSpeedMul() { return [0.65, 1.0, 1.15, 1.3][this.mode]; },
  // [新增] 敌人射击冷却倍率 (越大约慢)
  get fireCdMul()      { return [1.5, 1.0, 0.85, 0.7][this.mode]; }
};

document.getElementById('btnAutoPilot')?.addEventListener('click', () => {
  AutoPilot.toggle();
});

function render(dt) {
  updateFXState();
  Camera.update(dt);

  // 先重置回设备像素坐标系，清空整个 Canvas
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  // 防护：重置可能被污染的 canvas 状态
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // 绘制背景底色 (Vignette) - 使用固定屏幕坐标
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  ctx.fillStyle = '#070A12';
  ctx.fillRect(0, 0, W, H); // 全屏铺底
  
  // 绘制星空 (产生视差，不跟随 Zoom 或稍微跟随)
  ctx.save();
  if (FXState.additiveOn) ctx.globalCompositeOperation = 'lighter';
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  for (const s of stars) {
    s.y += (s.v * dt) / H * 400; // 简单的下落
    if (s.y > H) { s.y = 0; s.x = Math.random(); }
    ctx.fillRect((s.x * W) | 0, s.y | 0, s.s, s.s * 4);
  }
  ctx.restore();
  
  BG_Effect.draw(ctx);

  // --- 步骤 2: 应用震动和相机 ---
  let shakeX = 0, shakeY = 0;
  if (shakeT > 0) {
    shakeT = Math.max(0, shakeT - dt);
    
    // 计算当前震动幅度
    const s = shakeMag * (shakeT / (shakeT + dt + 1e-6));
    
    // 防护3：确保 s 是有效数字
    if (Number.isFinite(s) && s > 0.5) {
        shakeX = rand(-s, s);
        shakeY = rand(-s, s);
    }
    
    // 震动衰减
    shakeMag *= Math.exp(-8 * dt);
    // 防护4：极小值归零，避免浮点数精度问题
    if (shakeMag < 0.1) shakeMag = 0;
  }

  // 应用游戏世界变换 (Zoom + Shake)
  // 注意：Camera.apply() 现在只负责缩放，我们手动叠加 Shake
  const z = Camera.zoom;
  const cx = W / 2, cy = H / 2;
  const tx = cx * (1 - z) + shakeX * z;
  const ty = cy * (1 - z) + shakeY * z;
  ctx.setTransform(DPR * z, 0, 0, DPR * z, tx * DPR, ty * DPR);

  // --- 步骤 3: 绘制世界 (World Space) ---
  drawGrid(dt);

  if (Game.mode==='fortress_duel'){
    ctx.save();
    ctx.strokeStyle = 'rgba(255,60,80,0.9)';
    ctx.lineWidth = 3;
    ctx.setLineDash([10,7]);
    ctx.beginPath();
    ctx.moveTo(0, H*0.5);
    ctx.lineTo(W, H*0.5);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }

  ctx.globalCompositeOperation = 'source-over';
  ctx.globalAlpha = 1;
  drawFortress();
  UnitBattle.drawGhosts();
  drawShockwaves();
  drawParticles();
  drawBeams();
  drawBullets(bulletsP);
  drawBullets(bulletsE);
  if (Game.state !== 'menu') Multiplayer.drawPeerBullets();

  for (const e of enemies) if (e.alive) e.draw();
  drawSupplies();
    if (AutoPilot.active && Player.alive) {
    ctx.save();
    ctx.strokeStyle = 'rgba(179,108,255,0.5)';
    ctx.setLineDash([4, 4]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(Player.x, Player.y);
    ctx.lineTo(Input.tx, Input.ty); // Input.tx/ty 现在是 AI 的目标点
    ctx.stroke();
    
    // 画个圈表示目标点
    ctx.beginPath();
    ctx.arc(Input.tx, Input.ty, 5, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }
  if (Game.state !== 'menu') {
    Multiplayer.drawPeers();
  }
  if (Game.state !== 'menu' && (Player.alive || Player.deathT > 0)) {
    drawPlayer();
  }
  drawTexts();
  UnitBattle.checkWinner();

  // --- 步骤 4: UI 覆盖层 (Screen Space) ---
  // 重置回无缩放状态画 UI
  Camera.reset();

  // Pause 遮罩
  if (Game.state === 'paused') {
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, W, H);
  }

  // Zoom 指示器
  if (Camera.zoom < 0.97) {
    ctx.save();
    ctx.globalAlpha = 0.45;
    ctx.fillStyle = '#52E6FF';
    ctx.font = '700 11px "Consolas", monospace';
    ctx.textAlign = 'right';
    ctx.fillText('ZOOM ' + Math.round(Camera.zoom * 100) + '%', W - 16, 80);
    ctx.restore();
  }
}

  // ================= Flow / UI =================
  function resetGame(){
    bulletsP.length=bulletsE.length=enemies.length=particles.length=supplies.length=texts.length=shockwaves.length=beams.length=0;
    FXState.tier = 0; FXState.glowBudget = 1.0; FXState.additiveOn = PERF.additive;

    Player.x=W*0.5; Player.y=H*0.78;
    Input.px=Player.x; Input.py=Player.y; Input.tx=Player.x; Input.ty=Player.y;
    
    Game.bossAlive = false;
    Game.lastBossAt = 0; 
    Game.spawnSeq = 0;

    Player.hp=100; Player.maxHp=100;
    Player.invuln=1.0;
    Player.shield=0;
    Player.slowT=0;
    Player.bomb=1;

    Player.lv=1;
    Player.xp=0;
    Player.xpNeed=xpNeedFor(1);

    Player.fireRate=1.0;
    Player.dmgMul=1.0;
    Player.crit=0.05;
    Player.gunMods.length=0;
    Player.pierceBase=0;
    Player.homingAmmo=0;
    Player.magnetT=0;
    Player.overdriveT=0;
    Player.drones=0;
    Player.mods=0;
    Player.emitters.length = 0;
    Player.emitterSeq = 0;

    Player.fireCd=0;
    Player.alive=true;

    Game.time=0;
    Game.score=0;
    Game.wave=1;
    Game.difficulty=1;
    Game.bossAlive=false;
    Game.lastBossAt=0;
    Game.continues=999999;
    
    Game.killerData = null;
    Game.failReason = '';
    Game.failSnapshot = null;

    Spawner.reset();
    WaveDirector.onWave(1);
    Fortress.reset();

    ui.score.textContent='0';
    ui.wave.textContent='1';
    ui.bombText.textContent=Player.bomb;
    
    ui.btnRevive.disabled = false;
    ui.btnRevive.textContent = 'EMERGENCY REBOOT';
    ui.btnRevive.style.opacity = '1';
  }

  function clearAllProjectiles(){
    bulletsP.length = 0;
    bulletsE.length = 0;
    beams.length = 0;
    if (Multiplayer?.peers?.size){
      for (const peer of Multiplayer.peers.values()){
        if (Array.isArray(peer.smoothBullets)) peer.smoothBullets.length = 0;
        if (Array.isArray(peer.netBullets)) peer.netBullets.length = 0;
      }
    }
  }
  
  function spawnForgeEnemy(forge){
  // forge 允许两种结构：
  // A) {isBoss,hp,traits,spec:{moveKey,baseCol,tint,bodySeed,bodyKind,bodyScale,emitters:[{type,cfg}],waveBulletMods}}
  // B) 你旧版 readForgeSpec() 结构（只要包含 spec/traits/hp/isBoss 即可）

  const d = Game.difficulty || 1;

  const spec = forge?.spec;
  if (!spec) return null;

  // 复用你已有的 spawnEnemyCoreFromSpecs（第三段里有）
  const e = spawnEnemyCoreFromSpecs(spec, d);

  // hp
  e.maxHp = Math.max(20, forge.hp|0);
  e.hp = e.maxHp;

  // 外形参数（可选）
  if (spec.bodySeed != null){
    e.bodySeed = spec.bodySeed|0;
    e.body = genEnemyBody(e.bodySeed);
  }
  if (spec.bodyKind && spec.bodyKind !== 'AUTO' && e.body){
    e.body.kind = spec.bodyKind;
  }
  // apply appearance overrides (IMPORTANT: makes LAB match preview)
if (!e.body){
  e.bodySeed = (spec.bodySeed ?? 1337)|0;
  e.body = genEnemyBody(e.bodySeed);
}
applyBodyOverrides(e.body, spec.bodyOpt || ForgeState.bodyOpt);
  
  if (spec.bodyScale != null){
    e.r = Math.max(8, e.r * clamp(+spec.bodyScale || 1, 0.5, 2.2));
  }

  // boss 标记
  if (forge.isBoss){
    e.type = 'BOSS';
    Game.bossAlive = true;
    e.r = Math.max(e.r, 44);

    // 给 boss 加一条 hp bar（不改你原 boss）
    wrapDraw(e, (draw)=>{
      draw();
      const bw = Math.min(380, W*0.82);
      const p  = clamp(e.hp/e.maxHp, 0, 1);
      ctx.save();
      ctx.globalAlpha=0.60;
      ctx.fillStyle='rgba(255,255,255,0.14)';
      ctx.fillRect(W/2-bw/2, e.y-70, bw, 9);
      ctx.globalAlpha=0.95;
      ctx.fillStyle=rgbToRgba(enemyColor(e),0.92);
      ctx.fillRect(W/2-bw/2, e.y-70, bw*p, 9);
      ctx.restore();
    });
  } else {
    e.type = 'ENEMY';
  }

  // traits
  if (forge.traits?.length) applyEnemyTraits(e, forge.traits, d);
  
  const col = String(spec.baseCol || spec.tint || ForgeState.col || C.E2).trim();
    e.baseCol = col;
    e.tint = col;

  // 不掉落不加分
  e.noDrop = true;
  e.score = 0;

  // 放到更适合观察的位置
  e.x = W*0.5;
  e.y = H*0.22;
  
 
  const _superUpdate = e.update.bind(e);
  e.update = (dt) => {
    // 1. 执行正常的移动和射击逻辑
    _superUpdate(dt);

    // 2. 计算屏幕边界 (考虑缩放)
    // baseEnemy 默认在 y > H + 220 时判定死亡
    // 我们在它判定死亡之前，或者死亡的一瞬间把它拉回来
    const zoom = (typeof Camera !== 'undefined' && Camera.zoom) ? Camera.zoom : 1.0;
    const limitY = (H / zoom) + 180; 

    // 3. 循环判定
    if (e.y > limitY) {
      e.y = -80; // 瞬移回屏幕上方
      e.age = 0;
      
      // 如果它因为越界被标记为死亡，强制复活
      if (!e.alive && e.hp > 0) {
        e.alive = true;
      }

      // 特殊处理：如果是 MoveMixer (mmx) 驱动的，可能需要重置部分状态以防卡住
      if (e.mmx) {
        // 如果处于 HOLD 或 ORBIT 状态且被强制退出了，重置一下进入状态
        if (e.mmx.mode === 'HOLD' || e.mmx.mode === 'ORBIT') {
           e.mmx.state = 'enter'; 
           // 重新计算轨道中心，防止它还在通过旧坐标计算
           if (e.mmx.mode === 'ORBIT' && typeof mmxInitOrbitFromHere === 'function') {
             mmxInitOrbitFromHere(e);
           }
        }
      }
    }
  };
  e.alive = true;
  e.hp = e.maxHp;
  e.y = H * 0.22; // 确保初始位置在屏幕内
  e.age = 0;     // 禁用 14秒下坠逻辑

  enemies.push(e);
  return e;
}
  
  function makeRivalFromBuild(build){
  // build 结构：{maxHp, fireRate, dmgMul, crit, pierceBase, drones, homingAmmo, bomb, gunMods[]}
  const b = (typeof clampBuild === 'function') ? clampBuild(JSON.parse(JSON.stringify(build))) : JSON.parse(JSON.stringify(build));

  const e = baseEnemy('RIVAL', 14, Math.max(30, b.maxHp|0), 0);
  e.noDrop = true;
  e.score = 0;

  // styling
  e.baseCol = C.E6;
  e.tint = C.E6;

  // spawn position
  e.x = W*0.5;
  e.y = H*0.20;

  // AI state
  e._b = b;
  setupRivalEmittersFromBuild(e, b);
  e._t = rand(0, Math.PI*2);
  e._fireCd = 0;

  e.move = (dt)=>{
    // simple hover + lateral drift
    e._t += dt*(1.2 + 0.25*hellFactor());
    const tx = W*0.5 + Math.sin(e._t)*W*0.22;
    const ty = H*0.20 + Math.sin(e._t*0.7)*22;
    e.x = lerp(e.x, tx, 1 - Math.exp(-3.6*dt));
    e.y = lerp(e.y, ty, 1 - Math.exp(-3.6*dt));
  };

  e.update = (dt)=>{
    e.hit = Math.max(0, e.hit-dt);
    e.move(dt);
    updateRivalEmitters(e, dt);

    // fire enemy bullets toward player
    e._fireCd -= dt;
    if (e._fireCd<=0 && Player.alive){
      const rate = clamp(b.fireRate||1, 0.5, 3.0);
      e._fireCd = Math.max(0.08, 0.22 / rate);

      const dmgBase = (9 + Math.log2(1+Player.lv)*5.8) * (b.dmgMul||1);
      const sp = 420;
      const a = Math.atan2(Player.y-e.y, Player.x-e.x);

      const mods = (b.gunMods||[]).slice(0, 6);
      const pierce = clamp(b.pierceBase|0, 0, 8);

      const bullet = spawnBullet('E', e.x, e.y+10, Math.cos(a)*sp, Math.sin(a)*sp, {
        r: 3.0,
        dmg: dmgBase,
        col: e.tint,
        style: 1,
        life: 2.2,
        pierce,
        mods,
        modCtx: {owner:e, team:'E'}
      });

      // crit imitation (optional)
      if (bullet && chance(clamp(b.crit||0,0,0.6))){
        bullet.dmg *= 1.45;
        bullet.col = C.Y;
        bullet.spr = 'glowY';
        bullet.r *= 1.15;
      }
    }
  };

  // custom draw (不要用敌人通用几何体也行，这里简单画一台“倒过来的玩家机”)
  e.draw = ()=>{
    const col = e.tint || C.E6;

    ctx.save();
    if (PERF.additive) ctx.globalCompositeOperation='lighter';

    // glow core
    drawGlow(Spr.glowE6 || Spr.glowE2 || Spr.glowE, e.x, e.y, 0.85, 0.95);

    // ship
    ctx.fillStyle = 'rgba(0,0,0,0.82)';
    ctx.strokeStyle = rgbToRgba(col, 1.0);
    ctx.lineWidth = 2;

    ctx.beginPath();
    ctx.moveTo(e.x, e.y+22);
    ctx.lineTo(e.x-14, e.y-14);
    ctx.lineTo(e.x-6,  e.y-10);
    ctx.lineTo(e.x,    e.y-16);
    ctx.lineTo(e.x+6,  e.y-10);
    ctx.lineTo(e.x+14, e.y-14);
    ctx.closePath();
    ctx.fill(); ctx.stroke();

    // hp bar
    const p = clamp(e.hp/e.maxHp,0,1);
    const w = 150, h = 6;
    ctx.globalAlpha = 0.55;
    ctx.fillStyle='rgba(0,0,0,0.45)';
    ctx.fillRect(e.x-w/2, e.y-34, w, h);
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = rgbToRgba(col, 0.92);
    ctx.fillRect(e.x-w/2, e.y-34, w*p, h);

    ctx.restore();
  };

  e.onDeath = ()=>{
    textPop(W*0.5, 96, 'DUEL WIN', C.G);
    spawnShockwave(W*0.5, 96, C.G, 320, 0.6);
  };

  return e;
}

  
const UnitBattle = {
  active:false,
  units:[],
  ghosts:[],
  dragging:null,
  winner:null,
  _source:null,
  _bulletSource:null,
  assaultSnapshot:null,
  reset(){ this.active=false; this.ghosts=[]; this.dragging=null; this.winner=null; this._bulletSource=null; },
  parseUnitJSON(txt){
    const obj = JSON.parse(txt||'{}');
    const raw = obj?.forge ? obj.forge : obj;
    if (raw?.spec) return raw;

    const emitters = Array.isArray(raw?.emitters)
      ? raw.emitters
      : [raw?.slot1, raw?.slot2].filter(Boolean);
    if (!emitters.length) throw new Error('不是 forge 格式：缺少 spec 或 emitters/slot1/slot2');

    const spec = {
      moveKey: (Array.isArray(raw.moveKeys) && raw.moveKeys.length ? raw.moveKeys[0] : raw.moveKey) || 'DRIFT',
      moveKeys: (Array.isArray(raw.moveKeys) && raw.moveKeys.length ? raw.moveKeys : [raw.moveKey || 'DRIFT']),
      baseCol: raw.baseCol || raw.col || raw.tint || C.E2,
      tint: raw.tint || raw.baseCol || raw.col || C.E2,
      bodySeed: raw.bodySeed ?? 1337,
      bodyKind: raw.bodyKind || 'AUTO',
      bodyScale: raw.bodyScale ?? 1,
      bodyOpt: raw.bodyOpt || {},
      emitters: emitters,
      waveBulletMods: Array.isArray(raw.mods) ? raw.mods : []
    };
    return {
      isBoss: !!raw.isBoss,
      hp: Math.max(20, (+raw.hp||240)),
      traits: Array.isArray(raw.traits) ? raw.traits : [],
      spec
    };
  },
  importOne(txt){
    const forge = this.parseUnitJSON(txt);
    this.units.push(JSON.parse(JSON.stringify(forge)));
    this.refreshList();
  },
  refreshList(){
    const el=document.getElementById('ubList');
    const modal=document.getElementById('unitBattleModal');
    if (!el || !modal) return;
    const modalCard = modal.querySelector('.ub-modal-card');
    if (modalCard && !el.closest('#unitBattleModal')) modalCard.appendChild(el);
    el.style.display = modal.classList.contains('show') ? 'flex' : 'none';
    el.innerHTML='';
    this.units.forEach((u,i)=>{
      const card=document.createElement('div');
      card.className='ub-unit-card';
      const cv=document.createElement('canvas');
      cv.className='ub-unit-icon';
      cv.width=64; cv.height=64;
      const g=cv.getContext('2d');
      if (g){
        g.clearRect(0,0,64,64);
        const seed=((u?.spec?.bodySeed)||1337) + i*131;
        const body=genEnemyBody(seed);
        const fake={x:32,y:34,r:14,body,bodySeed:seed,tint:(u?.spec?.baseCol||C.E2),baseCol:(u?.spec?.baseCol||C.E2),hit:0,shieldHP:0};
        drawEnemyGenericBody(g, fake, body, fake.baseCol, 14, 0.0, 0.0);
      }
      const meta=document.createElement('div');
      meta.className='ub-unit-meta';
      meta.textContent=`#${i+1} ${u?.spec?.moveKey||'MIX'} HP:${u?.hp||0}`;
      const del=document.createElement('button');
      del.className='ub-unit-del';
      del.type='button';
      del.textContent='×';
      del.title='删除该兵种';
      del.addEventListener('click', (ev)=>{
        ev.stopPropagation();
        UnitBattle.units.splice(i,1);
        UnitBattle.refreshList();
      });
      card.appendChild(del);
      card.appendChild(cv);
      card.appendChild(meta);
      el.appendChild(card);
    });
  },
  setupGhosts(){
    this.ghosts = this.units.map((u,i)=>({
      idx:i,
      x: clamp(80 + (i%8)*90, 40, W-40),
      y: clamp(H*0.18 + ((i/8|0)%4)*58, 60, H*0.45),
      team: (i%2===0) ? 1 : 2,
      forge: JSON.parse(JSON.stringify(u)),
      r: 18
    }));
    this.winner = null;
  },
  pickGhost(sx,sy){
    const p=Fortress.toWorld(sx,sy);
    for(let i=this.ghosts.length-1;i>=0;i--){
      const g=this.ghosts[i];
      if (dist2(g.x,g.y,p.x,p.y) <= (g.r+12)*(g.r+12)) return g;
    }
    return null;
  },
  handlePointerDown(sx,sy,pid){
    if (!this.active || Fortress.phase!=='fortify') return false;
    const g=this.pickGhost(sx,sy);
    if (!g) return false;
    this.dragging={id:pid,g};
    return true;
  },
  handlePointerMove(sx,sy,pid){
    if (!this.dragging || (pid!=null && this.dragging.id!=null && pid!==this.dragging.id)) return false;
    const p=Fortress.toWorld(sx,sy);
    this.dragging.g.x = clamp(p.x, 28, W-28);
    this.dragging.g.y = clamp(p.y, 40, H-40);
    return true;
  },
  handlePointerUp(_sx,_sy,pid){
    if (!this.dragging || (pid!=null && this.dragging.id!=null && pid!==this.dragging.id)) return false;
    this.dragging=null; return true;
  },
  spawnBattle(){
    enemies.length = 0;
    for (const g of this.ghosts){
      const e = spawnForgeEnemy(g.forge);
      if (!e) continue;
      e.x = g.x; e.y = g.y;
      e.ubTeam = g.team;
      e._ubSpec = JSON.parse(JSON.stringify(g.forge));
      e.noDrop = true; e.score = 0;
      const baseMove = e.move?.bind(e);
      e.move = (dt)=>{
        if (baseMove) baseMove(dt*0.45);
        const t = UnitBattle.findOpponent(e, e.x, e.y, 1400);
        if (!t) return;
        const tx = (t.x ?? e.x), ty = (t.y ?? e.y);
        const dx = tx - e.x, dy = ty - e.y;
        const d = Math.hypot(dx,dy) || 1;
        const sp = 90 + (e.r||14)*2.5;
        e.x += (dx/d) * sp * dt;
        e.y += (dy/d) * sp * dt;
      };
    }
    this.winner=null;
  },
  findOpponent(source, x,y,maxD=99999){
    if (!source || source.ubTeam==null) return Fortress.pickStrategicTarget(x,y,maxD) || null;
    let bestEnemy=null,bestD=maxD*maxD;
    for (const e of enemies){
      if (!e.alive || e===source || e.ubTeam==null || e.ubTeam===source.ubTeam) continue;
      const d2=dist2(x,y,e.x,e.y);
      if (d2<bestD){ bestD=d2; bestEnemy=e; }
    }

    let bestStruct=null, bestStructScore=-1e18;
    const structs = Fortress.structures || [];
    for (const st of structs){
      if (!st || (st.hp||0)<=0) continue;
      const d2 = dist2(x,y,st.x,st.y);
      if (d2 > maxD*maxD) continue;
      const laneW = (Math.abs(st.x-W*0.5)<180 && st.y>H*0.42) ? 1.8 : 1.0;
      const hpW = 1.0 + (1.0 - clamp((st.hp||1)/Math.max(1, st.maxHp||1),0,1))*1.2;
      const score = laneW*1.4 + hpW + (1/(1+Math.sqrt(d2)*0.012));
      if (score > bestStructScore){ bestStructScore = score; bestStruct = st; }
    }

    if (!bestEnemy) return bestStruct || null;
    if (!bestStruct) return bestEnemy;

    const enemyDist = Math.sqrt(bestD);
    const structDist = Math.hypot(bestStruct.x-x, bestStruct.y-y);
    const preferBreak = structDist < enemyDist*1.15;
    return preferBreak ? bestStruct : bestEnemy;
  },
  checkWinner(){
    if (!this.active || Fortress.phase!=='assault') return;
    const alive = enemies.filter(e=>e.alive && e.ubTeam!=null);
    const teams = new Set(alive.map(e=>e.ubTeam));
    if (teams.size===1 && alive.length){
      const t=[...teams][0];
      if (!this.winner){
        this.winner = alive[0]._ubSpec || null;
        textPop(W*0.5, H*0.18, `TEAM ${t} WIN`, C.G);
      }
    }
  },
  exportWinner(){
    if (!this.winner) return alert('暂无胜者');
    const txt = JSON.stringify({type:'forge', forge:this.winner}, null, 2);
    const io = document.getElementById('ioText');
    if (io) io.value = txt;
    try{ navigator.clipboard.writeText(txt); }catch(_){ }
    textPop(W*0.5, H*0.2, '胜者已导出到 I/O', C.P2);
  },
  drawGhosts(){
    if (!this.active || Fortress.phase!=='fortify') return;
    ctx.save();
    for (const g of this.ghosts){
      const col = g.team===1 ? 'rgba(130,229,255,.62)' : 'rgba(255,155,114,.62)';
      ctx.fillStyle = col;
      ctx.beginPath(); ctx.arc(g.x,g.y,g.r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(255,255,255,.8)'; ctx.lineWidth=1.2; ctx.stroke();
      const body = genEnemyBody((g.forge?.spec?.bodySeed||1337) + g.idx*97);
      const fake = {x:g.x,y:g.y,r:g.r*0.75,body,bodySeed:(g.forge?.spec?.bodySeed||1337),tint:(g.forge?.spec?.baseCol||C.E2),baseCol:(g.forge?.spec?.baseCol||C.E2),hit:0,shieldHP:0};
      drawEnemyGeneric(fake);
    }
    ctx.restore();
  }
};

function startRun({mode='survival', wave=1, forge=null, net=false, opponentBuild=null, keepLabLayout=false} = {}){
  const reqMode = mode;
  if (mode==='unitbattle'){
    UnitBattle.active = true;
    UnitBattle.setupGhosts();
    if (keepLabLayout && UnitBattle.assaultSnapshot?.ghosts?.length){
      UnitBattle.ghosts = deepClone(UnitBattle.assaultSnapshot.ghosts);
    }
    mode = 'lab';
  } else {
    UnitBattle.reset();
  }
  const savedLabLayout = (keepLabLayout && mode==='lab')
    ? deepClone((Fortress?._labAssaultStart?.layout?.length
        ? Fortress._labAssaultStart.layout
        : (Fortress?.structures?.filter(st=>st && st.hp>0).map(st=>({type:st.type,x:st.x,y:st.y,rot:(st.rot||0)}))?.length
            ? Fortress.structures.filter(st=>st && st.hp>0).map(st=>({type:st.type,x:st.x,y:st.y,rot:(st.rot||0)}))
            : (Fortress?._labSavedLayout || []))))
    : null;
  // 1. Reset
  resetGame();
  recoverLocalControl();
  Game.lastStart = { 
    mode:reqMode,
    wave,
    forge: forge ? JSON.parse(JSON.stringify(forge)) : null,
    net,
  };
  if (mode === 'survival' || mode === 'fortress' || mode === 'fortress_duel') {
    const diffVal = document.getElementById('inpDiffMode')?.value || 1;
    DiffConfig.apply(diffVal);
  } else {
    DiffConfig.apply(1); // Duel/Lab 默认 Normal
  }
  
  const zoomEl = document.getElementById('inpDynZoom');
  Camera.enabled = zoomEl ? (zoomEl.value === '1') : true;
  Camera.zoom = 1.0;
  Camera.targetZoom = 1.0;
  Game.mode = mode;
  Game.lastStart = {mode:reqMode, wave, forge: forge ? JSON.parse(JSON.stringify(forge)) : null, net};
  if (!net) Multiplayer.clearRemoteTransientState?.();
  
  const b = clampBuild(deepClone(Builds.A));
Player.maxHp = b.maxHp; Player.hp = b.maxHp;
Player.fireRate = b.fireRate;
Player.dmgMul = b.dmgMul;
Player.crit = b.crit;
Player.pierceBase = b.pierceBase;
Player.drones = b.drones;
Player.homingAmmo = b.homingAmmo;
Player.bomb = b.bomb;
Player.gunMods.length = 0;
for(const k of (b.gunMods||[])) Player.gunMods.push(k);
setupPlayerEmittersFromBuild(b);


  // 3. Mode-specific setup
  if (mode === 'survival'){
    // warp
    const startW = clamp((wave|0)||1, 1, 200);
    if (startW > 1){
      Game.wave = startW;
        Game.time = (startW - 1) * 22;
        Game.score = (startW - 1) * 1200;
        
        // BAL.bossInterval 约为 92
        const interval = 92; 
        // 计算最近的过去周期：例如当前200秒，最近周期是184秒
        Game.lastBossAt = Math.floor(Game.time / interval) * interval;

      const timeSlope = (Game.time < BAL.diffSwitchT) ? BAL.diffTimeEarly : BAL.diffTimeLate;
      Game.difficulty = 1 + Game.time*timeSlope + Game.score*BAL.diffScore;

      // light auto-scale (keep your original style)
      const targetLv = startW + 2;
      Player.lv = targetLv;
      Player.xpNeed = xpNeedFor(targetLv);
      const lvDelta = targetLv - 1;
      Player.maxHp += lvDelta * 1.5;
      Player.hp = Player.maxHp;
      Player.dmgMul += lvDelta * 0.015;
      Player.fireRate += lvDelta * 0.008;

      WaveDirector.onWave(startW);

      // fast-forward mods silently
      const modsCount = Math.min(Player.gunModsMax, Math.ceil(targetLv / 4));
      const prevAudio = audioOn;
      audioOn = false;
      for(let i=0; i<modsCount; i++) grantPlayerGunMod();
      audioOn = prevAudio;

      textPop(W/2, H/2 - 40, `SYSTEM WARP: WAVE ${startW}`, C.Y);
      spawnShockwave(W/2, H/2, C.P1, 400, 0.8);
    }
  }

  if (mode === 'fortress'){
    const startW = Math.max(1, wave|0);
    Game.wave = startW;
    Game.time = (Game.wave - 1) * 14;
    Game.score = Math.max(0, (Game.wave - 1) * 700);
    Game.difficulty = 1 + (Game.wave - 1) * 0.12;
    enemies.length = 0;
    Fortress.start();
    Fortress.onEnterFortifyEffects?.();

    // fortress warp：同步给予玩家升级与补给，避免只有波数变化
    if (startW > 1){
      const targetLv = Math.min(120, startW + 1);
      Player.lv = targetLv;
      Player.xpNeed = xpNeedFor(targetLv);
      Player.xp = 0;
      const lvDelta = Math.max(0, targetLv - 1);
      Player.maxHp += lvDelta * 1.25;
      Player.hp = Player.maxHp;
      Player.dmgMul += lvDelta * 0.012;
      Player.fireRate += lvDelta * 0.007;

      const modsCount = Math.min(Player.gunModsMax, Math.ceil(targetLv / 5));
      const prevAudio = audioOn;
      audioOn = false;
      for(let i=0; i<modsCount; i++) grantPlayerGunMod();
      audioOn = prevAudio;

      // 材料和地图补给双通道
      Fortress.stock += Math.floor((startW - 1) * 3.6);
      const dropN = clamp(2 + Math.floor(startW / 5), 2, 8);
      for (let i=0;i<dropN;i++){
        spawnSupply(rand(W*0.16, W*0.84), rand(H*0.36, H*0.70), chance(0.5)?'WXP':'WMOD');
      }

      textPop(W*0.5, H*0.24, `FORTRESS WARP: WAVE ${startW}`, C.Y);
      spawnShockwave(W*0.5, H*0.24, C.Y, 300, 0.6);
    }

    textPop(W*0.5, 92, 'FORTRESS MODE', '#7ef9c0');
    spawnShockwave(W*0.5, 92, '#7ef9c0', 260, 0.55);
  }

  if (mode === 'duel'){
    // no spawner; spawn rival from Build B
    Game.wave = 1;
    Game.time = 0;
    Game.score = 0;
    enemies.length = 0;

    const rival = makeRivalFromBuild(Builds.B);
    enemies.push(rival);

    textPop(W*0.5, 92, 'DUEL MODE', C.Y);
    spawnShockwave(W*0.5, 92, C.Y, 240, 0.55);
  }

  
if (mode === 'fortress_duel'){
    Game.wave = 1;
    Game.time = 0;
    Game.score = 0;
    enemies.length = 0;
    Fortress.start();
    Fortress.phase = 'fortify';
    Fortress.onEnterFortifyEffects?.();
    Fortress.duelTimer = 35;
    Fortress.stock = 38;
    Fortress.flagMaxHp = 1200;
    Fortress.flagHp = Fortress.flagMaxHp;
    Fortress.updatePanel();

    textPop(W*0.5, 92, 'FORTRESS DUEL PREP', '#ff8ea2');
    spawnShockwave(W*0.5, 92, '#ff8ea2', 220, 0.52);
  }

if (mode === 'workshop'){
    // online workshop duel: no AI rival; remote player acts as opponent
    Game.wave = 1;
    Game.time = 0;
    Game.score = 0;
    enemies.length = 0;

    textPop(W*0.5, 92, 'WORKSHOP 1V1 (A vs A)', C.P2);
    spawnShockwave(W*0.5, 92, C.P2, 260, 0.58);
  }

if (mode === 'lab'){
    Game.wave = 1;
    Game.time = 0;
    Game.score = 0;
    enemies.length = 0;

    Fortress.start();
    Fortress.stock = 999999;
    Fortress.phase = 'fortify';
    Fortress.onEnterFortifyEffects?.();
    Fortress.labLockedAssault = false;
    Fortress.labForgeSpawned = false;
    Fortress.labForgeSpec = forge || JSON.parse(localStorage.getItem(LS_FORGE) || 'null');
    if (savedLabLayout?.length) Fortress.applyLabLayout(savedLabLayout);
    else Fortress.snapshotLabLayout();
    if (keepLabLayout && Fortress._labAssaultStart){
      Fortress.selected = Fortress._labAssaultStart.selected || Fortress.selected;
      Fortress.placeRot = Fortress._labAssaultStart.placeRot || 0;
      Fortress.sellMode = !!Fortress._labAssaultStart.sellMode;
    }
    Fortress.updatePanel();

    textPop(W*0.5, 92, 'LAB FORTRESS PREP', C.P2);
    spawnShockwave(W*0.5, 92, C.P2, 240, 0.55);
  }

  // [修正] 混沌挑战模式初始化 (兼容 Warp)
  if (mode === 'challenge') {
    // 1. 应用传入的波次
    Game.wave = Math.max(1, wave);
    
    // 2. 根据波次预热分数和难度，防止高波次难度过低
    Game.time = (Game.wave - 1) * 10; 
    Game.score = (Game.wave - 1) * 2000;
    // 难度系数随波次线性增长
    Game.difficulty = 1.0 + (Game.wave - 1) * 0.15; 
    
    // 3. 给予玩家初始资源/等级补偿 (可选，防止裸奔打第50波)
    if (Game.wave > 1) {
      const targetLv = Game.wave + 2;
      Player.lv = targetLv;
      // 简单粗暴的属性补偿
      Player.maxHp += (targetLv - 1) * 2;
      Player.hp = Player.maxHp;
      Player.dmgMul += (targetLv - 1) * 0.04;
      Player.fireRate += (targetLv - 1) * 0.015;
      // 补发 Mod (不播放音效)
      const mods = Math.min(Player.gunModsMax, Math.ceil(targetLv / 3));
      for(let i=0; i<mods; i++) grantPlayerGunMod();
    }

    enemies.length = 0;
    
    // 立即准备生成
    Spawner.cd = 0.5;

    textPop(W*0.5, 92, `CHAOS WAVE ${Game.wave}`, C.E1);
    spawnShockwave(W*0.5, 92, C.E1, 300, 0.6);
  }

  // 4. Enter game
  showOverlay('gameover', false);
showOverlay('pausePanel', false);
canvas.style.pointerEvents = 'auto';
  SFX.revive();
  Game.state='playing';
  setView('game');
  ui.menu.style.display='none';
  ui.over.classList.remove('show');
canvas.style.pointerEvents = 'auto';
  if (mode==='fortress' || mode==='lab' || mode==='fortress_duel') Fortress.updatePanel();
  syncAutoPilotBtnVisibility();

  if (audioOn){
    ensureAudio();
    const idx = (Math.random() * MusicTracks.length) | 0;
    Music.useTrack(idx);
    Music.start();
  }
}

  function syncAutoPilotBtnVisibility(){
  const btnAutoPilot = document.getElementById('btnAutoPilot');
  if (!btnAutoPilot) return;
  const hideInNetFortressDuel = (Game.mode==='fortress_duel' && !!Game.lastStart?.net);
  btnAutoPilot.style.display = hideInNetFortressDuel ? 'none' : 'inline-block';
}


function setView(view){
  const toGame = (view==='game');
  if (ui.menu) ui.menu.style.display = toGame ? 'none' : 'flex';
  if (ui.hud) ui.hud.style.display = toGame ? 'block' : 'none';
  if (!toGame) document.body.dataset.menupage = document.body.dataset.menupage || 'home';
}

function toMenu(){
  const wasNetRun = !!Game.lastStart?.net;
  Multiplayer.cancelPrepare(false);
  if (wasNetRun && Multiplayer.isActive?.()) Multiplayer.leaveRoom(true);
  Multiplayer.clearRemoteTransientState?.();
  clearAllProjectiles();
  showOverlay('gameover', false);
  showOverlay('pausePanel', false);
  canvas.style.pointerEvents = 'auto';
  Game.state = 'menu';
  setView('menu');
  ui.over.classList.remove('show');
  canvas.style.pointerEvents = 'auto';
  ui.btnPause.textContent='PAUSE';
  
  // 返回菜单时确保按钮状态重置
  const btnMute = document.getElementById('btnMute');
  const btnPauseRetry = document.getElementById('btnPauseRetry');
  // [新增] 获取 AI 按钮
  const btnAutoPilot = document.getElementById('btnAutoPilot');

  if (btnMute) btnMute.style.display = 'inline-block';
  if (btnPauseRetry) btnPauseRetry.style.display = 'none';
  ui.btnOption.style.display = 'none';
  // [新增] 强制重置 AI 按钮为可见，确保下局游戏正常显示
  syncAutoPilotBtnVisibility();

  Music.stop();
  Fortress.updatePanel();
}
function mountOverlaysToBody(){
  for (const id of ['gameover','pausePanel']){
    const el = document.getElementById(id);
    if (el && el.parentElement !== document.body){
      document.body.appendChild(el);
    }
  }
}

function showOverlay(id, on){
  const el = document.getElementById(id);
  if (!el) return;

  if (on){
    el.classList.add('show');
    el.style.display = 'flex';   // 双保险
    // 避免 canvas 捕获/吞点击，导致你以为弹窗没出来或无法点
    canvas.style.pointerEvents = 'none';
    // 释放 pointer capture（如果你实现了 endPointer）
    if (typeof endPointer === 'function') endPointer();
    Input.active = false;
  }else{
    el.classList.remove('show');
    el.style.display = 'none';
    canvas.style.pointerEvents = 'auto';
  }
}

// [最终修正版] 递归序列化发射器 (特殊处理 INTERLEAVE)
function serializeEmitterRecursive(em) {
  if (!em) return null;

  // [新增] 特殊处理 INTERLEAVE，因为它有两个分支
  if (em._composite === 'INTERLEAVE') {
    return {
      isWrapper: true,
      wrapperType: 'INTERLEAVE',
      compCfg: em._compCfg || {},
      // 分别保存两个分支
      innerA: serializeEmitterRecursive(em._emA),
      innerB: serializeEmitterRecursive(em._emB)
    };
  }
  
  // 原有的通用包装器逻辑
  if (em._composite) {
    const inner = em._base || em._emA;
    return {
      isWrapper: true,
      wrapperType: em._composite,
      compCfg: em._compCfg || {},
      inner: serializeEmitterRecursive(inner)
    };
  }

  // 基础发射器逻辑
  return {
    isWrapper: false,
    type: em.type || 'AIM',
    mods: em.mods || (em.cfg ? em.cfg.mods : []) || [],
    speed: em.speed || (em.cfg ? em.cfg.speed : 220),
    cd: em.cfg?.baseCd ?? em.cd ?? 1.2
  };
}

function deserializeEmitterRecursive(data) {
  if (!data) return null;
  if (data.wrapperType === 'INTERLEAVE') {
    const wrapperFn = CompositeWrappers['INTERLEAVE'];
    if (!wrapperFn) return null;
    const factoryA = () => deserializeEmitterRecursive(data.innerA);
    const factoryB = () => deserializeEmitterRecursive(data.innerB);
    const em = wrapperFn(factoryA, { ...(data.compCfg || {}), factoryB });
    if (em && data.cd != null) em.cd = data.cd;
    return em;
  }
  if (data.isWrapper) {
    const wrapperFn = CompositeWrappers[data.wrapperType];
    if (!wrapperFn) return null;
    const innerFactory = () => deserializeEmitterRecursive(data.inner || data.innerA || data.innerB);
    const em = wrapperFn(innerFactory, data.compCfg || {});
    if (em && data.cd != null) em.cd = data.cd;
    return em;
  }
  const factory = EmitterCatalog[data.type || 'AIM'];
  if (!factory) return null;
  return factory({ baseCd: data.cd, speed: data.speed, mods: data.mods || [] });
}

function buildEmitterSpecFromSerialized(data) {
  if (!data) return null;
  if (data.isWrapper || data.wrapperType === 'INTERLEAVE') {
    const inst = deserializeEmitterRecursive(data);
    return inst ? { type:'_COMPOSITE', _compositeInstance:inst, cfg:{} } : null;
  }
  return {
    type: data.type || 'AIM',
    cfg: {
      baseCd: data.cd ?? 1.2,
      speed: data.speed ?? 220,
      mods: Array.isArray(data.mods) ? data.mods : []
    }
  };
}

// 代码位置：替换旧的 extractEnemyForForge 函数
function extractEnemyForForge(e) {
  if (!e) return null;

  // 优先使用 _protoMoveKeys
  const moveKeys = e._protoMoveKeys || [e._protoMoveKey || (e.mmx ? e.mmx.mode : 'DRIFT')];

  const data = {
    isBoss: (e.type === 'BOSS'),
    hp: e.maxHp,
    col: e.baseCol || e.tint || 'rgb(255,77,109)',
    baseCol: e.baseCol || null,
    tint: (e.tint != null ? e.tint : null),
    moveKeys: moveKeys,
    moveKey: moveKeys[0], 
    mods: (e.waveBulletMods || []).slice(0, 6),
    traits: [],
    bodyKind: e.body?.kind || 'AUTO',
    bodySeed: (e._protoBodySeed ?? e.bodySeed ?? 1337) | 0,
    bodyScale: 1.0,
    bodyOpt: {},
    slot1: null,
    slot2: null,
    emitters: []
  };

  // 1. 提取 Body 参数
  if (e.body) {
    const b = e.body;
    data.bodyOpt = {
      baseN: b.baseN, innerN: b.innerN, ring: b.ring?1:0, spokes: b.spokes,
      starInner: b.starInner, teeth: b.teeth, toothDepth: b.toothDepth,
      rr: b.rr, diaSkew: b.diaSkew, arcSegs: b.arcSegs, arcSpan: b.arcSpan, arcGap: b.arcGap,
      // 兼容一些可能的旧属性
      crossT: b.crossT, chevT: b.chevT
    };
    const defR = (e.type === 'BOSS') ? 56 : 16;
    data.bodyScale = parseFloat(Math.max(0.6, Math.min(2.2, e.r / (defR * (b.scale1||1)))).toFixed(2));
  }

  const traitSource = e._appliedTraitKeys || e._protoTraitsForced || [];
  
  // 使用 Set 去重
  const traitsFound = new Set(traitSource);

  // 过滤：只保留有效的、非样式的 Trait 供 Forge 使用
  data.traits = Array.from(traitsFound).filter(k => {
    const t = EnemyTraitCatalog[k];
    return t
  }).slice(0, 6); // 保持上限

  const srcEms = e._protoEmitters || e.emitters || [];

  const resolveAndSerialize = (emItem) => {
  if (!emItem) return null;
  // 直接处理，因为 emItem 现在如果是实例，必带标识；如果是 proto 定义，也必带实例
  const target = emItem._compositeInstance || emItem;
  return serializeEmitterRecursive(target);
};
  
  data.emitters = srcEms.map(resolveAndSerialize).filter(Boolean);
  data.slot1 = data.emitters[0] || null;
  data.slot2 = data.emitters[1] || null;

  return data;
}

  function gameOver(){
  Game.state = 'over';

  // 保证不被 menu 状态影响
  setView('game');
  ui.menu.style.display = 'none';
  ui.menu.classList.remove('show');

  // 释放 pointer capture & 禁止 canvas 吞点击（避免你以为弹窗没出）
  try{ if (typeof endPointer === 'function') endPointer(); }catch(_){}
  Input.active = false;
  canvas.style.pointerEvents = 'none';

  ui.finalScore.textContent = Math.floor(Game.score);
  ui.finalWave.textContent  = Game.wave;

  ui.btnRevive.style.display = (Game.continues>0) ? 'block' : 'none';
  
  const btnKiller = document.getElementById('btnCopyKiller');
  if (btnKiller){
    btnKiller.style.display = Game.killerData ? 'block' : 'none';
  }

  // 真正显示：用 class 控制
  ui.over.classList.add('show');

  Music.start();
  Music.duck(0.20, 0.10);
  beep({f:110,t:0.12,g:0.03,type:'sawtooth',slide:0.6});
}

function togglePause(){
  // 释放输入，避免 canvas capture 吞掉点击
  if (typeof endPointer === 'function') endPointer();
  Input.active = false;

  const panel = document.getElementById('pausePanel');
  const btnMute = document.getElementById('btnMute');
  const btnPauseRetry = document.getElementById('btnPauseRetry');
  // [新增] 获取 AI 按钮
  const btnAutoPilot = document.getElementById('btnAutoPilot'); 

  if (Game.state === 'playing'){
    Game.state = 'paused';
    setView('game');
    ui.menu.style.display = 'none';
    if (panel) panel.style.display = 'flex';

    ui.btnPause.textContent = 'RESUME';
    if (ui.btnOption) ui.btnOption.style.display = 'inline-block';
    
    // --- 核心切换逻辑 ---
    if (btnMute) btnMute.style.display = 'none';           // 隐藏音频按钮
    if (btnPauseRetry) btnPauseRetry.style.display = 'inline-block'; // 显示重试按钮
    // [新增] 暂停时隐藏 AI 按钮
    if (btnAutoPilot) btnAutoPilot.style.display = 'none'; 
    
    Music.setPaused(true);
    return;
  }

  if (Game.state === 'paused'){
    Game.state = 'playing';
    if (panel) panel.style.display = 'none';
    canvas.style.pointerEvents = 'auto';

    ui.btnPause.textContent = 'PAUSE';
    if (ui.btnOption) ui.btnOption.style.display = 'none';
    
    // --- 核心恢复逻辑 ---
    if (btnMute) btnMute.style.display = 'inline-block';   // 恢复音频按钮
    if (btnPauseRetry) btnPauseRetry.style.display = 'none'; // 隐藏重试按钮
    // [新增] 恢复游戏时显示 AI 按钮
    syncAutoPilotBtnVisibility();
    
    Music.setPaused(false);
    return;
  }
}

  function revive(){
    if (Game.continues<=0 || Game.state!=='over') return;

    const isFlagFail = ((Game.mode==='fortress' || Game.mode==='fortress_duel') && (Game.failReason==='flag' || Fortress.flagHp<=0));
    const needPlayerReboot = !Player.alive || Player.hp<=0;
    Game.continues--;

    Player.alive=true;
    const snap = Game.failSnapshot || {};
    if (needPlayerReboot){
      Player.hp = Player.maxHp;
      Player.invuln = Math.max(snap.invuln ?? 0, BAL.continueInvuln);
      Player.shield = Math.max(snap.shield ?? 0, 12.0);
      Player.x = snap.x ?? Player.x;
      Player.y = snap.y ?? Player.y;
    }
    if (isFlagFail){
      Fortress.flagHp = Fortress.flagMaxHp;
      Fortress.flagInvulnT = 5.0;
      Fortress.updatePanel();
    }
    if (!needPlayerReboot && !isFlagFail){
      Player.hp = Math.max(1, Math.floor(Player.maxHp*BAL.continueHP));
      Player.invuln = BAL.continueInvuln;
      Player.shield = Math.max(Player.shield, 12.0); // Full shield on revive
    }
    Player.slowT = 0;

    // Nuke screen
    for (const b of bulletsE) b.alive=false;
    beams.length = 0;
    
    spawnShockwave(Player.x, Player.y, C.G, 520, 0.75);
    sparks(Player.x, Player.y, 'glowG', 60, 720);
    addShake(10,0.25);
    textPop(Player.x, Player.y-18, isFlagFail ? 'FLAG CORE REBOOTED' : 'SYSTEM REBOOTED', C.G);

    ui.over.classList.remove('show');
canvas.style.pointerEvents = 'auto';
    showOverlay('gameover', false);
canvas.style.pointerEvents = 'auto';
Game.state = 'playing';
    Game.state='playing';
    
   
    Game.failReason = '';
    Game.failSnapshot = null;
    Music.duck(0.30, 0.08);
  }


const DevEditor = {
  active:false,
  onCanvasPointerDown(){},
  onCanvasPointerMove(){},
  onCanvasPointerUp(){},
  onHudPointerDown(){},
  onHudPointerMove(){},
  onHudPointerUp(){},
  handleCanvasDoubleClick(){},
  bindMenuTitleUnlock(){},
};

const LS_BUILDS = 'NAW_BUILDS_V1';
const LS_FORGE  = 'NAW_FORGE_V1';
const deepClone = (o)=>JSON.parse(JSON.stringify(o));

const DefaultBuild = (name)=>({
  name, maxHp:100, fireRate:1.0, dmgMul:1.0, crit:0.05,
  pierceBase:0, drones:0, homingAmmo:0, bomb:1,
  gunMods:[],
  emitters:[],
});

let Builds = { A: DefaultBuild('BUILD A'), B: (()=>{ const b=DefaultBuild('BUILD B'); b.maxHp=120; return b; })() };
let ForgeState = {
  isBoss:false, moveKey:'DRIFT', col:C.E2, hp:900,
  em1:{type:'AIM', cd:1.2, speed:220},
  em2:{type:'RING', cd:2.2, speed:180},
  mods:[], traits:[],
  extraEmitters:[]
};
ForgeState.bodyKind = ForgeState.bodyKind || 'AUTO';
ForgeState.bodySeed = (ForgeState.bodySeed ?? 1337);
ForgeState.bodyScale = (ForgeState.bodyScale ?? 1.0);
ForgeState.bodyOpt = ForgeState.bodyOpt || {
  baseN:null, innerN:null, ring:null, spokes:null,
  starInner:null, teeth:null, toothDepth:null,
  rr:null, diaSkew:null,
  arcSegs:null, arcSpan:null, arcGap:null,
};

function applyBodyOverrides(body, opt){
  if (!body || !opt) return body;

  const num = (v)=> (v==null || v==='' || Number.isNaN(+v)) ? null : +v;

  const setInt = (k, min, max)=>{
    const v = num(opt[k]); if (v==null) return;
    body[k] = clamp(v|0, min, max);
  };
  const setNum = (k, min, max)=>{
    const v = num(opt[k]); if (v==null) return;
    body[k] = clamp(v, min, max);
  };

  setInt('baseN', 3, 12);
  setInt('innerN', 3, 12);

  if (opt.ring != null) body.ring = !!opt.ring;
  setInt('spokes', 0, 10);

  setNum('starInner', 0.20, 0.85);

  // 关键：允许 gear teeth 最小到 3（你设置 3 才会生效）
  setInt('teeth', 3, 26);
  setNum('toothDepth', 0.05, 0.45);

  setNum('rr', 0.10, 0.60);
  setNum('diaSkew', 0.40, 1.60);

  setInt('arcSegs', 2, 10);
  setNum('arcSpan', 0.20, 1.60);
  setNum('arcGap', 0.00, 1.00);

  return body;
}

function clampBuild(b){
  b.maxHp = clamp(+b.maxHp||100, 30, 600);
  b.fireRate = clamp(+b.fireRate||1, 0.5, 3.0);
  b.dmgMul = clamp(+b.dmgMul||1, 0.5, 5.0);
  b.crit = clamp(+b.crit||0.05, 0, 0.6);
  b.pierceBase = clamp((+b.pierceBase||0)|0, 0, 8);
  b.drones = clamp((+b.drones||0)|0, 0, 4);
  b.homingAmmo = clamp((+b.homingAmmo||0)|0, 0, 120);
  b.bomb = clamp((+b.bomb||1)|0, 0, 3);
  b.gunMods = Array.from(new Set((b.gunMods||[]))).slice(0, Player.gunModsMax);
  b.emitters = Array.from(new Set((b.emitters||[])))
  .filter(k => typeof PlayerEmitterCatalog==='object' && !!PlayerEmitterCatalog[k])
  .slice(0, (Player.emittersMax || 3));
  return b;
}

function saveBuilds(){ localStorage.setItem(LS_BUILDS, JSON.stringify({A:Builds.A, B:Builds.B})); }
function loadBuilds(){
  try{
    const raw = localStorage.getItem(LS_BUILDS);
    if (!raw) return false;
    const obj = JSON.parse(raw);
    if (obj?.A) Builds.A = clampBuild(obj.A);
    if (obj?.B) Builds.B = clampBuild(obj.B);
    return true;
  }catch(e){ return false; }
}
function saveForge(){ localStorage.setItem(LS_FORGE, JSON.stringify(ForgeState)); }
function loadForge(){
  try{
    const raw = localStorage.getItem(LS_FORGE);
    if (!raw) return false;
    ForgeState = Object.assign(ForgeState, JSON.parse(raw));
    return true;
  }catch(e){ return false; }
}

const MenuUI = {
  page:'home',
  editKey:'A',
  selectedMods:new Set(),
  forgeMods:new Set(),
  forgeTraits:new Set(),
  pvC:null, pvX:null
};

function setMenuPage(key){
  document.body.dataset.menupage = key;

  // 切页
  const map = {
    home: document.getElementById('pageHome'),
    workshop: document.getElementById('pageWorkshop'),
    forge: document.getElementById('pageForge'),
  };
  for (const k in map){
    if (map[k]) map[k].classList.toggle('active', k === key);
  }

  // nav active
  document.querySelectorAll('#menu .nav-btn[data-page]').forEach(btn=>{
    btn.classList.toggle('active', btn.dataset.page === key);
  });

  // forge 时：摆放预览并强刷一次
  if (key === 'forge'){
    placeForgePreview();
    refreshForgePreview();
  } else {
    placeForgePreview(); // 让它隐藏 & 不占 side
  }
}

function currentBuild(){ return (MenuUI.editKey==='A') ? Builds.A : Builds.B; }

function bindRangePair(rId, nId, getter, setter){
  const r = document.getElementById(rId);
  const n = document.getElementById(nId);
  const sync = ()=>{ const v=getter(); r.value=v; n.value=v; };
  const apply = (v)=>{ setter(+v); sync(); refreshForgePreview(); };
  r.addEventListener('input', ()=>apply(r.value));
  n.addEventListener('change', ()=>apply(n.value));
  sync();
}

function buildAffixChips(){
  const cont = document.getElementById('ws_modChips');
  const search = document.getElementById('ws_modSearch');
  cont.innerHTML='';

  const keys = Object.keys(BulletAffixCatalog);

  const mk = (k)=>{
    const btn = document.createElement('button');
    btn.type='button';
    btn.className='pick-chip';
    btn.dataset.key=k;
    btn.textContent=k;
    btn.addEventListener('click', ()=>{
      if (MenuUI.selectedMods.has(k)) MenuUI.selectedMods.delete(k);
      else{
        if (MenuUI.selectedMods.size>=Player.gunModsMax) return;
        MenuUI.selectedMods.add(k);
      }
      const b = currentBuild();
      b.gunMods = Array.from(MenuUI.selectedMods);
      saveBuilds();
      btn.classList.toggle('on', MenuUI.selectedMods.has(k));
      refreshForgePreview();
    });
    return btn;
  };

  for(const k of keys) cont.appendChild(mk(k));

  const filterNow = ()=>{
    const q = (search.value||'').trim().toUpperCase();
    for(const btn of cont.querySelectorAll('.pick-chip')){
      const k = btn.dataset.key;
      btn.style.display = (!q || k.includes(q)) ? 'inline-flex' : 'none';
    }
  };
  search.addEventListener('input', filterNow);
  filterNow();
}

function buildForgeChips(){
  const modCont = document.getElementById('forgeModChips');
  const trCont  = document.getElementById('forgeTraitChips');
  modCont.innerHTML=''; trCont.innerHTML='';

  for(const k of Object.keys(BulletAffixCatalog)){
    const btn=document.createElement('button');
    btn.type='button';
    btn.className='pick-chip';
    btn.dataset.key=k;
    btn.textContent=k;
    btn.addEventListener('click', ()=>{
      if (MenuUI.forgeMods.has(k)) MenuUI.forgeMods.delete(k);
      else { if (MenuUI.forgeMods.size>=4) return; MenuUI.forgeMods.add(k); }
      ForgeState.mods = Array.from(MenuUI.forgeMods);
      saveForge();
      btn.classList.toggle('on', MenuUI.forgeMods.has(k));
      refreshForgePreview();
    });
    modCont.appendChild(btn);
  }

  for(const k of Object.keys(EnemyTraitCatalog)){
    const btn=document.createElement('button');
    btn.type='button';
    btn.className='pick-chip';
    btn.dataset.key=k;
    btn.textContent=k;
    btn.addEventListener('click', ()=>{
      if (MenuUI.forgeTraits.has(k)) MenuUI.forgeTraits.delete(k);
      else { if (MenuUI.forgeTraits.size>=6) return; MenuUI.forgeTraits.add(k); }
      ForgeState.traits = Array.from(MenuUI.forgeTraits);
      saveForge();
      btn.classList.toggle('on', MenuUI.forgeTraits.has(k));
      refreshForgePreview();
    });
    trCont.appendChild(btn);
  }
}

function populateForgeSelects(){
  const colSel = document.getElementById('forgeCol');
  const em1Sel = document.getElementById('forgeEm1Type');
  const em2Sel = document.getElementById('forgeEm2Type');
  
  // 1. 颜色 (保持不变)
  colSel.innerHTML='';
  for(const c of [C.E1,C.E2,C.E3,C.E4,C.E5,C.E6,C.E7,C.Y]){
    const o=document.createElement('option'); o.value=c; o.textContent=c; colSel.appendChild(o);
  }

  // 2. Emitters (保持不变)
  em1Sel.innerHTML=''; em2Sel.innerHTML='';
  for(const k of Object.keys(EmitterCatalog)){
    const o1=document.createElement('option'); o1.value=k; o1.textContent=k; em1Sel.appendChild(o1);
    const o2=document.createElement('option'); o2.value=k; o2.textContent=k; em2Sel.appendChild(o2);
  }

  // [新增] 3. 自动填充 Body Kinds
  const bodySel = document.getElementById('forgeBodyKind');
  if (bodySel) {
    // 记录当前选中的值，防止刷新时跳回 AUTO
    const currentVal = bodySel.value; 
    bodySel.innerHTML = ''; // 清空硬编码的 HTML 选项

    // 添加 AUTO 选项
    const optAuto = document.createElement('option');
    optAuto.value = 'AUTO';
    optAuto.textContent = 'AUTO';
    bodySel.appendChild(optAuto);

    // 动态添加所有外形
    BODY_KINDS.forEach(k => {
      const opt = document.createElement('option');
      opt.value = k;
      opt.textContent = k;
      bodySel.appendChild(opt);
    });

    // 尝试恢复选中值
    bodySel.value = currentVal || 'AUTO';
  }
}

function bindWorkshopCoreFinal(){
  // ===== hard-rebind: 通过 clone 节点移除旧 addEventListener，彻底避免“双绑定” =====
  const rebind = (id)=>{
    const el = document.getElementById(id);
    if (!el || !el.parentNode) return el;
    const c = el.cloneNode(true);
    el.parentNode.replaceChild(c, el);
    return c;
  };

  // buttons
  const btnA = rebind('btnEditA');
  const btnB = rebind('btnEditB');
  const btnReset = rebind('btnResetBuilds');

  // inputs (core)
  const wsName = rebind('ws_name');

  const core = [
    {n:'ws_hp_n',     r:'ws_hp_r',     prop:'maxHp',      fix:v=>clamp(+v||100, 30, 600)},
    {n:'ws_fire_n',   r:'ws_fire_r',   prop:'fireRate',   fix:v=>clamp(+v||1,   0.5, 3.0)},
    {n:'ws_dmg_n',    r:'ws_dmg_r',    prop:'dmgMul',     fix:v=>clamp(+v||1,   0.5, 5.0)},
    {n:'ws_crit_n',   r:'ws_crit_r',   prop:'crit',       fix:v=>clamp(+v||0,   0,   0.6)},
    {n:'ws_pierce_n', r:'ws_pierce_r', prop:'pierceBase', fix:v=>clamp((+v||0)|0,0,8)},
    {n:'ws_drones_n', r:'ws_drones_r', prop:'drones',     fix:v=>clamp((+v||0)|0,0,4)},
    {n:'ws_homing_n', r:'ws_homing_r', prop:'homingAmmo', fix:v=>clamp((+v||0)|0,0,120)},
    {n:'ws_bomb_n',   r:'ws_bomb_r',   prop:'bomb',       fix:v=>clamp((+v||1)|0,0,3)},
  ].map(p=>({
    ...p,
    nEl: rebind(p.n),
    rEl: rebind(p.r),
  }));

  function pushUI(){
    const b = currentBuild();

    // name
    if (wsName) wsName.value = b.name || (MenuUI.editKey==='A'?'BUILD A':'BUILD B');

    // core
    for (const p of core){
      const v = b[p.prop];
      if (p.nEl) p.nEl.value = v;
      if (p.rEl) p.rEl.value = v;
    }

    // chips
    MenuUI.selectedMods = new Set(b.gunMods||[]);
    document.querySelectorAll('#ws_modChips .pick-chip').forEach(btn=>{
      btn.classList.toggle('on', MenuUI.selectedMods.has(btn.dataset.key));
    });

    // active btn
    btnA?.classList.toggle('active', MenuUI.editKey==='A');
    btnB?.classList.toggle('active', MenuUI.editKey==='B');
    
    // ---- emitter chips (FIX: refresh on build switch / reset) ----
const emSet = new Set(b.emitters || []);
document.querySelectorAll('#ws_emitChips .pick-chip').forEach(btn=>{
  btn.classList.toggle('on', emSet.has(btn.dataset.key));
});

    refreshForgePreview?.();
  }

  function pullUI(){
    const b = currentBuild();
    if (wsName) b.name = (wsName.value || '').trim() || b.name;

    for (const p of core){
      const v = p.nEl ? p.nEl.value : (p.rEl ? p.rEl.value : b[p.prop]);
      b[p.prop] = p.fix(v);
    }

    b.gunMods = Array.from(MenuUI.selectedMods || []);
    clampBuild?.(b);
    saveBuilds?.();
  }

  // ===== events =====
  btnA && (btnA.onclick = ()=>{
    pullUI();               // 保存当前 build
    MenuUI.editKey = 'A';
    pushUI();               // 刷新为 A
  });

  btnB && (btnB.onclick = ()=>{
    pullUI();
    MenuUI.editKey = 'B';
    pushUI();
  });

  // 任意 core 输入变化 => 写回 build
  for (const p of core){
    const syncToRange = ()=>{ if (p.nEl && p.rEl) p.rEl.value = p.nEl.value; };
    const syncToNum   = ()=>{ if (p.nEl && p.rEl) p.nEl.value = p.rEl.value; };

    if (p.nEl){
      p.nEl.oninput = ()=>{ syncToRange(); pullUI(); };
      p.nEl.onchange = ()=>pullUI();
    }
    if (p.rEl){
      p.rEl.oninput = ()=>{ syncToNum(); pullUI(); };
      p.rEl.onchange = ()=>pullUI();
    }
  }

  if (wsName){
    wsName.oninput = ()=>pullUI();
    wsName.onchange = ()=>pullUI();
  }

  // Reset 当前 build：真正重置 Core + Mods
  btnReset && (btnReset.onclick = ()=>{
  const k = (MenuUI.editKey === 'B') ? 'B' : 'A';
  const nb = DefaultBuild(k==='A' ? 'BUILD A' : 'BUILD B');
  if (k==='B') nb.maxHp = 120;

  Builds[k] = clampBuild(nb);
  saveBuilds?.();

  // 关键：把 UI（含 emitters acc）强制刷新
  syncWorkshopFromModel();
});

  // 初次回填
  if (!MenuUI.editKey) MenuUI.editKey = 'A';
  pushUI();
}

function buildPlayerEmitterChips(){
  const cont = document.getElementById('ws_emitChips');
  const search = document.getElementById('ws_emitSearch');
  if (!cont) return;

  cont.innerHTML = '';

  // 允许选择的 emitter 列表
  const keys = Object.keys(PlayerEmitterCatalog || {});

  const mk = (k)=>{
    const btn = document.createElement('button');
    btn.type='button';
    btn.className='pick-chip';
    btn.dataset.key=k;
    btn.textContent=k;

    btn.addEventListener('click', ()=>{
      const b = currentBuild();
      const set = new Set(b.emitters || []);
      const cap = (Player.emittersMax || 3);

      if (set.has(k)){
        set.delete(k);
      } else {
        if (set.size >= cap) return; // 超上限不加
        set.add(k);
      }
      b.emitters = Array.from(set);
      clampBuild(b);
      saveBuilds();
      syncWorkshopFromModel(); // 统一回填/刷新
    });

    return btn;
  };

  for(const k of keys) cont.appendChild(mk(k));

  const filterNow = ()=>{
    const q = (search?.value || '').trim().toUpperCase();
    for(const btn of cont.querySelectorAll('.pick-chip')){
      const k = btn.dataset.key || '';
      btn.style.display = (!q || k.includes(q)) ? 'inline-flex' : 'none';
    }
  };

  if (search){
    search.addEventListener('input', filterNow);
  }
  filterNow();
}

function syncWorkshopFromModel(){
  const b = currentBuild();

  // name
  const nameEl = document.getElementById('ws_name');
  if (nameEl) nameEl.value = b.name || (MenuUI.editKey==='A'?'BUILD A':'BUILD B');

  // core pairs (如果你用的是 bindWorkshopCoreFinal，这里同步也不冲突)
  const setPair = (nId, rId, v)=>{
    const n = document.getElementById(nId);
    const r = document.getElementById(rId);
    if (n) n.value = v;
    if (r) r.value = v;
  };
  setPair('ws_hp_n','ws_hp_r', b.maxHp);
  setPair('ws_fire_n','ws_fire_r', b.fireRate);
  setPair('ws_dmg_n','ws_dmg_r', b.dmgMul);
  setPair('ws_crit_n','ws_crit_r', b.crit);
  setPair('ws_pierce_n','ws_pierce_r', b.pierceBase);
  setPair('ws_drones_n','ws_drones_r', b.drones);
  setPair('ws_homing_n','ws_homing_r', b.homingAmmo);
  setPair('ws_bomb_n','ws_bomb_r', b.bomb);

  // gun mods chips
  MenuUI.selectedMods = new Set(b.gunMods||[]);
  document.querySelectorAll('#ws_modChips .pick-chip').forEach(btn=>{
    btn.classList.toggle('on', MenuUI.selectedMods.has(btn.dataset.key));
  });

  // NEW: emitter chips
  const emSet = new Set(currentBuild().emitters || []);
document.querySelectorAll('#ws_emitChips .pick-chip').forEach(btn=>{
  btn.classList.toggle('on', emSet.has(btn.dataset.key));
});

  // active state
  document.getElementById('btnEditA')?.classList.toggle('active', MenuUI.editKey==='A');
  document.getElementById('btnEditB')?.classList.toggle('active', MenuUI.editKey==='B');
  

  refreshForgePreview?.();
}


const WrapperFieldDefs = {
  'MULTI_DIR':      [{id:'dirs',type:'number',min:2,max:8,def:3}, {id:'spreadMode',type:'select',opts:['even','front','sides'],def:'even'}],
  'CHILD_BURST':    [{id:'childType',type:'selectEmitter'}, {id:'childDelay',type:'number',step:0.1,def:0}],
  'INTERLEAVE':     [{id:'secondType',type:'selectEmitter'}, {id:'pattern',type:'text',def:'0,1'}],
  'SALVO':          [{id:'salvoCount',type:'number',def:3}, {id:'salvoInterval',type:'number',step:0.01,def:0.08}],
  'MIRROR':         [{id:'mirrorOffset',type:'number',def:28}],
  'ROTATE_SWEEP':   [{id:'sweepSpeed',type:'number',step:0.1,def:1.2}, {id:'sweepArc',type:'number',step:0.1,def:1.2}],
  'DELAYED_WAVE':   [{id:'pauseDur',type:'number',step:0.05,def:0.35}],
  'WIDENING_FAN':   [{id:'maxSpread',type:'number',step:0.1,def:1.5}, {id:'steps',type:'number',def:4}],
  'SPIRAL_ARMS':    [{id:'arms',type:'number',def:3}, {id:'rotSpeed',type:'number',step:0.1,def:1.5}],
  'ALTERNATING':    [{id:'altOffset',type:'number',step:0.05,def:0.45}],
  'STACKED_RING':   [{id:'layers',type:'number',def:3}, {id:'layerInterval',type:'number',step:0.01,def:0.12}],
  'FOCUSED_SCATTER':[{id:'scatterCount',type:'number',def:7}, {id:'scatterSpread',type:'number',step:0.05,def:0.55}],
  'BOOMERANG_WRAP': [{id:'reverseAt',type:'number',step:0.1,def:0.55}],
  'ACCEL_WAVE':     [{id:'accelVal',type:'number',def:280}],
  'DOUBLE_HELIX':   [{id:'helixSpeed',type:'number',step:0.1,def:2.0}]
};

// 渲染指定 Slot 和 Layer 的配置面板
function renderWrapperConfigUI(slot, layer, wrapperName) {
  const divId = `forgeEm${slot}Comp${layer}Cfg`;
  const container = document.getElementById(divId);
  if(!container) return;
  container.innerHTML = '';
  
  const defs = WrapperFieldDefs[wrapperName];
  if(!defs) return;

  defs.forEach(def => {
    const row = document.createElement('div');
    row.className = 'field';
    row.style.marginBottom = '4px';
    
    const label = document.createElement('label');
    label.textContent = def.id.toUpperCase();
    label.style.fontSize = '9px';
    row.appendChild(label);

    let input;
    const inputId = `f_s${slot}_l${layer}_${def.id}`; // Generate unique ID

    if(def.type === 'select' || def.type === 'selectEmitter') {
      input = document.createElement('select');
      input.id = inputId;
      const opts = (def.type==='selectEmitter') 
        ? Object.keys(EmitterCatalog).filter(k=>k!=='LASER') 
        : def.opts;
      opts.forEach(v => {
        const o = document.createElement('option'); o.value=v; o.textContent=v; input.appendChild(o);
      });
    } else {
      input = document.createElement('input');
      input.id = inputId;
      input.type = (def.type==='number') ? 'number' : 'text';
      if(def.step) input.step = def.step;
      if(def.min!=null) input.min = def.min;
      if(def.max!=null) input.max = def.max;
      input.placeholder = def.def;
    }
    
    // 绑定事件：写入全局 ForgeState
    input.addEventListener('change', () => {
      // 确保路径存在
      if(!ForgeState[`slot${slot}`]) ForgeState[`slot${slot}`] = {};
      if(!ForgeState[`slot${slot}`][`layer${layer}Cfg`]) ForgeState[`slot${slot}`][`layer${layer}Cfg`] = {};
      
      // 写入值
      let val = input.value;
      if(def.type === 'number') val = parseFloat(val);
      if(def.id === 'pattern' && typeof val === 'string') val = val.split(',').map(Number);
      
      ForgeState[`slot${slot}`][`layer${layer}Cfg`][def.id] = val;
      saveForge();
    });

    row.appendChild(input);
    container.appendChild(row);
  });
}

// 初始化 Forge 扩展 UI 逻辑
// 代码位置：在脚本中替换原有的 initForgeExtendedUI 函数

function initForgeExtendedUI() {
  // 1. 填充 Wrapper Selectors (保持不变)
  const wrappers = Object.keys(CompositeWrappers);
  document.querySelectorAll('.comp-selector').forEach(sel => {
    sel.innerHTML = '<option value="">(NONE)</option>';
    wrappers.forEach(w => {
      const o = document.createElement('option'); o.value=w; o.textContent=w; sel.appendChild(o);
    });

    sel.addEventListener('change', (e) => {
      const slot = sel.dataset.slot;
      const layer = sel.dataset.layer;
      const val = sel.value;

      if(!ForgeState[`slot${slot}`]) ForgeState[`slot${slot}`] = {};
      ForgeState[`slot${slot}`][`layer${layer}`] = val;
      ForgeState[`slot${slot}`][`layer${layer}Cfg`] = {}; 

      renderWrapperConfigUI(slot, layer, val);
      saveForge();
      refreshForgePreview();
    });
  });

  // 2. 构建 Base Emitter Mods 选择器 (新逻辑)
  const buildEmitterModPicker = (slot) => {
    const container = document.getElementById(`forgeEm${slot}ModsContainer`);
    if (!container) return;
    container.innerHTML = '';

    // 获取所有可用 Mods，过滤掉内部使用的
    const allMods = Object.keys(BulletAffixCatalog).filter(k => 
      !BulletAffixCatalog[k].tags?.includes('_internal')
    );

    allMods.forEach(k => {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'pick-chip';
      btn.dataset.key = k;
      btn.textContent = k;
      // 稍微缩小一点字体以适应紧凑空间
      btn.style.fontSize = '9px'; 
      btn.style.padding = '2px 6px';

      btn.addEventListener('click', () => {
        // 确保 State 存在
        if(!ForgeState[`slot${slot}`]) ForgeState[`slot${slot}`] = {};
        if(!ForgeState[`slot${slot}`].baseMods) ForgeState[`slot${slot}`].baseMods = [];
        
        const list = ForgeState[`slot${slot}`].baseMods;
        const idx = list.indexOf(k);
        
        if (idx >= 0) {
          list.splice(idx, 1); // 移除
          btn.classList.remove('on');
        } else {
          if (list.length >= 6) return; // 限制数量防止溢出
          list.push(k); // 添加
          btn.classList.add('on');
        }
        
        saveForge();
        refreshForgePreview();
      });
      container.appendChild(btn);
    });
  };

  // 为 Slot 1 和 Slot 2 构建选择器
  buildEmitterModPicker(1);
  buildEmitterModPicker(2);
}


function ensureForgeExtraEmitters(){
  if (!Array.isArray(ForgeState.extraEmitters)) ForgeState.extraEmitters = [];
  if (!ForgeState.extraEmittersViewMode) ForgeState.extraEmittersViewMode = 'ui';
}

function summarizeSerializedEmitter(node){
  if (!node) return 'EMPTY';
  const wrappers = [];
  let cur = node;
  while (cur && cur.isWrapper){
    wrappers.push(cur.wrapperType || '?');
    cur = cur.inner || cur.innerA || cur.innerB;
  }
  const baseType = cur?.type || 'AIM';
  const mods = Array.isArray(cur?.mods) ? cur.mods : [];
  const modTxt = mods.length ? ` mods:${mods.join(',')}` : '';
  const wrapTxt = wrappers.length ? ` [${wrappers.join(' -> ')}]` : '';
  return `${baseType}${wrapTxt}${modTxt}`;
}

function normalizeSerializedEmitter(node){
  if (!node) return null;
  if (node.type && !node.isWrapper){
    return {
      isWrapper:false,
      type: node.type || 'AIM',
      mods: Array.isArray(node.mods) ? node.mods.slice(0, 24) : [],
      speed: Number.isFinite(+node.speed) ? +node.speed : 220,
      cd: Number.isFinite(+node.cd) ? +node.cd : 1.2
    };
  }
  if (node.isWrapper || node.wrapperType){
    const out = {
      isWrapper:true,
      wrapperType: node.wrapperType || node.type || '',
      compCfg: (node.compCfg && typeof node.compCfg==='object') ? deepClone(node.compCfg) : {}
    };
    if (out.wrapperType === 'INTERLEAVE'){
      out.innerA = normalizeSerializedEmitter(node.innerA || node.inner);
      out.innerB = normalizeSerializedEmitter(node.innerB || node.inner);
    } else {
      out.inner = normalizeSerializedEmitter(node.inner || node.innerA || node.innerB);
    }
    return out;
  }
  return null;
}

function getSerializedFromSlot(slotNum){
  const spec = buildEmitterSpecFromSlot(slotNum);
  if (!spec) return null;
  if (spec.type === '_COMPOSITE') return serializeEmitterRecursive(spec._compositeInstance);
  return normalizeSerializedEmitter({
    isWrapper:false,
    type: spec.type || 'AIM',
    mods: Array.isArray(spec.cfg?.mods) ? spec.cfg.mods : [],
    speed: spec.cfg?.speed ?? 220,
    cd: spec.cfg?.baseCd ?? 1.2
  });
}

function emitterToUiModel(node){
  const n = normalizeSerializedEmitter(node) || {isWrapper:false,type:'AIM',mods:[],speed:220,cd:1.2};
  const wrappers = [];
  let cur = n;
  while (cur && cur.isWrapper){
    wrappers.push({
      wrapperType: cur.wrapperType || '',
      compCfg: deepClone(cur.compCfg || {}),
      _warnInterleave: (cur.wrapperType === 'INTERLEAVE')
    });
    cur = cur.inner || cur.innerA || cur.innerB;
  }
  return {
    base: {
      type: cur?.type || 'AIM',
      cd: Number.isFinite(+cur?.cd) ? +cur.cd : 1.2,
      speed: Number.isFinite(+cur?.speed) ? +cur.speed : 220,
      mods: Array.isArray(cur?.mods) ? cur.mods.slice() : []
    },
    wrappers: wrappers.reverse() // inner -> outer
  };
}

function uiModelToEmitter(model){
  const base = {
    isWrapper:false,
    type: model?.base?.type || 'AIM',
    cd: Number.isFinite(+model?.base?.cd) ? +model.base.cd : 1.2,
    speed: Number.isFinite(+model?.base?.speed) ? +model.base.speed : 220,
    mods: Array.isArray(model?.base?.mods) ? model.base.mods.slice(0,24) : []
  };
  const ws = Array.isArray(model?.wrappers) ? model.wrappers : [];
  let cur = base;
  for (const w of ws){
    const wt = w?.wrapperType || '';
    if (!wt) continue;
    if (wt === 'INTERLEAVE'){
      cur = {
        isWrapper:true,
        wrapperType: wt,
        compCfg: deepClone(w?.compCfg || {}),
        innerA: cur,
        innerB: normalizeSerializedEmitter(w?.innerB) || deepClone(cur)
      };
    } else {
      cur = {
        isWrapper:true,
        wrapperType: wt,
        compCfg: deepClone(w?.compCfg || {}),
        inner: cur
      };
    }
  }
  return cur;
}

function renderWrapperCfgFieldsUI(container, item, wrapIdx, onChanged){
  const key = item.wrapperType || '';
  const defs = WrapperFieldDefs[key] || [];
  container.innerHTML = '';
  if (!key){
    const m = document.createElement('div');
    m.className = 'muted';
    m.textContent = '先选择 wrapper 类型';
    container.appendChild(m);
    return;
  }
  if (key==='INTERLEAVE'){
    const w = document.createElement('div');
    w.className = 'muted';
    w.textContent = 'INTERLEAVE 包含双分支，UI 模式仅编辑主分支。完整双分支请切到 JSON 模式。';
    container.appendChild(w);
  }
  if (!defs.length){
    const m = document.createElement('div');
    m.className = 'muted';
    m.textContent = '该 wrapper 无公开配置字段。';
    container.appendChild(m);
    return;
  }

  for (const def of defs){
    const row = document.createElement('div');
    row.className = 'field';
    row.style.marginBottom = '4px';

    const lb = document.createElement('label');
    lb.textContent = def.id;
    row.appendChild(lb);

    let input;
    if (def.type === 'select' || def.type === 'selectEmitter'){
      input = document.createElement('select');
      input.className = 'forge-extra-select';
      const opts = (def.type==='selectEmitter') ? Object.keys(EmitterCatalog).filter(k=>k!=='LASER') : (def.opts || []);
      for (const v of opts){
        const o = document.createElement('option');
        o.value = String(v);
        o.textContent = String(v);
        input.appendChild(o);
      }
      const cur = (item.compCfg?.[def.id] ?? def.def ?? (opts[0] ?? ''));
      input.value = String(cur);
      input.addEventListener('change', ()=>{
        if (!item.compCfg) item.compCfg = {};
        item.compCfg[def.id] = input.value;
        onChanged?.();
      });
    } else {
      input = document.createElement('input');
      if (def.type === 'number' || def.type === 'num' || def.type === 'int') input.type = 'number';
      else input.type = 'text';
      if ((def.type === 'number' || def.type === 'num') && def.step!=null) input.step = String(def.step);
      if (def.type === 'int') input.step = '1';
      if (def.min!=null) input.min = String(def.min);
      if (def.max!=null) input.max = String(def.max);
      let v = item.compCfg?.[def.id];
      if (v==null) v = def.def;
      input.value = (v==null) ? '' : String(v);
      input.addEventListener('change', ()=>{
        if (!item.compCfg) item.compCfg = {};
        if (def.id === 'pattern'){
          const arr = String(input.value||'').split(',').map(x=>+x.trim()).filter(n=>Number.isFinite(n));
          item.compCfg[def.id] = arr.length ? arr : [0,1];
        } else if (def.type === 'int') {
          item.compCfg[def.id] = (input.value==='') ? null : (parseInt(input.value,10)||0);
        } else if (def.type === 'number' || def.type === 'num') {
          item.compCfg[def.id] = (input.value==='') ? null : (+input.value||0);
        } else {
          item.compCfg[def.id] = input.value;
        }
        onChanged?.();
      });
    }

    row.appendChild(input);
    container.appendChild(row);
  }
}

function renderEmitterUiEditor(card, item, idx){
  const refreshAccHeight = ()=>{
    const body = card.closest('.acc-body');
    if (body && body.style.maxHeight && body.style.maxHeight !== '0px') body.style.maxHeight = body.scrollHeight + 'px';
  };
  const model = emitterToUiModel(item);

  const persist = ()=>{
    ForgeState.extraEmitters[idx] = uiModelToEmitter(model);
    saveForge();
  };

  const baseWrap = document.createElement('div');
  baseWrap.style.cssText = 'border:1px dashed rgba(255,255,255,0.2);padding:6px;margin-bottom:6px';
  baseWrap.innerHTML = '<div class="muted" style="margin-bottom:4px">BASE EMITTER</div>';

  const typeRow = document.createElement('div');
  typeRow.className = 'field';
  const typeLb = document.createElement('label');
  typeLb.textContent = 'TYPE';
  const typeSel = document.createElement('select');
  typeSel.className = 'forge-extra-select';
  Object.keys(EmitterCatalog).forEach(k=>{
    const op=document.createElement('option'); op.value=k; op.textContent=k; typeSel.appendChild(op);
  });
  typeSel.value = model.base.type;
  typeSel.addEventListener('change', ()=>{ model.base.type = typeSel.value; persist(); });
  typeRow.appendChild(typeLb); typeRow.appendChild(typeSel);

  const cdSp = document.createElement('div');
  cdSp.className = 'slider-row';
  const mkNum=(label,v,step,cb)=>{
    const f=document.createElement('div');f.className='field';
    const l=document.createElement('label');l.textContent=label;
    const i=document.createElement('input');i.type='number';i.step=step;i.value=String(v);
    i.addEventListener('change',()=>{ cb(+i.value||0); persist(); });
    f.appendChild(l);f.appendChild(i);return f;
  };
  cdSp.appendChild(mkNum('CD', model.base.cd, '0.01', v=>model.base.cd=v));
  cdSp.appendChild(mkNum('SPEED', model.base.speed, '1', v=>model.base.speed=v));

  const modsRow = document.createElement('div');
  modsRow.className = 'field';
  const modsLb = document.createElement('label'); modsLb.textContent = 'BASE MODS';
  const modsChips = document.createElement('div');
  modsChips.className = 'chip-pick';
  modsChips.style.maxHeight = '120px';
  modsChips.style.overflowY = 'auto';
  const selected = new Set(model.base.mods || []);
  Object.keys(BulletAffixCatalog).forEach(k=>{
    const btn = document.createElement('button');
    btn.type='button';
    btn.className='pick-chip';
    btn.textContent=k;
    btn.dataset.key=k;
    btn.classList.toggle('on', selected.has(k));
    btn.addEventListener('click', ()=>{
      if (selected.has(k)) selected.delete(k);
      else selected.add(k);
      model.base.mods = Array.from(selected).slice(0,24);
      btn.classList.toggle('on', selected.has(k));
      persist();
      refreshAccHeight();
    });
    modsChips.appendChild(btn);
  });
  modsRow.appendChild(modsLb);
  modsRow.appendChild(modsChips);

  baseWrap.appendChild(typeRow);
  baseWrap.appendChild(cdSp);
  baseWrap.appendChild(modsRow);
  card.appendChild(baseWrap);

  const wrappersWrap = document.createElement('div');
  wrappersWrap.className = 'forge-extra-wrap';
  wrappersWrap.innerHTML = '<div class="muted" style="margin-bottom:4px">WRAPPERS (INNER -> OUTER)</div>';
  const list = document.createElement('div');
  list.style.display='flex'; list.style.flexDirection='column'; list.style.gap='6px'; list.style.minWidth='0';

  const rerender = ()=>{
    list.innerHTML='';
    model.wrappers.forEach((w, wi)=>{
      const row = document.createElement('div');
      row.className='forge-extra-wrap-row';

      const top = document.createElement('div');
      top.className='forge-extra-wrap-top';
      const sel = document.createElement('select');
      sel.className = 'forge-extra-select';
      sel.style.minWidth = '0';
      sel.style.flex = '1 1 220px';
      const empty = document.createElement('option'); empty.value=''; empty.textContent='(NONE)'; sel.appendChild(empty);
      Object.keys(CompositeWrappers).forEach(k=>{ const op=document.createElement('option'); op.value=k; op.textContent=k; sel.appendChild(op); });
      sel.value = w.wrapperType || '';
      sel.addEventListener('change', ()=>{ w.wrapperType = sel.value; if(!w.compCfg) w.compCfg={}; persist(); rerender(); });

      const mkBtn=(txt,fn)=>{ const b=document.createElement('button'); b.className='mini-btn'; b.textContent=txt; b.addEventListener('click',fn); return b; };
      const up = mkBtn('↑', ()=>{ if (wi<=0) return; [model.wrappers[wi-1],model.wrappers[wi]]=[model.wrappers[wi],model.wrappers[wi-1]]; persist(); rerender(); });
      const dn = mkBtn('↓', ()=>{ if (wi>=model.wrappers.length-1) return; [model.wrappers[wi+1],model.wrappers[wi]]=[model.wrappers[wi],model.wrappers[wi+1]]; persist(); rerender(); });
      const del = mkBtn('REMOVE', ()=>{ model.wrappers.splice(wi,1); persist(); rerender(); });
      const act = document.createElement('div'); act.className='forge-extra-wrap-actions';
      act.appendChild(up); act.appendChild(dn); act.appendChild(del);
      top.appendChild(sel); top.appendChild(act);

      const cfgBox = document.createElement('div');
      cfgBox.style.marginTop='6px';
      renderWrapperCfgFieldsUI(cfgBox, w, wi, persist);

      row.appendChild(top);
      row.appendChild(cfgBox);
      list.appendChild(row);
    });
  };

  rerender();
  refreshAccHeight();
  const addW = document.createElement('button');
  addW.className='mini-btn'; addW.textContent='ADD WRAPPER';
  addW.addEventListener('click', ()=>{ model.wrappers.push({wrapperType:'', compCfg:{}}); persist(); rerender(); refreshAccHeight(); });

  wrappersWrap.appendChild(list);
  wrappersWrap.appendChild(addW);
  card.appendChild(wrappersWrap);
}

function renderForgeExtraEmittersUI(){
  ensureForgeExtraEmitters();
  const root = document.getElementById('forgeExtraEmittersList');
  const modeBtn = document.getElementById('btnForgeExtraMode');
  if (!root) return;
  if (modeBtn){
    modeBtn.textContent = `VIEW: ${ForgeState.extraEmittersViewMode==='json' ? 'JSON' : 'UI'}`;
  }
  root.innerHTML = '';

  if (!ForgeState.extraEmitters.length){
    const empty = document.createElement('div');
    empty.className = 'muted';
    empty.textContent = '暂无额外 emitter。可无限添加。';
    root.appendChild(empty);
    return;
  }

  ForgeState.extraEmitters.forEach((item, idx)=>{
    const card = document.createElement('div');
    card.className = 'forge-extra-card';
    card.style.cssText = 'border:1px solid rgba(255,255,255,0.15);background:rgba(0,0,0,0.22);padding:8px';

    const title = document.createElement('div');
    title.className = 'forge-extra-title';
    title.innerHTML = `<div class="mono forge-extra-title-text" style="font-size:12px">EXTRA #${idx+1} · ${summarizeSerializedEmitter(item)}</div>`;

    const btns = document.createElement('div');
    btns.style.cssText = 'display:flex;gap:6px';
    const btnDel = document.createElement('button');
    btnDel.className = 'mini-btn';
    btnDel.textContent = 'REMOVE';
    btns.appendChild(btnDel);
    title.appendChild(btns);

    btnDel.addEventListener('click', ()=>{
      ForgeState.extraEmitters.splice(idx,1);
      saveForge();
      syncForgeUIFromState();
    });

    card.appendChild(title);

    if (ForgeState.extraEmittersViewMode === 'json'){
      const ta = document.createElement('textarea');
      ta.style.cssText = 'width:100%;min-height:120px;background:rgba(0,0,0,0.4);color:#9deeff;border:1px solid rgba(157,238,255,0.35);font-family:monospace;font-size:11px';
      ta.value = JSON.stringify(item, null, 2);
      const btnSave = document.createElement('button');
      btnSave.className = 'mini-btn';
      btnSave.textContent = 'APPLY JSON';
      btnSave.style.marginTop = '6px';
      btnSave.addEventListener('click', ()=>{
        try{
          const parsed = JSON.parse(ta.value || '{}');
          const norm = normalizeSerializedEmitter(parsed);
          if (!norm) throw new Error('invalid emitter json');
          ForgeState.extraEmitters[idx] = norm;
          saveForge();
          syncForgeUIFromState();
          textPop(W*0.5, 90, `EXTRA #${idx+1} UPDATED`, C.P1);
        }catch(err){
          alert('Emitter JSON 无效：' + (err?.message || err));
        }
      });
      card.appendChild(ta);
      card.appendChild(btnSave);
    } else {
      renderEmitterUiEditor(card, item, idx);
    }

    root.appendChild(card);
  });
}

function wireForgeExtraEmitterButtons(){
  const addBase = document.getElementById('btnForgeExtraAdd');
  const add1 = document.getElementById('btnForgeExtraAddFrom1');
  const add2 = document.getElementById('btnForgeExtraAddFrom2');
  const mode = document.getElementById('btnForgeExtraMode');
  const push = (data)=>{
    ensureForgeExtraEmitters();
    const norm = normalizeSerializedEmitter(data || {isWrapper:false,type:'AIM',mods:[],speed:220,cd:1.2});
    if (!norm) return;
    ForgeState.extraEmitters.push(norm);
    saveForge();
    syncForgeUIFromState();
  };
  addBase?.addEventListener('click', ()=>push({isWrapper:false,type:'AIM',mods:[...(ForgeState.mods||[])],speed:220,cd:1.2}));
  add1?.addEventListener('click', ()=>push(getSerializedFromSlot(1)));
  add2?.addEventListener('click', ()=>push(getSerializedFromSlot(2)));
  mode?.addEventListener('click', ()=>{
    ensureForgeExtraEmitters();
    ForgeState.extraEmittersViewMode = ForgeState.extraEmittersViewMode === 'json' ? 'ui' : 'json';
    saveForge();
    syncForgeUIFromState();
  });
}

function restoreWrapperUI(slot, layer) {
  const wrapperName = ForgeState[`slot${slot}`]?.[`layer${layer}`] || '';
  const sel = document.getElementById(`forgeEm${slot}Comp${layer}`);
  if(sel) {
    sel.value = wrapperName;
    renderWrapperConfigUI(slot, layer, wrapperName); // 渲染字段
  }
  
  // 填值
  const cfg = ForgeState[`slot${slot}`]?.[`layer${layer}Cfg`] || {};
  const defs = WrapperFieldDefs[wrapperName] || [];
  defs.forEach(def => {
    const input = document.getElementById(`f_s${slot}_l${layer}_${def.id}`);
    if(input) {
      let val = cfg[def.id];
      if(val == null) val = def.def; // 默认值
      input.value = val;
    }
  });
}

// 代码位置：在脚本中替换原有的 syncForgeUIFromState 函数

function syncForgeUIFromState() {
  // --- 基础同步 ---
  document.getElementById('forgeBoss').value = ForgeState.isBoss ? '1':'0';
 
  document.getElementById('forgeCol').value  = ForgeState.col;
  document.getElementById('forgeHp').value   = ForgeState.hp;
  
  // --- Emitter 1 Base ---
  if(ForgeState.em1) {
    document.getElementById('forgeEm1Type').value  = ForgeState.em1.type;
    document.getElementById('forgeEm1Cd').value    = ForgeState.em1.cd;
    document.getElementById('forgeEm1Speed').value = ForgeState.em1.speed;
  }
  // --- Emitter 2 Base ---
  if(ForgeState.em2) {
    document.getElementById('forgeEm2Type').value  = ForgeState.em2.type;
    document.getElementById('forgeEm2Cd').value    = ForgeState.em2.cd;
    document.getElementById('forgeEm2Speed').value = ForgeState.em2.speed;
  }

  // --- 同步 Wrappers 配置 ---
  restoreWrapperUI(1, 1);
  restoreWrapperUI(1, 2);
  restoreWrapperUI(2, 1);
  restoreWrapperUI(2, 2);

  // --- 新增：同步 Emitter Mods Chips 状态 ---
  const updateChips = (slot) => {
    const container = document.getElementById(`forgeEm${slot}ModsContainer`);
    if (!container) return;
    const mods = new Set(ForgeState[`slot${slot}`]?.baseMods || []);
    
    container.querySelectorAll('.pick-chip').forEach(btn => {
      const k = btn.dataset.key;
      if (mods.has(k)) btn.classList.add('on');
      else btn.classList.remove('on');
    });
  };
  
  updateChips(1);
  updateChips(2);

  // --- Body options ---
  document.getElementById('forgeBodyKind').value = ForgeState.bodyKind || 'AUTO';
  document.getElementById('forgeBodySeed').value = ForgeState.bodySeed || 1337;
  document.getElementById('forgeBodyScale').value = ForgeState.bodyScale || 1.0;
  
  // --- Global Traits/Mods Chips ---
  MenuUI.forgeMods = new Set(ForgeState.mods||[]);
  MenuUI.forgeTraits = new Set(ForgeState.traits||[]);
  document.querySelectorAll('#forgeModChips .pick-chip').forEach(b=>b.classList.toggle('on', MenuUI.forgeMods.has(b.dataset.key)));
  document.querySelectorAll('#forgeTraitChips .pick-chip').forEach(b=>b.classList.toggle('on', MenuUI.forgeTraits.has(b.dataset.key)));
if (!Array.isArray(ForgeState.moveKeys)) ForgeState.moveKeys = [ForgeState.moveKey || 'DRIFT'];
const moveSet = new Set(ForgeState.moveKeys);
document.querySelectorAll('#forgeMoveChips .pick-chip').forEach(btn => {
  btn.classList.toggle('on', moveSet.has(btn.dataset.key));
});
  renderForgeExtraEmittersUI();
  refreshForgePreview();
}

// 辅助：从 Slot State 构建 Emitter Spec
function buildEmitterSpecFromSlot(slotNum) {
  // Base
  const baseData = (slotNum===1) ? ForgeState.em1 : ForgeState.em2;
  const slotState = ForgeState[`slot${slotNum}`] || {};
  
  let currentCfg = {
    baseCd: baseData.cd,
    speed: baseData.speed,
    col: ForgeState.col,
    mods: slotState.baseMods || [] // Emitter-specific mods
  };
  
  // 基础类型
  const baseFactory = EmitterCatalog[baseData.type];
  if (!baseFactory) return null; // Should not happen

  // 构建链： Layer 2(Outer) -> Layer 1(Inner) -> Base
  // 但是代码结构是：Wrapper(Factory, Cfg)
  // 所以构造顺序是：
  // 1. Factory = BaseFactory
  // 2. 如果有 Layer 1: Factory = Wrapper1(Factory, Layer1Cfg)
  // 3. 如果有 Layer 2: Factory = Wrapper2(Factory, Layer2Cfg)
  
  // 需要返回 { type, cfg, _compositeInstance } 结构

  let finalFactory = baseFactory;
  let finalCfg = currentCfg;
  
  // Layer 1 (Inner)
  const l1Key = slotState.layer1;
  if (l1Key && CompositeWrappers[l1Key]) {
    const l1Cfg = Object.assign({}, slotState.layer1Cfg || {}, { baseCfg: finalCfg });
    // Handle special factories (INTERLEAVE)
    if(l1Key==='INTERLEAVE' && l1Cfg.secondType) l1Cfg.factoryB = EmitterCatalog[l1Cfg.secondType];
    
    const innerFactory = finalFactory; // snap current
    const innerCfg = finalCfg;         // snap current
    
    finalFactory = (overrideCfg) => CompositeWrappers[l1Key](innerFactory, Object.assign({}, l1Cfg, overrideCfg));
    finalCfg = {}; // Wrapped config is usually consumed
  }
  
  // Layer 2 (Outer)
  const l2Key = slotState.layer2;
  if (l2Key && CompositeWrappers[l2Key]) {
    const l2Cfg = Object.assign({}, slotState.layer2Cfg || {}, { baseCfg: {} }); // Outer wrapper baseCfg usually empty as it calls inner
    if(l2Key==='INTERLEAVE' && l2Cfg.secondType) l2Cfg.factoryB = EmitterCatalog[l2Cfg.secondType];

    const innerFactory = finalFactory;
    finalFactory = (overrideCfg) => CompositeWrappers[l2Key](innerFactory, Object.assign({}, l2Cfg, overrideCfg));
  }
  
  // 如果没有任何 Wrapper
  if (!l1Key && !l2Key) {
    return { type: baseData.type, cfg: finalCfg };
  }
  
  // 如果有 Wrapper，实例化
  try {
    const instance = finalFactory({});
    return { type: '_COMPOSITE', _compositeInstance: instance, cfg: currentCfg };
  } catch(e) {
    console.error("Emitter Build Fail", e);
    return { type: 'AIM', cfg: {} }; // fallback
  }
}

function hookForgeInputs(){
  const ids = [
    'forgeBoss','forgeMove','forgeCol','forgeHp',
    'forgeEm1Type','forgeEm1Cd','forgeEm1Speed',
    'forgeEm2Type','forgeEm2Cd','forgeEm2Speed',
    'forgeBodyKind','forgeBodySeed','forgeBodyScale',

    // appearance (new)
    'forgeBaseN','forgeInnerN','forgeRing','forgeSpokes',
    'forgeStarInner','forgeTeeth','forgeToothDepth',
    'forgeRR','forgeDiaSkew',
    'forgeArcSegs','forgeArcSpan','forgeArcGap',
    
    'forgeEm1Composite','forgeEm2Composite',
  ];

  const readNum = (id)=>{
    const v = document.getElementById(id)?.value;
    if (v==null || v==='') return null;
    const n = +v;
    return Number.isFinite(n) ? n : null;
  };
  const readInt = (id)=>{
    const n = readNum(id);
    return (n==null) ? null : (n|0);
  };

  const onAny = ()=>{
    ForgeState.isBoss = document.getElementById('forgeBoss')?.value==='1'
    ForgeState.col = document.getElementById('forgeCol')?.value || C.E2;
    ForgeState.hp = +document.getElementById('forgeHp')?.value || 900;

    ForgeState.em1.type = document.getElementById('forgeEm1Type')?.value || 'AIM';
    ForgeState.em1.cd = +document.getElementById('forgeEm1Cd')?.value || 1.2;
    ForgeState.em1.speed = +document.getElementById('forgeEm1Speed')?.value || 220;

    ForgeState.em2.type = document.getElementById('forgeEm2Type')?.value || 'RING';
    ForgeState.em2.cd = +document.getElementById('forgeEm2Cd')?.value || 2.2;
    ForgeState.em2.speed = +document.getElementById('forgeEm2Speed')?.value || 180;

    ForgeState.bodyKind = document.getElementById('forgeBodyKind')?.value || 'AUTO';
    ForgeState.bodySeed = ((+document.getElementById('forgeBodySeed')?.value)||1337)|0;
    ForgeState.bodyScale = clamp(+document.getElementById('forgeBodyScale')?.value || 1, 0.6, 2.2);

    // appearance -> ForgeState.bodyOpt
    ForgeState.bodyOpt = ForgeState.bodyOpt || {};
    ForgeState.bodyOpt.baseN = readInt('forgeBaseN');
    ForgeState.bodyOpt.innerN = readInt('forgeInnerN');

    const ringSel = document.getElementById('forgeRing')?.value ?? '';
    ForgeState.bodyOpt.ring = (ringSel==='') ? null : (ringSel==='1');

    ForgeState.bodyOpt.spokes = readInt('forgeSpokes');

    ForgeState.bodyOpt.starInner = readNum('forgeStarInner');
    ForgeState.bodyOpt.teeth = readInt('forgeTeeth');
    ForgeState.bodyOpt.toothDepth = readNum('forgeToothDepth');

    ForgeState.bodyOpt.rr = readNum('forgeRR');
    ForgeState.bodyOpt.diaSkew = readNum('forgeDiaSkew');

    ForgeState.bodyOpt.arcSegs = readInt('forgeArcSegs');
    ForgeState.bodyOpt.arcSpan = readNum('forgeArcSpan');
    ForgeState.bodyOpt.arcGap  = readNum('forgeArcGap');

    saveForge();
    refreshForgePreview();
  };

  for(const id of ids){
    const el = document.getElementById(id);
    if (!el) continue;
    el.addEventListener('input', onAny);
    el.addEventListener('change', onAny);
  }
  if (!ForgeState.em1Composite) ForgeState.em1Composite = '';
  if (!ForgeState.em2Composite) ForgeState.em2Composite = '';
  if (!ForgeState.em1CompositeCfg) ForgeState.em1CompositeCfg = {};
  if (!ForgeState.em2CompositeCfg) ForgeState.em2CompositeCfg = {};

  // 填充 CHILD_BURST / INTERLEAVE 的 emitter type 下拉（这些 select 是静态 DOM，只需填充 options）
  function _fillEmitterOptions(selId){
    const sel = document.getElementById(selId);
    if (!sel || sel.children.length > 0) return;
    for(const k of Object.keys(EmitterCatalog)){
      if (k === 'LASER') continue;
      const o = document.createElement('option');
      o.value = k; o.textContent = k;
      sel.appendChild(o);
    }
  }
  _fillEmitterOptions('forgeEm1Comp_childType');
  _fillEmitterOptions('forgeEm1Comp_secondType');
  _fillEmitterOptions('forgeEm2Comp_childType');
  _fillEmitterOptions('forgeEm2Comp_secondType');

  // 显示/隐藏对应 wrapper 的配置字段
  function _showCompFields(containerId, wrapperKey){
    const cont = document.getElementById(containerId);
    if (!cont) return;
    for(const field of cont.querySelectorAll('.field[data-comp]')){
      field.style.display = (field.dataset.comp === wrapperKey) ? '' : 'none';
    }
  }

  // 从 DOM 读取 composite 配置写入 ForgeState
  function _readCompCfg(prefix, stateKey){
    const v = (sfx) => document.getElementById(`${prefix}_${sfx}`)?.value ?? null;
    const wKey = ForgeState[stateKey.replace('CompositeCfg','Composite')] || '';
    const cfg = {};

    if (wKey === 'MULTI_DIR'){
      cfg.dirs = clamp(+(v('dirs'))||3, 2, 6);
      cfg.spreadMode = v('spreadMode') || 'even';
    } else if (wKey === 'CHILD_BURST'){
      cfg.childType = v('childType') || 'RING';
      cfg.childDelay = clamp(+(v('childDelay'))||0, 0, 2);
    } else if (wKey === 'INTERLEAVE'){
      cfg.secondType = v('secondType') || 'RING';
      const ps = (v('pattern')||'0,1').split(',').map(s => clamp(+s.trim()||0, 0, 1));
      cfg.pattern = ps.length ? ps : [0,1];
    } else if (wKey === 'SALVO'){
      cfg.salvoCount = clamp(+(v('salvoCount'))||3, 2, 5);
      cfg.salvoInterval = clamp(+(v('salvoInterval'))||0.08, 0.03, 0.3);
    } else if (wKey === 'MIRROR'){
      cfg.mirrorOffset = clamp(+(v('mirrorOffset'))||28, 10, 80);
    } else if (wKey === 'ROTATE_SWEEP'){
      cfg.sweepSpeed = clamp(+(v('sweepSpeed'))||1.2, 0.3, 3);
      cfg.sweepArc = clamp(+(v('sweepArc'))||1.2, 0.2, Math.PI);
    } else if (wKey === 'DELAYED_WAVE'){
      cfg.pauseDur = clamp(+(v('pauseDur'))||0.35, 0.1, 1.0);
    } else if (wKey === 'WIDENING_FAN'){
      cfg.maxSpread = clamp(+(v('maxSpread'))||1.5, 0.3, Math.PI);
      cfg.steps = clamp(+(v('steps'))||4, 2, 8);
    }
    else if (wKey === 'SPIRAL_ARMS'){
      cfg.arms = clamp(+(v('arms'))||3, 2, 6);
      cfg.rotSpeed = clamp(+(v('rotSpeed'))||1.5, 0.3, 4);
    }
    else if (wKey === 'ALTERNATING'){
      cfg.altOffset = clamp(+(v('altOffset'))||0.45, 0.1, 1.5);
    }
    else if (wKey === 'STACKED_RING'){
      cfg.layers = clamp(+(v('layers'))||3, 2, 5);
      cfg.layerInterval = clamp(+(v('layerInterval'))||0.12, 0.04, 0.3);
    }
    else if (wKey === 'FOCUSED_SCATTER'){
      cfg.scatterCount = clamp(+(v('scatterCount'))||7, 3, 12);
      cfg.scatterSpread = clamp(+(v('scatterSpread'))||0.55, 0.15, 1.2);
    }
    else if (wKey === 'BOOMERANG_WRAP'){
      cfg.reverseAt = clamp(+(v('reverseAt'))||0.55, 0.2, 5);
    }
    else if (wKey === 'ACCEL_WAVE'){
      cfg.accelVal = clamp(+(v('accelVal'))||280, 80, 500);
    }
    else if (wKey === 'DOUBLE_HELIX'){
      cfg.helixSpeed = clamp(+(v('helixSpeed'))||2.0, 0.5, 4);
    }

    ForgeState[stateKey] = cfg;
    saveForge();
  }

  // 从 ForgeState 回填 DOM
  function _pushCompCfg(prefix, stateKey){
    const cfg = ForgeState[stateKey] || {};
    const set = (sfx, val) => {
      const el = document.getElementById(`${prefix}_${sfx}`);
      if (el && val != null) el.value = val;
    };
    set('dirs', cfg.dirs);
    set('spreadMode', cfg.spreadMode);
    set('childType', cfg.childType);
    set('childDelay', cfg.childDelay);
    set('secondType', cfg.secondType);
    set('pattern', Array.isArray(cfg.pattern) ? cfg.pattern.join(',') : cfg.pattern);
    set('salvoCount', cfg.salvoCount);
    set('salvoInterval', cfg.salvoInterval);
    set('mirrorOffset', cfg.mirrorOffset);
    set('sweepSpeed', cfg.sweepSpeed);
    set('sweepArc', cfg.sweepArc);
    set('pauseDur', cfg.pauseDur);
    set('maxSpread', cfg.maxSpread);
    set('steps', cfg.steps);
    set('arms', cfg.arms);
    set('rotSpeed', cfg.rotSpeed);
    set('altOffset', cfg.altOffset);
    set('layers', cfg.layers);
    set('layerInterval', cfg.layerInterval);
    set('scatterCount', cfg.scatterCount);
    set('scatterSpread', cfg.scatterSpread);
    set('reverseAt', cfg.reverseAt);
    set('accelVal', cfg.accelVal);
    set('helixSpeed', cfg.helixSpeed);
  }

  // 绑定 EM1 composite select
  const _cs1 = document.getElementById('forgeEm1Composite');
  if (_cs1){
    _cs1.value = ForgeState.em1Composite || '';
    const onCh1 = () => {
      ForgeState.em1Composite = _cs1.value || '';
      _showCompFields('forgeEm1CompCfg', ForgeState.em1Composite);
      _pushCompCfg('forgeEm1Comp', 'em1CompositeCfg');
      saveForge();
    };
    _cs1.addEventListener('change', onCh1);
    onCh1();
  }

  // 绑定 EM2 composite select
  const _cs2 = document.getElementById('forgeEm2Composite');
  if (_cs2){
    _cs2.value = ForgeState.em2Composite || '';
    const onCh2 = () => {
      ForgeState.em2Composite = _cs2.value || '';
      _showCompFields('forgeEm2CompCfg', ForgeState.em2Composite);
      _pushCompCfg('forgeEm2Comp', 'em2CompositeCfg');
      saveForge();
    };
    _cs2.addEventListener('change', onCh2);
    onCh2();
  }

  // 绑定所有 composite 配置输入的变化事件
  for(const prefix of ['forgeEm1Comp','forgeEm2Comp']){
    const stateKey = prefix === 'forgeEm1Comp' ? 'em1CompositeCfg' : 'em2CompositeCfg';
    const cont = document.getElementById(prefix === 'forgeEm1Comp' ? 'forgeEm1CompCfg' : 'forgeEm2CompCfg');
    if (!cont) continue;
    for(const inp of cont.querySelectorAll('input,select')){
      inp.addEventListener('input', () => _readCompCfg(prefix, stateKey));
      inp.addEventListener('change', () => _readCompCfg(prefix, stateKey));
    }
  }
  
}



function placeForgePreview(){
  const menuMain = document.querySelector('#menu .menu-main');
  const side = document.querySelector('#menu .side');
  const forgePage = document.getElementById('pageForge');

  const topWrap  = document.getElementById('forgePreviewTopWrap');
  const sideWrap = document.getElementById('forgePreviewSideWrap');

  const isForge = (document.body.dataset.menupage === 'forge');
  const desktop = matchMedia('(min-width: 901px)').matches;

  // PC 强制两列，避免被旧 CSS 压成 1 列导致 side 掉到底部
  if (menuMain){
    if (isForge && desktop){
      menuMain.style.display = 'grid';
      menuMain.style.gridTemplateColumns = 'minmax(0,1fr) minmax(0,0.88fr)';
      menuMain.style.gap = '14px';
      menuMain.style.alignItems = 'start';
    } else {
      menuMain.style.display = '';
      menuMain.style.gridTemplateColumns = '';
      menuMain.style.gap = '';
      menuMain.style.alignItems = '';
    }
  }

  // 显示/隐藏
  if (topWrap)  topWrap.style.display  = (isForge && !desktop) ? 'block' : 'none';
  if (sideWrap) sideWrap.style.display = (isForge && desktop) ? 'block' : 'none';
  if (side) side.style.display = (isForge && desktop) ? 'block' : '';

  // 关键：确保 sideWrap 真正在右侧 side 里（否则右侧空白，preview 跑到底部）
  if (isForge && desktop && side && sideWrap && sideWrap.parentElement !== side){
    side.prepend(sideWrap);
  }
  if (isForge && !desktop && forgePage && topWrap && topWrap.parentElement !== forgePage){
    forgePage.prepend(topWrap);
  }
}


function refreshForgePreview(){
  if (document.body.dataset.menupage !== 'forge') return;

  const desktop = matchMedia('(min-width: 901px)').matches;
  const canvas = (desktop ? document.getElementById('forgePreviewSide') : document.getElementById('forgePreviewTop'))
              || document.getElementById('forgePreviewSide')
              || document.getElementById('forgePreviewTop');
  if (!canvas) return;

  const ctx = canvas.getContext('2d');
  const Wp = canvas.width, Hp = canvas.height;

  // 1. 背景 (调亮，增加科技感蓝调)
  ctx.clearRect(0,0,Wp,Hp);
  const g = ctx.createRadialGradient(Wp*0.5, Hp*0.55, 0, Wp*0.5, Hp*0.55, Hp);
  g.addColorStop(0,'rgba(255,255,255,0.08)');
  g.addColorStop(1,'rgba(12,16,24,0.88)');
  ctx.fillStyle=g; ctx.fillRect(0,0,Wp,Hp);

  // 2. 读取参数
  const col  = document.getElementById('forgeCol')?.value || C.E2;
  const kindSel = document.getElementById('forgeBodyKind')?.value || 'AUTO';
  const seed = ((+document.getElementById('forgeBodySeed')?.value) || 1337)|0;
  const scale = clamp(+document.getElementById('forgeBodyScale')?.value || 1, 0.6, 2.2);

  // 3. 生成 Body 数据
  let body = genEnemyBody(seed);
  // 应用手动覆盖参数
  if (typeof applyBodyOverrides === 'function') applyBodyOverrides(body, ForgeState.bodyOpt);
  
  const kind = (kindSel === 'AUTO') ? (body.kind || 'poly') : kindSel;
  body.kind = kind;
  // 如果手动选择了这几种，覆盖 body 参数以匹配几何逻辑
  if (kind === 'spiral') body.spokes = body.spokes || 3;
  if (kind === 'lotus') body.innerN = body.innerN || 6;
  if (kind === 'phoenix') body.baseN = body.baseN || 3;

  const cx = Wp*0.5, cy = Hp*0.52; // 稍微上移一点视觉中心
  const R  = 44 * scale * (body.scale1 || 1);
  const rot = (performance.now()/1000) * (body.rot1 || 1);

  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  const previewEnemy = {x:cx, y:cy, r:Math.max(8, R-10), body, bodySeed:seed, tint:col, baseCol:col, hit:0, shieldHP:0};
  drawEnemyGenericBody(ctx, previewEnemy, body, col, R, rot, performance.now()/1000);

  ctx.restore();
}

// 绑定 forge 输入变化 -> 刷新预览（覆盖旧绑定：用 oninput/onchange）
function bindForgePreviewFinal(){
  const ids = ['forgeCol','forgeBodyKind','forgeBodySeed','forgeBodyScale'];
  ids.forEach(id=>{
    const el = document.getElementById(id);
    if (!el) return;
    el.oninput = ()=>refreshForgePreview();
    el.onchange = ()=>refreshForgePreview();
  });
  window.addEventListener('resize', ()=>{
    placeForgePreview();
    refreshForgePreview();
  });
}

/* I/O Drawer */
function openIO(){ document.getElementById('ioDrawer').classList.add('open'); }
function closeIO(){ document.getElementById('ioDrawer').classList.remove('open'); }
function setIOText(s){ document.getElementById('ioText').value = s; }
function getIOText(){ return document.getElementById('ioText').value || ''; }

function exportBuildsJSON(){ return JSON.stringify({version:1,type:'builds',builds:Builds}, null, 2); }
function importBuildsJSON(str){
  const obj=JSON.parse(str);
  if (obj?.type!=='builds') throw new Error('Not builds JSON');
  Builds.A = clampBuild(obj.builds?.A || Builds.A);
  Builds.B = clampBuild(obj.builds?.B || Builds.B);
  saveBuilds();
  syncWorkshopFromModel();
}
function exportForgeJSON(){
  const forgeOut = Object.assign({}, ForgeState);
  const emitters = [
    serializeEmitterRecursive(buildEmitterSpecFromSlot(1)?._compositeInstance || EmitterCatalog[ForgeState.em1?.type||'AIM']?.({baseCd:ForgeState.em1?.cd||1.2,speed:ForgeState.em1?.speed||220,mods:ForgeState.slot1?.baseMods||[]})),
    serializeEmitterRecursive(buildEmitterSpecFromSlot(2)?._compositeInstance || EmitterCatalog[ForgeState.em2?.type||'RING']?.({baseCd:ForgeState.em2?.cd||2.2,speed:ForgeState.em2?.speed||180,mods:ForgeState.slot2?.baseMods||[]})),
    ...((ForgeState.extraEmitters||[]).map(it => it?.isWrapper || it?.wrapperType || it?.type ? deepClone(it) : serializeEmitterRecursive(it)))
  ].filter(Boolean);
  forgeOut.emitters = emitters;
  forgeOut.slot1 = emitters[0] || null;
  forgeOut.slot2 = emitters[1] || null;
  return JSON.stringify({version:1,type:'forge',forge:forgeOut}, null, 2);
}
// 代码位置：替换旧的 importForgeJSON 函数
function importForgeJSON(str) {
  let obj;
  try { obj = JSON.parse(str); } catch(e){ alert('Invalid JSON'); return; }
  
  const data = obj.forge || obj;
  
  // 基础属性
  ForgeState.isBoss = !!data.isBoss;
  ForgeState.hp = data.hp || 900;
  ForgeState.col = data.col || 'rgb(255,77,109)';

  // --- 核心修正：兼容 moveKeys 和 moveKey ---
  if (Array.isArray(data.moveKeys) && data.moveKeys.length > 0) {
    ForgeState.moveKeys = data.moveKeys;
  } else {
    // 为旧格式或不规范数据提供后备
    ForgeState.moveKeys = [data.moveKey || 'DRIFT'];
  }
  // 确保旧的 moveKey 属性也同步
  ForgeState.moveKey = ForgeState.moveKeys[0];

  ForgeState.mods = data.mods || [];
  ForgeState.traits = data.traits || [];
  ForgeState.bodyKind = data.bodyKind || 'AUTO';
  ForgeState.bodySeed = data.bodySeed || 1337;
  ForgeState.bodyScale = data.bodyScale || 1.0;
  ForgeState.bodyOpt = data.bodyOpt || {};

  // 重置 Emitter State
  ForgeState.slot1 = { layer1:'', layer2:'', layer1Cfg:{}, layer2Cfg:{}, baseMods:[] };
  ForgeState.slot2 = { layer1:'', layer2:'', layer1Cfg:{}, layer2Cfg:{}, baseMods:[] };
  ForgeState.extraEmitters = [];
  ForgeState.em1 = { type:'AIM', cd:1.2, speed:220 };
  ForgeState.em2 = { type:'RING', cd:2.2, speed:180 };

  const emittersIn = Array.isArray(data.emitters) ? data.emitters : [data.slot1, data.slot2].filter(Boolean);
  const first = emittersIn[0] || data.slot1 || null;
  const second = emittersIn[1] || data.slot2 || null;

  // 兼容 UI 的双层 wrapper 展示（超过两层仍完整保存在 extraEmitters/emittersIn）
  const parseSlot = (srcSlotData, targetSlotNum) => {
    if (!srcSlotData) return;
    const emState = (targetSlotNum===1) ? ForgeState.em1 : ForgeState.em2;
    const slotState = ForgeState[`slot${targetSlotNum}`];
    let current = srcSlotData;
    const layersFound = [];
    while (current && current.isWrapper) {
      layersFound.push({ type: current.wrapperType, cfg: current.compCfg });
      current = current.inner || current.innerA || current.innerB;
    }
    if (current) {
      emState.type = current.type || 'AIM';
      emState.cd = current.cd || 1.0;
      emState.speed = current.speed || 200;
      slotState.baseMods = current.mods || [];
    }
    if (layersFound.length > 0) {
      slotState.layer2 = layersFound[0].type;
      slotState.layer2Cfg = layersFound[0].cfg;
    }
    if (layersFound.length > 1) {
      slotState.layer1 = layersFound[1].type;
      slotState.layer1Cfg = layersFound[1].cfg;
    }
  };

  if (first) parseSlot(first, 1);
  if (second) parseSlot(second, 2);

  const extraSerialized = emittersIn.slice(2).filter(Boolean);
  ForgeState.extraEmitters = extraSerialized.map(it=>deepClone(it));
  saveForge();
  syncForgeUIFromState();
}
function downloadText(filename, text){
  const blob = new Blob([text], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href=url; a.download=filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 500);
}

/* Forge -> startRun 需要的结构（兼容你第一次补丁的 lab/forge 逻辑） */
function readForgeSpecFromUI() {
  // 确保 moveKeys 是数组
  if (!Array.isArray(ForgeState.moveKeys) || ForgeState.moveKeys.length === 0) {
    ForgeState.moveKeys = [ForgeState.moveKey || 'DRIFT'];
  }

  return {
    isBoss: ForgeState.isBoss,
    hp: ForgeState.hp,
    traits: ForgeState.traits || [],
    spec: {
      // 核心改动：传递 moveKeys 数组
      moveKeys: ForgeState.moveKeys, 
      // 为了兼容旧的 spawnEnemyCoreFromSpecs，仍然保留 moveKey
      moveKey: ForgeState.moveKeys[0], 
      baseCol: ForgeState.col,
      tint: null,
      bodyKind: ForgeState.bodyKind,
      bodySeed: ForgeState.bodySeed,
      bodyScale: ForgeState.bodyScale,
      bodyOpt: deepClone(ForgeState.bodyOpt || {}),
      emitters: [
        buildEmitterSpecFromSlot(1),
        buildEmitterSpecFromSlot(2),
        ...((ForgeState.extraEmitters||[]).map(buildEmitterSpecFromSerialized))
      ].filter(e=>e),
      waveBulletMods: ForgeState.mods || []
    }
  };
}

function resetForgeStateAndUI(){
  // 重置基础属性
  ForgeState.isBoss=false;
  ForgeState.moveKey='DRIFT';
  ForgeState.moveKeys = ['DRIFT']
  ForgeState.col=C.E2;
  ForgeState.hp=900;
  ForgeState.mods=[];
  ForgeState.traits=[];
  
  // 重置外观
  ForgeState.bodyKind='AUTO';
  ForgeState.bodySeed=1337;
  ForgeState.bodyScale=1.0;
  ForgeState.bodyOpt = {
    baseN:null, innerN:null, ring:null, spokes:null,
    starInner:null, teeth:null, toothDepth:null,
    rr:null, diaSkew:null,
    arcSegs:null, arcSpan:null, arcGap:null,
  };

  ForgeState.em1={type:'AIM', cd:1.2, speed:220};
  ForgeState.em2={type:'RING', cd:2.2, speed:180};
  
  // 清空 Slot 1 和 Slot 2 的所有配置
  ForgeState.slot1 = { layer1:'', layer2:'', layer1Cfg:{}, layer2Cfg:{}, baseMods:[] };
  ForgeState.slot2 = { layer1:'', layer2:'', layer1Cfg:{}, layer2Cfg:{}, baseMods:[] };
  ForgeState.extraEmitters = [];

  // 兼容旧属性（虽然新逻辑不主要使用，但重置以保持状态干净）
  ForgeState.em1Composite = '';
  ForgeState.em2Composite = '';
  ForgeState.em1CompositeCfg = {};
  ForgeState.em2CompositeCfg = {};

  saveForge();
  syncForgeUIFromState(); // 现在 UI 会基于一个完全干净的 ForgeState 进行刷新
}


function buildForgeMoveChips() {
  const cont = document.getElementById('forgeMoveChips');
  if (!cont) return;
  cont.innerHTML = '';

  Object.keys(MoveCatalog).forEach(k => {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'pick-chip';
    btn.dataset.key = k;
    btn.textContent = k;

    btn.addEventListener('click', () => {
      if (!Array.isArray(ForgeState.moveKeys)) ForgeState.moveKeys = [ForgeState.moveKey || 'DRIFT'];
      const set = new Set(ForgeState.moveKeys);

      if (set.has(k)) {
        if (set.size > 1) set.delete(k); // 至少保留一个
      } else {
        set.add(k);
      }
      ForgeState.moveKeys = Array.from(set);
      // 旧的 moveKey 也同步一下，以防万一
      ForgeState.moveKey = ForgeState.moveKeys[0] || 'DRIFT'; 
      saveForge();
      syncForgeUIFromState(); // 刷新UI
    });
    cont.appendChild(btn);
  });
}

function initMenuUI(){
  // 顶部导航切页
  for(const b of document.querySelectorAll('#menu .nav-btn[data-page]')){
    b.addEventListener('click', ()=>setMenuPage(b.dataset.page));
  }

  // load state
  loadBuilds();
  Builds.A = clampBuild(Builds.A); 
  Builds.B = clampBuild(Builds.B);
  loadForge();

  // forge selects + chips
  populateForgeSelects();
  //injectForgeAppearancePanel();
  buildAffixChips();
  buildPlayerEmitterChips();
  buildForgeChips();
  hookForgeInputs();
  initForgeExtendedUI();
  buildForgeMoveChips()
  wireForgeExtraEmitterButtons();
  bindAccordionsAnimated();

  document.querySelectorAll('#pageWorkshop details.acc, #pageForge details.acc').forEach(d=>{ d.open = false; });

  // save 按钮（只负责存档，不再负责 core 绑定）
  document.getElementById('btnSaveBuilds')?.addEventListener('click', ()=>{
    saveBuilds();
    textPop(W*0.5, 86, 'SAVED', C.Y);
  });

  // I/O drawer
  document.getElementById('btnOpenIO')?.addEventListener('click', openIO);
  document.getElementById('btnCloseIO')?.addEventListener('click', closeIO);

  document.getElementById('btnExportBuilds')?.addEventListener('click', ()=>setIOText(exportBuildsJSON()));
  const importIOAuto = (txt)=>{
    let obj = null;
    try{ obj = JSON.parse(txt||'{}'); }catch(_){ }
    const t = obj?.type || '';
    if (t === 'forge' || obj?.forge || obj?.slot1 || obj?.emitters){ importForgeJSON(txt); return 'forge'; }
    if (t === 'builds' || obj?.builds){ importBuildsJSON(txt); return 'builds'; }
    importForgeJSON(txt);
    return 'forge';
  };

  document.getElementById('btnImportBuilds')?.addEventListener('click', ()=>{
    try{ importIOAuto(getIOText()); }catch(err){ alert(err?.message || err); }
  });
  document.getElementById('btnExportForge')?.addEventListener('click', ()=>setIOText(exportForgeJSON()));
  document.getElementById('btnImportForge')?.addEventListener('click', ()=>{
    try{ importIOAuto(getIOText()); }catch(err){ alert(err?.message || err); }
  });

  document.getElementById('btnCopyIO')?.addEventListener('click', async ()=>{
    try{ await navigator.clipboard.writeText(getIOText()); textPop(W*0.5, 86, 'COPIED', C.P1); }catch(e){}
  });
  document.getElementById('btnDownloadIO')?.addEventListener('click', ()=>{
    downloadText('neon_air_war_io.json', getIOText() || exportBuildsJSON());
  });

  document.getElementById('btnChooseFile')?.addEventListener('click', ()=>{
    document.getElementById('ioFile')?.click();
  });

  document.getElementById('ioFile')?.addEventListener('change', ()=>{
    const f = document.getElementById('ioFile')?.files?.[0];
    const nameEl = document.getElementById('ioFileName');
    if (nameEl) nameEl.textContent = f ? f.name : 'NO FILE';
  });

  document.getElementById('btnLoadFile')?.addEventListener('click', ()=>{
    const f = document.getElementById('ioFile')?.files?.[0];
    if (!f) return;
    const r = new FileReader();
    r.onload = ()=>{
      const txt = String(r.result || '');
      const ta = document.getElementById('ioText');
      if (ta) ta.value = txt;
    };
    r.readAsText(f);
  });

  // 同步 UI（注意：core 同步由 bindWorkshopCoreFinal() 负责）
  syncForgeUIFromState();
  syncWorkshopFromModel();
  setMenuPage('home');
  
  // ===== Forge RESET button (inject) =====
(function ensureForgeResetButton(){
  // 找到 ENEMY / BOSS FORGE 那个卡片
  const cards = Array.from(document.querySelectorAll('#pageForge .menu-card'));
  const target = cards.find(c=>c.querySelector('.card-title')?.textContent?.includes('ENEMY / BOSS FORGE'));
  if (!target) return;

  if (document.getElementById('btnResetForge')) return;

  const row = document.createElement('div');
  row.className = 'menu-actions';
  row.style.marginTop = '10px';
  row.innerHTML = `
    <button id="btnResetForge" style="border-color:rgba(255,255,255,0.25);color:#aaa">
      RESET FORGE
    </button>
  `;
  target.appendChild(row);

  document.getElementById('btnResetForge').addEventListener('click', ()=>{
    resetForgeStateAndUI();
  });
})();
}


(function injectForgeButtons(){
  // 找到 Forge 面板的目标卡片
  const cards = Array.from(document.querySelectorAll('#pageForge .menu-card'));
  const target = cards.find(c=>c.querySelector('.card-title')?.textContent?.includes('ENEMY / BOSS FORGE'));
  if (!target) return;

  // 清空旧的 actions (防止重复添加)
  const oldActions = target.querySelector('.menu-actions');
  if(oldActions) oldActions.remove();

  const row = document.createElement('div');
  row.className = 'menu-actions';
  row.style.marginTop = '10px';
  row.innerHTML = `
    <button id="btnRandomForge" style="border-color:var(--c-magenta);color:var(--c-magenta)">
      RANDOMIZE
    </button>
    <button id="btnResetForge" style="border-color:rgba(255,255,255,0.25);color:#aaa">
      RESET
    </button>
  `;
  target.appendChild(row);

  document.getElementById('btnResetForge').addEventListener('click', ()=>{
    resetForgeStateAndUI();
  });
  
  document.getElementById('btnRandomForge').addEventListener('click', ()=>{
    randomizeForgeState();
    // 播放一个音效反馈
    beep({f:1200,t:0.05,g:0.05,type:'square',slide:-0.5}); 
  });
})();


const BODY_KINDS = [
  'poly','star','gear','ringRect','diamondRing','arcSeg','crescent','cross','chevron',
  'insect', 'wing', 'crystal',
  'cube', 'pyramid', 'octa', 'prism', 'dodeca',
  // 新增壮美外观
  'spiral', 'lotus', 'dragon', 'phoenix', 'nebula', 'cone'
];


function randomizeForgeState() {
  const R = (arr) => arr[Math.floor(Math.random() * arr.length)];
  const chance = (p) => Math.random() < p;
  const randInt = (min, max) => Math.floor(min + Math.random() * (max - min + 1));
  const randFloat = (min, max) => min + Math.random() * (max - min);

  // 1. 基础属性
  ForgeState.isBoss = chance(0.3); // 30% 概率是 Boss
  ForgeState.hp = ForgeState.isBoss ? randInt(2000, 8000) : randInt(200, 1500);
  
  const colors = [C.E1, C.E2, C.E3, C.E4, C.E5, C.E6, C.E7, C.Y];
  ForgeState.col = R(colors);

  // 2. 移动模式 (1-2种混合)
  const moves = Object.keys(MoveCatalog);
  ForgeState.moveKeys = [R(moves)];
  if (chance(0.4)) {
    let m2 = R(moves);
    if (m2 !== ForgeState.moveKeys[0]) ForgeState.moveKeys.push(m2);
  }
  ForgeState.moveKey = ForgeState.moveKeys[0]; // 兼容旧字段

  // 3. 外观 (Body)
  const kinds = BODY_KINDS;
  ForgeState.bodyKind = chance(0.2) ? 'AUTO' : R(kinds);
  ForgeState.bodySeed = randInt(0, 999999);
  ForgeState.bodyScale = parseFloat(randFloat(0.8, 1.5).toFixed(2));
  
  // 重置详细参数为 null (让 AUTO 生效)，或者你可以随机化它们
  for(let k in ForgeState.bodyOpt) ForgeState.bodyOpt[k] = null; 

  // 4. 词条 (Traits & Mods)
  ForgeState.traits = [];
  ForgeState.mods = [];
  
  // 随机挑选 0-3 个 Enemy Traits
  const allTraits = Object.keys(EnemyTraitCatalog);
  const traitCount = randInt(0, 3);
  for(let i=0; i<traitCount; i++) {
    const t = R(allTraits);
    if(!ForgeState.traits.includes(t)) ForgeState.traits.push(t);
  }

  // 随机挑选 0-2 个 Bullet Mods (全局)
  const allMods = Object.keys(BulletAffixCatalog).filter(k => !BulletAffixCatalog[k].tags?.includes('_internal'));
  const modCount = randInt(0, 2);
  for(let i=0; i<modCount; i++) {
    const m = R(allMods);
    if(!ForgeState.mods.includes(m)) ForgeState.mods.push(m);
  }

  // 5. 武器生成器 (Helper)
  const emitters = Object.keys(EmitterCatalog).filter(k => k !== 'LASER'); // LASER 有点特殊，少用
  const wrappers = Object.keys(CompositeWrappers);

  const randomizeSlot = (slotNum) => {
    // Base Emitter
    const baseType = R(emitters);
    // 随机参数
    let cd = parseFloat(randFloat(0.5, 2.5).toFixed(1));
    let speed = randInt(150, 350);
    
    if (slotNum === 1) {
      ForgeState.em1 = { type: baseType, cd, speed };
    } else {
      ForgeState.em2 = { type: baseType, cd, speed };
    }

    // Wrappers (Layer 1 & 2)
    // 50% 概率无 Wrapper, 30% 1层, 20% 2层
    const r = Math.random();
    const layerCount = r > 0.8 ? 2 : (r > 0.5 ? 1 : 0);
    
    // 重置当前 Slot
    const slotState = { layer1:'', layer2:'', layer1Cfg:{}, layer2Cfg:{}, baseMods:[] };
    
    // Base Mods (Emitter 专属词条)
    if (chance(0.3)) slotState.baseMods.push(R(allMods));

    if (layerCount >= 1) {
      slotState.layer1 = R(wrappers);
      // 简单生成一些通用配置，避免 null
      slotState.layer1Cfg = generateRandomWrapperCfg(slotState.layer1);
    }
    if (layerCount >= 2) {
      slotState.layer2 = R(wrappers);
      slotState.layer2Cfg = generateRandomWrapperCfg(slotState.layer2);
    }

    ForgeState[`slot${slotNum}`] = slotState;
  };

  // 生成配置的辅助函数
  const generateRandomWrapperCfg = (type) => {
    const cfg = {};
    if(type === 'MULTI_DIR') { cfg.dirs = randInt(2, 6); cfg.spreadMode = R(['even','front']); }
    if(type === 'SALVO') { cfg.salvoCount = randInt(2, 5); cfg.salvoInterval = 0.1; }
    if(type === 'MIRROR') { cfg.mirrorOffset = randInt(20, 60); }
    if(type === 'ROTATE_SWEEP') { cfg.sweepSpeed = 1.2; cfg.sweepArc = 1.0; }
    if(type === 'DELAYED_WAVE') { cfg.pauseDur = 0.4; }
    if(type === 'SPIRAL_ARMS') { cfg.arms = randInt(2, 5); cfg.rotSpeed = 1.5; }
    if(type === 'STACKED_RING') { cfg.layers = randInt(2, 4); cfg.layerInterval = 0.15; }
    return cfg;
  };

  // 随机化两个槽位
  randomizeSlot(1);
  if (chance(0.7) || ForgeState.isBoss) randomizeSlot(2); // Slot 2 70% 概率开启
  else {
    // 关闭 Slot 2 (设为默认但无 wrapper)
    ForgeState.em2 = { type:'AIM', cd:99, speed:0 }; 
    ForgeState.slot2 = { layer1:'', layer2:'', layer1Cfg:{}, layer2Cfg:{}, baseMods:[] };
  }

  // 6. 保存并刷新 UI
  saveForge();
  syncForgeUIFromState();
  
  // 强制刷新右侧预览
  refreshForgePreview();
}


// ================= UI events (robust) =================
if (ui.inpMpServer && !ui.inpMpServer.value) ui.inpMpServer.value = 'ws://127.0.0.1:8787';

ui.btnMpConnect?.addEventListener('click', ()=>{
  Multiplayer.connect(ui.inpMpServer?.value, ui.inpMpNick?.value);
});

ui.btnMpJoin?.addEventListener('click', ()=>{
  Multiplayer.joinRoom(ui.inpMpRoom?.value);
});

ui.btnMpLeave?.addEventListener('click', ()=>{
  Multiplayer.disconnect();
});

ui.btnMpStart?.addEventListener('click', ()=>{
  if (!Multiplayer.isActive()){
    Multiplayer.setStatus('请先 JOIN 房间');
    return;
  }
  if (Multiplayer.localPrepared){
    Multiplayer.cancelPrepare(true);
    return;
  }
  const mode = ui.inpMpMode?.value || 'survival';
  const wave = parseInt(document.getElementById('inpStartWave')?.value || '1') || 1;
  const forge = (mode === 'lab' && typeof readForgeSpecFromUI === 'function') ? readForgeSpecFromUI() : null;
  const cfg = {mode, wave: (mode==='survival' || mode==='challenge') ? wave : 1, forge};
  Multiplayer.prepare(cfg);
});

window.addEventListener('beforeunload', ()=> Multiplayer.disconnect(), {passive:true});

const btnSurvival = document.getElementById('btnStartSurvival') || ui.btnStart;
const waveInput  = document.getElementById('inpStartWave') || ui.inpWave;

btnSurvival?.addEventListener('click', ()=>{
  const wave = parseInt(waveInput?.value) || 1;
  const cfg = {mode:'survival', wave};
  startRun(cfg);
});

document.getElementById('btnStartFortress')?.addEventListener('click', ()=>{
  const wave = parseInt(waveInput?.value) || 1;
  const cfg = {mode:'fortress', wave};
  startRun(cfg);
});

document.getElementById('btnStartDuel')?.addEventListener('click', ()=>{
  const cfg = {mode:'duel', wave:1};
  startRun(cfg);
});

document.getElementById('btnStartLab')?.addEventListener('click', ()=>{
  const forge = (typeof readForgeSpecFromUI === 'function') ? readForgeSpecFromUI() : null;
  const cfg = {mode:'lab', wave:1, forge};
  startRun(cfg);
});
document.getElementById('btnStartUnitBattle')?.addEventListener('click', ()=>{
  const m = document.getElementById('unitBattleModal');
  if (!m) return;
  m.classList.add('show');
  UnitBattle.refreshList();
  requestAnimationFrame(()=>m.classList.add('visible'));
});

ui.btnRestart?.addEventListener('click', () => {
  const last = Game.lastStart || {};
  let currentForge = last.forge;

  if (last.net){
    const cfg = {
      mode: last.mode || 'survival',
      wave: (last.mode === 'survival' || last.mode === 'challenge') ? (parseInt(ui.inpWave.value) || 1) : 1,
      forge: currentForge || null,
    };
    Multiplayer.prepare(cfg);
    return;
  }

  // Lab 模式的特殊处理 (保持不变)
  if (last.mode === 'lab' || last.mode === 'unitbattle') {
    if (ForgeState._isRandom && typeof randomizeForgeState === 'function') {
      randomizeForgeState(); 
    }
    if (typeof readForgeSpecFromUI === 'function') {
      currentForge = readForgeSpecFromUI();
    }
  }

  // 判断当前模式是否支持跳关
  const supportsWarp = (last.mode === 'survival' || last.mode === 'challenge' || last.mode === 'fortress');

  startRun({
    keepLabLayout: (last.mode==='lab' || last.mode==='unitbattle'),
    mode: last.mode || 'survival',
    // 如果支持跳关，就读取死亡界面的 ui.inpWave 输入框。
    // 否则（比如 Duel 模式），就回到该模式的起始波次 1。
    wave: supportsWarp ? (parseInt(ui.inpWave.value) || 1) : 1,
    forge: currentForge
  });
});
ui.btnBack?.addEventListener('click', ()=>{
  if (Game.lastStart?.net) Multiplayer.cancelPrepare(true);
  toMenu();
});
ui.btnPause?.addEventListener('click', ()=>{ if (Game.state==='playing'||Game.state==='paused') togglePause(); });
ui.btnMute?.addEventListener('click', ()=>Game.mute());
ui.btnRevive?.addEventListener('click', revive);
function toggleCompactHUD(e){
  e?.preventDefault?.();
  e?.stopPropagation?.();
  const root = document.querySelector('.ui');
  if (!root) return;
  root.classList.toggle('compact');
  ui.btnCompactUI.textContent = root.classList.contains('compact') ? 'HUD' : 'UI';
}
ui.btnCompactUI?.addEventListener('click', toggleCompactHUD, {passive:false});


function bindAccordionsAnimated(rootSel='#pageWorkshop, #pageForge'){
  const roots = document.querySelectorAll(rootSel);
  roots.forEach(root=>{
    root.querySelectorAll('details.acc').forEach(d=>{
      const sum = d.querySelector(':scope > summary');
      const body = d.querySelector(':scope > .acc-body');
      if (!sum || !body || d.dataset.accBound==='1') return;
      d.dataset.accBound='1';
      sum.addEventListener('click', (ev)=>{
        ev.preventDefault();
        const opening = !d.open;
        if (opening){
          d.open = true;
          body.style.maxHeight = '0px';
          body.style.opacity = '0';
          body.style.transform = 'translateY(-4px)';
          requestAnimationFrame(()=>{
            body.style.maxHeight = body.scrollHeight + 'px';
            body.style.opacity = '1';
            body.style.transform = 'translateY(0)';
          });
        } else {
          body.style.maxHeight = body.scrollHeight + 'px';
          requestAnimationFrame(()=>{
            body.style.maxHeight = '0px';
            body.style.opacity = '0';
            body.style.transform = 'translateY(-4px)';
          });
          setTimeout(()=>{ d.open = false; }, 260);
        }
      });
    });
  });
}

document.querySelectorAll('#fortressBuildScroller [data-item]').forEach((el)=>{
  el.addEventListener('click', ()=>Fortress.select(el.dataset.item));
});
ui.btnFortSell?.addEventListener('click', ()=>Fortress.select(Fortress.sellMode ? Fortress.selected : 'sell'));
ui.btnFortUndo?.addEventListener('click', ()=>Fortress.undo());
ui.btnFortStartWave?.addEventListener('click', ()=>Fortress.beginAssault());
ui.btnFortRepairFlag?.addEventListener('click', ()=>Fortress.repairFlag(6, 180));
ui.btnFortExportLayout?.addEventListener('click', ()=>Fortress.exportLabLayout());
ui.btnFortImportLayout?.addEventListener('click', ()=>Fortress.importLabLayout());

document.addEventListener('pointerdown', (e)=>{
  if ((Game.mode!=='fortress' && Game.mode!=='lab' && Game.mode!=='fortress_duel') || !Fortress.preview) return;
  if (e.target === canvas) return;
  if (e.target?.closest?.('#fortressPanel')) return;
  Fortress.clearPreview();
}, {passive:true, capture:true});

document.getElementById('btnResumePause')?.addEventListener('click', ()=>{
  if (Game.state==='paused') togglePause();
});


(function initOptionSystem() {
  const pnl = document.getElementById('optionPanel');
  const btnOpt = document.getElementById('btnOption');
  const inpSpeed = document.getElementById('inpSpeed');
  const valSpeed = document.getElementById('valSpeed');
  const inpTas = document.getElementById('inpTas');
  const optSpeedField = document.getElementById('optSpeedField');
  const optTasField = document.getElementById('optTasField');

  // 打开 Option 面板
  btnOpt?.addEventListener('click', () => {
    // 暂停游戏
    if (Game.state === 'playing') {
      togglePause(); // 这会打开 PausePanel
      // 我们需要隐藏默认的 PausePanel，显示 OptionPanel
      document.getElementById('pausePanel').style.display = 'none'; 
    }
    const isNetMode = !!Game.lastStart?.net;
    if (optSpeedField) optSpeedField.style.display = isNetMode ? 'none' : '';
    if (optTasField) optTasField.style.display = isNetMode ? 'none' : '';
    showOverlay('optionPanel', true);
  });

  // 调整速度
  inpSpeed?.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    TimeMachine.speed = v;
    valSpeed.textContent = v.toFixed(1);
  });

  // TAS 开关
  inpTas?.addEventListener('change', (e) => {
    TimeMachine.enabled = e.target.checked;
    // 如果关闭 TAS，清空缓存释放内存
    if (!TimeMachine.enabled) TimeMachine.buffer = [];
  });

  // Resume 按钮
  document.getElementById('btnOptResume')?.addEventListener('click', () => {
    showOverlay('optionPanel', false);
    // 如果之前是暂停的，恢复游戏

  });

  // Exit to Menu 按钮
  document.getElementById('btnOptMenu')?.addEventListener('click', () => {
    showOverlay('optionPanel', false);
    if (Game.lastStart?.net) Multiplayer.cancelPrepare(true);
    toMenu();
  });
})();

document.addEventListener('pointerdown', (e)=>{ DevEditor.onHudPointerDown(e); }, {passive:true});
document.addEventListener('pointermove', (e)=>{ DevEditor.onHudPointerMove(e); }, {passive:true});
document.addEventListener('pointerup', (e)=>{ DevEditor.onHudPointerUp(e); }, {passive:true});

document.getElementById('btnStartChallenge')?.addEventListener('click', () => {
  // 读取输入框，默认为 1
  const w = parseInt(document.getElementById('inpStartWave')?.value) || 1;
  const cfg = {mode:'challenge', wave:w};
  startRun(cfg);
});

// 为暂停界面的重试按钮绑定逻辑
document.getElementById('btnPauseRetry')?.addEventListener('click', () => {
  // 1. 先解除暂停状态
  if (Game.state === 'paused') togglePause();
  
  // 2. 模拟点击游戏结束界面的重启按钮（复用其智能重试逻辑）
  // 或者直接手动触发逻辑：
  const last = Game.lastStart || {};
  let currentForge = last.forge;

  if (last.net){
    const cfg = {
      mode: last.mode || 'survival',
      wave: (last.mode === 'survival' || last.mode === 'challenge') ? (parseInt(ui.inpWave.value) || 1) : 1,
      forge: currentForge || null,
    };
    Multiplayer.prepare(cfg);
    return;
  }

  if (last.mode === 'lab' || last.mode === 'unitbattle') {
    if (typeof readForgeSpecFromUI === 'function') {
      currentForge = readForgeSpecFromUI();
    }
  }

  startRun({
    keepLabLayout: (last.mode==='lab' || last.mode==='unitbattle'),
    mode: last.mode || 'survival',
    wave: (last.mode === 'survival') ? (parseInt(ui.inpWave.value) || 1) : (last.wave || 1),
    forge: currentForge
  });
});


function spawnChaosEnemy(wave) {
  const hf = wave / 50; // 混乱因子，随波次无限增长
  const d = 1 + wave * 0.15; // 难度系数

  // 1. 随机基础属性 (血量随波次非线性增长)
  // Wave 1: ~400, Wave 10: ~1500, Wave 50: ~10000+
  const baseHp = 300 + wave * 100 + Math.pow(wave, 1.8) * 15;
  const r = rand(16, 25) + Math.min(30, wave * 0.5); // 体积也会慢慢变大
  
  // 2. 随机颜色
  const cols = [C.E1, C.E2, C.E3, C.E4, C.E5, C.E6, C.E7, C.Y];
  const col = cols[randi(0, cols.length - 1)];

  // 3. 构建敌人 (复用 baseEnemy)
  // 类型标记为 BOSS 以显示血条，但逻辑上是普通怪
  const e = baseEnemy('CHAOS_BEAST', r, Math.round(baseHp), wave * 100);
  e.baseCol = col;
  e.tint = col;
  
  // 4. 随机外形
  e.bodySeed = randi(0, 9999999);
  e.body = genEnemyBody(e.bodySeed);
  // 强制应用一些高级外形参数
  if (wave > 10) e.body.scale1 = 1.0 + Math.min(1.0, wave*0.02);

  // 5. 混合移动模式 (随着波次增加，混合更多模式)
  const allMoves = Object.keys(MoveCatalog);
  const mixCount = (wave < 5) ? 1 : (wave < 20 ? 2 : 3);
  const moveKeys = [];
  for(let i=0; i<mixCount; i++) moveKeys.push(allMoves[randi(0, allMoves.length-1)]);
  
  // 挂载移动逻辑
  attachMoveMixer(e, d, moveKeys[0]);
  if (e.mmx) e.mmx.availableModes = moveKeys;

  // 6. 疯狂的发射器组合
  // 数量无上限，每 15 波增加一个发射器槽位 (1~4个)
  const emCount = 1 + Math.floor(wave / 15); 
  const emTypes = Object.keys(EmitterCatalog);
  
  e.emitters = [];
  for(let i=0; i<emCount; i++) {
    // 随机挑选发射器类型
    const type = emTypes[randi(0, emTypes.length-1)];
    const factory = EmitterCatalog[type];
    
    // 随机参数 (随着 wave 减少冷却，增加速度)
    const baseCd = rand(0.5, 2.0) * Math.max(0.3, 1.0 - wave * 0.01);
    const speed = 200 + wave * 8;
    
    // 随机套用 Wrapper (30% + wave加成 概率)
    const wrappers = Object.keys(CompositeWrappers);
    let emInstance;
    
    if (chance(0.3 + Math.min(0.5, wave*0.01))) {
      const wType = wrappers[randi(0, wrappers.length-1)];
      const wFn = CompositeWrappers[wType];
      // 简单的随机配置
      const wCfg = {
        dirs: randi(2,6), count: randi(3,8), 
        spread: 0.5, rotSpeed: 1.5,
        baseCfg: { baseCd, speed, col, r: 3 + wave*0.05 }
      };
      // 实例化包装器
      emInstance = wFn(factory, wCfg);
    } else {
      // 基础发射器
      emInstance = factory({ baseCd, speed, col, r: 3 + wave*0.05 });
    }
    
    // 随机词条
    const modCount = 1 + Math.floor(wave/5);
    // 使用你现有的 rollAffixes 工具
    const mods = rollAffixes({wave: 100, maxCount: modCount}); // wave 传100解锁所有
    emInstance.cfg = emInstance.cfg || {};
    emInstance.cfg.mods = mods;
    
    e.emitters.push(emInstance);
  }
 
  // 随着波次增加，词条数量增加，且允许出现稀有词条
  const maxAffix = 1 + Math.floor(wave / 10); // 每10波多一个词条
  e.waveBulletMods = rollAffixes({
    wave: 100, // 传入100以解锁所有等级限制的词条
    maxCount: Math.min(5, maxAffix)
  }) || [];

  // [补丁] 随机生成敌人特性 (Traits)
  // 随着波次增加，特性数量增加
  const maxTraits = 1 + Math.floor(wave / 8); // 每8波多一个特性
  // 临时覆盖 Game.wave 以骗过 pickEnemyTraits 的等级限制检查，确保能选出高级特性
  const realWave = Game.wave;
  Game.wave = 100; 
  const randomTraits = pickEnemyTraits(false, Math.min(6, maxTraits), []);
  Game.wave = realWave; // 恢复
  
  applyEnemyTraits(e, randomTraits, d);

  // 7. 强制 Traits
  if (wave > 5) applyEnemyTraits(e, ['ARMORED'], d);
  if (wave > 15) applyEnemyTraits(e, ['REGEN'], d);
  if (wave > 25) applyEnemyTraits(e, ['SHIELD_LAYER'], d);
  
  // 8. 【核心】循环场地逻辑 + 移除超时惩罚
  // 劫持 update
  const _superUpdate = e.update.bind(e);
  e.update = (dt) => {
    e.age = 0; // 移除 14秒强制离场
    _superUpdate(dt);
    
    // 循环场地：下出上进
    const limitY = H / (Camera.zoom||1) + 150;
    if (e.y > limitY) {
      e.y = -150;
      // 保持水平位置变化，防止太单调
      e.x = clamp(e.x + rand(-100, 100), 50, W-50);
      
      // 如果 AI 是轨道类，重置状态
      if (e.mmx && (e.mmx.mode === 'HOLD' || e.mmx.mode === 'ORBIT')) {
         e.mmx.state = 'enter';
         if (typeof mmxInitOrbitFromHere === 'function') mmxInitOrbitFromHere(e);
      }
    }
  };
  
  e.x = W*0.5;
  e.y = -20;

  enemies.push(e);
  
  // 视觉效果
  textPop(W/2, H*0.4, `CHALLENGE WAVE ${wave}`, C.R);
  spawnShockwave(W/2, -50, C.E1, 500, 1.0);
}


// ================= Loop =================
  let lastT = performance.now();

function step(now){
  requestAnimationFrame(step);
  let dt = (now - lastT) / 1000;
  lastT = now;
  dt = clamp(dt, 0, 0.040);

  // 应用游戏速率
  const devTimeScale = Game.devFrozen ? 0 : 1;
  const finalDt = dt * TimeMachine.speed * devTimeScale;
  // 网络心跳/房间状态在所有界面都保持更新，避免大厅/菜单超时掉线
  Multiplayer.update(finalDt);

  const netKeepRunning = !!(Game.lastStart?.net && Multiplayer?.isActive?.() && (Game.mode==='fortress_duel' || Game.mode==='workshop') && (Game.state==='paused' || Game.state==='over'));
  if (Game.state === 'playing' || netKeepRunning) {
    update(finalDt); // 使用变速后的 dt

    // [插入] TAS 录制
    if (TimeMachine.enabled && Game.state === 'playing') {
      TimeMachine.record();
    }
  }

  // SFX 和 Music 保持原速更新，否则声音会变调或卡顿
  SFX.update(dt);
  Music.update();

  if (Player.deathT > 0) Player.deathT = Math.max(0, Player.deathT - dt); // 死亡动画也不变速

  render(finalDt); // 渲染使用变速 dt 以匹配逻辑
}

  // ================= Boot =================
  initMenuUI();
bindWorkshopCoreFinal();
bindForgePreviewFinal();
placeForgePreview();
refreshForgePreview();

document.getElementById('btnUbImport')?.addEventListener('click', ()=>{
  const txt = document.getElementById('ubJsonInput')?.value || '';
  if (!txt.trim()) return alert('请粘贴 JSON');
  try{ UnitBattle.importOne(txt); textPop(W*0.5,H*0.2,'兵种已导入',C.P2); }
  catch(err){ alert('导入失败: '+(err?.message||err)); }
});
document.getElementById('btnUbClear')?.addEventListener('click', ()=>{ UnitBattle.units.length=0; UnitBattle.refreshList(); });
document.getElementById('btnUbExportWinner')?.addEventListener('click', ()=>UnitBattle.exportWinner());
function closeUnitBattleModal(){
  const m = document.getElementById('unitBattleModal');
  if (!m) return;
  m.classList.remove('visible');
  setTimeout(()=>{ m.classList.remove('show'); UnitBattle.refreshList(); }, 240);
}
document.getElementById('btnUbClose')?.addEventListener('click', closeUnitBattleModal);
document.getElementById('unitBattleModal')?.addEventListener('click', (e)=>{ if (e.target?.id==='unitBattleModal') closeUnitBattleModal(); });
document.getElementById('btnUbStart')?.addEventListener('click', ()=>{
  if (!UnitBattle.units.length){ alert('请先导入至少一个兵种 JSON'); return; }
  closeUnitBattleModal();
  startRun({mode:'unitbattle', wave:1});
});
UnitBattle.refreshList();
toMenu();
canvas.style.pointerEvents = 'auto';
mountOverlaysToBody();
requestAnimationFrame(step);


// 代码位置：建议放在 extractEnemyForForge 之后，或其它工具函数附近
async function copyToClipboardRobust(text) {
  // --- Fallback 1: 现代异步 API (需要 HTTPS 或 localhost) ---
  if (navigator.clipboard && window.isSecureContext) {
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch (err) {
      console.error("Clipboard API 失败，尝试传统方法", err);
    }
  }

  // --- Fallback 2: 传统 document.execCommand ('copy') ---
  try {
    const textArea = document.createElement("textarea");
    textArea.value = text;
    // 确保 textarea 在屏幕外且不可见
    textArea.style.position = "fixed";
    textArea.style.left = "-9999px";
    textArea.style.top = "0";
    textArea.style.opacity = "0";
    document.body.appendChild(textArea);
    
    textArea.focus();
    textArea.select();
    
    const successful = document.execCommand('copy');
    document.body.removeChild(textArea);
    if (successful) return true;
  } catch (err) {
    console.error("execCommand 复制失败", err);
  }

  // --- Fallback 3: 如果都失败了，弹窗让用户手动复制 ---
  // 或者将其直接填入 I/O 面板
  return false;
}
// 代码位置：替换脚本末尾原有的 $('btnCopyKiller').addEventListener('click', ...)
document.getElementById('btnCopyKiller')?.addEventListener('click', async () => {
  if (!Game.killerData) return;
  
  // 构建符合 Forge 格式的 JSON 字符串
  const exportObj = { 
    version: 1, 
    type: 'forge', 
    forge: Game.killerData 
  };
  const jsonString = JSON.stringify(exportObj, null, 2);

  // 调用健壮复制函数
  const success = await copyToClipboardRobust(jsonString);

  if (success) {
    // 视觉反馈
    textPop(W * 0.5, H * 0.5, 'KILLER DATA COPIED!', C.G);
    beep({f:880, t:0.05, g:0.02, slide:1.2});
  } else {
    // Fallback 4: 如果剪贴板权限完全被封死，强制打开 I/O 面板并填入
    openIO();
    setIOText(jsonString);
    textPop(W * 0.5, H * 0.5, 'COPY FAILED: OPENING I/O PANEL', C.Y);
    alert("由于浏览器限制无法直接访问剪贴板，已将数据填入 I/O 面板，请手动复制。");
  }
});

(function patchEmitterCatalog() {
  for (const key in EmitterCatalog) {
    const originalFactory = EmitterCatalog[key];
    EmitterCatalog[key] = function(cfg) {
      const instance = originalFactory(cfg);
      if (instance && typeof instance === 'object') {
        instance.type = key;
        instance.cfg = JSON.parse(JSON.stringify(cfg || {})); 
        // 记录基础属性，方便后续提取
        instance.mods = instance.cfg.mods || [];
        instance.speed = instance.cfg.speed;
        instance.cd = instance.cfg.baseCd;
      }
      return instance;
    };
  }
})();

(function patchCompositeWrappersMetadata() {
  for (const key in CompositeWrappers) {
    const originalWrapper = CompositeWrappers[key];
    CompositeWrappers[key] = function(baseFactory, cfg) {
      // 执行原始包装逻辑
      const em = originalWrapper(baseFactory, cfg);
      
      if (em && typeof em === 'object') {
        em._composite = key;
        em._compCfg = JSON.parse(JSON.stringify(cfg || {}));
        
        const originalFire = em.fire.bind(em);
        em.fire = function(owner) {
          const bp = bulletsP.length;
          const be = bulletsE.length;
          originalFire(owner);
          refreshDNAAfterFire(bp, be);
        };
      }
      
      // 无论原始函数返回什么，都直接返回，不做修改
      return em;
    };
  }
})();



// ── Dynamic Zoom 开关 ──
document.getElementById('inpDynZoom')?.addEventListener('change', (e)=>{
  Camera.enabled = (e.target.value === '1');
});

</script>
</body>
</html>
